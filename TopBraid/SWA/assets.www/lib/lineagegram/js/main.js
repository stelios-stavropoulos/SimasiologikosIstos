(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LineageGram = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

polyfill();
// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],2:[function(require,module,exports){
/*! FileSaver.js v1.3.6
 *
 * A saveAs() FileSaver implementation.
 *
 * By Travis Clarke, https://travismclarke.com
 * By Eli Grey, http://eligrey.com
 *
 * License: MIT (https://github.com/clarketm/FileSaver.js/blob/master/LICENSE.md)
 */

;(function (root, factory) {
    if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        module.exports = root.document ? factory(root, true) : function (w) {
            if (!w.document) {
                throw new Error("FileSaver requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(root);
    }
}(window || this, function (window, noGlobal) {
        "use strict";
        // IE <10 is explicitly unsupported
        if (typeof window === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
            return;
        }
        var
            doc = window.document
            // only get URL when necessary in case Blob.js hasn't overridden it yet
            , get_URL = function () {
                return window.URL || window.webkitURL || window;
            }
            , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
            , can_use_save_link = "download" in save_link
            , click = function (node) {
                var event = new MouseEvent("click");
                node.dispatchEvent(event);
            }
            , is_safari = /constructor/i.test(window.HTMLElement) || window.safari
            , is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent)
            , throw_outside = function (ex) {
                (window.setImmediate || window.setTimeout)(function () {
                    throw ex;
                }, 0);
            }
            , force_saveable_type = "application/octet-stream"
            // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
            , arbitrary_revoke_timeout = 1000 * 40 // in ms
            , revoke = function (file) {
                var revoker = function () {
                    if (typeof file === "string") { // file is an object URL
                        get_URL().revokeObjectURL(file);
                    } else { // file is a File
                        file.remove();
                    }
                };
                setTimeout(revoker, arbitrary_revoke_timeout);
            }
            , dispatch = function (filesaver, event_types, event) {
                event_types = [].concat(event_types);
                var i = event_types.length;
                while (i--) {
                    var listener = filesaver["on" + event_types[i]];
                    if (typeof listener === "function") {
                        try {
                            listener.call(filesaver, event || filesaver);
                        } catch (ex) {
                            throw_outside(ex);
                        }
                    }
                }
            }
            , auto_bom = function (blob) {
                // prepend BOM for UTF-8 XML and text/* types (including HTML)
                // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                    return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
                }
                return blob;
            }
            , FileSaver = function (blob, name, no_auto_bom) {
                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                // First try a.download, then web filesystem, then object URLs
                var
                    filesaver = this
                    , type = blob.type
                    , force = type === force_saveable_type
                    , object_url
                    , dispatch_all = function () {
                        dispatch(filesaver, "writestart progress write writeend".split(" "));
                    }
                    // on any filesys errors revert to saving with object URLs
                    , fs_error = function () {
                        if ((is_chrome_ios || (force && is_safari)) && window.FileReader) {
                            // Safari doesn't allow downloading of blob urls
                            var reader = new FileReader();
                            reader.onloadend = function () {
                                var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                var popup = window.open(url, '_blank');
                                if (!popup) window.location.href = url;
                                url = undefined; // release reference before dispatching
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                            };
                            reader.readAsDataURL(blob);
                            filesaver.readyState = filesaver.INIT;
                            return;
                        }
                        // don't create more object URLs than needed
                        if (!object_url) {
                            object_url = get_URL().createObjectURL(blob);
                        }
                        if (force) {
                            window.location.href = object_url;
                        } else {
                            var opened = window.open(object_url, "_blank");
                            if (!opened) {
                                // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                window.location.href = object_url;
                            }
                        }
                        filesaver.readyState = filesaver.DONE;
                        dispatch_all();
                        revoke(object_url);
                    }
                    ;
                filesaver.readyState = filesaver.INIT;

                if (can_use_save_link) {
                    object_url = get_URL().createObjectURL(blob);
                    setTimeout(function () {
                        save_link.href = object_url;
                        save_link.download = name;
                        click(save_link);
                        dispatch_all();
                        revoke(object_url);
                        filesaver.readyState = filesaver.DONE;
                    });
                    return;
                }

                fs_error();
            }
            , FS_proto = FileSaver.prototype
            , saveAs = function (blob, name, no_auto_bom) {
                return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
            }
            ;
        // IE 10+ (native saveAs)
        if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
            saveAs = function (blob, name, no_auto_bom) {
                name = name || blob.name || "download";

                if (!no_auto_bom) {
                    blob = auto_bom(blob);
                }
                return navigator.msSaveOrOpenBlob(blob, name);
            };
        }

        FS_proto.abort = function () {
        };
        FS_proto.readyState = FS_proto.INIT = 0;
        FS_proto.WRITING = 1;
        FS_proto.DONE = 2;

        FS_proto.error =
            FS_proto.onwritestart =
                FS_proto.onprogress =
                    FS_proto.onwrite =
                        FS_proto.onabort =
                            FS_proto.onerror =
                                FS_proto.onwriteend =
                                    null;

        if (typeof define === "function" && define.amd) {
            define("file-saverjs", [], function () {
                return saveAs;
            });
        }

        if (typeof noGlobal === 'undefined') {
            window.saveAs = saveAs;
        }
        return saveAs;
    }
));

},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapĥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik Möller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: Sébastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],5:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./src/adaptor"));
__export(require("./src/d3adaptor"));
__export(require("./src/descent"));
__export(require("./src/geom"));
__export(require("./src/gridrouter"));
__export(require("./src/handledisconnected"));
__export(require("./src/layout"));
__export(require("./src/layout3d"));
__export(require("./src/linklengths"));
__export(require("./src/powergraph"));
__export(require("./src/pqueue"));
__export(require("./src/rbtree"));
__export(require("./src/rectangle"));
__export(require("./src/shortestpaths"));
__export(require("./src/vpsc"));
__export(require("./src/batch"));

},{"./src/adaptor":6,"./src/batch":7,"./src/d3adaptor":8,"./src/descent":11,"./src/geom":12,"./src/gridrouter":13,"./src/handledisconnected":14,"./src/layout":15,"./src/layout3d":16,"./src/linklengths":17,"./src/powergraph":18,"./src/pqueue":19,"./src/rbtree":20,"./src/rectangle":21,"./src/shortestpaths":22,"./src/vpsc":23}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var LayoutAdaptor = (function (_super) {
    __extends(LayoutAdaptor, _super);
    function LayoutAdaptor(options) {
        var _this = _super.call(this) || this;
        var self = _this;
        var o = options;
        if (o.trigger) {
            _this.trigger = o.trigger;
        }
        if (o.kick) {
            _this.kick = o.kick;
        }
        if (o.drag) {
            _this.drag = o.drag;
        }
        if (o.on) {
            _this.on = o.on;
        }
        _this.dragstart = _this.dragStart = layout_1.Layout.dragStart;
        _this.dragend = _this.dragEnd = layout_1.Layout.dragEnd;
        return _this;
    }
    LayoutAdaptor.prototype.trigger = function (e) { };
    ;
    LayoutAdaptor.prototype.kick = function () { };
    ;
    LayoutAdaptor.prototype.drag = function () { };
    ;
    LayoutAdaptor.prototype.on = function (eventType, listener) { return this; };
    ;
    return LayoutAdaptor;
}(layout_1.Layout));
exports.LayoutAdaptor = LayoutAdaptor;
function adaptor(options) {
    return new LayoutAdaptor(options);
}
exports.adaptor = adaptor;

},{"./layout":15}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var gridrouter_1 = require("./gridrouter");
function gridify(pgLayout, nudgeGap, margin, groupMargin) {
    pgLayout.cola.start(0, 0, 0, 10, false);
    var gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
    return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, function (e) { return e.source.routerNode.id; }, function (e) { return e.target.routerNode.id; });
}
exports.gridify = gridify;
function route(nodes, groups, margin, groupMargin) {
    nodes.forEach(function (d) {
        d.routerNode = {
            name: d.name,
            bounds: d.bounds.inflate(-margin)
        };
    });
    groups.forEach(function (d) {
        d.routerNode = {
            bounds: d.bounds.inflate(-groupMargin),
            children: (typeof d.groups !== 'undefined' ? d.groups.map(function (c) { return nodes.length + c.id; }) : [])
                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(function (c) { return c.index; }) : [])
        };
    });
    var gridRouterNodes = nodes.concat(groups).map(function (d, i) {
        d.routerNode.id = i;
        return d.routerNode;
    });
    return new gridrouter_1.GridRouter(gridRouterNodes, {
        getChildren: function (v) { return v.children; },
        getBounds: function (v) { return v.bounds; }
    }, margin - groupMargin);
}
function powerGraphGridLayout(graph, size, grouppadding) {
    var powerGraph;
    graph.nodes.forEach(function (v, i) { return v.index = i; });
    new layout_1.Layout()
        .avoidOverlaps(false)
        .nodes(graph.nodes)
        .links(graph.links)
        .powerGraphGroups(function (d) {
        powerGraph = d;
        powerGraph.groups.forEach(function (v) { return v.padding = grouppadding; });
    });
    var n = graph.nodes.length;
    var edges = [];
    var vs = graph.nodes.slice(0);
    vs.forEach(function (v, i) { return v.index = i; });
    powerGraph.groups.forEach(function (g) {
        var sourceInd = g.index = g.id + n;
        vs.push(g);
        if (typeof g.leaves !== 'undefined')
            g.leaves.forEach(function (v) { return edges.push({ source: sourceInd, target: v.index }); });
        if (typeof g.groups !== 'undefined')
            g.groups.forEach(function (gg) { return edges.push({ source: sourceInd, target: gg.id + n }); });
    });
    powerGraph.powerEdges.forEach(function (e) {
        edges.push({ source: e.source.index, target: e.target.index });
    });
    new layout_1.Layout()
        .size(size)
        .nodes(vs)
        .links(edges)
        .avoidOverlaps(false)
        .linkDistance(30)
        .symmetricDiffLinkLengths(5)
        .convergenceThreshold(1e-4)
        .start(100, 0, 0, 0, false);
    return {
        cola: new layout_1.Layout()
            .convergenceThreshold(1e-3)
            .size(size)
            .avoidOverlaps(true)
            .nodes(graph.nodes)
            .links(graph.links)
            .groupCompactness(1e-4)
            .linkDistance(30)
            .symmetricDiffLinkLengths(5)
            .powerGraphGroups(function (d) {
            powerGraph = d;
            powerGraph.groups.forEach(function (v) {
                v.padding = grouppadding;
            });
        }).start(50, 0, 100, 0, false),
        powerGraph: powerGraph
    };
}
exports.powerGraphGridLayout = powerGraphGridLayout;

},{"./gridrouter":13,"./layout":15}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3v3 = require("./d3v3adaptor");
var d3v4 = require("./d3v4adaptor");
;
function d3adaptor(d3Context) {
    if (!d3Context || isD3V3(d3Context)) {
        return new d3v3.D3StyleLayoutAdaptor();
    }
    return new d3v4.D3StyleLayoutAdaptor(d3Context);
}
exports.d3adaptor = d3adaptor;
function isD3V3(d3Context) {
    var v3exp = /^3\./;
    return d3Context.version && d3Context.version.match(v3exp) !== null;
}

},{"./d3v3adaptor":9,"./d3v4adaptor":10}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor() {
        var _this = _super.call(this) || this;
        _this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3.behavior.drag()
                    .origin(layout_1.Layout.dragOrigin)
                    .on("dragstart.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3.event);
                    d3layout.resume();
                })
                    .on("dragend.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            this
                .call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event[d3event.type](d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        d3.timer(function () { return _super.prototype.tick.call(_this); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
function d3adaptor() {
    return new D3StyleLayoutAdaptor();
}
exports.d3adaptor = d3adaptor;

},{"./layout":15}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var layout_1 = require("./layout");
var D3StyleLayoutAdaptor = (function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor(d3Context) {
        var _this = _super.call(this) || this;
        _this.d3Context = d3Context;
        _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3Context.drag()
                    .subject(layout_1.Layout.dragOrigin)
                    .on("start.d3adaptor", layout_1.Layout.dragStart)
                    .on("drag.d3adaptor", function (d) {
                    layout_1.Layout.drag(d, d3Context.event);
                    d3layout.resume();
                })
                    .on("end.d3adaptor", layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            arguments[0].call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = { type: layout_1.EventType[e.type], alpha: e.alpha, stress: e.stress };
        this.event.call(d3event.type, d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        var t = this.d3Context.timer(function () { return _super.prototype.tick.call(_this) && t.stop(); });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        }
        else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout));
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;

},{"./layout":15}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Locks = (function () {
    function Locks() {
        this.locks = {};
    }
    Locks.prototype.add = function (id, x) {
        this.locks[id] = x;
    };
    Locks.prototype.clear = function () {
        this.locks = {};
    };
    Locks.prototype.isEmpty = function () {
        for (var l in this.locks)
            return false;
        return true;
    };
    Locks.prototype.apply = function (f) {
        for (var l in this.locks) {
            f(Number(l), this.locks[l]);
        }
    };
    return Locks;
}());
exports.Locks = Locks;
var Descent = (function () {
    function Descent(x, D, G) {
        if (G === void 0) { G = null; }
        this.D = D;
        this.G = G;
        this.threshold = 0.0001;
        this.numGridSnapNodes = 0;
        this.snapGridSize = 100;
        this.snapStrength = 1000;
        this.scaleSnapByMaxH = false;
        this.random = new PseudoRandom();
        this.project = null;
        this.x = x;
        this.k = x.length;
        var n = this.n = x[0].length;
        this.H = new Array(this.k);
        this.g = new Array(this.k);
        this.Hd = new Array(this.k);
        this.a = new Array(this.k);
        this.b = new Array(this.k);
        this.c = new Array(this.k);
        this.d = new Array(this.k);
        this.e = new Array(this.k);
        this.ia = new Array(this.k);
        this.ib = new Array(this.k);
        this.xtmp = new Array(this.k);
        this.locks = new Locks();
        this.minD = Number.MAX_VALUE;
        var i = n, j;
        while (i--) {
            j = n;
            while (--j > i) {
                var d = D[i][j];
                if (d > 0 && d < this.minD) {
                    this.minD = d;
                }
            }
        }
        if (this.minD === Number.MAX_VALUE)
            this.minD = 1;
        i = this.k;
        while (i--) {
            this.g[i] = new Array(n);
            this.H[i] = new Array(n);
            j = n;
            while (j--) {
                this.H[i][j] = new Array(n);
            }
            this.Hd[i] = new Array(n);
            this.a[i] = new Array(n);
            this.b[i] = new Array(n);
            this.c[i] = new Array(n);
            this.d[i] = new Array(n);
            this.e[i] = new Array(n);
            this.ia[i] = new Array(n);
            this.ib[i] = new Array(n);
            this.xtmp[i] = new Array(n);
        }
    }
    Descent.createSquareMatrix = function (n, f) {
        var M = new Array(n);
        for (var i = 0; i < n; ++i) {
            M[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                M[i][j] = f(i, j);
            }
        }
        return M;
    };
    Descent.prototype.offsetDir = function () {
        var _this = this;
        var u = new Array(this.k);
        var l = 0;
        for (var i = 0; i < this.k; ++i) {
            var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;
            l += x * x;
        }
        l = Math.sqrt(l);
        return u.map(function (x) { return x *= _this.minD / l; });
    };
    Descent.prototype.computeDerivatives = function (x) {
        var _this = this;
        var n = this.n;
        if (n < 1)
            return;
        var i;
        var d = new Array(this.k);
        var d2 = new Array(this.k);
        var Huu = new Array(this.k);
        var maxH = 0;
        for (var u = 0; u < n; ++u) {
            for (i = 0; i < this.k; ++i)
                Huu[i] = this.g[i][u] = 0;
            for (var v = 0; v < n; ++v) {
                if (u === v)
                    continue;
                var maxDisplaces = n;
                while (maxDisplaces--) {
                    var sd2 = 0;
                    for (i = 0; i < this.k; ++i) {
                        var dx = d[i] = x[i][u] - x[i][v];
                        sd2 += d2[i] = dx * dx;
                    }
                    if (sd2 > 1e-9)
                        break;
                    var rd = this.offsetDir();
                    for (i = 0; i < this.k; ++i)
                        x[i][v] += rd[i];
                }
                var l = Math.sqrt(sd2);
                var D = this.D[u][v];
                var weight = this.G != null ? this.G[u][v] : 1;
                if (weight > 1 && l > D || !isFinite(D)) {
                    for (i = 0; i < this.k; ++i)
                        this.H[i][u][v] = 0;
                    continue;
                }
                if (weight > 1) {
                    weight = 1;
                }
                var D2 = D * D;
                var gs = 2 * weight * (l - D) / (D2 * l);
                var l3 = l * l * l;
                var hs = 2 * -weight / (D2 * l3);
                if (!isFinite(gs))
                    console.log(gs);
                for (i = 0; i < this.k; ++i) {
                    this.g[i][u] += d[i] * gs;
                    Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);
                }
            }
            for (i = 0; i < this.k; ++i)
                maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);
        }
        var r = this.snapGridSize / 2;
        var g = this.snapGridSize;
        var w = this.snapStrength;
        var k = w / (r * r);
        var numNodes = this.numGridSnapNodes;
        for (var u = 0; u < numNodes; ++u) {
            for (i = 0; i < this.k; ++i) {
                var xiu = this.x[i][u];
                var m = xiu / g;
                var f = m % 1;
                var q = m - f;
                var a = Math.abs(f);
                var dx = (a <= 0.5) ? xiu - q * g :
                    (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;
                if (-r < dx && dx <= r) {
                    if (this.scaleSnapByMaxH) {
                        this.g[i][u] += maxH * k * dx;
                        this.H[i][u][u] += maxH * k;
                    }
                    else {
                        this.g[i][u] += k * dx;
                        this.H[i][u][u] += k;
                    }
                }
            }
        }
        if (!this.locks.isEmpty()) {
            this.locks.apply(function (u, p) {
                for (i = 0; i < _this.k; ++i) {
                    _this.H[i][u][u] += maxH;
                    _this.g[i][u] -= maxH * (p[i] - x[i][u]);
                }
            });
        }
    };
    Descent.dotProd = function (a, b) {
        var x = 0, i = a.length;
        while (i--)
            x += a[i] * b[i];
        return x;
    };
    Descent.rightMultiply = function (m, v, r) {
        var i = m.length;
        while (i--)
            r[i] = Descent.dotProd(m[i], v);
    };
    Descent.prototype.computeStepSize = function (d) {
        var numerator = 0, denominator = 0;
        for (var i = 0; i < this.k; ++i) {
            numerator += Descent.dotProd(this.g[i], d[i]);
            Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);
            denominator += Descent.dotProd(d[i], this.Hd[i]);
        }
        if (denominator === 0 || !isFinite(denominator))
            return 0;
        return 1 * numerator / denominator;
    };
    Descent.prototype.reduceStress = function () {
        this.computeDerivatives(this.x);
        var alpha = this.computeStepSize(this.g);
        for (var i = 0; i < this.k; ++i) {
            this.takeDescentStep(this.x[i], this.g[i], alpha);
        }
        return this.computeStress();
    };
    Descent.copy = function (a, b) {
        var m = a.length, n = b[0].length;
        for (var i = 0; i < m; ++i) {
            for (var j = 0; j < n; ++j) {
                b[i][j] = a[i][j];
            }
        }
    };
    Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {
        Descent.copy(x0, r);
        this.takeDescentStep(r[0], d[0], stepSize);
        if (this.project)
            this.project[0](x0[0], x0[1], r[0]);
        this.takeDescentStep(r[1], d[1], stepSize);
        if (this.project)
            this.project[1](r[0], x0[1], r[1]);
        for (var i = 2; i < this.k; i++)
            this.takeDescentStep(r[i], d[i], stepSize);
    };
    Descent.mApply = function (m, n, f) {
        var i = m;
        while (i-- > 0) {
            var j = n;
            while (j-- > 0)
                f(i, j);
        }
    };
    Descent.prototype.matrixApply = function (f) {
        Descent.mApply(this.k, this.n, f);
    };
    Descent.prototype.computeNextPosition = function (x0, r) {
        var _this = this;
        this.computeDerivatives(x0);
        var alpha = this.computeStepSize(this.g);
        this.stepAndProject(x0, r, this.g, alpha);
        if (this.project) {
            this.matrixApply(function (i, j) { return _this.e[i][j] = x0[i][j] - r[i][j]; });
            var beta = this.computeStepSize(this.e);
            beta = Math.max(0.2, Math.min(beta, 1));
            this.stepAndProject(x0, r, this.e, beta);
        }
    };
    Descent.prototype.run = function (iterations) {
        var stress = Number.MAX_VALUE, converged = false;
        while (!converged && iterations-- > 0) {
            var s = this.rungeKutta();
            converged = Math.abs(stress / s - 1) < this.threshold;
            stress = s;
        }
        return stress;
    };
    Descent.prototype.rungeKutta = function () {
        var _this = this;
        this.computeNextPosition(this.x, this.a);
        Descent.mid(this.x, this.a, this.ia);
        this.computeNextPosition(this.ia, this.b);
        Descent.mid(this.x, this.b, this.ib);
        this.computeNextPosition(this.ib, this.c);
        this.computeNextPosition(this.c, this.d);
        var disp = 0;
        this.matrixApply(function (i, j) {
            var x = (_this.a[i][j] + 2.0 * _this.b[i][j] + 2.0 * _this.c[i][j] + _this.d[i][j]) / 6.0, d = _this.x[i][j] - x;
            disp += d * d;
            _this.x[i][j] = x;
        });
        return disp;
    };
    Descent.mid = function (a, b, m) {
        Descent.mApply(a.length, a[0].length, function (i, j) {
            return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0;
        });
    };
    Descent.prototype.takeDescentStep = function (x, d, stepSize) {
        for (var i = 0; i < this.n; ++i) {
            x[i] = x[i] - stepSize * d[i];
        }
    };
    Descent.prototype.computeStress = function () {
        var stress = 0;
        for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {
            for (var v = u + 1, n = this.n; v < n; ++v) {
                var l = 0;
                for (var i = 0; i < this.k; ++i) {
                    var dx = this.x[i][u] - this.x[i][v];
                    l += dx * dx;
                }
                l = Math.sqrt(l);
                var d = this.D[u][v];
                if (!isFinite(d))
                    continue;
                var rl = d - l;
                var d2 = d * d;
                stress += rl * rl / d2;
            }
        }
        return stress;
    };
    Descent.zeroDistance = 1e-10;
    return Descent;
}());
exports.Descent = Descent;
var PseudoRandom = (function () {
    function PseudoRandom(seed) {
        if (seed === void 0) { seed = 1; }
        this.seed = seed;
        this.a = 214013;
        this.c = 2531011;
        this.m = 2147483648;
        this.range = 32767;
    }
    PseudoRandom.prototype.getNext = function () {
        this.seed = (this.seed * this.a + this.c) % this.m;
        return (this.seed >> 16) / this.range;
    };
    PseudoRandom.prototype.getNextBetween = function (min, max) {
        return min + this.getNext() * (max - min);
    };
    return PseudoRandom;
}());
exports.PseudoRandom = PseudoRandom;

},{}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var Point = (function () {
    function Point() {
    }
    return Point;
}());
exports.Point = Point;
var LineSegment = (function () {
    function LineSegment(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    return LineSegment;
}());
exports.LineSegment = LineSegment;
var PolyPoint = (function (_super) {
    __extends(PolyPoint, _super);
    function PolyPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolyPoint;
}(Point));
exports.PolyPoint = PolyPoint;
function isLeft(P0, P1, P2) {
    return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
}
exports.isLeft = isLeft;
function above(p, vi, vj) {
    return isLeft(p, vi, vj) > 0;
}
function below(p, vi, vj) {
    return isLeft(p, vi, vj) < 0;
}
function ConvexHull(S) {
    var P = S.slice(0).sort(function (a, b) { return a.x !== b.x ? b.x - a.x : b.y - a.y; });
    var n = S.length, i;
    var minmin = 0;
    var xmin = P[0].x;
    for (i = 1; i < n; ++i) {
        if (P[i].x !== xmin)
            break;
    }
    var minmax = i - 1;
    var H = [];
    H.push(P[minmin]);
    if (minmax === n - 1) {
        if (P[minmax].y !== P[minmin].y)
            H.push(P[minmax]);
    }
    else {
        var maxmin, maxmax = n - 1;
        var xmax = P[n - 1].x;
        for (i = n - 2; i >= 0; i--)
            if (P[i].x !== xmax)
                break;
        maxmin = i + 1;
        i = minmax;
        while (++i <= maxmin) {
            if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
                continue;
            while (H.length > 1) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
        if (maxmax != maxmin)
            H.push(P[maxmax]);
        var bot = H.length;
        i = maxmin;
        while (--i >= minmax) {
            if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
                continue;
            while (H.length > bot) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
    }
    return H;
}
exports.ConvexHull = ConvexHull;
function clockwiseRadialSweep(p, P, f) {
    P.slice(0).sort(function (a, b) { return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x); }).forEach(f);
}
exports.clockwiseRadialSweep = clockwiseRadialSweep;
function nextPolyPoint(p, ps) {
    if (p.polyIndex === ps.length - 1)
        return ps[0];
    return ps[p.polyIndex + 1];
}
function prevPolyPoint(p, ps) {
    if (p.polyIndex === 0)
        return ps[ps.length - 1];
    return ps[p.polyIndex - 1];
}
function tangent_PointPolyC(P, V) {
    var Vclosed = V.slice(0);
    Vclosed.push(V[0]);
    return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };
}
function Rtangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var upA, dnC;
    if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (above(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (dnC && !above(P, V[c - 1], V[c]))
            return c;
        upA = above(P, V[a + 1], V[a]);
        if (upA) {
            if (dnC)
                b = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (!dnC)
                a = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function Ltangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var dnA, dnC;
    if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (below(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (above(P, V[c - 1], V[c]) && !dnC)
            return c;
        dnA = below(P, V[a + 1], V[a]);
        if (dnA) {
            if (!dnC)
                b = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
        else {
            if (dnC)
                a = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {
    var ix1, ix2;
    ix1 = t1(W[0], V);
    ix2 = t2(V[ix1], W);
    var done = false;
    while (!done) {
        done = true;
        while (true) {
            if (ix1 === V.length - 1)
                ix1 = 0;
            if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
                break;
            ++ix1;
        }
        while (true) {
            if (ix2 === 0)
                ix2 = W.length - 1;
            if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
                break;
            --ix2;
            done = false;
        }
    }
    return { t1: ix1, t2: ix2 };
}
exports.tangent_PolyPolyC = tangent_PolyPolyC;
function LRtangent_PolyPolyC(V, W) {
    var rl = RLtangent_PolyPolyC(W, V);
    return { t1: rl.t2, t2: rl.t1 };
}
exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;
function RLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);
}
exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;
function LLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
}
exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;
function RRtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);
}
exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
var BiTangent = (function () {
    function BiTangent(t1, t2) {
        this.t1 = t1;
        this.t2 = t2;
    }
    return BiTangent;
}());
exports.BiTangent = BiTangent;
var BiTangents = (function () {
    function BiTangents() {
    }
    return BiTangents;
}());
exports.BiTangents = BiTangents;
var TVGPoint = (function (_super) {
    __extends(TVGPoint, _super);
    function TVGPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TVGPoint;
}(Point));
exports.TVGPoint = TVGPoint;
var VisibilityVertex = (function () {
    function VisibilityVertex(id, polyid, polyvertid, p) {
        this.id = id;
        this.polyid = polyid;
        this.polyvertid = polyvertid;
        this.p = p;
        p.vv = this;
    }
    return VisibilityVertex;
}());
exports.VisibilityVertex = VisibilityVertex;
var VisibilityEdge = (function () {
    function VisibilityEdge(source, target) {
        this.source = source;
        this.target = target;
    }
    VisibilityEdge.prototype.length = function () {
        var dx = this.source.p.x - this.target.p.x;
        var dy = this.source.p.y - this.target.p.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    return VisibilityEdge;
}());
exports.VisibilityEdge = VisibilityEdge;
var TangentVisibilityGraph = (function () {
    function TangentVisibilityGraph(P, g0) {
        this.P = P;
        this.V = [];
        this.E = [];
        if (!g0) {
            var n = P.length;
            for (var i = 0; i < n; i++) {
                var p = P[i];
                for (var j = 0; j < p.length; ++j) {
                    var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);
                    this.V.push(vv);
                    if (j > 0)
                        this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
                }
                if (p.length > 1)
                    this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));
            }
            for (var i = 0; i < n - 1; i++) {
                var Pi = P[i];
                for (var j = i + 1; j < n; j++) {
                    var Pj = P[j], t = tangents(Pi, Pj);
                    for (var q in t) {
                        var c = t[q], source = Pi[c.t1], target = Pj[c.t2];
                        this.addEdgeIfVisible(source, target, i, j);
                    }
                }
            }
        }
        else {
            this.V = g0.V.slice(0);
            this.E = g0.E.slice(0);
        }
    }
    TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {
        if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {
            this.E.push(new VisibilityEdge(u.vv, v.vv));
        }
    };
    TangentVisibilityGraph.prototype.addPoint = function (p, i1) {
        var n = this.P.length;
        this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
        for (var i = 0; i < n; ++i) {
            if (i === i1)
                continue;
            var poly = this.P[i], t = tangent_PointPolyC(p, poly);
            this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
            this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
        }
        return p.vv;
    };
    TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {
        for (var i = 0, n = this.P.length; i < n; ++i) {
            if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {
                return true;
            }
        }
        return false;
    };
    return TangentVisibilityGraph;
}());
exports.TangentVisibilityGraph = TangentVisibilityGraph;
function intersects(l, P) {
    var ints = [];
    for (var i = 1, n = P.length; i < n; ++i) {
        var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
        if (int)
            ints.push(int);
    }
    return ints;
}
function tangents(V, W) {
    var m = V.length - 1, n = W.length - 1;
    var bt = new BiTangents();
    for (var i = 0; i < m; ++i) {
        for (var j = 0; j < n; ++j) {
            var v1 = V[i == 0 ? m - 1 : i - 1];
            var v2 = V[i];
            var v3 = V[i + 1];
            var w1 = W[j == 0 ? n - 1 : j - 1];
            var w2 = W[j];
            var w3 = W[j + 1];
            var v1v2w2 = isLeft(v1, v2, w2);
            var v2w1w2 = isLeft(v2, w1, w2);
            var v2w2w3 = isLeft(v2, w2, w3);
            var w1w2v2 = isLeft(w1, w2, v2);
            var w2v1v2 = isLeft(w2, v1, v2);
            var w2v2v3 = isLeft(w2, v2, v3);
            if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0
                && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
                bt.ll = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0
                && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
                bt.rr = new BiTangent(i, j);
            }
            else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0
                && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
                bt.rl = new BiTangent(i, j);
            }
            else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0
                && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
                bt.lr = new BiTangent(i, j);
            }
        }
    }
    return bt;
}
exports.tangents = tangents;
function isPointInsidePoly(p, poly) {
    for (var i = 1, n = poly.length; i < n; ++i)
        if (below(poly[i - 1], poly[i], p))
            return false;
    return true;
}
function isAnyPInQ(p, q) {
    return !p.every(function (v) { return !isPointInsidePoly(v, q); });
}
function polysOverlap(p, q) {
    if (isAnyPInQ(p, q))
        return true;
    if (isAnyPInQ(q, p))
        return true;
    for (var i = 1, n = p.length; i < n; ++i) {
        var v = p[i], u = p[i - 1];
        if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)
            return true;
    }
    return false;
}
exports.polysOverlap = polysOverlap;

},{"./rectangle":21}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rectangle_1 = require("./rectangle");
var vpsc_1 = require("./vpsc");
var shortestpaths_1 = require("./shortestpaths");
var NodeWrapper = (function () {
    function NodeWrapper(id, rect, children) {
        this.id = id;
        this.rect = rect;
        this.children = children;
        this.leaf = typeof children === 'undefined' || children.length === 0;
    }
    return NodeWrapper;
}());
exports.NodeWrapper = NodeWrapper;
var Vert = (function () {
    function Vert(id, x, y, node, line) {
        if (node === void 0) { node = null; }
        if (line === void 0) { line = null; }
        this.id = id;
        this.x = x;
        this.y = y;
        this.node = node;
        this.line = line;
    }
    return Vert;
}());
exports.Vert = Vert;
var LongestCommonSubsequence = (function () {
    function LongestCommonSubsequence(s, t) {
        this.s = s;
        this.t = t;
        var mf = LongestCommonSubsequence.findMatch(s, t);
        var tr = t.slice(0).reverse();
        var mr = LongestCommonSubsequence.findMatch(s, tr);
        if (mf.length >= mr.length) {
            this.length = mf.length;
            this.si = mf.si;
            this.ti = mf.ti;
            this.reversed = false;
        }
        else {
            this.length = mr.length;
            this.si = mr.si;
            this.ti = t.length - mr.ti - mr.length;
            this.reversed = true;
        }
    }
    LongestCommonSubsequence.findMatch = function (s, t) {
        var m = s.length;
        var n = t.length;
        var match = { length: 0, si: -1, ti: -1 };
        var l = new Array(m);
        for (var i = 0; i < m; i++) {
            l[i] = new Array(n);
            for (var j = 0; j < n; j++)
                if (s[i] === t[j]) {
                    var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;
                    if (v > match.length) {
                        match.length = v;
                        match.si = i - v + 1;
                        match.ti = j - v + 1;
                    }
                    ;
                }
                else
                    l[i][j] = 0;
        }
        return match;
    };
    LongestCommonSubsequence.prototype.getSequence = function () {
        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
    };
    return LongestCommonSubsequence;
}());
exports.LongestCommonSubsequence = LongestCommonSubsequence;
var GridRouter = (function () {
    function GridRouter(originalnodes, accessor, groupPadding) {
        if (groupPadding === void 0) { groupPadding = 12; }
        var _this = this;
        this.originalnodes = originalnodes;
        this.groupPadding = groupPadding;
        this.leaves = null;
        this.nodes = originalnodes.map(function (v, i) { return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)); });
        this.leaves = this.nodes.filter(function (v) { return v.leaf; });
        this.groups = this.nodes.filter(function (g) { return !g.leaf; });
        this.cols = this.getGridLines('x');
        this.rows = this.getGridLines('y');
        this.groups.forEach(function (v) {
            return v.children.forEach(function (c) { return _this.nodes[c].parent = v; });
        });
        this.root = { children: [] };
        this.nodes.forEach(function (v) {
            if (typeof v.parent === 'undefined') {
                v.parent = _this.root;
                _this.root.children.push(v.id);
            }
            v.ports = [];
        });
        this.backToFront = this.nodes.slice(0);
        this.backToFront.sort(function (x, y) { return _this.getDepth(x) - _this.getDepth(y); });
        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) { return !g.leaf; });
        frontToBackGroups.forEach(function (v) {
            var r = rectangle_1.Rectangle.empty();
            v.children.forEach(function (c) { return r = r.union(_this.nodes[c].rect); });
            v.rect = r.inflate(_this.groupPadding);
        });
        var colMids = this.midPoints(this.cols.map(function (r) { return r.pos; }));
        var rowMids = this.midPoints(this.rows.map(function (r) { return r.pos; }));
        var rowx = colMids[0], rowX = colMids[colMids.length - 1];
        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];
        var hlines = this.rows.map(function (r) { return ({ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos }); })
            .concat(rowMids.map(function (m) { return ({ x1: rowx, x2: rowX, y1: m, y2: m }); }));
        var vlines = this.cols.map(function (c) { return ({ x1: c.pos, x2: c.pos, y1: coly, y2: colY }); })
            .concat(colMids.map(function (m) { return ({ x1: m, x2: m, y1: coly, y2: colY }); }));
        var lines = hlines.concat(vlines);
        lines.forEach(function (l) { return l.verts = []; });
        this.verts = [];
        this.edges = [];
        hlines.forEach(function (h) {
            return vlines.forEach(function (v) {
                var p = new Vert(_this.verts.length, v.x1, h.y1);
                h.verts.push(p);
                v.verts.push(p);
                _this.verts.push(p);
                var i = _this.backToFront.length;
                while (i-- > 0) {
                    var node = _this.backToFront[i], r = node.rect;
                    var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());
                    if (dx < r.width() / 2 && dy < r.height() / 2) {
                        p.node = node;
                        break;
                    }
                }
            });
        });
        lines.forEach(function (l, li) {
            _this.nodes.forEach(function (v, i) {
                v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {
                    var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);
                    _this.verts.push(p);
                    l.verts.push(p);
                    v.ports.push(p);
                });
            });
            var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
            var delta = function (a, b) { return isHoriz ? b.x - a.x : b.y - a.y; };
            l.verts.sort(delta);
            for (var i = 1; i < l.verts.length; i++) {
                var u = l.verts[i - 1], v = l.verts[i];
                if (u.node && u.node === v.node && u.node.leaf)
                    continue;
                _this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });
            }
        });
    }
    GridRouter.prototype.avg = function (a) { return a.reduce(function (x, y) { return x + y; }) / a.length; };
    GridRouter.prototype.getGridLines = function (axis) {
        var columns = [];
        var ls = this.leaves.slice(0, this.leaves.length);
        while (ls.length > 0) {
            var overlapping = ls.filter(function (v) { return v.rect['overlap' + axis.toUpperCase()](ls[0].rect); });
            var col = {
                nodes: overlapping,
                pos: this.avg(overlapping.map(function (v) { return v.rect['c' + axis](); }))
            };
            columns.push(col);
            col.nodes.forEach(function (v) { return ls.splice(ls.indexOf(v), 1); });
        }
        columns.sort(function (a, b) { return a.pos - b.pos; });
        return columns;
    };
    GridRouter.prototype.getDepth = function (v) {
        var depth = 0;
        while (v.parent !== this.root) {
            depth++;
            v = v.parent;
        }
        return depth;
    };
    GridRouter.prototype.midPoints = function (a) {
        var gap = a[1] - a[0];
        var mids = [a[0] - gap / 2];
        for (var i = 1; i < a.length; i++) {
            mids.push((a[i] + a[i - 1]) / 2);
        }
        mids.push(a[a.length - 1] + gap / 2);
        return mids;
    };
    GridRouter.prototype.findLineage = function (v) {
        var lineage = [v];
        do {
            v = v.parent;
            lineage.push(v);
        } while (v !== this.root);
        return lineage.reverse();
    };
    GridRouter.prototype.findAncestorPathBetween = function (a, b) {
        var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;
        while (aa[i] === ba[i])
            i++;
        return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };
    };
    GridRouter.prototype.siblingObstacles = function (a, b) {
        var _this = this;
        var path = this.findAncestorPathBetween(a, b);
        var lineageLookup = {};
        path.lineages.forEach(function (v) { return lineageLookup[v.id] = {}; });
        var obstacles = path.commonAncestor.children.filter(function (v) { return !(v in lineageLookup); });
        path.lineages
            .filter(function (v) { return v.parent !== path.commonAncestor; })
            .forEach(function (v) { return obstacles = obstacles.concat(v.parent.children.filter(function (c) { return c !== v.id; })); });
        return obstacles.map(function (v) { return _this.nodes[v]; });
    };
    GridRouter.getSegmentSets = function (routes, x, y) {
        var vsegments = [];
        for (var ei = 0; ei < routes.length; ei++) {
            var route = routes[ei];
            for (var si = 0; si < route.length; si++) {
                var s = route[si];
                s.edgeid = ei;
                s.i = si;
                var sdx = s[1][x] - s[0][x];
                if (Math.abs(sdx) < 0.1) {
                    vsegments.push(s);
                }
            }
        }
        vsegments.sort(function (a, b) { return a[0][x] - b[0][x]; });
        var vsegmentsets = [];
        var segmentset = null;
        for (var i = 0; i < vsegments.length; i++) {
            var s = vsegments[i];
            if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {
                segmentset = { pos: s[0][x], segments: [] };
                vsegmentsets.push(segmentset);
            }
            segmentset.segments.push(s);
        }
        return vsegmentsets;
    };
    GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {
        var n = segments.length;
        if (n <= 1)
            return;
        var vs = segments.map(function (s) { return new vpsc_1.Variable(s[0][x]); });
        var cs = [];
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j)
                    continue;
                var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;
                if (x == 'x') {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = j, rind = i;
                        }
                        else {
                            lind = i, rind = j;
                        }
                    }
                }
                else {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = i, rind = j;
                        }
                        else {
                            lind = j, rind = i;
                        }
                    }
                }
                if (lind >= 0) {
                    cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
                }
            }
        }
        var solver = new vpsc_1.Solver(vs, cs);
        solver.solve();
        vs.forEach(function (v, i) {
            var s = segments[i];
            var pos = v.position();
            s[0][x] = s[1][x] = pos;
            var route = routes[s.edgeid];
            if (s.i > 0)
                route[s.i - 1][1][x] = pos;
            if (s.i < route.length - 1)
                route[s.i + 1][0][x] = pos;
        });
    };
    GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {
        var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);
        for (var i = 0; i < vsegmentsets.length; i++) {
            var ss = vsegmentsets[i];
            var events = [];
            for (var j = 0; j < ss.segments.length; j++) {
                var s = ss.segments[j];
                events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });
                events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });
            }
            events.sort(function (a, b) { return a.pos - b.pos + a.type - b.type; });
            var open = [];
            var openCount = 0;
            events.forEach(function (e) {
                if (e.type === 0) {
                    open.push(e.s);
                    openCount++;
                }
                else {
                    openCount--;
                }
                if (openCount == 0) {
                    GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);
                    open = [];
                }
            });
        }
    };
    GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {
        var _this = this;
        var routePaths = edges.map(function (e) { return _this.route(source(e), target(e)); });
        var order = GridRouter.orderEdges(routePaths);
        var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });
        GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);
        GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);
        GridRouter.unreverseEdges(routes, routePaths);
        return routes;
    };
    GridRouter.unreverseEdges = function (routes, routePaths) {
        routes.forEach(function (segments, i) {
            var path = routePaths[i];
            if (path.reversed) {
                segments.reverse();
                segments.forEach(function (segment) {
                    segment.reverse();
                });
            }
        });
    };
    GridRouter.angleBetween2Lines = function (line1, line2) {
        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
        var diff = angle1 - angle2;
        if (diff > Math.PI || diff < -Math.PI) {
            diff = angle2 - angle1;
        }
        return diff;
    };
    GridRouter.isLeft = function (a, b, c) {
        return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;
    };
    GridRouter.getOrder = function (pairs) {
        var outgoing = {};
        for (var i = 0; i < pairs.length; i++) {
            var p = pairs[i];
            if (typeof outgoing[p.l] === 'undefined')
                outgoing[p.l] = {};
            outgoing[p.l][p.r] = true;
        }
        return function (l, r) { return typeof outgoing[l] !== 'undefined' && outgoing[l][r]; };
    };
    GridRouter.orderEdges = function (edges) {
        var edgeOrder = [];
        for (var i = 0; i < edges.length - 1; i++) {
            for (var j = i + 1; j < edges.length; j++) {
                var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);
                var u, vi, vj;
                if (lcs.length === 0)
                    continue;
                if (lcs.reversed) {
                    f.reverse();
                    f.reversed = true;
                    lcs = new LongestCommonSubsequence(e, f);
                }
                if ((lcs.si <= 0 || lcs.ti <= 0) &&
                    (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
                    edgeOrder.push({ l: i, r: j });
                    continue;
                }
                if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
                    u = e[lcs.si + 1];
                    vj = e[lcs.si - 1];
                    vi = f[lcs.ti - 1];
                }
                else {
                    u = e[lcs.si + lcs.length - 2];
                    vi = e[lcs.si + lcs.length];
                    vj = f[lcs.ti + lcs.length];
                }
                if (GridRouter.isLeft(u, vi, vj)) {
                    edgeOrder.push({ l: j, r: i });
                }
                else {
                    edgeOrder.push({ l: i, r: j });
                }
            }
        }
        return GridRouter.getOrder(edgeOrder);
    };
    GridRouter.makeSegments = function (path) {
        function copyPoint(p) {
            return { x: p.x, y: p.y };
        }
        var isStraight = function (a, b, c) { return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001; };
        var segments = [];
        var a = copyPoint(path[0]);
        for (var i = 1; i < path.length; i++) {
            var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;
            if (!c || !isStraight(a, b, c)) {
                segments.push([a, b]);
                a = b;
            }
        }
        return segments;
    };
    GridRouter.prototype.route = function (s, t) {
        var _this = this;
        var source = this.nodes[s], target = this.nodes[t];
        this.obstacles = this.siblingObstacles(source, target);
        var obstacleLookup = {};
        this.obstacles.forEach(function (o) { return obstacleLookup[o.id] = o; });
        this.passableEdges = this.edges.filter(function (e) {
            var u = _this.verts[e.source], v = _this.verts[e.target];
            return !(u.node && u.node.id in obstacleLookup
                || v.node && v.node.id in obstacleLookup);
        });
        for (var i = 1; i < source.ports.length; i++) {
            var u = source.ports[0].id;
            var v = source.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        for (var i = 1; i < target.ports.length; i++) {
            var u = target.ports[0].id;
            var v = target.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        var getSource = function (e) { return e.source; }, getTarget = function (e) { return e.target; }, getLength = function (e) { return e.length; };
        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
        var bendPenalty = function (u, v, w) {
            var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];
            var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);
            if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)
                return 0;
            return dx > 1 && dy > 1 ? 1000 : 0;
        };
        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
        var pathPoints = shortestPath.reverse().map(function (vi) { return _this.verts[vi]; });
        pathPoints.push(this.nodes[target.id].ports[0]);
        return pathPoints.filter(function (v, i) {
            return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source
                || i > 0 && v.node === target && pathPoints[i - 1].node === target);
        });
    };
    GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {
        var result = {
            routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',
            arrowpath: ''
        };
        if (route.length > 1) {
            for (var i = 0; i < route.length; i++) {
                var li = route[i];
                var x = li[1].x, y = li[1].y;
                var dx = x - li[0].x;
                var dy = y - li[0].y;
                if (i < route.length - 1) {
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * cornerradius;
                    }
                    else {
                        y -= dy / Math.abs(dy) * cornerradius;
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    var l = route[i + 1];
                    var x0 = l[0].x, y0 = l[0].y;
                    var x1 = l[1].x;
                    var y1 = l[1].y;
                    dx = x1 - x0;
                    dy = y1 - y0;
                    var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;
                    var x2, y2;
                    if (Math.abs(dx) > 0) {
                        x2 = x0 + dx / Math.abs(dx) * cornerradius;
                        y2 = y0;
                    }
                    else {
                        x2 = x0;
                        y2 = y0 + dy / Math.abs(dy) * cornerradius;
                    }
                    var cx = Math.abs(x2 - x);
                    var cy = Math.abs(y2 - y);
                    result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';
                }
                else {
                    var arrowtip = [x, y];
                    var arrowcorner1, arrowcorner2;
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * arrowheight;
                        arrowcorner1 = [x, y + arrowwidth];
                        arrowcorner2 = [x, y - arrowwidth];
                    }
                    else {
                        y -= dy / Math.abs(dy) * arrowheight;
                        arrowcorner1 = [x + arrowwidth, y];
                        arrowcorner2 = [x - arrowwidth, y];
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    if (arrowheight > 0) {
                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                    }
                }
            }
        }
        else {
            var li = route[0];
            var x = li[1].x, y = li[1].y;
            var dx = x - li[0].x;
            var dy = y - li[0].y;
            var arrowtip = [x, y];
            var arrowcorner1, arrowcorner2;
            if (Math.abs(dx) > 0) {
                x -= dx / Math.abs(dx) * arrowheight;
                arrowcorner1 = [x, y + arrowwidth];
                arrowcorner2 = [x, y - arrowwidth];
            }
            else {
                y -= dy / Math.abs(dy) * arrowheight;
                arrowcorner1 = [x + arrowwidth, y];
                arrowcorner2 = [x - arrowwidth, y];
            }
            result.routepath += 'L ' + x + ' ' + y + ' ';
            if (arrowheight > 0) {
                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]
                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
            }
        }
        return result;
    };
    return GridRouter;
}());
exports.GridRouter = GridRouter;

},{"./rectangle":21,"./shortestpaths":22,"./vpsc":23}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var packingOptions = {
    PADDING: 10,
    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
    FLOAT_EPSILON: 0.0001,
    MAX_INERATIONS: 100
};
function applyPacking(graphs, w, h, node_size, desired_ratio) {
    if (desired_ratio === void 0) { desired_ratio = 1; }
    var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];
    if (graphs.length == 0)
        return;
    calculate_bb(graphs);
    apply(graphs, desired_ratio);
    put_nodes_to_right_positions(graphs);
    function calculate_bb(graphs) {
        graphs.forEach(function (g) {
            calculate_single_bb(g);
        });
        function calculate_single_bb(graph) {
            var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;
            graph.array.forEach(function (v) {
                var w = typeof v.width !== 'undefined' ? v.width : node_size;
                var h = typeof v.height !== 'undefined' ? v.height : node_size;
                w /= 2;
                h /= 2;
                max_x = Math.max(v.x + w, max_x);
                min_x = Math.min(v.x - w, min_x);
                max_y = Math.max(v.y + h, max_y);
                min_y = Math.min(v.y - h, min_y);
            });
            graph.width = max_x - min_x;
            graph.height = max_y - min_y;
        }
    }
    function put_nodes_to_right_positions(graphs) {
        graphs.forEach(function (g) {
            var center = { x: 0, y: 0 };
            g.array.forEach(function (node) {
                center.x += node.x;
                center.y += node.y;
            });
            center.x /= g.array.length;
            center.y /= g.array.length;
            var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };
            var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2 };
            g.array.forEach(function (node) {
                node.x += offset.x;
                node.y += offset.y;
            });
        });
    }
    function apply(data, desired_ratio) {
        var curr_best_f = Number.POSITIVE_INFINITY;
        var curr_best = 0;
        data.sort(function (a, b) { return b.height - a.height; });
        min_width = data.reduce(function (a, b) {
            return a.width < b.width ? a.width : b.width;
        });
        var left = x1 = min_width;
        var right = x2 = get_entire_width(data);
        var iterationCounter = 0;
        var f_x1 = Number.MAX_VALUE;
        var f_x2 = Number.MAX_VALUE;
        var flag = -1;
        var dx = Number.MAX_VALUE;
        var df = Number.MAX_VALUE;
        while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {
            if (flag != 1) {
                var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x1 = step(data, x1);
            }
            if (flag != 0) {
                var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x2 = step(data, x2);
            }
            dx = Math.abs(x1 - x2);
            df = Math.abs(f_x1 - f_x2);
            if (f_x1 < curr_best_f) {
                curr_best_f = f_x1;
                curr_best = x1;
            }
            if (f_x2 < curr_best_f) {
                curr_best_f = f_x2;
                curr_best = x2;
            }
            if (f_x1 > f_x2) {
                left = x1;
                x1 = x2;
                f_x1 = f_x2;
                flag = 1;
            }
            else {
                right = x2;
                x2 = x1;
                f_x2 = f_x1;
                flag = 0;
            }
            if (iterationCounter++ > 100) {
                break;
            }
        }
        step(data, curr_best);
    }
    function step(data, max_width) {
        line = [];
        real_width = 0;
        real_height = 0;
        global_bottom = init_y;
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            put_rect(o, max_width);
        }
        return Math.abs(get_real_ratio() - desired_ratio);
    }
    function put_rect(rect, max_width) {
        var parent = undefined;
        for (var i = 0; i < line.length; i++) {
            if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {
                parent = line[i];
                break;
            }
        }
        line.push(rect);
        if (parent !== undefined) {
            rect.x = parent.x + parent.width + packingOptions.PADDING;
            rect.y = parent.bottom;
            rect.space_left = rect.height;
            rect.bottom = rect.y;
            parent.space_left -= rect.height + packingOptions.PADDING;
            parent.bottom += rect.height + packingOptions.PADDING;
        }
        else {
            rect.y = global_bottom;
            global_bottom += rect.height + packingOptions.PADDING;
            rect.x = init_x;
            rect.bottom = rect.y;
            rect.space_left = rect.height;
        }
        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
            real_height = rect.y + rect.height - init_y;
        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
            real_width = rect.x + rect.width - init_x;
    }
    ;
    function get_entire_width(data) {
        var width = 0;
        data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });
        return width;
    }
    function get_real_ratio() {
        return (real_width / real_height);
    }
}
exports.applyPacking = applyPacking;
function separateGraphs(nodes, links) {
    var marks = {};
    var ways = {};
    var graphs = [];
    var clusters = 0;
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var n1 = link.source;
        var n2 = link.target;
        if (ways[n1.index])
            ways[n1.index].push(n2);
        else
            ways[n1.index] = [n2];
        if (ways[n2.index])
            ways[n2.index].push(n1);
        else
            ways[n2.index] = [n1];
    }
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (marks[node.index])
            continue;
        explore_node(node, true);
    }
    function explore_node(n, is_new) {
        if (marks[n.index] !== undefined)
            return;
        if (is_new) {
            clusters++;
            graphs.push({ array: [] });
        }
        marks[n.index] = clusters;
        graphs[clusters - 1].array.push(n);
        var adjacent = ways[n.index];
        if (!adjacent)
            return;
        for (var j = 0; j < adjacent.length; j++) {
            explore_node(adjacent[j], false);
        }
    }
    return graphs;
}
exports.separateGraphs = separateGraphs;

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var powergraph = require("./powergraph");
var linklengths_1 = require("./linklengths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var shortestpaths_1 = require("./shortestpaths");
var geom_1 = require("./geom");
var handledisconnected_1 = require("./handledisconnected");
var EventType;
(function (EventType) {
    EventType[EventType["start"] = 0] = "start";
    EventType[EventType["tick"] = 1] = "tick";
    EventType[EventType["end"] = 2] = "end";
})(EventType = exports.EventType || (exports.EventType = {}));
;
function isGroup(g) {
    return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';
}
var Layout = (function () {
    function Layout() {
        var _this = this;
        this._canvasSize = [1, 1];
        this._linkDistance = 20;
        this._defaultNodeSize = 10;
        this._linkLengthCalculator = null;
        this._linkType = null;
        this._avoidOverlaps = false;
        this._handleDisconnected = true;
        this._running = false;
        this._nodes = [];
        this._groups = [];
        this._rootGroup = null;
        this._links = [];
        this._constraints = [];
        this._distanceMatrix = null;
        this._descent = null;
        this._directedLinkConstraints = null;
        this._threshold = 0.01;
        this._visibilityGraph = null;
        this._groupCompactness = 1e-6;
        this.event = null;
        this.linkAccessor = {
            getSourceIndex: Layout.getSourceIndex,
            getTargetIndex: Layout.getTargetIndex,
            setLength: Layout.setLinkLength,
            getType: function (l) { return typeof _this._linkType === "function" ? _this._linkType(l) : 0; }
        };
    }
    Layout.prototype.on = function (e, listener) {
        if (!this.event)
            this.event = {};
        if (typeof e === 'string') {
            this.event[EventType[e]] = listener;
        }
        else {
            this.event[e] = listener;
        }
        return this;
    };
    Layout.prototype.trigger = function (e) {
        if (this.event && typeof this.event[e.type] !== 'undefined') {
            this.event[e.type](e);
        }
    };
    Layout.prototype.kick = function () {
        while (!this.tick())
            ;
    };
    Layout.prototype.tick = function () {
        if (this._alpha < this._threshold) {
            this._running = false;
            this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });
            return true;
        }
        var n = this._nodes.length, m = this._links.length;
        var o, i;
        this._descent.locks.clear();
        for (i = 0; i < n; ++i) {
            o = this._nodes[i];
            if (o.fixed) {
                if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {
                    o.px = o.x;
                    o.py = o.y;
                }
                var p = [o.px, o.py];
                this._descent.locks.add(i, p);
            }
        }
        var s1 = this._descent.rungeKutta();
        if (s1 === 0) {
            this._alpha = 0;
        }
        else if (typeof this._lastStress !== 'undefined') {
            this._alpha = s1;
        }
        this._lastStress = s1;
        this.updateNodePositions();
        this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });
        return false;
    };
    Layout.prototype.updateNodePositions = function () {
        var x = this._descent.x[0], y = this._descent.x[1];
        var o, i = this._nodes.length;
        while (i--) {
            o = this._nodes[i];
            o.x = x[i];
            o.y = y[i];
        }
    };
    Layout.prototype.nodes = function (v) {
        if (!v) {
            if (this._nodes.length === 0 && this._links.length > 0) {
                var n = 0;
                this._links.forEach(function (l) {
                    n = Math.max(n, l.source, l.target);
                });
                this._nodes = new Array(++n);
                for (var i = 0; i < n; ++i) {
                    this._nodes[i] = {};
                }
            }
            return this._nodes;
        }
        this._nodes = v;
        return this;
    };
    Layout.prototype.groups = function (x) {
        var _this = this;
        if (!x)
            return this._groups;
        this._groups = x;
        this._rootGroup = {};
        this._groups.forEach(function (g) {
            if (typeof g.padding === "undefined")
                g.padding = 1;
            if (typeof g.leaves !== "undefined") {
                g.leaves.forEach(function (v, i) {
                    if (typeof v === 'number')
                        (g.leaves[i] = _this._nodes[v]).parent = g;
                });
            }
            if (typeof g.groups !== "undefined") {
                g.groups.forEach(function (gi, i) {
                    if (typeof gi === 'number')
                        (g.groups[i] = _this._groups[gi]).parent = g;
                });
            }
        });
        this._rootGroup.leaves = this._nodes.filter(function (v) { return typeof v.parent === 'undefined'; });
        this._rootGroup.groups = this._groups.filter(function (g) { return typeof g.parent === 'undefined'; });
        return this;
    };
    Layout.prototype.powerGraphGroups = function (f) {
        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        this.groups(g.groups);
        f(g);
        return this;
    };
    Layout.prototype.avoidOverlaps = function (v) {
        if (!arguments.length)
            return this._avoidOverlaps;
        this._avoidOverlaps = v;
        return this;
    };
    Layout.prototype.handleDisconnected = function (v) {
        if (!arguments.length)
            return this._handleDisconnected;
        this._handleDisconnected = v;
        return this;
    };
    Layout.prototype.flowLayout = function (axis, minSeparation) {
        if (!arguments.length)
            axis = 'y';
        this._directedLinkConstraints = {
            axis: axis,
            getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation; } : minSeparation
        };
        return this;
    };
    Layout.prototype.links = function (x) {
        if (!arguments.length)
            return this._links;
        this._links = x;
        return this;
    };
    Layout.prototype.constraints = function (c) {
        if (!arguments.length)
            return this._constraints;
        this._constraints = c;
        return this;
    };
    Layout.prototype.distanceMatrix = function (d) {
        if (!arguments.length)
            return this._distanceMatrix;
        this._distanceMatrix = d;
        return this;
    };
    Layout.prototype.size = function (x) {
        if (!x)
            return this._canvasSize;
        this._canvasSize = x;
        return this;
    };
    Layout.prototype.defaultNodeSize = function (x) {
        if (!x)
            return this._defaultNodeSize;
        this._defaultNodeSize = x;
        return this;
    };
    Layout.prototype.groupCompactness = function (x) {
        if (!x)
            return this._groupCompactness;
        this._groupCompactness = x;
        return this;
    };
    Layout.prototype.linkDistance = function (x) {
        if (!x) {
            return this._linkDistance;
        }
        this._linkDistance = typeof x === "function" ? x : +x;
        this._linkLengthCalculator = null;
        return this;
    };
    Layout.prototype.linkType = function (f) {
        this._linkType = f;
        return this;
    };
    Layout.prototype.convergenceThreshold = function (x) {
        if (!x)
            return this._threshold;
        this._threshold = typeof x === "function" ? x : +x;
        return this;
    };
    Layout.prototype.alpha = function (x) {
        if (!arguments.length)
            return this._alpha;
        else {
            x = +x;
            if (this._alpha) {
                if (x > 0)
                    this._alpha = x;
                else
                    this._alpha = 0;
            }
            else if (x > 0) {
                if (!this._running) {
                    this._running = true;
                    this.trigger({ type: EventType.start, alpha: this._alpha = x });
                    this.kick();
                }
            }
            return this;
        }
    };
    Layout.prototype.getLinkLength = function (link) {
        return typeof this._linkDistance === "function" ? +(this._linkDistance(link)) : this._linkDistance;
    };
    Layout.setLinkLength = function (link, length) {
        link.length = length;
    };
    Layout.prototype.getLinkType = function (link) {
        return typeof this._linkType === "function" ? this._linkType(link) : 0;
    };
    Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.jaccardLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) { w = 1; }
        this.linkDistance(function (l) { return idealLength * l.length; });
        this._linkLengthCalculator = function () { return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w); };
        return this;
    };
    Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {
        var _this = this;
        if (initialUnconstrainedIterations === void 0) { initialUnconstrainedIterations = 0; }
        if (initialUserConstraintIterations === void 0) { initialUserConstraintIterations = 0; }
        if (initialAllConstraintsIterations === void 0) { initialAllConstraintsIterations = 0; }
        if (gridSnapIterations === void 0) { gridSnapIterations = 0; }
        if (keepRunning === void 0) { keepRunning = true; }
        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];
        var x = new Array(N), y = new Array(N);
        var G = null;
        var ao = this._avoidOverlaps;
        this._nodes.forEach(function (v, i) {
            v.index = i;
            if (typeof v.x === 'undefined') {
                v.x = w / 2, v.y = h / 2;
            }
            x[i] = v.x, y[i] = v.y;
        });
        if (this._linkLengthCalculator)
            this._linkLengthCalculator();
        var distances;
        if (this._distanceMatrix) {
            distances = this._distanceMatrix;
        }
        else {
            distances = (new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) { return _this.getLinkLength(l); })).DistanceMatrix();
            G = descent_1.Descent.createSquareMatrix(N, function () { return 2; });
            this._links.forEach(function (l) {
                if (typeof l.source == "number")
                    l.source = _this._nodes[l.source];
                if (typeof l.target == "number")
                    l.target = _this._nodes[l.target];
            });
            this._links.forEach(function (e) {
                var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);
                G[u][v] = G[v][u] = e.weight || 1;
            });
        }
        var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {
            return distances[i][j];
        });
        if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {
            var i = n;
            var addAttraction = function (i, j, strength, idealDistance) {
                G[i][j] = G[j][i] = strength;
                D[i][j] = D[j][i] = idealDistance;
            };
            this._groups.forEach(function (g) {
                addAttraction(i, i + 1, _this._groupCompactness, 0.1);
                x[i] = 0, y[i++] = 0;
                x[i] = 0, y[i++] = 0;
            });
        }
        else
            this._rootGroup = { leaves: this._nodes, groups: [] };
        var curConstraints = this._constraints || [];
        if (this._directedLinkConstraints) {
            this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
            curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));
        }
        this.avoidOverlaps(false);
        this._descent = new descent_1.Descent([x, y], D);
        this._descent.locks.clear();
        for (var i = 0; i < n; ++i) {
            var o = this._nodes[i];
            if (o.fixed) {
                o.px = o.x;
                o.py = o.y;
                var p = [o.x, o.y];
                this._descent.locks.add(i, p);
            }
        }
        this._descent.threshold = this._threshold;
        this.initialLayout(initialUnconstrainedIterations, x, y);
        if (curConstraints.length > 0)
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
        this._descent.run(initialUserConstraintIterations);
        this.separateOverlappingComponents(w, h);
        this.avoidOverlaps(ao);
        if (ao) {
            this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
            this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });
        }
        this._descent.G = G;
        this._descent.run(initialAllConstraintsIterations);
        if (gridSnapIterations) {
            this._descent.snapStrength = 1000;
            this._descent.snapGridSize = this._nodes[0].width;
            this._descent.numGridSnapNodes = n;
            this._descent.scaleSnapByMaxH = n != N;
            var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {
                if (i >= n || j >= n)
                    return G[i][j];
                return 0;
            });
            this._descent.G = G0;
            this._descent.run(gridSnapIterations);
        }
        this.updateNodePositions();
        this.separateOverlappingComponents(w, h);
        return keepRunning ? this.resume() : this;
    };
    Layout.prototype.initialLayout = function (iterations, x, y) {
        if (this._groups.length > 0 && iterations > 0) {
            var n = this._nodes.length;
            var edges = this._links.map(function (e) { return ({ source: e.source.index, target: e.target.index }); });
            var vs = this._nodes.map(function (v) { return ({ index: v.index }); });
            this._groups.forEach(function (g, i) {
                vs.push({ index: g.index = n + i });
            });
            this._groups.forEach(function (g, i) {
                if (typeof g.leaves !== 'undefined')
                    g.leaves.forEach(function (v) { return edges.push({ source: g.index, target: v.index }); });
                if (typeof g.groups !== 'undefined')
                    g.groups.forEach(function (gg) { return edges.push({ source: g.index, target: gg.index }); });
            });
            new Layout()
                .size(this.size())
                .nodes(vs)
                .links(edges)
                .avoidOverlaps(false)
                .linkDistance(this.linkDistance())
                .symmetricDiffLinkLengths(5)
                .convergenceThreshold(1e-4)
                .start(iterations, 0, 0, 0, false);
            this._nodes.forEach(function (v) {
                x[v.index] = vs[v.index].x;
                y[v.index] = vs[v.index].y;
            });
        }
        else {
            this._descent.run(iterations);
        }
    };
    Layout.prototype.separateOverlappingComponents = function (width, height) {
        var _this = this;
        if (!this._distanceMatrix && this._handleDisconnected) {
            var x_1 = this._descent.x[0], y_1 = this._descent.x[1];
            this._nodes.forEach(function (v, i) { v.x = x_1[i], v.y = y_1[i]; });
            var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
            handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize);
            this._nodes.forEach(function (v, i) {
                _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;
                if (v.bounds) {
                    v.bounds.setXCentre(v.x);
                    v.bounds.setYCentre(v.y);
                }
            });
        }
    };
    Layout.prototype.resume = function () {
        return this.alpha(0.1);
    };
    Layout.prototype.stop = function () {
        return this.alpha(0);
    };
    Layout.prototype.prepareEdgeRouting = function (nodeMargin) {
        if (nodeMargin === void 0) { nodeMargin = 0; }
        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {
            return v.bounds.inflate(-nodeMargin).vertices();
        }));
    };
    Layout.prototype.routeEdge = function (edge, ah, draw) {
        if (ah === void 0) { ah = 5; }
        var lineData = [];
        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }), port1 = { x: edge.source.x, y: edge.source.y }, port2 = { x: edge.target.x, y: edge.target.y }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);
        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
        if (typeof draw !== 'undefined') {
            draw(vg2);
        }
        var sourceInd = function (e) { return e.source.id; }, targetInd = function (e) { return e.target.id; }, length = function (e) { return e.length(); }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);
        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
            var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);
            lineData = [route.sourceIntersection, route.arrowStart];
        }
        else {
            var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
            for (var i = n; i >= 0; --i)
                lineData.push(vg2.V[shortestPath[i]].p);
            lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));
        }
        return lineData;
    };
    Layout.getSourceIndex = function (e) {
        return typeof e.source === 'number' ? e.source : e.source.index;
    };
    Layout.getTargetIndex = function (e) {
        return typeof e.target === 'number' ? e.target : e.target.index;
    };
    Layout.linkId = function (e) {
        return Layout.getSourceIndex(e) + "-" + Layout.getTargetIndex(e);
    };
    Layout.dragStart = function (d) {
        if (isGroup(d)) {
            Layout.storeOffset(d, Layout.dragOrigin(d));
        }
        else {
            Layout.stopNode(d);
            d.fixed |= 2;
        }
    };
    Layout.stopNode = function (v) {
        v.px = v.x;
        v.py = v.y;
    };
    Layout.storeOffset = function (d, origin) {
        if (typeof d.leaves !== 'undefined') {
            d.leaves.forEach(function (v) {
                v.fixed |= 2;
                Layout.stopNode(v);
                v._dragGroupOffsetX = v.x - origin.x;
                v._dragGroupOffsetY = v.y - origin.y;
            });
        }
        if (typeof d.groups !== 'undefined') {
            d.groups.forEach(function (g) { return Layout.storeOffset(g, origin); });
        }
    };
    Layout.dragOrigin = function (d) {
        if (isGroup(d)) {
            return {
                x: d.bounds.cx(),
                y: d.bounds.cy()
            };
        }
        else {
            return d;
        }
    };
    Layout.drag = function (d, position) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    d.bounds.setXCentre(position.x);
                    d.bounds.setYCentre(position.y);
                    v.px = v._dragGroupOffsetX + position.x;
                    v.py = v._dragGroupOffsetY + position.y;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(function (g) { return Layout.drag(g, position); });
            }
        }
        else {
            d.px = position.x;
            d.py = position.y;
        }
    };
    Layout.dragEnd = function (d) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    Layout.dragEnd(v);
                    delete v._dragGroupOffsetX;
                    delete v._dragGroupOffsetY;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(Layout.dragEnd);
            }
        }
        else {
            d.fixed &= ~6;
        }
    };
    Layout.mouseOver = function (d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    };
    Layout.mouseOut = function (d) {
        d.fixed &= ~4;
    };
    return Layout;
}());
exports.Layout = Layout;

},{"./descent":11,"./geom":12,"./handledisconnected":14,"./linklengths":17,"./powergraph":18,"./rectangle":21,"./shortestpaths":22}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shortestpaths_1 = require("./shortestpaths");
var descent_1 = require("./descent");
var rectangle_1 = require("./rectangle");
var linklengths_1 = require("./linklengths");
var Link3D = (function () {
    function Link3D(source, target) {
        this.source = source;
        this.target = target;
    }
    Link3D.prototype.actualLength = function (x) {
        var _this = this;
        return Math.sqrt(x.reduce(function (c, v) {
            var dx = v[_this.target] - v[_this.source];
            return c + dx * dx;
        }, 0));
    };
    return Link3D;
}());
exports.Link3D = Link3D;
var Node3D = (function () {
    function Node3D(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
    }
    return Node3D;
}());
exports.Node3D = Node3D;
var Layout3D = (function () {
    function Layout3D(nodes, links, idealLinkLength) {
        if (idealLinkLength === void 0) { idealLinkLength = 1; }
        var _this = this;
        this.nodes = nodes;
        this.links = links;
        this.idealLinkLength = idealLinkLength;
        this.constraints = null;
        this.useJaccardLinkLengths = true;
        this.result = new Array(Layout3D.k);
        for (var i = 0; i < Layout3D.k; ++i) {
            this.result[i] = new Array(nodes.length);
        }
        nodes.forEach(function (v, i) {
            for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {
                var dim = _a[_i];
                if (typeof v[dim] == 'undefined')
                    v[dim] = Math.random();
            }
            _this.result[0][i] = v.x;
            _this.result[1][i] = v.y;
            _this.result[2][i] = v.z;
        });
    }
    ;
    Layout3D.prototype.linkLength = function (l) {
        return l.actualLength(this.result);
    };
    Layout3D.prototype.start = function (iterations) {
        var _this = this;
        if (iterations === void 0) { iterations = 100; }
        var n = this.nodes.length;
        var linkAccessor = new LinkAccessor();
        if (this.useJaccardLinkLengths)
            linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
        this.links.forEach(function (e) { return e.length *= _this.idealLinkLength; });
        var distanceMatrix = (new shortestpaths_1.Calculator(n, this.links, function (e) { return e.source; }, function (e) { return e.target; }, function (e) { return e.length; })).DistanceMatrix();
        var D = descent_1.Descent.createSquareMatrix(n, function (i, j) { return distanceMatrix[i][j]; });
        var G = descent_1.Descent.createSquareMatrix(n, function () { return 2; });
        this.links.forEach(function (_a) {
            var source = _a.source, target = _a.target;
            return G[source][target] = G[target][source] = 1;
        });
        this.descent = new descent_1.Descent(this.result, D);
        this.descent.threshold = 1e-3;
        this.descent.G = G;
        if (this.constraints)
            this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        this.descent.run(iterations);
        return this;
    };
    Layout3D.prototype.tick = function () {
        this.descent.locks.clear();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [v.x, v.y, v.z]);
            }
        }
        return this.descent.rungeKutta();
    };
    Layout3D.dims = ['x', 'y', 'z'];
    Layout3D.k = Layout3D.dims.length;
    return Layout3D;
}());
exports.Layout3D = Layout3D;
var LinkAccessor = (function () {
    function LinkAccessor() {
    }
    LinkAccessor.prototype.getSourceIndex = function (e) { return e.source; };
    LinkAccessor.prototype.getTargetIndex = function (e) { return e.target; };
    LinkAccessor.prototype.getLength = function (e) { return e.length; };
    LinkAccessor.prototype.setLength = function (e, l) { e.length = l; };
    return LinkAccessor;
}());

},{"./descent":11,"./linklengths":17,"./rectangle":21,"./shortestpaths":22}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function unionCount(a, b) {
    var u = {};
    for (var i in a)
        u[i] = {};
    for (var i in b)
        u[i] = {};
    return Object.keys(u).length;
}
function intersectionCount(a, b) {
    var n = 0;
    for (var i in a)
        if (typeof b[i] !== 'undefined')
            ++n;
    return n;
}
function getNeighbours(links, la) {
    var neighbours = {};
    var addNeighbours = function (u, v) {
        if (typeof neighbours[u] === 'undefined')
            neighbours[u] = {};
        neighbours[u][v] = {};
    };
    links.forEach(function (e) {
        var u = la.getSourceIndex(e), v = la.getTargetIndex(e);
        addNeighbours(u, v);
        addNeighbours(v, u);
    });
    return neighbours;
}
function computeLinkLengths(links, w, f, la) {
    var neighbours = getNeighbours(links, la);
    links.forEach(function (l) {
        var a = neighbours[la.getSourceIndex(l)];
        var b = neighbours[la.getTargetIndex(l)];
        la.setLength(l, 1 + w * f(a, b));
    });
}
function symmetricDiffLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) { return Math.sqrt(unionCount(a, b) - intersectionCount(a, b)); }, la);
}
exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
function jaccardLinkLengths(links, la, w) {
    if (w === void 0) { w = 1; }
    computeLinkLengths(links, w, function (a, b) {
        return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);
    }, la);
}
exports.jaccardLinkLengths = jaccardLinkLengths;
function generateDirectedEdgeConstraints(n, links, axis, la) {
    var components = stronglyConnectedComponents(n, links, la);
    var nodes = {};
    components.forEach(function (c, i) {
        return c.forEach(function (v) { return nodes[v] = i; });
    });
    var constraints = [];
    links.forEach(function (l) {
        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];
        if (u !== v) {
            constraints.push({
                axis: axis,
                left: ui,
                right: vi,
                gap: la.getMinSeparation(l)
            });
        }
    });
    return constraints;
}
exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
function stronglyConnectedComponents(numVertices, edges, la) {
    var nodes = [];
    var index = 0;
    var stack = [];
    var components = [];
    function strongConnect(v) {
        v.index = v.lowlink = index++;
        stack.push(v);
        v.onStack = true;
        for (var _i = 0, _a = v.out; _i < _a.length; _i++) {
            var w = _a[_i];
            if (typeof w.index === 'undefined') {
                strongConnect(w);
                v.lowlink = Math.min(v.lowlink, w.lowlink);
            }
            else if (w.onStack) {
                v.lowlink = Math.min(v.lowlink, w.index);
            }
        }
        if (v.lowlink === v.index) {
            var component = [];
            while (stack.length) {
                w = stack.pop();
                w.onStack = false;
                component.push(w);
                if (w === v)
                    break;
            }
            components.push(component.map(function (v) { return v.id; }));
        }
    }
    for (var i = 0; i < numVertices; i++) {
        nodes.push({ id: i, out: [] });
    }
    for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
        var e = edges_1[_i];
        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];
        v_1.out.push(w);
    }
    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
        var v = nodes_1[_a];
        if (typeof v.index === 'undefined')
            strongConnect(v);
    }
    return components;
}
exports.stronglyConnectedComponents = stronglyConnectedComponents;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PowerEdge = (function () {
    function PowerEdge(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
    }
    return PowerEdge;
}());
exports.PowerEdge = PowerEdge;
var Configuration = (function () {
    function Configuration(n, edges, linkAccessor, rootGroup) {
        var _this = this;
        this.linkAccessor = linkAccessor;
        this.modules = new Array(n);
        this.roots = [];
        if (rootGroup) {
            this.initModulesFromGroup(rootGroup);
        }
        else {
            this.roots.push(new ModuleSet());
            for (var i = 0; i < n; ++i)
                this.roots[0].add(this.modules[i] = new Module(i));
        }
        this.R = edges.length;
        edges.forEach(function (e) {
            var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);
            s.outgoing.add(type, t);
            t.incoming.add(type, s);
        });
    }
    Configuration.prototype.initModulesFromGroup = function (group) {
        var moduleSet = new ModuleSet();
        this.roots.push(moduleSet);
        for (var i = 0; i < group.leaves.length; ++i) {
            var node = group.leaves[i];
            var module = new Module(node.id);
            this.modules[node.id] = module;
            moduleSet.add(module);
        }
        if (group.groups) {
            for (var j = 0; j < group.groups.length; ++j) {
                var child = group.groups[j];
                var definition = {};
                for (var prop in child)
                    if (prop !== "leaves" && prop !== "groups" && child.hasOwnProperty(prop))
                        definition[prop] = child[prop];
                moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
            }
        }
        return moduleSet;
    };
    Configuration.prototype.merge = function (a, b, k) {
        if (k === void 0) { k = 0; }
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        var children = new ModuleSet();
        children.add(a);
        children.add(b);
        var m = new Module(this.modules.length, outInt, inInt, children);
        this.modules.push(m);
        var update = function (s, i, o) {
            s.forAll(function (ms, linktype) {
                ms.forAll(function (n) {
                    var nls = n[i];
                    nls.add(linktype, m);
                    nls.remove(linktype, a);
                    nls.remove(linktype, b);
                    a[o].remove(linktype, n);
                    b[o].remove(linktype, n);
                });
            });
        };
        update(outInt, "incoming", "outgoing");
        update(inInt, "outgoing", "incoming");
        this.R -= inInt.count() + outInt.count();
        this.roots[k].remove(a);
        this.roots[k].remove(b);
        this.roots[k].add(m);
        return m;
    };
    Configuration.prototype.rootMerges = function (k) {
        if (k === void 0) { k = 0; }
        var rs = this.roots[k].modules();
        var n = rs.length;
        var merges = new Array(n * (n - 1));
        var ctr = 0;
        for (var i = 0, i_ = n - 1; i < i_; ++i) {
            for (var j = i + 1; j < n; ++j) {
                var a = rs[i], b = rs[j];
                merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };
                ctr++;
            }
        }
        return merges;
    };
    Configuration.prototype.greedyMerge = function () {
        for (var i = 0; i < this.roots.length; ++i) {
            if (this.roots[i].modules().length < 2)
                continue;
            var ms = this.rootMerges(i).sort(function (a, b) { return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges; });
            var m = ms[0];
            if (m.nEdges >= this.R)
                continue;
            this.merge(m.a, m.b, i);
            return true;
        }
    };
    Configuration.prototype.nEdges = function (a, b) {
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        return this.R - inInt.count() - outInt.count();
    };
    Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {
        var _this = this;
        var groups = [];
        var root = {};
        toGroups(this.roots[0], root, groups);
        var es = this.allEdges();
        es.forEach(function (e) {
            var a = _this.modules[e.source];
            var b = _this.modules[e.target];
            retargetedEdges.push(new PowerEdge(typeof a.gid === "undefined" ? e.source : groups[a.gid], typeof b.gid === "undefined" ? e.target : groups[b.gid], e.type));
        });
        return groups;
    };
    Configuration.prototype.allEdges = function () {
        var es = [];
        Configuration.getEdges(this.roots[0], es);
        return es;
    };
    Configuration.getEdges = function (modules, es) {
        modules.forAll(function (m) {
            m.getEdges(es);
            Configuration.getEdges(m.children, es);
        });
    };
    return Configuration;
}());
exports.Configuration = Configuration;
function toGroups(modules, group, groups) {
    modules.forAll(function (m) {
        if (m.isLeaf()) {
            if (!group.leaves)
                group.leaves = [];
            group.leaves.push(m.id);
        }
        else {
            var g = group;
            m.gid = groups.length;
            if (!m.isIsland() || m.isPredefined()) {
                g = { id: m.gid };
                if (m.isPredefined())
                    for (var prop in m.definition)
                        g[prop] = m.definition[prop];
                if (!group.groups)
                    group.groups = [];
                group.groups.push(m.gid);
                groups.push(g);
            }
            toGroups(m.children, g, groups);
        }
    });
}
var Module = (function () {
    function Module(id, outgoing, incoming, children, definition) {
        if (outgoing === void 0) { outgoing = new LinkSets(); }
        if (incoming === void 0) { incoming = new LinkSets(); }
        if (children === void 0) { children = new ModuleSet(); }
        this.id = id;
        this.outgoing = outgoing;
        this.incoming = incoming;
        this.children = children;
        this.definition = definition;
    }
    Module.prototype.getEdges = function (es) {
        var _this = this;
        this.outgoing.forAll(function (ms, edgetype) {
            ms.forAll(function (target) {
                es.push(new PowerEdge(_this.id, target.id, edgetype));
            });
        });
    };
    Module.prototype.isLeaf = function () {
        return this.children.count() === 0;
    };
    Module.prototype.isIsland = function () {
        return this.outgoing.count() === 0 && this.incoming.count() === 0;
    };
    Module.prototype.isPredefined = function () {
        return typeof this.definition !== "undefined";
    };
    return Module;
}());
exports.Module = Module;
function intersection(m, n) {
    var i = {};
    for (var v in m)
        if (v in n)
            i[v] = m[v];
    return i;
}
var ModuleSet = (function () {
    function ModuleSet() {
        this.table = {};
    }
    ModuleSet.prototype.count = function () {
        return Object.keys(this.table).length;
    };
    ModuleSet.prototype.intersection = function (other) {
        var result = new ModuleSet();
        result.table = intersection(this.table, other.table);
        return result;
    };
    ModuleSet.prototype.intersectionCount = function (other) {
        return this.intersection(other).count();
    };
    ModuleSet.prototype.contains = function (id) {
        return id in this.table;
    };
    ModuleSet.prototype.add = function (m) {
        this.table[m.id] = m;
    };
    ModuleSet.prototype.remove = function (m) {
        delete this.table[m.id];
    };
    ModuleSet.prototype.forAll = function (f) {
        for (var mid in this.table) {
            f(this.table[mid]);
        }
    };
    ModuleSet.prototype.modules = function () {
        var vs = [];
        this.forAll(function (m) {
            if (!m.isPredefined())
                vs.push(m);
        });
        return vs;
    };
    return ModuleSet;
}());
exports.ModuleSet = ModuleSet;
var LinkSets = (function () {
    function LinkSets() {
        this.sets = {};
        this.n = 0;
    }
    LinkSets.prototype.count = function () {
        return this.n;
    };
    LinkSets.prototype.contains = function (id) {
        var result = false;
        this.forAllModules(function (m) {
            if (!result && m.id == id) {
                result = true;
            }
        });
        return result;
    };
    LinkSets.prototype.add = function (linktype, m) {
        var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
        s.add(m);
        ++this.n;
    };
    LinkSets.prototype.remove = function (linktype, m) {
        var ms = this.sets[linktype];
        ms.remove(m);
        if (ms.count() === 0) {
            delete this.sets[linktype];
        }
        --this.n;
    };
    LinkSets.prototype.forAll = function (f) {
        for (var linktype in this.sets) {
            f(this.sets[linktype], Number(linktype));
        }
    };
    LinkSets.prototype.forAllModules = function (f) {
        this.forAll(function (ms, lt) { return ms.forAll(f); });
    };
    LinkSets.prototype.intersection = function (other) {
        var result = new LinkSets();
        this.forAll(function (ms, lt) {
            if (lt in other.sets) {
                var i = ms.intersection(other.sets[lt]), n = i.count();
                if (n > 0) {
                    result.sets[lt] = i;
                    result.n += n;
                }
            }
        });
        return result;
    };
    return LinkSets;
}());
exports.LinkSets = LinkSets;
function intersectionCount(m, n) {
    return Object.keys(intersection(m, n)).length;
}
function getGroups(nodes, links, la, rootGroup) {
    var n = nodes.length, c = new Configuration(n, links, la, rootGroup);
    while (c.greedyMerge())
        ;
    var powerEdges = [];
    var g = c.getGroupHierarchy(powerEdges);
    powerEdges.forEach(function (e) {
        var f = function (end) {
            var g = e[end];
            if (typeof g == "number")
                e[end] = nodes[g];
        };
        f("source");
        f("target");
    });
    return { groups: g, powerEdges: powerEdges };
}
exports.getGroups = getGroups;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PairingHeap = (function () {
    function PairingHeap(elem) {
        this.elem = elem;
        this.subheaps = [];
    }
    PairingHeap.prototype.toString = function (selector) {
        var str = "", needComma = false;
        for (var i = 0; i < this.subheaps.length; ++i) {
            var subheap = this.subheaps[i];
            if (!subheap.elem) {
                needComma = false;
                continue;
            }
            if (needComma) {
                str = str + ",";
            }
            str = str + subheap.toString(selector);
            needComma = true;
        }
        if (str !== "") {
            str = "(" + str + ")";
        }
        return (this.elem ? selector(this.elem) : "") + str;
    };
    PairingHeap.prototype.forEach = function (f) {
        if (!this.empty()) {
            f(this.elem, this);
            this.subheaps.forEach(function (s) { return s.forEach(f); });
        }
    };
    PairingHeap.prototype.count = function () {
        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {
            return n + h.count();
        }, 0);
    };
    PairingHeap.prototype.min = function () {
        return this.elem;
    };
    PairingHeap.prototype.empty = function () {
        return this.elem == null;
    };
    PairingHeap.prototype.contains = function (h) {
        if (this === h)
            return true;
        for (var i = 0; i < this.subheaps.length; i++) {
            if (this.subheaps[i].contains(h))
                return true;
        }
        return false;
    };
    PairingHeap.prototype.isHeap = function (lessThan) {
        var _this = this;
        return this.subheaps.every(function (h) { return lessThan(_this.elem, h.elem) && h.isHeap(lessThan); });
    };
    PairingHeap.prototype.insert = function (obj, lessThan) {
        return this.merge(new PairingHeap(obj), lessThan);
    };
    PairingHeap.prototype.merge = function (heap2, lessThan) {
        if (this.empty())
            return heap2;
        else if (heap2.empty())
            return this;
        else if (lessThan(this.elem, heap2.elem)) {
            this.subheaps.push(heap2);
            return this;
        }
        else {
            heap2.subheaps.push(this);
            return heap2;
        }
    };
    PairingHeap.prototype.removeMin = function (lessThan) {
        if (this.empty())
            return null;
        else
            return this.mergePairs(lessThan);
    };
    PairingHeap.prototype.mergePairs = function (lessThan) {
        if (this.subheaps.length == 0)
            return new PairingHeap(null);
        else if (this.subheaps.length == 1) {
            return this.subheaps[0];
        }
        else {
            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
            var remaining = this.mergePairs(lessThan);
            return firstPair.merge(remaining, lessThan);
        }
    };
    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {
        var newHeap = subheap.removeMin(lessThan);
        subheap.elem = newHeap.elem;
        subheap.subheaps = newHeap.subheaps;
        if (setHeapNode !== null && newHeap.elem !== null) {
            setHeapNode(subheap.elem, subheap);
        }
        var pairingNode = new PairingHeap(newValue);
        if (setHeapNode !== null) {
            setHeapNode(newValue, pairingNode);
        }
        return this.merge(pairingNode, lessThan);
    };
    return PairingHeap;
}());
exports.PairingHeap = PairingHeap;
var PriorityQueue = (function () {
    function PriorityQueue(lessThan) {
        this.lessThan = lessThan;
    }
    PriorityQueue.prototype.top = function () {
        if (this.empty()) {
            return null;
        }
        return this.root.elem;
    };
    PriorityQueue.prototype.push = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pairingNode;
        for (var i = 0, arg; arg = args[i]; ++i) {
            pairingNode = new PairingHeap(arg);
            this.root = this.empty() ?
                pairingNode : this.root.merge(pairingNode, this.lessThan);
        }
        return pairingNode;
    };
    PriorityQueue.prototype.empty = function () {
        return !this.root || !this.root.elem;
    };
    PriorityQueue.prototype.isHeap = function () {
        return this.root.isHeap(this.lessThan);
    };
    PriorityQueue.prototype.forEach = function (f) {
        this.root.forEach(f);
    };
    PriorityQueue.prototype.pop = function () {
        if (this.empty()) {
            return null;
        }
        var obj = this.root.min();
        this.root = this.root.removeMin(this.lessThan);
        return obj;
    };
    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {
        if (setHeapNode === void 0) { setHeapNode = null; }
        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
    };
    PriorityQueue.prototype.toString = function (selector) {
        return this.root.toString(selector);
    };
    PriorityQueue.prototype.count = function () {
        return this.root.count();
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TreeBase = (function () {
    function TreeBase() {
        this.findIter = function (data) {
            var res = this._root;
            var iter = this.iterator();
            while (res !== null) {
                var c = this._comparator(data, res.data);
                if (c === 0) {
                    iter._cursor = res;
                    return iter;
                }
                else {
                    iter._ancestors.push(res);
                    res = res.get_child(c > 0);
                }
            }
            return null;
        };
    }
    TreeBase.prototype.clear = function () {
        this._root = null;
        this.size = 0;
    };
    ;
    TreeBase.prototype.find = function (data) {
        var res = this._root;
        while (res !== null) {
            var c = this._comparator(data, res.data);
            if (c === 0) {
                return res.data;
            }
            else {
                res = res.get_child(c > 0);
            }
        }
        return null;
    };
    ;
    TreeBase.prototype.lowerBound = function (data) {
        return this._bound(data, this._comparator);
    };
    ;
    TreeBase.prototype.upperBound = function (data) {
        var cmp = this._comparator;
        function reverse_cmp(a, b) {
            return cmp(b, a);
        }
        return this._bound(data, reverse_cmp);
    };
    ;
    TreeBase.prototype.min = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.left !== null) {
            res = res.left;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.max = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.right !== null) {
            res = res.right;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.iterator = function () {
        return new Iterator(this);
    };
    ;
    TreeBase.prototype.each = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.next()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype.reach = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.prev()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype._bound = function (data, cmp) {
        var cur = this._root;
        var iter = this.iterator();
        while (cur !== null) {
            var c = this._comparator(data, cur.data);
            if (c === 0) {
                iter._cursor = cur;
                return iter;
            }
            iter._ancestors.push(cur);
            cur = cur.get_child(c > 0);
        }
        for (var i = iter._ancestors.length - 1; i >= 0; --i) {
            cur = iter._ancestors[i];
            if (cmp(data, cur.data) > 0) {
                iter._cursor = cur;
                iter._ancestors.length = i;
                return iter;
            }
        }
        iter._ancestors.length = 0;
        return iter;
    };
    ;
    return TreeBase;
}());
exports.TreeBase = TreeBase;
var Iterator = (function () {
    function Iterator(tree) {
        this._tree = tree;
        this._ancestors = [];
        this._cursor = null;
    }
    Iterator.prototype.data = function () {
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.next = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._minNode(root);
            }
        }
        else {
            if (this._cursor.right === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.right === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._minNode(this._cursor.right);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.prev = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._maxNode(root);
            }
        }
        else {
            if (this._cursor.left === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    }
                    else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.left === save);
            }
            else {
                this._ancestors.push(this._cursor);
                this._maxNode(this._cursor.left);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype._minNode = function (start) {
        while (start.left !== null) {
            this._ancestors.push(start);
            start = start.left;
        }
        this._cursor = start;
    };
    ;
    Iterator.prototype._maxNode = function (start) {
        while (start.right !== null) {
            this._ancestors.push(start);
            start = start.right;
        }
        this._cursor = start;
    };
    ;
    return Iterator;
}());
exports.Iterator = Iterator;
var Node = (function () {
    function Node(data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.red = true;
    }
    Node.prototype.get_child = function (dir) {
        return dir ? this.right : this.left;
    };
    ;
    Node.prototype.set_child = function (dir, val) {
        if (dir) {
            this.right = val;
        }
        else {
            this.left = val;
        }
    };
    ;
    return Node;
}());
var RBTree = (function (_super) {
    __extends(RBTree, _super);
    function RBTree(comparator) {
        var _this = _super.call(this) || this;
        _this._root = null;
        _this._comparator = comparator;
        _this.size = 0;
        return _this;
    }
    RBTree.prototype.insert = function (data) {
        var ret = false;
        if (this._root === null) {
            this._root = new Node(data);
            ret = true;
            this.size++;
        }
        else {
            var head = new Node(undefined);
            var dir = false;
            var last = false;
            var gp = null;
            var ggp = head;
            var p = null;
            var node = this._root;
            ggp.right = this._root;
            while (true) {
                if (node === null) {
                    node = new Node(data);
                    p.set_child(dir, node);
                    ret = true;
                    this.size++;
                }
                else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {
                    node.red = true;
                    node.left.red = false;
                    node.right.red = false;
                }
                if (RBTree.is_red(node) && RBTree.is_red(p)) {
                    var dir2 = ggp.right === gp;
                    if (node === p.get_child(last)) {
                        ggp.set_child(dir2, RBTree.single_rotate(gp, !last));
                    }
                    else {
                        ggp.set_child(dir2, RBTree.double_rotate(gp, !last));
                    }
                }
                var cmp = this._comparator(node.data, data);
                if (cmp === 0) {
                    break;
                }
                last = dir;
                dir = cmp < 0;
                if (gp !== null) {
                    ggp = gp;
                }
                gp = p;
                p = node;
                node = node.get_child(dir);
            }
            this._root = head.right;
        }
        this._root.red = false;
        return ret;
    };
    ;
    RBTree.prototype.remove = function (data) {
        if (this._root === null) {
            return false;
        }
        var head = new Node(undefined);
        var node = head;
        node.right = this._root;
        var p = null;
        var gp = null;
        var found = null;
        var dir = true;
        while (node.get_child(dir) !== null) {
            var last = dir;
            gp = p;
            p = node;
            node = node.get_child(dir);
            var cmp = this._comparator(data, node.data);
            dir = cmp > 0;
            if (cmp === 0) {
                found = node;
            }
            if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {
                if (RBTree.is_red(node.get_child(!dir))) {
                    var sr = RBTree.single_rotate(node, dir);
                    p.set_child(last, sr);
                    p = sr;
                }
                else if (!RBTree.is_red(node.get_child(!dir))) {
                    var sibling = p.get_child(!last);
                    if (sibling !== null) {
                        if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {
                            p.red = false;
                            sibling.red = true;
                            node.red = true;
                        }
                        else {
                            var dir2 = gp.right === p;
                            if (RBTree.is_red(sibling.get_child(last))) {
                                gp.set_child(dir2, RBTree.double_rotate(p, last));
                            }
                            else if (RBTree.is_red(sibling.get_child(!last))) {
                                gp.set_child(dir2, RBTree.single_rotate(p, last));
                            }
                            var gpc = gp.get_child(dir2);
                            gpc.red = true;
                            node.red = true;
                            gpc.left.red = false;
                            gpc.right.red = false;
                        }
                    }
                }
            }
        }
        if (found !== null) {
            found.data = node.data;
            p.set_child(p.right === node, node.get_child(node.left === null));
            this.size--;
        }
        this._root = head.right;
        if (this._root !== null) {
            this._root.red = false;
        }
        return found !== null;
    };
    ;
    RBTree.is_red = function (node) {
        return node !== null && node.red;
    };
    RBTree.single_rotate = function (root, dir) {
        var save = root.get_child(!dir);
        root.set_child(!dir, save.get_child(dir));
        save.set_child(dir, root);
        root.red = true;
        save.red = false;
        return save;
    };
    RBTree.double_rotate = function (root, dir) {
        root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));
        return RBTree.single_rotate(root, dir);
    };
    return RBTree;
}(TreeBase));
exports.RBTree = RBTree;

},{}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var vpsc_1 = require("./vpsc");
var rbtree_1 = require("./rbtree");
function computeGroupBounds(g) {
    g.bounds = typeof g.leaves !== "undefined" ?
        g.leaves.reduce(function (r, c) { return c.bounds.union(r); }, Rectangle.empty()) :
        Rectangle.empty();
    if (typeof g.groups !== "undefined")
        g.bounds = g.groups.reduce(function (r, c) { return computeGroupBounds(c).union(r); }, g.bounds);
    g.bounds = g.bounds.inflate(g.padding);
    return g.bounds;
}
exports.computeGroupBounds = computeGroupBounds;
var Rectangle = (function () {
    function Rectangle(x, X, y, Y) {
        this.x = x;
        this.X = X;
        this.y = y;
        this.Y = Y;
    }
    Rectangle.empty = function () { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); };
    Rectangle.prototype.cx = function () { return (this.x + this.X) / 2; };
    Rectangle.prototype.cy = function () { return (this.y + this.Y) / 2; };
    Rectangle.prototype.overlapX = function (r) {
        var ux = this.cx(), vx = r.cx();
        if (ux <= vx && r.x < this.X)
            return this.X - r.x;
        if (vx <= ux && this.x < r.X)
            return r.X - this.x;
        return 0;
    };
    Rectangle.prototype.overlapY = function (r) {
        var uy = this.cy(), vy = r.cy();
        if (uy <= vy && r.y < this.Y)
            return this.Y - r.y;
        if (vy <= uy && this.y < r.Y)
            return r.Y - this.y;
        return 0;
    };
    Rectangle.prototype.setXCentre = function (cx) {
        var dx = cx - this.cx();
        this.x += dx;
        this.X += dx;
    };
    Rectangle.prototype.setYCentre = function (cy) {
        var dy = cy - this.cy();
        this.y += dy;
        this.Y += dy;
    };
    Rectangle.prototype.width = function () {
        return this.X - this.x;
    };
    Rectangle.prototype.height = function () {
        return this.Y - this.y;
    };
    Rectangle.prototype.union = function (r) {
        return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
    };
    Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {
        var sides = [[this.x, this.y, this.X, this.y],
            [this.X, this.y, this.X, this.Y],
            [this.X, this.Y, this.x, this.Y],
            [this.x, this.Y, this.x, this.y]];
        var intersections = [];
        for (var i = 0; i < 4; ++i) {
            var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
            if (r !== null)
                intersections.push({ x: r.x, y: r.y });
        }
        return intersections;
    };
    Rectangle.prototype.rayIntersection = function (x2, y2) {
        var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);
        return ints.length > 0 ? ints[0] : null;
    };
    Rectangle.prototype.vertices = function () {
        return [
            { x: this.x, y: this.y },
            { x: this.X, y: this.y },
            { x: this.X, y: this.Y },
            { x: this.x, y: this.Y }
        ];
    };
    Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;
        if (denominator == 0)
            return null;
        var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;
        if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {
            return {
                x: x1 + a * dx12,
                y: y1 + a * dy12
            };
        }
        return null;
    };
    Rectangle.prototype.inflate = function (pad) {
        return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;
function makeEdgeBetween(source, target, ah) {
    var si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() }, ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;
    return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }
    };
}
exports.makeEdgeBetween = makeEdgeBetween;
function makeEdgeTo(s, target, ah) {
    var ti = target.rayIntersection(s.x, s.y);
    if (!ti)
        ti = { x: target.cx(), y: target.cy() };
    var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);
    return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };
}
exports.makeEdgeTo = makeEdgeTo;
var Node = (function () {
    function Node(v, r, pos) {
        this.v = v;
        this.r = r;
        this.pos = pos;
        this.prev = makeRBTree();
        this.next = makeRBTree();
    }
    return Node;
}());
var Event = (function () {
    function Event(isOpen, v, pos) {
        this.isOpen = isOpen;
        this.v = v;
        this.pos = pos;
    }
    return Event;
}());
function compareEvents(a, b) {
    if (a.pos > b.pos) {
        return 1;
    }
    if (a.pos < b.pos) {
        return -1;
    }
    if (a.isOpen) {
        return -1;
    }
    if (b.isOpen) {
        return 1;
    }
    return 0;
}
function makeRBTree() {
    return new rbtree_1.RBTree(function (a, b) { return a.pos - b.pos; });
}
var xRect = {
    getCentre: function (r) { return r.cx(); },
    getOpen: function (r) { return r.y; },
    getClose: function (r) { return r.Y; },
    getSize: function (r) { return r.width(); },
    makeRect: function (open, close, center, size) { return new Rectangle(center - size / 2, center + size / 2, open, close); },
    findNeighbours: findXNeighbours
};
var yRect = {
    getCentre: function (r) { return r.cy(); },
    getOpen: function (r) { return r.x; },
    getClose: function (r) { return r.X; },
    getSize: function (r) { return r.height(); },
    makeRect: function (open, close, center, size) { return new Rectangle(open, close, center - size / 2, center + size / 2); },
    findNeighbours: findYNeighbours
};
function generateGroupConstraints(root, f, minSep, isContained) {
    if (isContained === void 0) { isContained = false; }
    var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? []
        : root.groups.reduce(function (ccs, g) { return ccs.concat(generateGroupConstraints(g, f, minSep, true)); }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) { rs[i] = r; vs[i++] = v; };
    if (isContained) {
        var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;
        root.minVar.desiredPosition = min;
        add(f.makeRect(open, close, min, padding), root.minVar);
        root.maxVar.desiredPosition = max;
        add(f.makeRect(open, close, max, padding), root.maxVar);
    }
    if (ln)
        root.leaves.forEach(function (l) { return add(l.bounds, l.variable); });
    if (gn)
        root.groups.forEach(function (g) {
            var b = g.bounds;
            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);
        });
    var cs = generateConstraints(rs, vs, f, minSep);
    if (gn) {
        vs.forEach(function (v) { v.cOut = [], v.cIn = []; });
        cs.forEach(function (c) { c.left.cOut.push(c), c.right.cIn.push(c); });
        root.groups.forEach(function (g) {
            var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
            g.minVar.cIn.forEach(function (c) { return c.gap += gapAdjustment; });
            g.minVar.cOut.forEach(function (c) { c.left = g.maxVar; c.gap += gapAdjustment; });
        });
    }
    return childConstraints.concat(cs);
}
function generateConstraints(rs, vars, rect, minSep) {
    var i, n = rs.length;
    var N = 2 * n;
    console.assert(vars.length >= n);
    var events = new Array(N);
    for (i = 0; i < n; ++i) {
        var r = rs[i];
        var v = new Node(vars[i], r, rect.getCentre(r));
        events[i] = new Event(true, v, rect.getOpen(r));
        events[i + n] = new Event(false, v, rect.getClose(r));
    }
    events.sort(compareEvents);
    var cs = new Array();
    var scanline = makeRBTree();
    for (i = 0; i < N; ++i) {
        var e = events[i];
        var v = e.v;
        if (e.isOpen) {
            scanline.insert(v);
            rect.findNeighbours(v, scanline);
        }
        else {
            scanline.remove(v);
            var makeConstraint = function (l, r) {
                var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;
                cs.push(new vpsc_1.Constraint(l.v, r.v, sep));
            };
            var visitNeighbours = function (forward, reverse, mkcon) {
                var u, it = v[forward].iterator();
                while ((u = it[forward]()) !== null) {
                    mkcon(u, v);
                    u[reverse].remove(v);
                }
            };
            visitNeighbours("prev", "next", function (u, v) { return makeConstraint(u, v); });
            visitNeighbours("next", "prev", function (u, v) { return makeConstraint(v, u); });
        }
    }
    console.assert(scanline.size === 0);
    return cs;
}
function findXNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var it = scanline.findIter(v);
        var u;
        while ((u = it[forward]()) !== null) {
            var uovervX = u.r.overlapX(v.r);
            if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {
                v[forward].insert(u);
                u[reverse].insert(v);
            }
            if (uovervX <= 0) {
                break;
            }
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function findYNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var u = scanline.findIter(v)[forward]();
        if (u !== null && u.r.overlapX(v.r) > 0) {
            v[forward].insert(u);
            u[reverse].insert(v);
        }
    };
    f("next", "prev");
    f("prev", "next");
}
function generateXConstraints(rs, vars) {
    return generateConstraints(rs, vars, xRect, 1e-6);
}
exports.generateXConstraints = generateXConstraints;
function generateYConstraints(rs, vars) {
    return generateConstraints(rs, vars, yRect, 1e-6);
}
exports.generateYConstraints = generateYConstraints;
function generateXGroupConstraints(root) {
    return generateGroupConstraints(root, xRect, 1e-6);
}
exports.generateXGroupConstraints = generateXGroupConstraints;
function generateYGroupConstraints(root) {
    return generateGroupConstraints(root, yRect, 1e-6);
}
exports.generateYGroupConstraints = generateYGroupConstraints;
function removeOverlaps(rs) {
    var vs = rs.map(function (r) { return new vpsc_1.Variable(r.cx()); });
    var cs = generateXConstraints(rs, vs);
    var solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setXCentre(v.position()); });
    vs = rs.map(function (r) { return new vpsc_1.Variable(r.cy()); });
    cs = generateYConstraints(rs, vs);
    solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) { return rs[i].setYCentre(v.position()); });
}
exports.removeOverlaps = removeOverlaps;
var IndexedVariable = (function (_super) {
    __extends(IndexedVariable, _super);
    function IndexedVariable(index, w) {
        var _this = _super.call(this, 0, w) || this;
        _this.index = index;
        return _this;
    }
    return IndexedVariable;
}(vpsc_1.Variable));
exports.IndexedVariable = IndexedVariable;
var Projection = (function () {
    function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {
        if (rootGroup === void 0) { rootGroup = null; }
        if (constraints === void 0) { constraints = null; }
        if (avoidOverlaps === void 0) { avoidOverlaps = false; }
        var _this = this;
        this.nodes = nodes;
        this.groups = groups;
        this.rootGroup = rootGroup;
        this.avoidOverlaps = avoidOverlaps;
        this.variables = nodes.map(function (v, i) {
            return v.variable = new IndexedVariable(i, 1);
        });
        if (constraints)
            this.createConstraints(constraints);
        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {
            nodes.forEach(function (v) {
                if (!v.width || !v.height) {
                    v.bounds = new Rectangle(v.x, v.x, v.y, v.y);
                    return;
                }
                var w2 = v.width / 2, h2 = v.height / 2;
                v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);
            });
            computeGroupBounds(rootGroup);
            var i = nodes.length;
            groups.forEach(function (g) {
                _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
                _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
            });
        }
    }
    Projection.prototype.createSeparation = function (c) {
        return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== "undefined" ? c.equality : false);
    };
    Projection.prototype.makeFeasible = function (c) {
        var _this = this;
        if (!this.avoidOverlaps)
            return;
        var axis = 'x', dim = 'width';
        if (c.axis === 'x')
            axis = 'y', dim = 'height';
        var vs = c.offsets.map(function (o) { return _this.nodes[o.node]; }).sort(function (a, b) { return a[axis] - b[axis]; });
        var p = null;
        vs.forEach(function (v) {
            if (p) {
                var nextPos = p[axis] + p[dim];
                if (nextPos > v[axis]) {
                    v[axis] = nextPos;
                }
            }
            p = v;
        });
    };
    Projection.prototype.createAlignment = function (c) {
        var _this = this;
        var u = this.nodes[c.offsets[0].node].variable;
        this.makeFeasible(c);
        var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;
        c.offsets.slice(1).forEach(function (o) {
            var v = _this.nodes[o.node].variable;
            cs.push(new vpsc_1.Constraint(u, v, o.offset, true));
        });
    };
    Projection.prototype.createConstraints = function (constraints) {
        var _this = this;
        var isSep = function (c) { return typeof c.type === 'undefined' || c.type === 'separation'; };
        this.xConstraints = constraints
            .filter(function (c) { return c.axis === "x" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        this.yConstraints = constraints
            .filter(function (c) { return c.axis === "y" && isSep(c); })
            .map(function (c) { return _this.createSeparation(c); });
        constraints
            .filter(function (c) { return c.type === 'alignment'; })
            .forEach(function (c) { return _this.createAlignment(c); });
    };
    Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {
        this.nodes.forEach(function (v, i) {
            if (v.fixed) {
                v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;
                desired[i] = getDesired(v);
            }
            else {
                v.variable.weight = 1;
            }
            var w = (v.width || 0) / 2, h = (v.height || 0) / 2;
            var ix = x0[i], iy = y0[i];
            v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);
        });
    };
    Projection.prototype.xProject = function (x0, y0, x) {
        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
            return;
        this.project(x0, y0, x0, x, function (v) { return v.px; }, this.xConstraints, generateXGroupConstraints, function (v) { return v.bounds.setXCentre(x[v.variable.index] = v.variable.position()); }, function (g) {
            var xmin = x[g.minVar.index] = g.minVar.position();
            var xmax = x[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.x = xmin - p2;
            g.bounds.X = xmax + p2;
        });
    };
    Projection.prototype.yProject = function (x0, y0, y) {
        if (!this.rootGroup && !this.yConstraints)
            return;
        this.project(x0, y0, y0, y, function (v) { return v.py; }, this.yConstraints, generateYGroupConstraints, function (v) { return v.bounds.setYCentre(y[v.variable.index] = v.variable.position()); }, function (g) {
            var ymin = y[g.minVar.index] = g.minVar.position();
            var ymax = y[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.y = ymin - p2;
            ;
            g.bounds.Y = ymax + p2;
        });
    };
    Projection.prototype.projectFunctions = function () {
        var _this = this;
        return [
            function (x0, y0, x) { return _this.xProject(x0, y0, x); },
            function (x0, y0, y) { return _this.yProject(x0, y0, y); }
        ];
    };
    Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {
        this.setupVariablesAndBounds(x0, y0, desired, getDesired);
        if (this.rootGroup && this.avoidOverlaps) {
            computeGroupBounds(this.rootGroup);
            cs = cs.concat(generateConstraints(this.rootGroup));
        }
        this.solve(this.variables, cs, start, desired);
        this.nodes.forEach(updateNodeBounds);
        if (this.rootGroup && this.avoidOverlaps) {
            this.groups.forEach(updateGroupBounds);
            computeGroupBounds(this.rootGroup);
        }
    };
    Projection.prototype.solve = function (vs, cs, starting, desired) {
        var solver = new vpsc_1.Solver(vs, cs);
        solver.setStartingPositions(starting);
        solver.setDesiredPositions(desired);
        solver.solve();
    };
    return Projection;
}());
exports.Projection = Projection;

},{"./rbtree":20,"./vpsc":23}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pqueue_1 = require("./pqueue");
var Neighbour = (function () {
    function Neighbour(id, distance) {
        this.id = id;
        this.distance = distance;
    }
    return Neighbour;
}());
var Node = (function () {
    function Node(id) {
        this.id = id;
        this.neighbours = [];
    }
    return Node;
}());
var QueueEntry = (function () {
    function QueueEntry(node, prev, d) {
        this.node = node;
        this.prev = prev;
        this.d = d;
    }
    return QueueEntry;
}());
var Calculator = (function () {
    function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {
        this.n = n;
        this.es = es;
        this.neighbours = new Array(this.n);
        var i = this.n;
        while (i--)
            this.neighbours[i] = new Node(i);
        i = this.es.length;
        while (i--) {
            var e = this.es[i];
            var u = getSourceIndex(e), v = getTargetIndex(e);
            var d = getLength(e);
            this.neighbours[u].neighbours.push(new Neighbour(v, d));
            this.neighbours[v].neighbours.push(new Neighbour(u, d));
        }
    }
    Calculator.prototype.DistanceMatrix = function () {
        var D = new Array(this.n);
        for (var i = 0; i < this.n; ++i) {
            D[i] = this.dijkstraNeighbours(i);
        }
        return D;
    };
    Calculator.prototype.DistancesFromNode = function (start) {
        return this.dijkstraNeighbours(start);
    };
    Calculator.prototype.PathFromNodeToNode = function (start, end) {
        return this.dijkstraNeighbours(start, end);
    };
    Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};
        q.push(qu);
        while (!q.empty()) {
            qu = q.pop();
            u = qu.node;
            if (u.id === end) {
                break;
            }
            var i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];
                if (qu.prev && v.id === qu.prev.node.id)
                    continue;
                var viduid = v.id + ',' + u.id;
                if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
                    continue;
                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;
                visitedFrom[viduid] = t;
                q.push(new QueueEntry(v, qu, t));
            }
        }
        var path = [];
        while (qu.prev) {
            qu = qu.prev;
            path.push(qu.node.id);
        }
        return path;
    };
    Calculator.prototype.dijkstraNeighbours = function (start, dest) {
        if (dest === void 0) { dest = -1; }
        var q = new pqueue_1.PriorityQueue(function (a, b) { return a.d <= b.d; }), i = this.neighbours.length, d = new Array(i);
        while (i--) {
            var node = this.neighbours[i];
            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;
            node.q = q.push(node);
        }
        while (!q.empty()) {
            var u = q.pop();
            d[u.id] = u.d;
            if (u.id === dest) {
                var path = [];
                var v = u;
                while (typeof v.prev !== 'undefined') {
                    path.push(v.prev.id);
                    v = v.prev;
                }
                return path;
            }
            i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i];
                var v = this.neighbours[neighbour.id];
                var t = u.d + neighbour.distance;
                if (u.d !== Number.MAX_VALUE && v.d > t) {
                    v.d = t;
                    v.prev = u;
                    q.reduceKey(v.q, v, function (e, q) { return e.q = q; });
                }
            }
        }
        return d;
    };
    return Calculator;
}());
exports.Calculator = Calculator;

},{"./pqueue":19}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PositionStats = (function () {
    function PositionStats(scale) {
        this.scale = scale;
        this.AB = 0;
        this.AD = 0;
        this.A2 = 0;
    }
    PositionStats.prototype.addVariable = function (v) {
        var ai = this.scale / v.scale;
        var bi = v.offset / v.scale;
        var wi = v.weight;
        this.AB += wi * ai * bi;
        this.AD += wi * ai * v.desiredPosition;
        this.A2 += wi * ai * ai;
    };
    PositionStats.prototype.getPosn = function () {
        return (this.AD - this.AB) / this.A2;
    };
    return PositionStats;
}());
exports.PositionStats = PositionStats;
var Constraint = (function () {
    function Constraint(left, right, gap, equality) {
        if (equality === void 0) { equality = false; }
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
        this.active = false;
        this.unsatisfiable = false;
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
    }
    Constraint.prototype.slack = function () {
        return this.unsatisfiable ? Number.MAX_VALUE
            : this.right.scale * this.right.position() - this.gap
                - this.left.scale * this.left.position();
    };
    return Constraint;
}());
exports.Constraint = Constraint;
var Variable = (function () {
    function Variable(desiredPosition, weight, scale) {
        if (weight === void 0) { weight = 1; }
        if (scale === void 0) { scale = 1; }
        this.desiredPosition = desiredPosition;
        this.weight = weight;
        this.scale = scale;
        this.offset = 0;
    }
    Variable.prototype.dfdv = function () {
        return 2.0 * this.weight * (this.position() - this.desiredPosition);
    };
    Variable.prototype.position = function () {
        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
    };
    Variable.prototype.visitNeighbours = function (prev, f) {
        var ff = function (c, next) { return c.active && prev !== next && f(c, next); };
        this.cOut.forEach(function (c) { return ff(c, c.right); });
        this.cIn.forEach(function (c) { return ff(c, c.left); });
    };
    return Variable;
}());
exports.Variable = Variable;
var Block = (function () {
    function Block(v) {
        this.vars = [];
        v.offset = 0;
        this.ps = new PositionStats(v.scale);
        this.addVariable(v);
    }
    Block.prototype.addVariable = function (v) {
        v.block = this;
        this.vars.push(v);
        this.ps.addVariable(v);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.updateWeightedPosition = function () {
        this.ps.AB = this.ps.AD = this.ps.A2 = 0;
        for (var i = 0, n = this.vars.length; i < n; ++i)
            this.ps.addVariable(this.vars[i]);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.compute_lm = function (v, u, postAction) {
        var _this = this;
        var dfdv = v.dfdv();
        v.visitNeighbours(u, function (c, next) {
            var _dfdv = _this.compute_lm(next, v, postAction);
            if (next === c.right) {
                dfdv += _dfdv * c.left.scale;
                c.lm = _dfdv;
            }
            else {
                dfdv += _dfdv * c.right.scale;
                c.lm = -_dfdv;
            }
            postAction(c);
        });
        return dfdv / v.scale;
    };
    Block.prototype.populateSplitBlock = function (v, prev) {
        var _this = this;
        v.visitNeighbours(prev, function (c, next) {
            next.offset = v.offset + (next === c.right ? c.gap : -c.gap);
            _this.addVariable(next);
            _this.populateSplitBlock(next, v);
        });
    };
    Block.prototype.traverse = function (visit, acc, v, prev) {
        var _this = this;
        if (v === void 0) { v = this.vars[0]; }
        if (prev === void 0) { prev = null; }
        v.visitNeighbours(prev, function (c, next) {
            acc.push(visit(c));
            _this.traverse(visit, acc, next, v);
        });
    };
    Block.prototype.findMinLM = function () {
        var m = null;
        this.compute_lm(this.vars[0], null, function (c) {
            if (!c.equality && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findMinLMBetween = function (lv, rv) {
        this.compute_lm(lv, null, function () { });
        var m = null;
        this.findPath(lv, null, rv, function (c, next) {
            if (!c.equality && c.right === next && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findPath = function (v, prev, to, visit) {
        var _this = this;
        var endFound = false;
        v.visitNeighbours(prev, function (c, next) {
            if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {
                endFound = true;
                visit(c, next);
            }
        });
        return endFound;
    };
    Block.prototype.isActiveDirectedPathBetween = function (u, v) {
        if (u === v)
            return true;
        var i = u.cOut.length;
        while (i--) {
            var c = u.cOut[i];
            if (c.active && this.isActiveDirectedPathBetween(c.right, v))
                return true;
        }
        return false;
    };
    Block.split = function (c) {
        c.active = false;
        return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];
    };
    Block.createSplitBlock = function (startVar) {
        var b = new Block(startVar);
        b.populateSplitBlock(startVar, null);
        return b;
    };
    Block.prototype.splitBetween = function (vl, vr) {
        var c = this.findMinLMBetween(vl, vr);
        if (c !== null) {
            var bs = Block.split(c);
            return { constraint: c, lb: bs[0], rb: bs[1] };
        }
        return null;
    };
    Block.prototype.mergeAcross = function (b, c, dist) {
        c.active = true;
        for (var i = 0, n = b.vars.length; i < n; ++i) {
            var v = b.vars[i];
            v.offset += dist;
            this.addVariable(v);
        }
        this.posn = this.ps.getPosn();
    };
    Block.prototype.cost = function () {
        var sum = 0, i = this.vars.length;
        while (i--) {
            var v = this.vars[i], d = v.position() - v.desiredPosition;
            sum += d * d * v.weight;
        }
        return sum;
    };
    return Block;
}());
exports.Block = Block;
var Blocks = (function () {
    function Blocks(vs) {
        this.vs = vs;
        var n = vs.length;
        this.list = new Array(n);
        while (n--) {
            var b = new Block(vs[n]);
            this.list[n] = b;
            b.blockInd = n;
        }
    }
    Blocks.prototype.cost = function () {
        var sum = 0, i = this.list.length;
        while (i--)
            sum += this.list[i].cost();
        return sum;
    };
    Blocks.prototype.insert = function (b) {
        b.blockInd = this.list.length;
        this.list.push(b);
    };
    Blocks.prototype.remove = function (b) {
        var last = this.list.length - 1;
        var swapBlock = this.list[last];
        this.list.length = last;
        if (b !== swapBlock) {
            this.list[b.blockInd] = swapBlock;
            swapBlock.blockInd = b.blockInd;
        }
    };
    Blocks.prototype.merge = function (c) {
        var l = c.left.block, r = c.right.block;
        var dist = c.right.offset - c.left.offset - c.gap;
        if (l.vars.length < r.vars.length) {
            r.mergeAcross(l, c, dist);
            this.remove(l);
        }
        else {
            l.mergeAcross(r, c, -dist);
            this.remove(r);
        }
    };
    Blocks.prototype.forEach = function (f) {
        this.list.forEach(f);
    };
    Blocks.prototype.updateBlockPositions = function () {
        this.list.forEach(function (b) { return b.updateWeightedPosition(); });
    };
    Blocks.prototype.split = function (inactive) {
        var _this = this;
        this.updateBlockPositions();
        this.list.forEach(function (b) {
            var v = b.findMinLM();
            if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {
                b = v.left.block;
                Block.split(v).forEach(function (nb) { return _this.insert(nb); });
                _this.remove(b);
                inactive.push(v);
            }
        });
    };
    return Blocks;
}());
exports.Blocks = Blocks;
var Solver = (function () {
    function Solver(vs, cs) {
        this.vs = vs;
        this.cs = cs;
        this.vs = vs;
        vs.forEach(function (v) {
            v.cIn = [], v.cOut = [];
        });
        this.cs = cs;
        cs.forEach(function (c) {
            c.left.cOut.push(c);
            c.right.cIn.push(c);
        });
        this.inactive = cs.map(function (c) { c.active = false; return c; });
        this.bs = null;
    }
    Solver.prototype.cost = function () {
        return this.bs.cost();
    };
    Solver.prototype.setStartingPositions = function (ps) {
        this.inactive = this.cs.map(function (c) { c.active = false; return c; });
        this.bs = new Blocks(this.vs);
        this.bs.forEach(function (b, i) { return b.posn = ps[i]; });
    };
    Solver.prototype.setDesiredPositions = function (ps) {
        this.vs.forEach(function (v, i) { return v.desiredPosition = ps[i]; });
    };
    Solver.prototype.mostViolated = function () {
        var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;
        for (var i = 0; i < n; ++i) {
            var c = l[i];
            if (c.unsatisfiable)
                continue;
            var slack = c.slack();
            if (c.equality || slack < minSlack) {
                minSlack = slack;
                v = c;
                deletePoint = i;
                if (c.equality)
                    break;
            }
        }
        if (deletePoint !== n &&
            (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {
            l[deletePoint] = l[n - 1];
            l.length = n - 1;
        }
        return v;
    };
    Solver.prototype.satisfy = function () {
        if (this.bs == null) {
            this.bs = new Blocks(this.vs);
        }
        this.bs.split(this.inactive);
        var v = null;
        while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {
            var lb = v.left.block, rb = v.right.block;
            if (lb !== rb) {
                this.bs.merge(v);
            }
            else {
                if (lb.isActiveDirectedPathBetween(v.right, v.left)) {
                    v.unsatisfiable = true;
                    continue;
                }
                var split = lb.splitBetween(v.left, v.right);
                if (split !== null) {
                    this.bs.insert(split.lb);
                    this.bs.insert(split.rb);
                    this.bs.remove(lb);
                    this.inactive.push(split.constraint);
                }
                else {
                    v.unsatisfiable = true;
                    continue;
                }
                if (v.slack() >= 0) {
                    this.inactive.push(v);
                }
                else {
                    this.bs.merge(v);
                }
            }
        }
    };
    Solver.prototype.solve = function () {
        this.satisfy();
        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();
        while (Math.abs(lastcost - cost) > 0.0001) {
            this.satisfy();
            lastcost = cost;
            cost = this.bs.cost();
        }
        return cost;
    };
    Solver.LAGRANGIAN_TOLERANCE = -1e-4;
    Solver.ZERO_UPPERBOUND = -1e-10;
    return Solver;
}());
exports.Solver = Solver;
function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
    var vs = spans.map(function (s) { return new Variable(s.desiredCenter); });
    var cs = [];
    var n = spans.length;
    for (var i = 0; i < n - 1; i++) {
        var left = spans[i], right = spans[i + 1];
        cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));
    }
    var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;
    var vLower = null, vUpper = null;
    if (lowerBound) {
        vLower = new Variable(lowerBound, leftMost.weight * 1000);
        vs.push(vLower);
        cs.push(new Constraint(vLower, leftMost, leftMostSize));
    }
    if (upperBound) {
        vUpper = new Variable(upperBound, rightMost.weight * 1000);
        vs.push(vUpper);
        cs.push(new Constraint(rightMost, vUpper, rightMostSize));
    }
    var solver = new Solver(vs, cs);
    solver.solve();
    return {
        newCenters: vs.slice(0, spans.length).map(function (v) { return v.position(); }),
        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
    };
}
exports.removeOverlapInOneDimension = removeOverlapInOneDimension;

},{}],24:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (typeof input === 'string') {
      this.url = input
    } else {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split('\r\n').forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var UNKNOW_IMAGE = exports.UNKNOW_IMAGE = 'data:image/png;base64,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';
var LINK_OPTIONS = exports.LINK_OPTIONS = 'data:image/png;base64,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';
var FEED_PIPE = exports.FEED_PIPE = 'data:image/png;base64,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';

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataContainer = DataContainer;
exports.GroupOfZones = GroupOfZones;
exports.NodesZone = NodesZone;
/**
 * Maps is the set of the map functions
 * @typedef {Object} Maps
 * @property {[id: string]: Node} nodeMap - map id to [Node]{@link Node} - Returns Node by id and (optional) role.
 * @property {[id: string]: Link} linkMap - map id to  [Link]{@link Link} - Returns Link by id and (optional) role.
 * @property {[id: string]: Link} sourceMap - map id to  [Link]{@link Link}[] - Returns all incoming links for the node with specified id (filters by role).
 * @property {[id: string]: Link} targetMap - map id to  [Link]{@link Link}[] - Returns all outgoing links for the node with specified id (filters by role).
*/

/**
 * End elements of the graph, which were created from {@link ServerData}.
 * @typedef {Object} GraphData
 * @property {Link[]} links - List of Links of the graph
 * @property {Node[]} nodes - List of Nodes of the graph
*/

/**
 * @private
 * DataContainer - an object which is a data model of the LinegeGram. It stores and orginizes
 * data for the views and also provides set of maps (dictionaries) for links and nodes of the graph.
 * You can get this model using a LineaGram method which is called 'getGraphModel'.
 * DataContainer implements separation and filtration mechanisms, in other words,
 * you can return different data for different roles.
 * @class
 * @param {GraphData} data - Raw data - models for links and nodes of the graph.
 * @param {Parameters} parameters - Parameters set
 * 
 * @property {Maps} maps - Set of the map functions
 */
function DataContainer(data, parameters) {
    var self = this;

    if (!data) data = {};
    if (!data.nodes) data.nodes = [];
    if (!data.links) data.links = [];

    self.nodes = data.nodes;
    self.links = data.links;
    self.maps = { sourceMap: {}, targetMap: {}, nodeMap: {}, linkMap: {}, idMap: {} };
    self.zones = [];

    var _zoneSize = parameters.dataZoneSize;
    var _elementSize = parameters.elementSize;
    var _zonesInGroup = parameters.zonesInGroup;

    // If some node dont hit any real zone it will hit this one.
    var _fakeZone = new NodesZone(null, {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        elementSize: 0,
        fakeZone: true
    });
    if (_elementSize.width >= _zoneSize.width || _elementSize.height >= _zoneSize.height) {
        _zoneSize.width = _elementSize.width * 20;
        _zoneSize.height = _elementSize.height * 20;
    }

    /**
     * Returns nodes and links which are lie near the point
     * @param {Point[]} points - Array of points
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsNearThePoints = function (points) {
        var suitableZones = _zonesForPoints(points);
        var resultNodes = [];
        var resultLinks = [];

        suitableZones.forEach(function (z) {
            z.relatedNodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.nodes.forEach(function (n) {
                if (resultNodes.indexOf(n) === -1) {
                    resultNodes.push(n);
                }
            });
            z.links.forEach(function (l) {
                if (resultLinks.indexOf(l) === -1) {
                    resultLinks.push(l);
                }
            });
        });

        return {
            nodes: resultNodes,
            links: resultLinks
        };
    };

    /**
     * Rectangle
     * @typedef {Object} Rectangle
     * @property {number} x - Position by x axis
     * @property {number} y - Position by y axis
     * @property {number} width - Width of the rectangle
     * @property {number} height - Height of the rectangle
    */

    /**
     * Returns nodes and links which are lie into the rectangle
     * @param {Rectangle} rect - Hit rectangle
     * @return {GraphData} - Nodes and Links
     * @memberof DataContainer
     * @method
    */
    self.getElementsForRectangle = function (rect) {

        if (!rect) return { nodes: [], links: [] };
        var points = [];
        if (rect.width <= _zoneSize.width && rect.height <= _zoneSize.height) {
            points.push({ x: rect.x, y: rect.y });
            points.push({ x: rect.x + rect.width, y: rect.y });
            points.push({ x: rect.x, y: rect.y + rect.height });
            points.push({ x: rect.x + rect.width, y: rect.y + rect.height });
        } else {
            for (var x = rect.x;; x += _zoneSize.width) {
                for (var y = rect.y;; y += _zoneSize.height) {
                    points.push({
                        x: Math.min(x, rect.x + rect.width),
                        y: Math.min(y, rect.y + rect.height)
                    });
                    if (y >= rect.y + rect.height) break;
                }
                if (x >= rect.x + rect.width) break;
            }
        }
        return self.getElementsNearThePoints(points);
    };

    /**
     * Returns nodes related with the target node
     * @param {Node} node - target node
     * @return {Node[]}
     * @memberof DataContainer
     * @method
    */
    self.getRelatedNodes = function (node) {
        var neighbors = [];
        if (self.maps.targetMap[node.id]) {
            self.maps.targetMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.target]);
            });
        }
        if (self.maps.sourceMap[node.id]) {
            self.maps.sourceMap[node.id].forEach(function (l) {
                return neighbors.push(self.maps.nodeMap[l.model.source]);
            });
        }
        return neighbors;
    };

    /**
     * Refreshes container. It means that all maps will
     * be updated and nodes in the container will be organized.
     * @param {Node} node - Target node (optional)
     * @memberof DataContainer
     * @method
    */
    self.refresh = function (newData) {
        if (newData) {
            if (newData.nodes) {
                self.nodes = newData.nodes;
            }
            if (newData.links) {
                self.links = newData.links;
            }
        }
        _refreshMaps();
        _refreshGrid();
    };

    /**
     * Moves node from one zone to another.
     * We are using it when node is dragged to somewhere on the paper
     * @param {Node} node - target node
     * @param {Point} oldPos - previous position of the target node
     * @memberof DataContainer
     * @method
    */
    self.updateZonesForNode = function (node, oldPos) {
        var curPos = node.model.position;
        var oldZones = _zonesForPoints([oldPos]);

        oldZones.forEach(function (zone) {
            var newNodes = zone.nodes.filter(function (n) {
                return n !== node;
            });
            _clearZone(zone);
            _fillZone(zone, newNodes);
        });

        var newZones = _zonesForPoints([curPos]);
        if (newZones) {
            newZones.forEach(function (z) {
                _fillZone(z, [node]);
            });
        } else {
            _fillZone(_fakeZone, [node]);
        }
    };

    /**
     * Returns all zones which contain obtained points.
     * @private
     * @param {Point[]} points
     * @return {NodesZone[]}
    */
    function _zonesForPoints(points) {
        points = points || [];
        var suitableZones = [];

        function recursion(p, zones) {
            zones.forEach(function (z) {
                if (z.hitTest(p)) {
                    if (z instanceof GroupOfZones) {
                        recursion(p, z.zones);
                    } else if (suitableZones.indexOf(z) === -1) {
                        suitableZones.push(z);
                    }
                }
            });
        }
        points.forEach(function (p) {
            recursion(p, self.zones);
        });
        suitableZones.push(_fakeZone);

        return suitableZones;
    }

    /**
     * Calculates zones tree.
     * @private
    */
    function _refreshGrid() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.nodes.forEach(function (node) {
            var pos = node.model.position;
            minX = minX === undefined ? pos.x : Math.min(minX, pos.x);
            minY = minY === undefined ? pos.y : Math.min(minY, pos.y);
            maxX = maxX === undefined ? pos.x : Math.max(maxX, pos.x);
            maxY = maxY === undefined ? pos.y : Math.max(maxY, pos.y);
        });

        var zones = [];
        var nodes = [].concat(self.nodes);
        for (var x = minX, i = 0; x <= maxX; x += _zoneSize.width - _elementSize.width, i++) {
            zones[i] = [];
            for (var y = minY, j = 0; y <= maxY; y += _zoneSize.height - _elementSize.height, j++) {
                var newZone = new NodesZone(null, {
                    x: x,
                    y: y,
                    width: _zoneSize.width,
                    height: _zoneSize.height,
                    elementSize: _elementSize
                });
                nodes = _fillZone(newZone, nodes);
                zones[i][j] = newZone;
            }
        }
        self.zones = _groupZones(zones);
        self.zones.push(_fakeZone);
    }

    /**
     * Groups zones by groups of (by default) four.
     * @private
     * @param {NodeZone[]} zones
     * @return {NodeZone[] | GroupOfZones}
    */
    function _groupZones(zones) {
        var MAX_DEEP = 1000;
        var side = Math.sqrt(_zonesInGroup); // length of side of group
        var newZones = void 0;
        for (var n = 0; n < MAX_DEEP && zones.length !== 1; n++) {
            // iterations
            newZones = [];
            for (var i = 0, ni = 0; i < zones.length; i += side, ni++) {
                newZones[ni] = [];
                for (var j = 0, nj = 0; j < zones[i].length; j += side, nj++) {
                    var zonesOfGroup = [];
                    zonesOfGroup.push(zones[i][j]);
                    if (zones[i + 1] && zones[i + 1][j]) zonesOfGroup.push(zones[i + 1][j]);
                    if (zones[i] && zones[i][j + 1]) zonesOfGroup.push(zones[i][j + 1]);
                    if (zones[i + 1] && zones[i + 1][j + 1]) zonesOfGroup.push(zones[i + 1][j + 1]);
                    newZones[ni][nj] = new GroupOfZones(zonesOfGroup);
                }
            }
            zones = newZones;
        }
        if (newZones) zones = newZones;
        return zones[0] || [];
    }

    /**
     * Puts nodes and links into zone.
     * @private
     * @param {NodeZone} zone
     * @param {Node[]} nodes
     * @return {Node[]}
    */
    function _fillZone(zone, nodes) {
        var notFitedNodes = []; // indexes to remove the catched nodes from the list
        nodes.forEach(function (node) {
            if (zone.nodeHitTest(node)) {
                zone.nodes.push(node);

                self.getRelatedNodes(node).forEach(function (n) {
                    if (zone.relatedNodes.indexOf(n) === -1) {
                        zone.relatedNodes.push(n);
                    }
                });

                if (self.maps.sourceMap[node.id]) {
                    self.maps.sourceMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
                if (self.maps.targetMap[node.id]) {
                    self.maps.targetMap[node.id].forEach(function (link) {
                        zone.links.push(link);
                    });
                }
            } else {
                notFitedNodes.push(node);
            }
        });
        return notFitedNodes;
    }

    /**
     * Clear zone - remove all data from the zone.
     * @private
     * @param {NodeZone} zone
    */
    function _clearZone(zone) {
        zone.relatedNodes = [];
        zone.nodes = [];
        zone.links = [];
    }

    /**
     * Creates map for nodes
     * and updates aspect relations between nodes
     * @private
     * @returns nodeMap
    */
    function _createNodeMaps() {
        var nodeMap = {};
        var idMap = {};
        self.nodes.forEach(function (node) {
            nodeMap[node.id] = node;
            nodeMap[node.model.id] = node.id;
        });
        return {
            nodeMap: nodeMap,
            idMap: idMap
        };
    }

    /**
     * Creates maps for links.
     * @private
     * @param {Object} nodeMap
     * @param {Object} idMap
     * @returns {linkMap, idMap}
    */
    function _createLinkMaps(nodeMap, idMap) {
        var sourceMap = {};
        var targetMap = {};
        var linkMap = {};

        self.links.forEach(function (link) {
            linkMap[link.id] = link;
            idMap[link.model.id] = link.id;

            var source = nodeMap[link.model.source];
            var target = nodeMap[link.model.target];

            if (!sourceMap[target.id]) {
                sourceMap[target.id] = [];
            }
            sourceMap[target.id].push(link);

            if (!targetMap[source.id]) {
                targetMap[source.id] = [];
            }
            targetMap[source.id].push(link);
        });
        return {
            linkMap: linkMap,
            sourceMap: sourceMap,
            targetMap: targetMap,
            idMap: idMap
        };
    }

    /**
     * Updates maps.
     * @private
    */
    function _refreshMaps() {
        var _createNodeMaps2 = _createNodeMaps(),
            nodeMap = _createNodeMaps2.nodeMap,
            idMap = _createNodeMaps2.idMap;

        var linkMaps = _createLinkMaps(nodeMap, idMap);

        self.maps = {
            sourceMap: linkMaps.sourceMap,
            targetMap: linkMaps.targetMap,
            nodeMap: nodeMap,
            idMap: linkMaps.idMap,
            linkMap: linkMaps.linkMap
        };
    }

    self.refresh();
}
exports.default = DataContainer;

/**
 * @private
 * Object that is the leaf of the zones tree
 * @class
 * @param {NodeZone[]} zones - Array of zonnes for containing
 * @property {NodeZone[]} zones - Array of zonnes
 */

function GroupOfZones(zones) {
    var self = this;

    self.model = {};
    self.zones = zones;

    _calculateBounds();

    /**
     * @private
     * Calculates bounds of the total area of contained zones. 
    */
    function _calculateBounds() {
        var minX = undefined,
            minY = undefined,
            maxX = undefined,
            maxY = undefined;

        self.zones.forEach(function (zone) {
            minX = minX === undefined ? zone.model.x : Math.min(minX, zone.model.x);
            minY = minY === undefined ? zone.model.y : Math.min(minY, zone.model.y);
            maxX = maxX === undefined ? zone.model.x + zone.model.width : Math.max(maxX, zone.model.x + zone.model.width);
            maxY = maxY === undefined ? zone.model.y + zone.model.height : Math.max(maxY, zone.model.y + zone.model.height);
        });
        self.model.x = minX;
        self.model.y = minY;
        self.model.width = maxX - minX;
        self.model.height = maxY - minY;
    }

    /**
     * Tells us whether a point fall into this group of zones or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof GroupOfZones
     * @method
    */
    self.hitTest = function (point) {
        return point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

/**
 * @private
 * Options of a NodeZone
 * @typedef {Object} NodeZoneOptions
 * @property {number} x - Position by x axis
 * @property {number} y - Position by y axis
 * @property {number} width - Width of the rectangle
 * @property {number} height - Height of the rectangle
 * @property {ElementSize} elementSize - Size of elements of the graph
 * @property {boolean} fakeZone - Is it fake zone (abstract or don't has position)
*/

/**
 * @private
 * Object that is the leaf of the tree of zones
 * @class
 * @param {Node[]} nodes - Nodes of the zone (can be undefined)
 * @param {NodeZoneOptions} parameters - Properties set
 * 
 * @property {NodeZoneOptions} model - Properties set
 */
function NodesZone(nodes, parameters) {
    var self = this;

    self.model = parameters;
    self.nodes = nodes || [];
    self.relatedNodes = [];
    self.links = [];

    var _elementSize = parameters.elementSize;

    /**
     * Tells us whether a Node fall into the zone or no.
     * @param {Node} node - Tested node
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.nodeHitTest = function (node) {
        if (self.model.fakeZone) return true;
        var nodePosition = node.model.position;

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + _elementSize.height };
        var p4 = { x: nodePosition.x + _elementSize.width, y: nodePosition.y + _elementSize.height };

        return self.hitTest(p1) && self.hitTest(p2) && self.hitTest(p3) && self.hitTest(p4);
    };

    /**
     * Tells us whether a point fall into the zone or no.
     * @param {Point} point - Tested point
     * @returns {boolean}
     * @memberof NodesZone
     * @method
    */
    self.hitTest = function (point) {
        return self.model.fakeZone || point.x >= self.model.x && point.x <= self.model.x + self.model.width && point.y >= self.model.y && point.y <= self.model.y + self.model.height;
    };
}

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;
exports.createAspectRelations = createAspectRelations;
var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var NODE_MODEL_FIELDS = exports.NODE_MODEL_FIELDS = ['id', 'label', 'viewFrame', 'typeId', 'activeResource', 'resource', 'resourceType', 'position', 'defaultPosition', 'data', 'offset'];

var LINK_MODEL_FIELDS = exports.LINK_MODEL_FIELDS = ['id', 'source', 'target', 'linkType', 'activeResourcesList', 'group', 'data'];

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */
function processData(data) {
    if (!data || !data.nodes) return;
    data.links = data.links || [];

    var nodeMap = {};

    data.nodes.forEach(function (node) {
        nodeMap[node.id] = node;
        node.position = { x: 0, y: 0 };
        // extracting additional data
        var data = {};
        Object.keys(node).forEach(function (key) {
            var notPermanentField = NODE_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = node[key];
                delete node[key];
            }
        });
        node.data = data;
    });

    var destinationMap = {};
    data.links.forEach(function (rawLink) {
        if (nodeMap[rawLink.source] && nodeMap[rawLink.target]) {
            var linkCacheId = getCacheId(rawLink);

            if (destinationMap[linkCacheId]) {
                destinationMap[linkCacheId] = group(destinationMap[linkCacheId], rawLink);
            } else {
                destinationMap[linkCacheId] = rawLink;
            }
        } else {
            if (!nodeMap[rawLink.source]) {
                console.warn('Source not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            } else {
                console.warn('Target not found! The link from ' + rawLink.source + ' to ' + rawLink.target);
            }
        }
    });

    var sourceMap = {};
    var targetMap = {};
    var links = Object.keys(destinationMap).map(function (cacheId) {
        var link = destinationMap[cacheId];
        Object.keys(link).forEach(function (key) {
            var notPermanentField = LINK_MODEL_FIELDS.indexOf(key) === -1;
            if (notPermanentField) {
                data[key] = link[key];
                delete link[key];
            }
        });

        if (!sourceMap[link.target]) sourceMap[link.target] = [];
        sourceMap[link.target].push(link);

        if (!targetMap[link.source]) targetMap[link.source] = [];
        targetMap[link.source].push(link);

        return link;
    });

    return {
        nodes: Object.keys(nodeMap).map(function (key) {
            return nodeMap[key];
        }),
        links: links
    };

    function getCacheId(link) {
        return 'source:(' + link.source + ')~#~target:(' + link.target + ')';
    }

    function group(existedLink, newLink) {
        var group = existedLink.group ? existedLink : {
            id: getCacheId(existedLink),
            source: existedLink.source,
            target: existedLink.target,
            linkType: LG_GROUP_TYPE_ID, // existedLink.linkType,
            group: [existedLink]
        };
        group.group.push(newLink);
        // extracting additional data
        return group;
    }
}
exports.default = processData;

/**
 * @private
 *
 * The function filters the data, sets authorities and collapses links.
 * @param {
 *  nodes: NodeModel[],
 *  links: LinkModel[]
 * } data
 */

function createAspectRelations(nodes) {
    var aspectMap = {};
    nodes.forEach(function (node) {
        // combine nodes with the same id
        var clearId = node.model.resource;
        if (clearId) {
            if (!aspectMap[clearId]) {
                aspectMap[clearId] = [node];
            } else {
                aspectMap[clearId].push(node);
            }
        }
    });
    Object.keys(aspectMap).forEach(function (key) {
        if (aspectMap[key].length > 1) {
            aspectMap[key].forEach(function (n) {
                var index = aspectMap[key].indexOf(n);
                n.aspects = aspectMap[key].slice(0, index).concat(aspectMap[key].slice(index + 1, aspectMap[key].length));
            });
        }
    });
}

},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultDataProvider = DefaultDataProvider;
function DefaultDataProvider(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _serverURL = parameters.serverURL || '/api/tbl/swp';
    var _defaultLineageGramViewClass = parameters.lgViewClass || 'http://edg.topbraid.solutions/model/BuildJSONforLineageModelLineageGram';
    var _vfViewClass = parameters.vfViewClass || 'edg:getViewFramesForResource';
    var _dmViewClass = parameters.dmViewClass || 'edg:DerivationMapDataService';
    var _vcViewClass = parameters.vcViewClass || 'edg:getLineageGramDataProvider';

    var _graph = parameters.graph || 'undefined';
    var _configGraph = parameters.configGraph || 'http://edg.topbraidlive.org/1.0/config/diagrams';
    var _base = parameters.base || 'undefined';

    var _reach = parameters.reach;
    var _range = parameters.range;
    var _breadth = parameters.breadth;
    var _depth = parameters.depth;

    self.fetchData = function (options) {
        return _executQuery(getFetchDataUrl(options.targetNodeId, options.viewFrame, options.lineageGramViewClass, options.diagramType, options.hasOwnProperty('offset') ? options.offset : null));
    };

    self.getViewFrames = function (resource) {
        return _executQuery(getViewFramesUrl(resource));
    };

    self.getViewClassForResource = function (resource) {
        return _executQuery(getViewClassUrl(resource));
    };

    self.getReach = function () {
        return _reach;
    };

    self.setReach = function (reach) {
        if (reach > 0 && reach < 11) {
            _reach = reach;
        }
    };

    self.getBreadth = function () {
        return _breadth;
    };

    self.setBreadth = function (breadth) {
        if (breadth > 0 && breadth < 11) {
            _breadth = breadth;
        }
    };

    self.relationInfo = function (relation) {
        var sourceResource = relation.source.resource;

        if (relation.source.hasOwnProperty('activeResource')) {
            sourceResource = relation.source.activeResource;
        }

        var targetResource = relation.target.resource;

        if (relation.target.hasOwnProperty('activeResource')) {
            targetResource = relation.target.activeResource;
        }

        return _postQuery(_serverURL, getDerivationDataParams(sourceResource, targetResource, relation.linkType, relation.activeResourcesList));
    };

    function getViewFramesUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vfViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getViewClassUrl(resource) {
        return _serverURL + '?' + '_viewClass=' + _vcViewClass + '&' + 'graph=' + _graph + '&' + 'resource=' + resource + '&' + 'configGraph=' + _configGraph + '&' + '_base=' + _base;
    }

    function getFetchDataUrl(focusNode, viewFrame, lineageGramViewClass, diagramType, offset) {
        var dataUrl = _serverURL + '?' + '_viewClass=' + (lineageGramViewClass || _defaultLineageGramViewClass) + '&' + 'graph=' + _graph + '&' + 'focusNode=' + encodeURIComponent(focusNode) + '&' + '_base=' + _base;

        if (viewFrame) {
            dataUrl += '&viewFrame=' + viewFrame;
        }

        if (offset) {
            dataUrl += '&offset=' + offset;
        }

        if (_reach) {
            dataUrl += '&reach=' + _reach;
        }

        if (_range) {
            dataUrl += '&range=' + _range;
        }

        if (_breadth) {
            dataUrl += '&breadth=' + _breadth;
        }

        if (_depth) {
            dataUrl += '&depth=' + _depth;
        }

        if (diagramType) {
            dataUrl += '&diagramType=' + diagramType;
        }

        return dataUrl;
    }

    function _executQuery(url) {
        return fetch(url, {
            method: 'GET',
            credentials: 'same-origin',
            mode: 'cors',
            cache: 'default',
            headers: {
                'Accept': 'application/json, text/turtle',
                'Content-Type': 'application/sparql-query'
            }
        }).then(function (response) {
            if (response.ok) {
                return response.json(); // Also possible to use: response.text(); //response.type;
            } else {
                var error = new Error(response.statusText);
                error.response = response;
                throw error;
            }
        });
    }

    function _postQuery(url, params) {

        var requestArgs = {};

        if (params != null) {
            for (var key in params) {
                //decode everything
                requestArgs[key] = decodeURIComponent(params[key]);
            }
        }

        var queryParams = new URLSearchParams(requestArgs);

        return fetch(url, {
            method: 'POST',
            credentials: 'same-origin',
            mode: 'cors',
            cache: 'default',
            headers: {
                'Accept': 'application/json, text/turtle'
            },
            body: queryParams
        }).then(function (response) {
            if (response.ok) {
                return response.json(); // Also possible to use: response.text(); //response.type;
            } else {
                var error = new Error(response.statusText);
                error.response = response;
                throw error;
            }
        });
    }

    function getDerivationDataParams(leftNode, rightNode, linkType, activeResourcesList) {

        var derivationParams = {
            _base: _base,
            _viewClass: _dmViewClass,
            leftNode: leftNode,
            rightNode: rightNode
        };

        if (linkType) {
            derivationParams['linkType'] = linkType;
        }

        if (activeResourcesList) {
            derivationParams['activeResourcesList'] = activeResourcesList;
        }

        return derivationParams;
    }
}
exports.default = DefaultDataProvider;

},{}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FEED_PIPE_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.LG_GROUP_TYPE_ID = exports.FEED_PIPE_TYPE = undefined;
exports.ResourceProvider = ResourceProvider;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _base64Images = require('./base64Images');

var images = _interopRequireWildcard(_base64Images);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FEED_PIPE_TYPE = exports.FEED_PIPE_TYPE = 'feedpipe';

var LG_GROUP_TYPE_ID = exports.LG_GROUP_TYPE_ID = 'tq-lg-group';

var DEFAULT_DERIVATION_MAP_LINK_STYLE = exports.DEFAULT_DERIVATION_MAP_LINK_STYLE = {
    cssClass: 'derivation-link',
    lineType: 'solid', // 'dashed'
    color: 'black',
    textColor: 'black',
    textBackgroundColor: 'white',
    thickness: 2
};

var DEFAULT_LINK_STYLE = exports.DEFAULT_LINK_STYLE = {
    cssClass: 'lineage-gram-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.LINK_OPTIONS,
        width: 30,
        height: 30,
        alwaysVisible: false
    },
    thickness: 2,
    hasArrow: true
};

var DEFAULT_GROUP_LINK_STYLE = exports.DEFAULT_GROUP_LINK_STYLE = {
    cssClass: 'lineage-gram-links-group',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    thickness: 2,
    hasArrow: true,
    toolButton: {
        alwaysVisible: true
    }
};

var FEED_PIPE_LINK_STYLE = exports.FEED_PIPE_LINK_STYLE = {
    cssClass: 'lineage-gram-feed-pipe-link',
    lineType: 'solid', // 'dashed'
    color: '#3c4260',
    toolButton: {
        image: images.FEED_PIPE,
        width: 30,
        height: 30,
        alwaysVisible: true
    },
    thickness: 3,
    hasArrow: true
};

function ResourceProvider(_parameters) {
    var self = this;

    self.getLinkStyle = _getLinkStyle;
    self.getImage = _getImage;
    self.getColor = _getColor;
    self.getIcon = _getIcon;

    function _getColor(type) {
        if (!type) {
            return 'white';
        }
        if (!type) {
            return _parameters.colors['default'];
        } else {
            return _parameters.colors[type] || _parameters.colors['default'];
        }
    }

    function _getImage(type) {
        if (!type) {
            return images.UNKNOW_IMAGE;
        }
        if (!_parameters.images[type] && type === 'link-options' || type === 'default-link-options') {
            return images.LINK_OPTIONS;
        }
        if (!_parameters.images[type] && type === 'feed-pipe' || type === 'default-feed-pipe') {
            return images.FEED_PIPE;
        }
        return _parameters.resourcePath + (_parameters.images[type] || _parameters.images['unknown'] || images.UNKNOW_IMAGE);
    }

    function _getLinkStyle(type) {
        var linkStyles = _parameters.linkStyles;
        var defaultStyle = _.cloneDeep(linkStyles['default-link-style'] || DEFAULT_LINK_STYLE);

        var linkStyle = void 0;
        if (!type) {
            linkStyle = defaultStyle || defaultStyle;
        } else {
            if (linkStyles[type]) {
                linkStyle = linkStyles[type];
            } else {
                linkStyle = defaultStyle || defaultStyle;
            }
        }
        return _.merge(defaultStyle, linkStyle);
    }

    function _getIcon(type) {
        if (!type) {
            return undefined;
        }

        return _parameters.icons[type];
    }
}

},{"./base64Images":25,"lodash":"lodash"}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DefaultUI = DefaultUI;

var _visualizationsLibrary = require("visualizations-library");

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _viewFrameButtons = require("./viewFrameButtons");

var _map = require("./map");

var _map2 = _interopRequireDefault(_map);

var _infoPanel = require("./infoPanel");

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require("./optionsPanel");

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DefaultUI(options) {
  var self = this;
  // Initialization
  // =======================================================
  var _lineageGram = options.lineageGram;
  var markup = "\n        <div class=\"tq-lg-default-user-ui\">\n            <div id=\"tqLgToolbar\"></div>\n            <div id=\"tqLgMiniMap\"></div>\n            <div id=\"tqLgInfoPanel\"></div>\n            <div id=\"tqLgOptionsPanel\"></div>\n            <div id=\"tqLgSearchPanel\"></div>\n        </div>\n    ";

  var _el = void 0;
  if (typeof options.baseElement === "string") {
    _el = document.getElementById(options.baseElement);
  } else if (_typeof(options.baseElement) === "object") {
    _el = options.baseElement;
  }
  if (!_el) return;
  _el.innerHTML = markup;

  var tqLgToolbar = _el.querySelector("#tqLgToolbar");
  var tqLgMiniMap = _el.querySelector("#tqLgMiniMap");
  var tqLgInfoPanel = _el.querySelector("#tqLgInfoPanel");
  var tqLgOptionsPanel = _el.querySelector("#tqLgOptionsPanel");
  var tqLgSearchPanel = _el.querySelector("#tqLgSearchPanel");

  var _zooming = _lineageGram.zoom();
  var _expandAll = false;
  // =======================================================

  var _coloredButtons = new _viewFrameButtons.ViewFrameButtons({
    lineageGram: _lineageGram
  });
  var _switcher = new _visualizationsLibrary2.default.Switcher({
    states: [{
      id: "lineageDiagram",
      label: "Lineage diagram view",
      icon: "fas fa-clone"
    }, {
      id: "birdEye",
      label: "Bird eye view",
      icon: "fas fa-eye"
    }],
    verticalOrientation: true
  });

  _switcher.on("state-changed", function (tabId) {
    _lineageGram.setCurrentView(tabId);
  });

  var _toolbar = new _visualizationsLibrary2.default.Toolbar({
    baseElement: tqLgToolbar,
    tools: [{
      id: "tqLgSearch",
      icon: "fas fa-search",
      label: "Search"
    }, {
      id: "tqLgZoomIn",
      icon: "fas fa-search-plus",
      label: "Zoom in",
      callback: function callback() {
        _zooming = _lineageGram.zoomIn();
        _toolbar.rootHtml.querySelector("#tqLgZoomIn").disabled = _zooming.cur === _zooming.max;
        _toolbar.rootHtml.querySelector("#tqLgZoomOut").disabled = _zooming.cur === _zooming.min;
      }
    }, {
      id: "tqLgZoomOut",
      icon: "fas fa-search-minus",
      label: "Zoom out",
      callback: function callback() {
        _zooming = _lineageGram.zoomOut();
        _toolbar.rootHtml.querySelector("#tqLgZoomIn").disabled = _zooming.cur === _zooming.max;
        _toolbar.rootHtml.querySelector("#tqLgZoomOut").disabled = _zooming.cur === _zooming.min;
      }
    }, {
      id: "tqLgZoomToFit",
      icon: "fas fa-expand",
      label: "Zoom to fit",
      callback: function callback() {
        _zooming = _lineageGram.zoomToFit();
      }
    }, {
      id: "tqLgReset",
      icon: "fas fa-sync",
      label: "Reset layout",
      callback: function callback() {
        _lineageGram.resetLayout();
      }
    }, {
      id: "tqLgGather",
      icon: "fas fa-thumbtack",
      label: "Gather relatives",
      callback: function callback() {
        _lineageGram.combine();
      }
    }, {
      id: "expandAll",
      icon: "fas fa-compress-alt",
      icon2: "fas fa-expand-alt",
      label: "Expand all nodes",
      callback: function callback() {
        if (_expandAll) {
          _lineageGram.expandAllNodes();
        } else {
          _lineageGram.collapseAllNodes();
        }
        _expandAll = !_expandAll;
      }
    }, _coloredButtons, _switcher, {
      id: "infoPanelBtn",
      icon: "fas fa-info-circle",
      label: "Info Panel"
    }, {
      id: "tqLgOptionsButton",
      icon: "fas fa-bars",
      label: "Options Panel"
    }]
  });
  self.toolbar = _toolbar;

  _lineageGram.on("current-view-changed", function (viewId) {
    var disabled = viewId !== "lineageDiagram";
    _switcher.setState(viewId);
    _toolbar.rootHtml.querySelector("#expandAll").disabled = disabled;
    _toolbar.rootHtml.querySelector("#tqLgReset").disabled = disabled;
    _toolbar.rootHtml.querySelector("#tqLgZoomIn").disabled = disabled;
    _toolbar.rootHtml.querySelector("#tqLgZoomOut").disabled = disabled;
    _toolbar.rootHtml.querySelector("#tqLgZoomToFit").disabled = disabled;
  });

  new _visualizationsLibrary2.default.SearchPanel({
    baseElement: tqLgSearchPanel,
    triggerButton: _toolbar.rootHtml.querySelector("#tqLgSearch"),
    active: false
  });

  new _infoPanel2.default({
    baseElement: tqLgInfoPanel,
    active: false,
    triggerButton: _toolbar.rootHtml.querySelector("#infoPanelBtn"),
    lineageGram: _lineageGram
  });

  new _optionsPanel2.default({
    lineageGram: _lineageGram,
    baseElement: tqLgOptionsPanel,
    active: false,
    triggerButton: _toolbar.rootHtml.querySelector("#tqLgOptionsButton"),
    legends: options.legends,
    onPressHelp: options.onPressHelp
  });

  new _map2.default({
    baseElement: tqLgMiniMap,
    active: false,
    lineageGram: _lineageGram,
    position: {
      x: "calc(100% - 265px)",
      y: "calc(100% - 265px)"
    }
  });
}
exports.default = DefaultUI;

},{"./infoPanel":33,"./map":34,"./optionsPanel":35,"./viewFrameButtons":37,"visualizations-library":70}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMDefaultUI = DMDefaultUI;

var _visualizationsLibrary = require("visualizations-library");

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _dmInfoPanel = require("./dmInfoPanel");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parameters set for a {@link Toolbar}.
 * @typedef {Object} DefaultUIOptions
 * @property {HTMLElement | String} baseElement - Root HTMLElement
 * @property {Object.<string, LegendDescriptor>} legends
 * @property {string} neighborGramViewClass
 * @property {DerivationMap} derivationMap
 */

/**
 * @private
 * @param {DefaultUIOptions} options
 */
function DMDefaultUI(options) {
  var self = this;
  var _derivationMap = options.derivationMap;
  var _base = _createBase(_getHtmlElement(options.baseElement), _getHtmlElement(options.infoPanel));
  var _expandAll = true;
  var _diagramInfo = undefined;

  // Initialization
  // ==================================================

  var baseTools = [{
    id: "tqDMSearch",
    icon: "fas fa-search",
    label: "Search",
    callback: _openCloseSearchPanel
  }, {
    id: "tqDMExportSVG",
    icon: "tool-bar-svg-icon",
    label: "Export to SVG",
    callback: function callback() {
      _derivationMap.exportToSvg();
    }
  }, {
    id: "tqDMExportPNG",
    icon: "tool-bar-png-icon",
    label: "Export to PNG",
    callback: function callback() {
      _derivationMap.exportToPng();
    }
  }, {
    id: "tqPrint",
    icon: "fas fa-print",
    label: "Print",
    callback: function callback() {
      _derivationMap.print();
    }
  }, {
    id: "tqDMZoomIn",
    icon: "fas fa-search-plus",
    label: "Zoom in",
    callback: function callback() {
      _derivationMap.zoomIn();
    }
  }, {
    id: "tqDMZoomOut",
    icon: "fas fa-search-minus",
    label: "Zoom out",
    callback: function callback() {
      _derivationMap.zoomOut();
    }
  }, {
    id: "tqDMZoomToFit",
    icon: "fas fa-expand",
    label: "Zoom to fit",
    callback: function callback() {
      _derivationMap.zoomToFit();
    }
  }, {
    id: "infoPanelBtn",
    icon: "fas fa-info-circle",
    label: "Open Info panel"
  }, {
    id: "expandAll",
    icon: "fas fa-compress-alt",
    icon2: "fas fa-expand-alt",
    label: "Expand all",
    callback: function callback() {
      if (_expandAll) {
        _derivationMap.expandAllElements();
      } else {
        _derivationMap.collapseAllElements();
      }
      _expandAll = !_expandAll;
    }
  }];

  if (options.tools) {
    options.tools.forEach(function (tool) {
      if (tool.position < baseTools.length) {
        baseTools.splice(tool.position, 0, tool);
      } else {
        baseTools.push(tool);
      }
    });
  }

  self.toolbar = new _visualizationsLibrary2.default.Toolbar({
    baseElement: _base.toolbar,
    tools: baseTools
  });

  self.infoPanel = new _dmInfoPanel.DMInfoPanel({
    baseElement: _base.infoPanel,
    triggerButton: self.toolbar.rootHtml.querySelector("#infoPanelBtn")
  });

  self.infoPanel.on("size-changed", function () {
    return _derivationMap.resetFocus();
  });

  self.infoPanel.on("element-click", function (elementId) {
    _derivationMap.setSelectedElement(elementId);
  });

  _derivationMap.on("diagram-state-changed", function (stateId) {
    if (stateId === "completed") {
      _diagramInfo = _derivationMap.getDiagramInfo();
      if (_diagramInfo && _diagramInfo.title) {
        _base.diagramTitle.innerText = _diagramInfo.title;
      } else {
        _base.diagramTitle.innerText = "";
      }
    }
  });

  // =======================================================

  var searchPaneVisible = false;
  var debounce = false;
  var searchButton = self.toolbar.rootHtml.querySelector("#tqDMSearch");
  var searchInput = _base.searchPanel.querySelector("input");
  searchInput.onkeyup = function () {
    if (debounce) clearTimeout(debounce);

    debounce = setTimeout(function () {
      var searchKey = searchInput.value;
      _derivationMap.setSearchKey(searchKey);
    }, 300);
  };
  function _openCloseSearchPanel() {
    if (searchPaneVisible) {
      _derivationMap.setSearchKey(undefined);
      _base.searchPanel.classList.add("tq-dm-hidden");
      searchButton.classList.remove("tq-ui-selected");
    } else {
      _derivationMap.setSearchKey(searchInput.value);
      _base.searchPanel.classList.remove("tq-dm-hidden");
      searchButton.classList.add("tq-ui-selected");
    }
    searchPaneVisible = !searchPaneVisible;
  }

  function _getHtmlElement(baseElement) {
    var baseHtml = void 0;
    if (typeof baseElement === "string") {
      baseHtml = document.getElementById(baseElement);
    } else if ((typeof baseElement === "undefined" ? "undefined" : _typeof(baseElement)) === "object") {
      baseHtml = baseElement;
    }
    if (!baseHtml) throw new Error("Base element is not found!");
    return baseHtml;
  }

  /**
   * Creates html markup.
   * @private
   * @param {HTMLElement} htmlNode - Root node for markup
   * @returns {Object.<string, HTMLElement>} - Map of html elements
   */
  function _createBase(htmlNode, infoPanel) {
    htmlNode.innerHTML = "";
    htmlNode.tabIndex = 0;

    var toolbarBase = document.createElement("DIV");
    toolbarBase.className = "tq-derivation-map__toolbar";
    toolbarBase.id = "tq-derivation-map-toolbar";
    htmlNode.appendChild(toolbarBase);

    var diagramTitleContainter = document.createElement("DIV");
    diagramTitleContainter.className = "tq-derivation-map_container";
    var diagramTitle = document.createElement("DIV");
    diagramTitle.className = "tq-derivation-map_container__title";
    diagramTitle.innerText = "";
    diagramTitleContainter.appendChild(diagramTitle);
    htmlNode.appendChild(diagramTitleContainter);

    var searchPanel = document.createElement("DIV");
    searchPanel.className = "tq-derivation-map_search-pane tq-dm-hidden";
    searchPanel.innerHTML = "\n            <input\n                id=\"tq-dm-search-pane\"\n                type=\"text\"\n                class=\"tq-derivation-map_search-pane__input\"\n                aria-label=\"Search input for Derivation Map\">\n            </input>\n        ";
    htmlNode.appendChild(searchPanel);

    return {
      searchPanel: searchPanel,
      rootHtml: htmlNode,
      infoPanel: infoPanel,
      toolbar: toolbarBase,
      diagramTitle: diagramTitle
    };
  }
}
exports.default = DMDefaultUI;

},{"./dmInfoPanel":32,"visualizations-library":70}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.DMInfoPanel = DMInfoPanel;

var _subscribeable = require("../subscriptionAPI/subscribeable");

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _mapElements = require("../jointViews/derivationMap/mapElements");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 * The data model for a {@link DMInfoPanel} object.
 * @typedef {Object} DMInfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} derivationMap - DerivationMap object.
 */

/**
 * @private
 * @class
 * @param {DMInfoPanelModel} - Data model.
 * @fires size-changed
 * @fires element-click (id:string)
 */
function DMInfoPanel(parameters) {
  _subscribeable2.default.apply(this); // make this class Subscribable
  var self = this;

  if (!parameters) parameters = {};

  var _selectedElement = parameters.selectedElement;
  var _width = 250;
  var _hidden = true;
  // ===================================================
  self.rootHtml = _getElement(parameters.baseElement);

  var _container = document.createElement("DIV");
  _container.className = "tq-lg-dm-property-pane-container";
  self.rootHtml.appendChild(_container);

  var _triggerButton = parameters.triggerButton;
  _triggerButton.onclick = function () {
    if (_hidden) {
      _show();
    } else {
      _hide();
    }
  };

  var _slider = document.createElement("DIV");
  _slider.className = "tq-lg-dm-slider";
  _slider.addEventListener("mousedown", function (event) {
    _onMousedown(event);
  });
  _container.appendChild(_slider);

  var _closeButton = document.createElement("DIV");
  _closeButton.setAttribute("title", "Close info panel");
  _closeButton.className = "tq-lg-dm-hide-button";
  _closeButton.onclick = function () {
    _hide();
  };
  _container.appendChild(_closeButton);

  self.body = document.createElement("DIV");
  _container.appendChild(self.body);
  // ===================================================
  self.id = "derivationMapInfoPanel";
  self.redraw = _redraw;
  self.setSelectedElement = _setSelectedElement;
  self.show = _show;
  self.hidde = _hide;
  // width: 250px;

  _redraw();

  function _redraw() {
    if (_hidden) return;
    var markup = void 0;
    if (_selectedElement) {
      if (_selectedElement instanceof _mapElements.Node) {
        markup = _getNodeInfo(_selectedElement);
      } else if (_selectedElement instanceof _mapElements.Link) {
        markup = _getLinkInfo(_selectedElement);
      } else {
        markup = "\n                    <div class=\"tq-lg-dm-property-pane tq-lg-dm-empty\">\n                        <div>Unknown type of element</div>\n                    </div>\n                ";
      }
    } else {
      markup = "\n                <div class=\"tq-lg-dm-property-pane tq-lg-dm-empty\">\n                    <div>Select a diagram element</div>\n                </div>\n            ";
    }
    self.body.style.width = _width + "px";
    self.body.innerHTML = markup;

    if (_selectedElement instanceof _mapElements.Node) {
      var children = self.body.querySelectorAll(".tq-lg-dm-child-button");
      for (var i = 0; i < children.length; i++) {
        children[i].onclick = function () {
          self.trigger("element-click", this.id);
        };
      }
    } else if (_selectedElement instanceof _mapElements.Link) {
      self.body.querySelector(".tq-lg-dm-source-button").onclick = function () {
        self.trigger("element-click", this.id);
      };
      self.body.querySelector(".tq-lg-dm-target-button").onclick = function () {
        self.trigger("element-click", this.id);
      };
    } else {
      //...
    }
  }

  function _getNodeInfo(node) {
    var chilren = node.children.map(function (child) {
      return "<div\n                id=\"" + child.id + "\"\n                title=\"" + child.label + "(" + child.endpointId + ")\"\n                type=\"text\"\n                class=\"tq-ui-property-button tq-lg-dm-child-button\">\n                " + child.label + "\n            </div>";
    }).join("");
    return "\n            <div class=\"tq-lg-dm-property-pane\">\n                <label class=\"tq-label\">ID</label>\n                <input\n                    value=\"" + node.endpointId + "\"\n                    title=\"" + node.endpointId + "\" type=\"text\" aria-label=\"Input for ID\" class=\"tq-ui-property\" disabled>\n                </input>\n                <label class=\"tq-label\">Diagram ID</label>\n                <input\n                    value=\"" + node.id + "\"\n                    title=\"" + node.id + "\"\n                    type=\"text\"\n                    class=\"tq-ui-property\"\n                    aria-label=\"Input for Label\"\n                    disabled>\n                </input>\n                <label class=\"tq-label\">Label</label>\n                <input value=\"" + node.label + "\" title=\"" + node.label + "\" type=\"text\" aria-label=\"Input for Types\" class=\"tq-ui-property\" disabled></input>\n                " + (chilren.length > 0 ? '<label class="tq-label">Children</label>' : "") + "\n                " + chilren + "\n            </div>\n        ";
  }

  function _getLinkInfo(link) {
    return "\n            <div class=\"tq-lg-dm-property-pane\">\n                <label class=\"tq-label\">Label</label>\n                <input value=\"" + link.label + "\" title=\"" + link.label + "\" type=\"text\" aria-label=\"Input for label\" class=\"tq-ui-property\" disabled></input>\n                <label class=\"tq-label\">Source</label>\n                <div id=\"" + link.source.id + "\"\n                    title=\"" + link.source.label + "(" + link.source.endpointId + ")\"\n                    type=\"text\"\n                    class=\"tq-ui-property-button tq-lg-dm-source-button\">\n                    " + link.source.label + "\n                </div>\n                <label class=\"tq-label\">Target</label>\n                <div id=\"" + link.target.id + "\"\n                    title=\"" + link.target.label + "(" + link.target.endpointId + ")\"\n                    type=\"text\"\n                    class=\"tq-ui-property-button tq-lg-dm-target-button\">\n                    " + link.target.label + "\n                </div>\n            </div>\n        ";
  }

  var SELECTED_CLASS = "tq-ui-selected";
  function _show() {
    _hidden = false;
    _container.style.display = null;
    _triggerButton.classList.add(SELECTED_CLASS);
    _redraw();
    setTimeout(function () {
      self.trigger("size-changed");
    }, 0);
  }

  function _hide() {
    _hidden = true;
    _container.style.display = "none";
    _triggerButton.classList.remove(SELECTED_CLASS);
    setTimeout(function () {
      self.trigger("size-changed");
    }, 0);
  }

  function _onMousedown(event) {
    var startX = 0;
    var MIN_WIDTH = 100;

    if (event.pageX) startX = event.pageX;else if (event.clientX) startX = event.clientX;

    window.getSelection().removeAllRanges();

    document.body.addEventListener("mousemove", _onchange);
    document.body.addEventListener("mouseup", _onmouseup);

    function _onchange(event) {
      var endX = 0;

      if (event.pageX) endX = event.pageX;else if (event.clientX) endX = event.clientX;

      var diffX = startX - endX;
      startX = endX;

      _width += diffX;
      _width = Math.max(MIN_WIDTH, _width);
      self.trigger("size-changed");
      _redraw();
    }

    function _onmouseup(event) {
      if (self._mouseMove) {
        _onchange(event, true);
        self._mouseMove = false;
      }
      document.body.onmousemove = document.body.onmouseup = null;
      document.body.removeEventListener("mousemove", _onchange);
      document.body.removeEventListener("mouseup", _onmouseup);
    }
  }

  function _setSelectedElement(element) {
    _selectedElement = element;
    _redraw();
  }
}
exports.default = DMInfoPanel;


function _getElement(el) {
  var element = void 0;
  if (typeof el === "string") {
    element = document.getElementById(el);
  } else if ((typeof el === "undefined" ? "undefined" : _typeof(el)) === "object") {
    element = el;
  }
  return element;
}

},{"../jointViews/derivationMap/mapElements":42,"../subscriptionAPI/subscribeable":65}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InfoPanel = InfoPanel;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * The data model for a {@link InfoPanel} object.
 * @typedef {Object} InfoPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 * @property {Function} onPressExternal
 */

/**
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {InfoPanelModel} options - Data model.
 * @fires state-changed
*/
function InfoPanel(options) {
    _subscribeable2.default.apply(this); // make this class Subscribable

    var infoTemplate = new _visualizationsLibrary2.default.InfoPanel({ launchExternal: options.lineageGram.launchExternal });

    var _lineageGram = options.lineageGram;

    _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
        baseElement: options.baseElement,
        active: options.active,
        header: 'Info panel',
        triggerButton: options.triggerButton,
        launchExternal: options.onPressExternal,
        emptyBody: false,
        size: { width: '300px', height: '450px' },
        body: infoTemplate,
        resizable: true
    }]);

    _lineageGram.on('selected-element-changed', function (elementModel) {
        var graphModel = _lineageGram.getGraphModel();
        var nodeMap = graphModel.maps.nodeMap;

        if (elementModel) {
            var source = nodeMap[elementModel.source];
            var target = nodeMap[elementModel.target];

            var data = void 0;
            if (elementModel.linkType && elementModel.group) {
                data = {};
                elementModel.group.forEach(function (el) {
                    return data = _.merge(data, el.data);
                });
            } else {
                data = _.cloneDeep(elementModel.data) || {};
            }

            if (elementModel.linkType) {
                if (elementModel.linkType && !elementModel.group) {
                    data['Link type'] = elementModel.linkType;
                } else {
                    var typeMap = {};
                    elementModel.group.forEach(function (el) {
                        return typeMap[el.linkType] = el;
                    });
                    var types = Object.keys(typeMap);
                    if (types.length > 1) {
                        data['Link type'] = elementModel.linkType;
                        data['Grouped types'] = types.join(', ');
                    } else {
                        data['Link type'] = types[0];
                    }
                    data['IDs'] = elementModel.group.map(function (el) {
                        return el.id;
                    }).join(', ');
                }
            }

            if (elementModel.activeResource) data["Active Resource"] = decodeURIComponent(elementModel.activeResource);
            if (elementModel.offset) data['Offset'] = elementModel.offset;
            if (elementModel.viewFrame) data['View frame'] = elementModel.viewFrame;

            infoTemplate.setSelectedElement({
                id: elementModel.id,
                label: elementModel.label,
                resource: elementModel.resource,
                resourceType: elementModel.resourceType,
                diagramType: elementModel.diagramType,
                types: elementModel.typeId,
                source: source ? {
                    id: source.id,
                    label: source.label
                } : undefined,
                target: target ? {
                    id: target.id,
                    label: target.label
                } : undefined,
                data: data,
                relations: _getRelations(elementModel, graphModel)
            });
        } else {
            infoTemplate.setSelectedElement(undefined);
        }
    });

    infoTemplate.on('selected-element-changed', function (elementId) {
        _lineageGram.setSelectedElement(elementId);
    });

    function _getAspects(elementModel, nodes) {
        var aspects = [];
        if (elementModel.resource) {
            nodes.forEach(function (node) {
                if (node.resource === elementModel.resource) aspects.push(node);
            });
        } else {
            aspects.push(elementModel);
        }
        return aspects;
    }

    function _getRelations(elementModel, graphModel) {
        var sourceMap = graphModel.maps.sourceMap;
        var targetMap = graphModel.maps.targetMap;
        var nodeMap = graphModel.maps.nodeMap;

        var ids = _getAspects(elementModel, graphModel.nodes).map(function (a) {
            return a.id;
        });

        var sources = [];
        var targets = [];
        ids.forEach(function (id) {
            if (sourceMap[id]) {
                sources = sources.concat(sourceMap[id].map(function (l) {
                    var node = nodeMap[l.source];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
            if (targetMap[id]) {
                targets = targets.concat(targetMap[id].map(function (l) {
                    var node = nodeMap[l.target];
                    return {
                        id: node.id,
                        label: node.label
                    };
                }));
            }
        });

        if (sources && sources.length > 0 || targets && targets.length > 0) {
            return {
                incomings: sources,
                outgoings: targets
            };
        }
        return undefined;
    }
}
exports.default = InfoPanel;

},{"../subscriptionAPI/subscribeable":65,"lodash":"lodash","visualizations-library":70}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Map = Map;

var _visualizationsLibrary = require("visualizations-library");

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Map(options) {
  var markup = "\n        <div id=\"mapButton\" class=\"tq-lg-map\">\n            <span title=\"Mini map\" class=\"tq-lg-collapse-panel_body__label fas fa-image\" aria-hidden=\"true\"></span>\n        </div>\n        <div id=\"baseElementForMap\"></div>\n    ";
  var _lineageGram = options.lineageGram;

  var _el = void 0;

  if (typeof options.baseElement === "string") {
    _el = document.getElementById(options.baseElement);
  } else if (_typeof(options.baseElement) === "object") {
    _el = options.baseElement;
  }
  if (!_el) return;

  _el.innerHTML = markup;

  var mapFlyingPanel = new _visualizationsLibrary2.default.FlyingPanel({
    baseElement: _el.querySelector("#baseElementForMap"),
    active: options.active,
    header: "Map",
    triggerButton: _el.querySelector("#mapButton"),
    emptyBody: false,
    size: { width: "250px", height: "250px" },
    position: options.position,
    body: "",
    resizable: true
  });

  _lineageGram.setRootHtmlForMap(mapFlyingPanel.rootHtml.querySelector(".tq-ui-body_container"));

  mapFlyingPanel.on("size-changed", function () {
    _lineageGram.refresh("graphMap");
  });
}
exports.default = Map;

},{"visualizations-library":70}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionsPanel = OptionsPanel;

var _subscribeable = require("../subscriptionAPI/subscribeable");

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _visualizationsLibrary = require("visualizations-library");

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The data model for a {@link OptionsPanel} object.
 * @typedef {Object} OptionsPanelModel
 * @property {string|HTMLElement} baseElement - Root for this panel
 * @property {LineageGram} lineageGram - LineageGram object.
 * @property {boolean} active - false - collapsed, true - expanded
 * @property {string|HTMLElement} triggerButton
 */

/**
 * Class which is a simple UI panel.
 * This panel can represent an information about selected element
 * and also, it supports simple navigation between elements.
 * @class
 * @param {OptionsPanelModel} options - Data model.
 * @fires state-changed
 */
function OptionsPanel(options) {
  _subscribeable2.default.apply(this); // make this class Subscribable

  var legends = options.legends || [];
  var _lineageGram = options.lineageGram;
  var self = this;

  _visualizationsLibrary2.default.FlyingPanel.apply(this, [{
    baseElement: options.baseElement,
    active: options.active,
    header: "Options panel",
    triggerButton: options.triggerButton,
    emptyBody: true,
    size: {
      width: "400px",
      height: "500px"
    },
    removeBackground: true,
    body: new _visualizationsLibrary2.default.TabPanel({
      tabs: [{
        id: "tqUiGeneral",
        label: "General",
        body: "\n                        <label for=\"displayGroup\" class=\"tq-label\">Display</label>\n                        <div id=\"displayGroup\" class=\"tq-ui-group\">\n                            <div class=\"tq-ui-group__select-line\">\n                                <select aria-label=\"Dropdown for setting orientation\" id=\"tqUiOrientation\" size=\"1\" name=\"orientation\">\n                                    <option value=\"left-to-right\">left to right</option>\n                                    <option value=\"right-to-left\">right to left</option>\n                                    <option value=\"top-to-bottom\">top to bottom</option>\n                                    <option value=\"bottom-to-top\">bottom to top</option>\n                                </select>\n                                <span> - Graph orientation</span>\n                            </div>\n                            <div class=\"tq-ui-group__select-line\">\n                                <select aria-label=\"Dropdown for setting Link routing\" id=\"tqUiRouting\" size=\"1\" name=\"routing\">\n                                    <option value=\"metro\">Metro</option>\n                                    <option value=\"lgrouter\">RailRoad</option>\n                                    <option value=\"normal\">Normal</option>\n                                    <option value=\"manhattan\">Manhattan</option>\n                                </select>\n                                <span> - Link routing</span>\n                            </div>\n                            <div class=\"tq-ui-group__select-line\">\n                                <select aria-label=\"Dropdown for setting Layout algorithm\" id=\"tqUiLayout\" size=\"1\" name=\"layout\">\n                                    <option value=\"sankey\">Sankey</option>\n                                    <option value=\"flow-directed\">Flow-directed</option>\n                                </select>\n                                <span> - Layout algorithm</span>\n                            </div>\n                            <div class=\"tq-ui-group__check-box-line\">\n                                <span><input aria-label=\"Checkbox to set showing full labels\" id=\"tqUiExpandCollapse\" type=\"checkbox\" checked=\"checked\"></span>\n                                <span>Expand node containers to show full text labels</span>\n                            </div>\n                            <div class=\"tq-ui-group__check-box-line\">\n                                <span><input aria-label=\"Checkbox to set trimming on borders\" id=\"tqUiClipNodes\" type=\"checkbox\"></span>\n                                <span>Nodes trimming on borders</span>\n                            </div>\n                        </div>\n                        <label for=\"dataProviderGroup\" class=\"tq-label\">Data Provider</label>\n                        <div id=\"dataProviderGroup\" class=\"tq-ui-group tq-ui-data-provider-group\">\n                          <div class=\"tq-ui-group__input-group\">\n                            <input aria-label=\"Reach for data \" class=\"tq-ui-options__input\" aria-label=\"Reach: the number of graph traversals.\" id=\"tqUiReach\" value=\"3\" type=\"number\" min=\"1\" max=\"10\" required />\n                            <button id=\"tqUiReachApply\" title=\"Apply Reach\" class=\"tq-button tq-provider-button\"><i class=\"tq-provider-icon\"></i></button>\n                            <label labelFor=\"tqUiReach\" title=\"Reach: the number of graph traversals.\"> - Reach</label>\n                          </div>\n                          <div class=\"tq-ui-group__input-group\">\n                            <input class=\"tq-ui-options__input\" aria-label=\"Breadth: the number of paths evaulated per node.\" id=\"tqUiBreadth\" value=\"10\" type=\"number\" min=\"1\"  max=\"10\" required/>\n                            <button id=\"tqUiBreadthApply\" title=\"Apply Breadth\" class=\"tq-button tq-provider-button\"><i class=\"tq-provider-icon\"></i></button>\n                            <label labelFor=\"tqUiBreadth\" title=\"Breadth: the number of paths evaluated per node.\"> - Breadth</label>\n                          </div>\n                        </div>\n                        <label for=\"exportGroup\" class=\"tq-label\">Export as</label>\n                        <div id=\"exportGroup\" class=\"tq-ui-group tq-ui-export-group\">\n                            <button id=\"tqUiExportSVG\" title=\"Export diagram to SVG\" class=\"tq-button\">SVG</button>\n                            <button id=\"tqUiExportPNG\" title=\"Export diagram to PNG\" class=\"tq-button\">PNG</button>\n                            <button id=\"tqUiPrint\" title=\"Print\" class=\"tq-button\">\n                                <span class=\"fas fa-print\"></span>\n                            </button>\n                        </div>\n                        <label for=\"howToUseGroup\" class=\"tq-label\">How to use</label>\n                        <div id=\"howToUseGroup\" class=\"tq-ui-group tq-ui-opt-group\">\n                            <button id=\"tqUiHelpBtn\" title=\"Help\" class=\"tq-button\">\n                                <span class=\"fas fa-info-circle\" aria-hidden=\"true\"></span>\n                            </button>\n                            <a class=\"tq-button\" title=\"Documentation\" href=\"./documentation/index.html\">DOC</a>\n                        </div>\n                    "
      }, {
        id: "tqUiLegends",
        label: "Legends",
        body: new _visualizationsLibrary2.default.Legends({ legends: legends })
      }]
    })
  }]);

  // General

  var svgButton = self.rootHtml.querySelector("#tqUiExportSVG");
  var pngButton = self.rootHtml.querySelector("#tqUiExportPNG");
  var printButton = self.rootHtml.querySelector("#tqUiPrint");
  var expandCollapse = self.rootHtml.querySelector("#tqUiExpandCollapse");
  var orientation = self.rootHtml.querySelector("#tqUiOrientation");
  var routing = self.rootHtml.querySelector("#tqUiRouting");
  var layout = self.rootHtml.querySelector("#tqUiLayout");
  var clipping = self.rootHtml.querySelector("#tqUiClipNodes");
  var helpButton = self.rootHtml.querySelector("#tqUiHelpBtn");
  var reach = self.rootHtml.querySelector('#tqUiReach');
  var applyReach = self.rootHtml.querySelector('#tqUiReachApply');
  var breadth = self.rootHtml.querySelector('#tqUiBreadth');
  var applyBreadth = self.rootHtml.querySelector('#tqUiBreadthApply');

  _lineageGram.on("current-view-changed", function (viewId) {
    svgButton.disabled = viewId !== "lineageDiagram";
    expandCollapse.disabled = viewId !== "lineageDiagram";
  });

  svgButton.onclick = function () {
    _lineageGram.export({
      type: "svg",
      view: "lineageDiagram"
    });
  };
  pngButton.onclick = function () {
    _lineageGram.export({
      type: "png"
    });
  };
  printButton.onclick = function () {
    _lineageGram.print();
  };

  expandCollapse.onchange = function () {
    if (expandCollapse.checked) {
      _lineageGram.expandAllNodes();
    } else {
      _lineageGram.collapseAllNodes();
    }
  };

  orientation.value = _lineageGram.getOrientation();
  orientation.onchange = function () {
    _lineageGram.setOrientation(orientation.value);
  };

  routing.value = _lineageGram.getRouting();
  routing.onchange = function () {
    _lineageGram.setRouting(routing.value);
  };

  layout.value = _lineageGram.getLayoutAlgorithm();
  layout.onchange = function () {
    _lineageGram.setLayoutAlgorithm(layout.value);
  };

  reach.value = _lineageGram.getReach();

  applyReach.onclick = reach.oninput = function () {
    var isValid = reach.checkValidity();

    if (!isValid) {
      return;
    }

    _lineageGram.setReach(reach.value);
  };

  breadth.value = _lineageGram.getBreadth();

  applyBreadth.onclick = breadth.oninput = function () {
    var isValid = breadth.checkValidity();

    if (!isValid) {
      return;
    }
    _lineageGram.setBreadth(breadth.value);
  };

  helpButton.onclick = options.onPressHelp;

  clipping.checked = _lineageGram.getClipping();
  clipping.onchange = function () {
    _lineageGram.setClipping(clipping.checked);
  };

  helpButton.onclick = options.onPressHelp;
}
exports.default = OptionsPanel;

},{"../subscriptionAPI/subscribeable":65,"visualizations-library":70}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Splitter = Splitter;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * 
 * Html-UI element which manage size of two splitted windows.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  viewFrameA: ViewFrame,
 *  viewFrameB: ViewFrame,
 * } model
 * @param {Object} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * el: HTMLELement
 * 
 * Public methods:
 * ========================================
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ===========================================
 * @fires diff({ diff: number, lastChange: boolean })
 */
function Splitter(model, parameters) {
    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _graphOrientation = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var _visible = true;

    self.model = model;
    if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
        _swapViewFrames();
    }

    self.el = document.createElement('DIV');
    self.el.className = _graphOrientation ? 'tq_lineage_ui__view-frame-splitter' : 'tq_lineage_ui__view-frame-splitter-vertical';
    self.el.addEventListener('mousedown', _onmousedown);

    var start = 0;
    function _onmousedown(event) {
        event = event || window.event;
        start = 0;
        window.getSelection().removeAllRanges();

        if (_graphOrientation) {
            if (event.pageX) start = event.pageX;else if (event.clientX) start = event.clientX;
        } else {
            if (event.pageY) start = event.pageY;else if (event.clientY) start = event.clientY;
        }

        document.body.addEventListener('mousemove', _onchange);
        document.body.addEventListener('mouseup', _onmouseup);

        function _onchange(event, onMouseUp) {
            event = event || window.event;
            var end = 0;

            if (_graphOrientation) {
                if (event.pageX) end = event.pageX;else if (event.clientX) end = event.clientX;
            } else {
                if (event.pageY) end = event.pageY;else if (event.clientY) end = event.clientY;
            }

            var diff = end - start;
            start = end;
            self.trigger('splitter-position-changed', { diff: _limitDiff(diff), lastChange: onMouseUp });
        }

        function _onmouseup(event) {
            _onchange(event, true);
            document.body.onmousemove = document.body.onmouseup = null;
            document.body.removeEventListener('mousemove', _onchange);
            document.body.removeEventListener('mouseup', _onmouseup);
        }
    }

    // ===================================================================
    // ===================================================================

    self.updateNeighbour = function (newNeighbour) {
        if (self.model.viewFrameB !== newNeighbour) {
            self.model.viewFrameB = newNeighbour;
        }
    };

    self.hide = function () {
        if (_visible) {
            self.el.style.display = 'none';
            _visible = false;
        }
    };

    self.show = function () {
        if (!_visible) {
            self.el.style.display = '';
            _visible = true;
        }
    };

    function _swapViewFrames() {
        var temp = model.viewFrameA;
        model.viewFrameA = model.viewFrameB;
        model.viewFrameB = temp;
    }

    function _limitDiff(diff) {
        if (diff === 0) return;
        var vfA = self.model.viewFrameA;
        var vfB = self.model.viewFrameB;

        var sideA = void 0;
        var sideB = void 0;
        var minSideShouldBe = void 0;

        if (_graphOrientation) {
            sideA = vfA.size.width;
            sideB = vfB.size.width;
            minSideShouldBe = parameters.framePadding.x * 2 + 1;
        } else {
            sideA = vfA.size.height;
            sideB = vfB.size.height;
            minSideShouldBe = parameters.framePadding.y * 2 + 1;
        }

        var resultSideA = sideA + diff;
        var resultSideB = sideB - diff;

        var limitationA = 0;
        var limitationB = 0;
        if (resultSideA < minSideShouldBe && resultSideB < minSideShouldBe) {
            return;
        }
        if (resultSideA < minSideShouldBe) {
            limitationA = minSideShouldBe - resultSideA;
        }
        if (resultSideB < minSideShouldBe) {
            limitationB = resultSideB - minSideShouldBe;
        }
        if (limitationA !== 0 || limitationB !== 0) {
            var resultDiff = Math.abs(limitationA) > Math.abs(limitationB) ? diff + limitationA : diff + limitationB;
            var _resultSideA = sideA + resultDiff;
            var _resultSideB = sideB - resultDiff;
            if (_resultSideA < minSideShouldBe || _resultSideB < minSideShouldBe) {
                return;
            }
            return resultDiff;
        } else {
            return diff;
        }
    }
}
Splitter.prototype = Object.create(joint.shapes.basic.Rect.prototype);

exports.default = Splitter;

},{"../subscriptionAPI/subscribeable":65,"rappid":"rappid"}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrameButtons = ViewFrameButtons;
/**
 * ColoredButtonModel - data model for ColoredButtons in the ColoredButtonsList
 * @typedef {Object} ColoredButtonModel
 * @property {string} id - String id
 * @property {string} label - are used for implementing tooltip and icon
 * @property {string} borderColor - Border color
 * @property {string} backgroundColor - Background color
 * @property {function} callback - Function wich will be colled on mouse click on button
*/

var uniqueId = 0;

/**
 * Class is a collection of colored buttons,
 * which use first letters of the label as an icons for the buttons.
 * (Initially it was developed as a collection of collapsed viewFrames for LineageGram)
 * @class
 * @augments TQUIElement
 * @param {LineageGram} lineageGram
 * 
 * @property {ColoredButtonModel[]} buttons - list of button models
*/
function ViewFrameButtons(parameters) {
    var self = this;
    if (!parameters) throw Error('The arguments parameters shouldn\'t be undefined!');
    if (!parameters.lineageGram) throw Error('lineageGram field is undefined!');

    self.rootHtml = _initRootElement();
    self.id = parameters.lineageGram.id || 'coloredButtons-' + uniqueId++;
    self.rootHtml.id = self.id;

    var _lineageGram = parameters.lineageGram;
    var _state = {};
    var _buttons = {};
    var _overViewFrameButton = void 0;

    _createButtons();

    _lineageGram.on('view-frame-state-changed', _updateButtons);
    _lineageGram.on('history-state-changed', _createButtons);

    function _createButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        _state = {};
        _buttons = {};
        self.rootHtml.innerHTML = '';

        if (overViewFrame) {
            _overViewFrameButton = createButton(overViewFrame);
            _overViewFrameButton.style.borderColor = null;
            _overViewFrameButton.style.backgroundColor = null;
            _overViewFrameButton.style.color = null;
            _overViewFrameButton.classList.add('tq-ui-colored-buttons-overview');
            self.rootHtml.appendChild(_overViewFrameButton);
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                var htmlButton = createButton(viewFrame);
                _buttons[viewFrame.id] = htmlButton;
                self.rootHtml.appendChild(htmlButton);
            }
        });

        _updateButtons();

        function createButton(viewFrame) {
            var htmlButton = document.createElement('BUTTON');

            htmlButton.className = 'tq-ui-toolbar__button tq-ui-colored-button';

            if (viewFrame.isOverView) {
                htmlButton.classList.add('tq-ui-colored-buttons-overview');
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.setFullScreenMode(false);
                    } else {
                        _lineageGram.setFullScreenMode(true);
                    }
                };
            } else {
                htmlButton.innerHTML = '<span>' + _getShortLabel(viewFrame.label) + '</span>';
                htmlButton.style.backgroundColor = viewFrame.backgroundColor || 'white';
                htmlButton.style.borderColor = viewFrame.borderColor || 'black';
                htmlButton.style.color = viewFrame.borderColor || 'black';
                htmlButton.onclick = function () {
                    if (_state[viewFrame.id]) {
                        _lineageGram.collapseViewFrame(viewFrame.id);
                    } else {
                        _lineageGram.expandViewFrame(viewFrame.id);
                    }
                };
            }

            _state[viewFrame.id] = viewFrame.expanded;
            return htmlButton;
        }
    }

    function _updateButtons() {
        var viewFrames = _lineageGram.getViewFrames();
        var overViewFrame = _lineageGram.getOverViewFrame();

        if (overViewFrame) {
            _state[overViewFrame.id] = overViewFrame.active;
            _overViewFrameButton.innerHTML = '<span>' + (overViewFrame.active ? 'F' : 'O') + '</span>';
            if (overViewFrame.active) {
                _overViewFrameButton.title = 'Switch to Frames mode';
                self.rootHtml.classList.add('tq-ui-colored-buttons-collapsed');
            } else {
                _overViewFrameButton.title = 'Switch to single frame mode';
                self.rootHtml.classList.remove('tq-ui-colored-buttons-collapsed');
            }
        }

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.id !== overViewFrame.id) {
                _state[viewFrame.id] = viewFrame.expanded;
                updateButton(viewFrame);
            }
        });

        function updateButton(viewFrame) {
            var htmlButton = _buttons[viewFrame.id];
            if (_state[viewFrame.id]) {
                htmlButton.title = 'Collapse ' + viewFrame.label;
                htmlButton.classList.remove('tq-ui-selected');
            } else {
                htmlButton.title = 'Expand ' + viewFrame.label;
                htmlButton.classList.add('tq-ui-selected');
            }
        }
    }

    function _getShortLabel(label) {
        if (!label) return;
        var words = label.match(/[a-z'\-]+/gi);
        return words.filter(function (w) {
            return w.toLowerCase() !== 'and' && w !== '&';
        }).map(function (w) {
            return w[0];
        }).join('');
    }

    function _initRootElement() {
        var el = document.createElement('DIV');
        el.className = 'tq-ui-colored-buttons-list';
        el.innerHTML = '';
        return el;
    }
}
exports.default = ViewFrameButtons;

},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ViewFramesUI = ViewFramesUI;

var _subscribeable = require("../subscriptionAPI/subscribeable");

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _splitter = require("./splitter");

var _splitter2 = _interopRequireDefault(_splitter);

var _lineageDiagramUtils = require("../utils/lineageDiagramUtils");

var _utils = require("../utils/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @private
 *
 * Manages the main view of application (View-2)
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  rootEl: HTMLElement
 *  viewFrames: Array of ViewFrame
 * } options
 * @param {Object} parameters - parameters set
 *
 * Public methods:
 * ========================================
 * refreshState (): void
 * updateViewFrames (viewFrames: ViewFrame[]): void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 *
 * Events:
 * ===========================================
 * @fires view-port-position-changed (ViewFrame)
 * @fires splitter-position-changed (vf: ViewFrame, diff: { diff: number, lastChange: boolean })
 * @fires view-frame-collapsed (ViewFrame, boolean)
 */
function ViewFramesUI(options, parameters) {
  // Init
  // ===================================================================
  // ===================================================================

  _subscribeable2.default.apply(this); // make this class Subscribable

  var self = this;
  var _root = options.rootEl;

  var _orientation = parameters.graphOrientation === "right-to-left" || parameters.graphOrientation === "bottom-to-top";
  var _graphOrientation = parameters.graphOrientation === "left-to-right" || parameters.graphOrientation === "right-to-left";

  var _viewManager = options.viewManager;
  var _viewFrames = _viewManager.getViewFrames() || [];
  var _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
  var _uiSetForViewFrames = void 0;
  var _buttons4Sets = void 0;
  var _splitters = void 0;
  var _uiBody = void 0;

  _createUI();

  // ===================================================================
  // ===================================================================

  /**
   * Refreshes a state of UI. (Change arrows states)
   */
  self.refresh = _refresh;

  /**
   * Set new view manager
   * @param {Array of ViewFrame} viewFrames
   */
  self.setViewManager = function (viewManager) {
    _viewManager = viewManager;
    _viewFrames = _viewManager.getViewFrames();
    _createUI();
  };

  /**
   * It changes orientation of the graph.
   * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
   * @memberof ViewFramesUI
   * @method
   */
  self.setOrientation = function (orientation) {
    _orientation = orientation === "right-to-left" || orientation === "bottom-to-top";
    _graphOrientation = orientation === "left-to-right" || orientation === "right-to-left";
    _createUI();
  };

  /**
   * Refreshes a state of UI. (Change arrows states)
   */
  function _refresh() {
    _updateViewFrames();
    _refreshUI();
    _viewFrames.forEach(function (vf) {
      if (vf.customeSized) {
        if (vf.size.width) _uiSetForViewFrames[vf.id].style.width = vf.size.width + "px";
        if (vf.size.height) _uiSetForViewFrames[vf.id].style.height = vf.size.height + "px";
        _uiSetForViewFrames[vf.id].style.flexGrow = 0;
      } else {
        _uiSetForViewFrames[vf.id].style.flexGrow = vf.spaceShare;
      }
    });
  }

  function _updateViewFrames() {
    _viewFrames = _viewManager.getViewFrames();
    var vfMap = (0, _utils.arrayToMap)(_viewFrames);
    _splitters.forEach(function (splitter) {
      splitter.model.viewFrameA = vfMap[splitter.model.viewFrameA.id];
      splitter.model.viewFrameB = vfMap[splitter.model.viewFrameB.id];
    });
    _viewFramesMap = (0, _utils.arrayToMap)(_viewFrames);
  }

  /**
   * Creates html navigate buttons for the views.
   */
  function _createUI() {
    if (!_root) return;else _root.innerHTML = "";

    _uiBody = document.createElement("DIV");
    _uiBody.className = "tq_lineage_ui";
    _root.appendChild(_uiBody);
    _splitters = [];

    _uiBody.innerHTML = "";
    _uiSetForViewFrames = {};
    _buttons4Sets = {};

    var MODIFIER = 0.5;

    if (parameters.graphOrientation === "right-to-left") {
      _uiBody.style.flexDirection = "row-reverse";
    } else if (parameters.graphOrientation === "top-to-bottom") {
      _uiBody.style.flexDirection = "column";
    } else if (parameters.graphOrientation === "bottom-to-top") {
      _uiBody.style.flexDirection = "column-reverse";
    } else {
      // horizontal
      _uiBody.style.flexDirection = "row";
    }

    _viewFrames.forEach(function (vf, index, arr) {
      var viewFrameUi = document.createElement("DIV");
      viewFrameUi.id = (0, _lineageDiagramUtils.cacheIdForViewFrameUI)(vf);
      if (_orientation) {
        viewFrameUi.className = "tq_lineage_ui_view-frame_" + parameters.graphOrientation;
      } else {
        viewFrameUi.className = "tq_lineage_ui_view-frame_" + parameters.graphOrientation;
      }

      if (vf.customeSized) {
        if (vf.size.width) viewFrameUi.style.width = vf.size.width + "px";
        if (vf.size.height) viewFrameUi.style.height = vf.size.height + "px";
        viewFrameUi.style.flexGrow = 0;
      } else {
        viewFrameUi.style.flexGrow = vf.spaceShare;
      }
      _uiBody.appendChild(viewFrameUi);

      var up = document.createElement("IMG");
      up.className = "tq_lineage_ui__button tq_lineage_ui__up-button";
      up.setAttribute("alt", "Up button");
      up.onclick = function () {
        var viewFrame = _viewFramesMap[vf.id];
        var curPos = viewFrame.viewPortPosition;
        self.trigger("view-port-position-changed", {
          id: vf.id,
          viewPortPosition: {
            x: curPos.x,
            y: curPos.y - viewFrame.size.height * MODIFIER
          }
        });
      };
      viewFrameUi.appendChild(up);

      var down = document.createElement("IMG");
      down.className = "tq_lineage_ui__button tq_lineage_ui__down-button";
      down.setAttribute("alt", "Down button");
      down.onclick = function () {
        var viewFrame = _viewFramesMap[vf.id];
        var curPos = viewFrame.viewPortPosition;
        self.trigger("view-port-position-changed", {
          id: vf.id,
          viewPortPosition: {
            x: curPos.x,
            y: curPos.y + viewFrame.size.height * MODIFIER
          }
        });
      };
      viewFrameUi.appendChild(down);

      var left = document.createElement("IMG");
      left.className = "tq_lineage_ui__button tq_lineage_ui__left-button";
      left.setAttribute("alt", "Left button");
      left.onclick = function () {
        var viewFrame = _viewFramesMap[vf.id];
        var curPos = viewFrame.viewPortPosition;
        self.trigger("view-port-position-changed", {
          id: vf.id,
          viewPortPosition: {
            x: curPos.x - viewFrame.size.width * MODIFIER,
            y: curPos.y
          }
        });
      };
      viewFrameUi.appendChild(left);

      var right = document.createElement("IMG");
      right.setAttribute("alt", "Right button");
      right.className = "tq_lineage_ui__button tq_lineage_ui__right-button";
      right.onclick = function () {
        var viewFrame = _viewFramesMap[vf.id];
        var curPos = viewFrame.viewPortPosition;
        self.trigger("view-port-position-changed", {
          id: vf.id,
          viewPortPosition: {
            x: curPos.x + viewFrame.size.width * MODIFIER,
            y: curPos.y
          }
        });
      };
      viewFrameUi.appendChild(right);

      var collapse = document.createElement("IMG");
      collapse.className = "tq_lineage_ui__button tq_lineage_ui__collapse-button";
      collapse.setAttribute("alt", "Collapse button");

      collapse.onclick = function () {
        self.trigger("view-frame-collapsed", { id: vf.id, expanded: false });
      };
      viewFrameUi.appendChild(collapse);

      _buttons4Sets[vf.id] = {
        up: up,
        down: down,
        left: left,
        right: right
      };

      if (index !== arr.length - 1) {
        var splitter = new _splitter2.default({
          viewFrameA: vf,
          viewFrameB: arr[index + 1]
        }, parameters);
        _splitters.push(splitter);
        _uiBody.appendChild(splitter.el);
        splitter.on("splitter-position-changed", function (diff) {
          self.trigger("splitter-position-changed", [splitter, diff]);
        });
      }

      _uiSetForViewFrames[vf.id] = viewFrameUi;
    });

    _refreshUI();
  }

  /**
   * Refresh navigation buttons. Button isn't active if the viewPort can't move by this direction.
   */
  function _refreshUI() {
    if (!_root) return;
    _refreshSplittersState();

    _viewFrames.forEach(function (vf) {
      var check = (0, _lineageDiagramUtils.checkPagination)(vf);

      _uiSetForViewFrames[vf.id].style.display = vf.active ? "" : "none";

      var up = _buttons4Sets[vf.id].up;
      var down = _buttons4Sets[vf.id].down;
      var left = _buttons4Sets[vf.id].left;
      var right = _buttons4Sets[vf.id].right;

      up.style.cursor = check.canMoveUp ? "pointer" : "not-allowed";
      down.style.cursor = check.canMoveDown ? "pointer" : "not-allowed";
      left.style.cursor = check.canMoveLeft ? "pointer" : "not-allowed";
      right.style.cursor = check.canMoveRight ? "pointer" : "not-allowed";

      up.style.opacity = check.canMoveUp ? "" : "0.03";
      down.style.opacity = check.canMoveDown ? "" : "0.03";
      left.style.opacity = check.canMoveLeft ? "" : "0.03";
      right.style.opacity = check.canMoveRight ? "" : "0.03";
    });
  }

  function _refreshSplittersState() {
    var activeFrames = _viewFrames.filter(function (vf) {
      return vf.active;
    }).sort(function (a, b) {
      var posA = a.position;
      var posB = b.position;
      if (_graphOrientation) {
        return posA.x - posB.x;
      } else {
        return posA.y - posB.y;
      }
    });
    var activeIds = activeFrames.map(function (vf) {
      return vf.id;
    });

    if (_orientation) {
      _splitters.forEach(function (splitter) {
        updateSplitter(splitter);
      });
    } else {
      for (var i = _splitters.length - 1; i >= 0; i--) {
        updateSplitter(_splitters[i]);
      }
    }

    function updateSplitter(splitter) {
      if (splitter.model.viewFrameA.active) {
        var neighbour = getNeighbour(splitter.model.viewFrameA.id);
        if (!neighbour) {
          splitter.hide();
        } else {
          splitter.updateNeighbour(neighbour);
          splitter.show();
        }
      } else {
        splitter.hide();
      }
    }

    function getNeighbour(viewFrameId) {
      if (!viewFrameId) return null;
      var index = activeIds.indexOf(viewFrameId);
      if (index >= 0 && index < activeIds.length - 1) {
        return activeFrames[index + 1];
      } else {
        return null;
      }
    }
  }
}
exports.default = ViewFramesUI;

},{"../subscriptionAPI/subscribeable":65,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./splitter":36}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processData = processData;

var _lodash = require('lodash');

var _mapElements = require('./mapElements');

var _resourceProvider = require('../../data/resourceProvider');

function processData(rawData, parameters) {
    var topNodeModels = processNodes(rawData.nodes, parameters);
    var derivationMapNodes = createDiagramNodes(topNodeModels, parameters);

    var mapLinkModels = processLinks(rawData.edges, derivationMapNodes);
    // Create fake link if there are no links at all (it means we have a problem with a data)
    // ===================================
    if (mapLinkModels.length === 0 && topNodeModels.length === 2) {
        var topIds = topNodeModels.map(function (tm) {
            return tm.id;
        });
        var topViews = derivationMapNodes.filter(function (n) {
            return topIds.indexOf(n.id) !== -1;
        });
        mapLinkModels.push({
            source: topViews[0],
            target: topViews[1],
            label: ''
        });
    }
    // ===================================
    var finalLinkModels = groupLinks(mapLinkModels, parameters);
    var derivationMapLinks = finalLinkModels.map(function (model) {
        return new _mapElements.Link(model, parameters);
    });
    return {
        elements: derivationMapNodes,
        links: derivationMapLinks
    };
}
exports.default = processData;


function processLinks(rawLinks, derivationMapNodes) {
    if (!rawLinks) return [];

    var nodeMap = {};
    derivationMapNodes.forEach(function (node) {
        if (nodeMap[node.endpointId]) {
            nodeMap[node.endpointId].push(node);
        } else {
            nodeMap[node.endpointId] = [node];
        }
    });

    // const existingLinks = {};
    // rawLinks.forEach(link => {
    //     (nodeMap[link.source] || []).forEach(source => {
    //         (nodeMap[link.target] || []).forEach(target => {
    //             if (!(existingLinks[source.id] && existingLinks[source.id][target.id])) {
    //                 const finalLink = {
    //                     source: source,
    //                     target: target,
    //                     label: link.label || getLabelFromId(link.id),
    //                     typeId: link.id,
    //                 };

    //                 [source.id].concat(source.orderedPossibleIds).forEach(sourceId => {
    //                     if (!existingLinks[sourceId]) existingLinks[sourceId] = {};
    //                     [target.id].concat(target.orderedPossibleIds).forEach(targetId => {
    //                         existingLinks[sourceId][targetId] = finalLink;
    //                     });
    //                 });
    //             }
    //         });
    //     });
    // });

    // const links = [];
    // Object.keys(existingLinks).forEach(sourceId => {
    //     Object.keys(existingLinks[sourceId]).forEach(targetId => {
    //         const link = existingLinks[sourceId][targetId];
    //         if (links.indexOf(link) === -1) {
    //             links.push(link);
    //         }
    //     });
    // });

    var uniqMap = {};
    var links = [];
    rawLinks.forEach(function (link) {
        var sources = nodeMap[link.source];
        var targets = nodeMap[link.target];
        if (sources && targets) {
            var linkId = cacheFunction(link);
            if (!uniqMap[linkId]) {
                uniqMap[linkId] = link;
                sources.forEach(function (source) {
                    targets.forEach(function (target) {
                        links.push({
                            source: source,
                            target: target,
                            label: link.label || getLabelFromId(link.id),
                            typeId: link.id
                        });
                    });
                });
            }
        }
    });

    return links;

    function cacheFunction(rawLink) {
        return rawLink.source + '~#tqDMLink#~' + rawLink.target;
    }
}

function groupLinks(linkModels, parameters) {
    var groupsBySource = {};
    var groupsByTarget = {};

    linkModels.forEach(function (linkModel) {
        var typeId = linkModel.typeId || linkModel.label;
        var sourceCacheId = cacheFunction(typeId, linkModel.source.id);
        if (!groupsBySource[sourceCacheId]) {
            groupsBySource[sourceCacheId] = [];
            groupsBySource[sourceCacheId].source = linkModel.source;
            groupsBySource[sourceCacheId].label = linkModel.label;
            groupsBySource[sourceCacheId].typeId = typeId;
        }
        groupsBySource[sourceCacheId].push(linkModel);

        var targetCacheId = cacheFunction(typeId, linkModel.target.id);
        if (!groupsByTarget[targetCacheId]) {
            groupsByTarget[targetCacheId] = [];
            groupsByTarget[targetCacheId].target = linkModel.target;
            groupsByTarget[targetCacheId].label = linkModel.label;
            groupsByTarget[targetCacheId].typeId = typeId;
        }
        groupsByTarget[targetCacheId].push(linkModel);
    });

    Object.keys(groupsBySource).forEach(function (groupId) {
        var group = groupsBySource[groupId];
        var crossedElements = group.length > 1 ? group : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var sourceLink = new _mapElements.GraphLink({
            source: group.source,
            target: crossNode,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var targetLink = new _mapElements.GraphCrossLink({
                typeId: group.typeId,
                source: crossNode,
                target: linkModel.target,
                label: ''
            });
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'source';
        }, parameters);
    });

    Object.keys(groupsByTarget).forEach(function (groupId) {
        var group = groupsByTarget[groupId];
        var crossedElements = group.length > 1 ? group.filter(function (linkModel) {
            return !linkModel.graphPrimitives;
        }) : [];
        var crossNode = new _mapElements.GraphCrossNode({ crossedElements: crossedElements });
        var targetLink = new _mapElements.GraphCrossLink({
            source: crossNode,
            target: group.target,
            label: group.label,
            typeId: group.typeId,
            crossedElements: crossedElements
        }, parameters);
        crossedElements.forEach(function (linkModel) {
            var sourceLink = new _mapElements.GraphLink({
                typeId: group.typeId,
                source: linkModel.source,
                target: crossNode,
                label: ''
            }, parameters);
            linkModel.graphPrimitives = [crossNode, sourceLink, targetLink];
            linkModel.groupedBy = 'target';
        });
    });

    return linkModels;

    function cacheFunction(label, terminalId) {
        return label + '~#tqDMLink#~' + terminalId;
    }
}

function processNodes(rawNodes, parameters) {
    var topNodesMap = {};
    var allNodesMap = {};
    var parentMap = {};
    var res = new _resourceProvider.ResourceProvider(parameters);

    rawNodes.forEach(function (rawNode) {
        if (rawNode.id) {
            var children = parentMap[rawNode.id];
            var typeIcon = res.getIcon(rawNode.type);
            var model = allNodesMap[rawNode.id] || createModel(rawNode, children, typeIcon);
            allNodesMap[rawNode.id] = model;
            delete parentMap[rawNode.id];

            if (rawNode.parent) {
                if (allNodesMap[rawNode.parent]) {
                    allNodesMap[rawNode.parent].children.push(model);
                } else {
                    if (!parentMap[rawNode.parent]) parentMap[rawNode.parent] = [];
                    parentMap[rawNode.parent].push(model);
                }
            } else if (!topNodesMap[rawNode.id]) {
                topNodesMap[rawNode.id] = model;
            }
        }
    });

    // Process orphan nodes.
    // There were links to them but no defenitions.
    Object.keys(parentMap).forEach(function (id) {
        topNodesMap[id] = createModel({
            id: id,
            label: getLabelFromId(id),
            children: parentMap[id]
        });
    });

    var topNodes = Object.keys(topNodesMap).map(function (key) {
        return topNodesMap[key];
    });

    // remove cycles
    var processedNodesMap = {};
    function recursion(rootNode) {
        var childrenIds = {};
        rootNode.children = rootNode.children.filter(function (child) {
            if (!processedNodesMap[child.id] && !childrenIds[child.id]) {
                childrenIds[child.id] = true;
                processedNodesMap[child.id] = true;
                recursion(child);
                processedNodesMap[child.id] = false;
                return true;
            } else {
                return false;
            }
        });
    }

    return topNodes.filter(function (top) {
        if (!processedNodesMap[top.id]) {
            processedNodesMap[top.id] = true;
            recursion(top);
            processedNodesMap[top.id] = false;
            return true;
        } else {
            return false;
        }
    });
}

function createModel(rawNode, children, typeIcon) {
    return {
        id: (0, _lodash.uniqueId)('mapElement'),
        endpointId: rawNode.id,
        label: rawNode.label || getLabelFromId(rawNode.id),
        children: children || [],
        resourceType: rawNode.resourceType || 'undefined',
        resource: rawNode.resource || 'undefined',
        type: rawNode.type || 'undefined',
        collapsed: rawNode.collapsed,
        icon: rawNode.icon || typeIcon
    };
}

function createDiagramNodes(topNodeModels, parameters) {
    var derivationMapNodes = [];

    function copy(element, dublicationMap) {
        var dublication = dublicationMap || {};
        if (!dublication[element.id]) {
            var clonedElement = (0, _lodash.clone)(element);
            clonedElement.id = (0, _lodash.uniqueId)('copyOfMapElement');

            dublication[element.id] = clonedElement;
            clonedElement.children = element.children.map(function (child) {
                return copy(child, dublication);
            });
        }
        return dublication[element.id];
    }

    function createGroup(model1, model2) {
        return {
            id: (0, _lodash.uniqueId)('Group'),
            label: 'Group',
            endpointId: 'none',
            children: [model1, model2],
            synthetic: true,
            collapsed: true
        };
    }

    function addToGroup(group, model) {
        group.children.push(model);
    }

    // if there is more then one topElement for some model
    var topElementForId = {};
    var filteredTopModels = {};
    topNodeModels.forEach(function (topElement) {
        recursion(topElement);

        function recursion(curModel) {
            if (topElementForId[curModel.id]) {
                if (!topElementForId[curModel.id].synthetic && topElement.id !== topElementForId[curModel.id].id) {
                    delete filteredTopModels[topElement.id];
                    delete filteredTopModels[topElementForId[curModel.id].id];

                    topElementForId[curModel.id] = createGroup(topElementForId[curModel.id], topElement);

                    filteredTopModels[topElementForId[curModel.id].id] = topElementForId[curModel.id];
                } else {
                    addToGroup(topElementForId[curModel.id], topElement);
                }
                return copy(curModel);
            } else {
                topElementForId[curModel.id] = topElement;
                filteredTopModels[topElement.id] = topElement;
                curModel.children = curModel.children.map(function (child) {
                    return recursion(child);
                });
                return curModel;
            }
        }
    });

    Object.keys(filteredTopModels).forEach(function (topElementId) {
        var topElement = filteredTopModels[topElementId];

        var graphNode = new _mapElements.GraphNode(topElement, parameters);
        var processedNodes = {};
        recursion(topElement, []);

        function recursion(curModel, possibleIds) {
            if (!processedNodes[curModel.id]) {
                var model = (0, _lodash.cloneDeep)(curModel);
                model.orderedPossibleIds = possibleIds;
                model.graphNode = graphNode;

                processedNodes[curModel.id] = new _mapElements.Node(model, parameters);
                processedNodes[curModel.id].children = curModel.children.map(function (child) {
                    return recursion(child, possibleIds.concat([curModel.id]));
                });
                derivationMapNodes.push(processedNodes[curModel.id]);
            }
            return processedNodes[curModel.id];
        }
    });

    return derivationMapNodes;
}

function getLabelFromId(id) {
    var terms = id.split('/');
    var slashLabel = terms[terms.length - 1];
    if (slashLabel) {
        return slashLabel;
    } else {
        var hashIndex = id.indexOf('#');
        if (hashIndex !== -1) {
            var hashLabel = id.substring(hashIndex, id.length - 1);
            return hashLabel;
        } else {
            return id;
        }
    }
}

},{"../../data/resourceProvider":29,"./mapElements":42,"lodash":"lodash"}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultParametersSet = getDefaultParametersSet;
exports.DerivationMap = DerivationMap;

var _visualizationsLibrary = require("visualizations-library");

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _lodash = require("lodash");

var _ = _interopRequireWildcard(_lodash);

var _dataProcessing = require("./dataProcessing");

var _dataProcessing2 = _interopRequireDefault(_dataProcessing);

var _mapElements = require("./mapElements");

var mapElements = _interopRequireWildcard(_mapElements);

var _mapLayout = require("./mapLayout");

var _dmDefaultUI = require("../../htmlUI/dmDefaultUI");

var _resourceProvider = require("../../data/resourceProvider");

var _dataUtils = require("../../utils/dataUtils");

var _subscribeable = require("../../subscriptionAPI/subscribeable");

var _subscribeable2 = _interopRequireDefault(_subscribeable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Link style definition for DM
 * @typedef {Object} DMLinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {string} textColor - Color of the text on the line
 * @property {string} textBackgroundColor - Color of the background of the text on the line
 * @property {number} thickness
 */

/**
 * Set of parameters for Derivation Map
 * @typedef {Object} DerivationMapParameters
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {number} defaultElementWidth
 * @property {number} defaultElementHeight
 * @property {number} defaultLinkLabelLength
 * @property {number} defaultLayoutStep
 * @property {Function} errorCallBack - it is called in response to warnings and errors
 */

/**
 * Returns default set of parameters
 * @returns {DerivationMapParameters}
 */
function getDefaultParametersSet() {
  return {
    defaultElementWidth: 250,
    defaultElementHeight: 250,
    defaultLinkLabelLength: 100,
    defaultLayoutStep: 150,
    linkStyles: {
      "default-link-style": _resourceProvider.DEFAULT_DERIVATION_MAP_LINK_STYLE
      // Example:
      // 'type-id-1234': {
      //     lineType: 'dashed', // 'solid'
      //     cssClass: 'class-123'
      //     color: 'green',
      //     textColor: 'blue',
      //     textBackgroundColor: 'yellow',
      //     thickness: 5,
      // },
    },
    icons: {
      "SQL script": "fas fa-cog",
      "Database Table": "fas fa-folder"
    },
    tools: [],
    errorCallBack: undefined // It is called in response to warnings and errors
  };
}

/**
 * @private
 * @class
 * Displays derivation view for selected link
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataProvider: DataContainer
 *  rootElement: HTMLElement
 *  relation: { source: string, target: string }
 * } options
 * @param {DerivationMapParameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * relation: { source: string, target: string }
 *
 * Public methods:
 * ========================================
 * openWithRelation (relation: { source: string, target: string }) - Initializes DM diagram
 * exportToSvg()
 * exportToPng()
 * resetFocus()
 * zoomIn()
 * zoomOut()
 * zoomToFit()
 * print()
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 *
 * Events:
 * ========================================
 * @fires diagram-state-changed (stateId: string)
 */
function DerivationMap(properties, parameters) {
  var _this = this;

  _subscribeable2.default.apply(this);

  var defaultParameterSet = getDefaultParametersSet();
  // Merging parameters default and user
  var _parameters = _.merge(defaultParameterSet, parameters || {});

  var _errorCallback = function _errorCallback(e) {
    if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
      var error = typeof e === "string" ? new Error(e) : e;
      _parameters.errorCallback.call(_this, error);
    }
  };

  /**
   * State changed event - fires when DM state changes.
   * E.g. from a fetching state to a rendering state.
   * The state string identifier is returned as a parameter of the event
   * @event diagram-state-changed
   * @type {Object}
   * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
   */

  var self = this;
  var _dataProvider = properties.dataProvider;
  var _base = _createBase(properties.rootElement);

  var _layout = new _mapLayout.MapLayout({
    rootElement: _base.derivationMapRootHtml
  }, _parameters);
  var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
    baseElement: _base.container
  });

  var _selectedElement = undefined;
  var _diagramInfo = undefined;

  // Initialization
  // ==================================================

  var _defaultUI = new _dmDefaultUI.DMDefaultUI({
    baseElement: _base.toolbar,
    infoPanel: _base.infoPanel,
    tools: _parameters.tools || null,
    derivationMap: self
  });

  if (properties.relation) {
    _openWithRelation(properties.relation);
  }

  // Public functions
  // ==================================================

  self.relation;
  self.openWithRelation = _openWithRelation;

  self.resetFocus = function () {
    _layout.zoom();
  };

  self.getSelectedElement = function () {
    return _selectedElement;
  };

  self.setSelectedElement = function (elementId) {
    var selectedELement = _layout.getNodes().find(function (el) {
      return el.id === elementId;
    });
    _setSelectedElement(selectedELement);
  };

  self.setSearchKey = function (key) {
    _layout.setSearchKey(key);
  };

  self.expandAllElements = function () {
    _layout.getNodes().forEach(function (el) {
      el.expand();
    });
  };

  self.collapseAllElements = function () {
    _layout.getNodes().forEach(function (el) {
      el.collapse();
    });
  };

  self.exportToSvg = function () {
    _layout.export({ type: "svg" });
  };

  self.exportToPng = function () {
    _layout.export({ type: "png" });
  };

  self.zoomIn = function () {
    _layout.zoom(0.2, { max: 4 });
  };

  self.zoomOut = function () {
    _layout.zoom(-0.2, { min: 0.2 });
  };

  self.zoomToFit = function () {
    _layout.zoom();
  };

  self.print = function () {
    _layout.print();
  };

  self.getDiagramInfo = function () {
    return _diagramInfo;
  };

  // Private functions
  // ==================================================

  function _openWithRelation(relation) {
    _setSelectedElement(undefined);
    if (relation) {
      if (!self.relation || relation.source !== self.relation.source || relation.target !== self.relation.target || relation.linkType !== self.relation.linkType) {
        _layout.clear();
        self.relation = relation;
        _setDiagramState("fetching");
        _dataProvider.relationInfo(relation).then(function (rawData) {
          _setDiagramState("rendering");

          (0, _dataUtils.checkDmRawData)(rawData);

          _diagramInfo = rawData.diagramInfo;

          var mapElements = (0, _dataProcessing2.default)(rawData, _parameters);
          _layout.setElements(mapElements.elements.concat(mapElements.links), _diagramInfo);
          self.resetFocus();
          _subscribeOnElements();
          _setDiagramState("completed");
        }).catch(function (e) {
          var error = typeof e === "string" ? new Error(e) : e;

          _setDiagramState("error", error.message);
          _errorCallback(error);

          console.error(error.message);
          console.error(error.stack);
        });
      } else {
        self.resetFocus();
      }
    } else {
      var errorText = "The relation you want to use is empty!";
      var error = new Error(errorText);
      _setDiagramState("error", errorText);
      _errorCallback(error);
      throw error;
    }
  }

  function _subscribeOnElements() {
    _layout.getNodes().forEach(function (el) {
      el.on("element-click", function () {
        _setSelectedElement(el);
      });
      el.on("collapse-button-click", function () {
        var model = el.getModel();
        if (model.collapsed) {
          el.expand();
        } else {
          el.collapse();
        }
      });
    });

    _layout.getLinks().forEach(function (el) {
      el.on("element-click", function () {
        _setSelectedElement(el);
      });
    });
  }

  _layout.on("blank-click", function () {
    return _setSelectedElement(undefined);
  });

  function _setSelectedElement(element) {
    if (_selectedElement) _selectedElement.highlighting(false);
    _selectedElement = element;

    if (_selectedElement) _selectedElement.highlighting(true);
    _defaultUI.infoPanel.setSelectedElement(element);

    self.trigger("selected-element-changed", _getModel(element));
  }

  /**
   * Sets state of indicator
   * @private
   * @param {string} state - fetching | rendering | completed
   * @param {string} message - Custom message
   */
  function _setDiagramState(state, message) {
    self.state = state;
    if (state === "fetching") {
      _progressScreen.setState("active", message || "Fetching data");
    } else if (state === "rendering") {
      _progressScreen.setState("active", message || "Rendering graph");
    } else if (state === "completed") {
      _progressScreen.setState("completed");
    } else if (state === "error") {
      _progressScreen.setState("error", message || "Error has occurred!");
    }
    self.trigger("diagram-state-changed", message || state);
  }

  function _getModel(element) {
    if (element instanceof mapElements.Node) {
      return {
        id: element.id,
        label: element.label,
        resource: element.resource,
        parent: element.parent,
        resourceType: element.resourceType,
        diagramType: "node",
        endpointId: element.endpointId
      };
    } else if (element instanceof mapElements.Link) {
      return {
        id: element.id,
        source: element.source.endpointId,
        target: element.target.endpointId,
        diagramType: "link",
        typeId: element.typeId
      };
    } else {
      return undefined;
    }
  }

  /**
   * Creates html markup.
   * @private
   * @param {HTMLElement} htmlNode - Root node for markup
   * @returns {Object.<string, HTMLElement>} - Map of html elements
   */
  function _createBase(htmlNode) {
    htmlNode.innerHTML = "";
    htmlNode.tabIndex = 0;

    var rowContainer = document.createElement("DIV");
    rowContainer.className = "tq-row-container";
    htmlNode.appendChild(rowContainer);

    var baseDiv = document.createElement("DIV");
    baseDiv.className = "tq-derivation-map";
    baseDiv.id = "tq-derivation-map";
    rowContainer.appendChild(baseDiv);

    var derivationMapRootHtml = document.createElement("DIV");
    derivationMapRootHtml.className = "tq-derivation-map-diagram";
    derivationMapRootHtml.id = "tq-derivation-map-diagram";
    baseDiv.appendChild(derivationMapRootHtml);

    var progressIndication = document.createElement("DIV");
    progressIndication.className = "tq-lg-progress-screen";
    baseDiv.appendChild(progressIndication);

    var toolbarBase = document.createElement("DIV");
    toolbarBase.className = "tq-derivation-map__toolbar";
    toolbarBase.id = "tq-derivation-map-toolbar";
    baseDiv.appendChild(toolbarBase);

    var infoPanel = document.createElement("DIV");
    infoPanel.className = "tq-row-container__properties-pane";
    infoPanel.id = "tq-properties-pane";
    rowContainer.appendChild(infoPanel);

    return {
      container: htmlNode,
      baseDiv: baseDiv,
      infoPanel: infoPanel,
      toolbar: toolbarBase,
      derivationMapRootHtml: derivationMapRootHtml,
      progress: progressIndication
    };
  }
}

exports.default = DerivationMap;

},{"../../data/resourceProvider":29,"../../htmlUI/dmDefaultUI":31,"../../subscriptionAPI/subscribeable":65,"../../utils/dataUtils":66,"./dataProcessing":39,"./mapElements":42,"./mapLayout":43,"lodash":"lodash","visualizations-library":70}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dmrouter = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = require('../../utils/utils');

var _lineageDiagramUtils = require('../../utils/lineageDiagramUtils');

var ELEMENT_OFFSET = 10;

var dmrouter = exports.dmrouter = function () {
    return function (manualVertices, opts, linkView) {
        this._findConnectionPoints([]);

        return buildWay(this.sourcePoint, this.targetPoint);

        function buildWay(start, finish) {
            var elements = linkView.model.graph.getElements().map(function (el) {
                var rect = el.getBBox();
                var center = rect.center();
                return {
                    el: el,
                    rect: rect,
                    distA: (0, _utils.getDist)(center, start)
                };
            }).sort(function (a, b) {
                if (a.dist > b.dist) return -1;else if (a.dist < b.dist) return 1;else return 0;
            });
            var line = { p1: start, p2: finish };

            for (var i = 0; i < elements.length; i++) {
                var element = elements[i];
                var rect = element.rect;

                var elementSides = [{ p1: { x: rect.x, y: rect.y }, p2: { x: rect.x + rect.width, y: rect.y } }, { p1: { x: rect.x, y: rect.y }, p2: { x: rect.x, y: rect.y + rect.height } }, { p1: { x: rect.x, y: rect.y + rect.height }, p2: { x: rect.x + rect.width, y: rect.y + rect.height } }, { p1: { x: rect.x + rect.width, y: rect.y }, p2: { x: rect.x + rect.width, y: rect.y + rect.height } }];

                var intersectionPoints = elementSides.map(function (side) {
                    return (0, _lineageDiagramUtils.getCrosPoint)(line.p1, line.p2, side.p1, side.p2);
                }).filter(function (point) {
                    return point;
                });
                var intersectWithObject = intersectionPoints.length !== 0;

                if (intersectWithObject) {
                    var _ret = function () {
                        var elementPoints = [{ x: rect.x - ELEMENT_OFFSET, y: rect.y - ELEMENT_OFFSET }, { x: rect.x + rect.width + ELEMENT_OFFSET, y: rect.y - ELEMENT_OFFSET }, { x: rect.x + rect.width + ELEMENT_OFFSET, y: rect.y + rect.height + ELEMENT_OFFSET }, { x: rect.x - ELEMENT_OFFSET, y: rect.y + rect.height + ELEMENT_OFFSET }];
                        var allPoints = elementPoints.concat([start, finish]);
                        var hull = getConvexHull(allPoints);

                        var cahce = hull.map(function (p) {
                            return pointToString(p);
                        });
                        var startIndex = cahce.indexOf(pointToString(start));
                        var endIndex = cahce.indexOf(pointToString(finish));

                        var way1 = [];
                        if (startIndex !== -1 && endIndex !== -1) {
                            for (var j = startIndex; j !== endIndex; j++) {
                                if (j >= hull.length) {
                                    j = 0;
                                }
                                if (j !== startIndex && j !== endIndex) way1.push(hull[j]);
                                if (way1.length >= hull.length) break;
                            }
                            var way2 = hull.filter(function (p, i) {
                                return i !== startIndex && i !== endIndex && way1.indexOf(p) === -1;
                            });

                            way1 = correctDirection(start, way1);
                            way2 = correctDirection(start, way2);

                            var fullWay1 = [start].concat(way1).concat(finish);
                            var fullWay2 = [start].concat(way2).concat(finish);
                            var length1 = calculateWayLength(fullWay1);
                            var length2 = calculateWayLength(fullWay2);
                            var way = length1 < length2 ? way1 : way2;

                            return {
                                v: way
                            };
                        }
                    }();

                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                }
            }
            return [];
        }
    };
}();

function correctDirection(start, way) {
    var firstPoint = way[0];
    var lastPoint = way[way.length - 1];

    if (way.length > 0) {
        if ((0, _utils.getDist)(firstPoint, start) > (0, _utils.getDist)(lastPoint, start)) {
            way.reverse();
        }
    }

    return way;
}

function calculateWayLength(way) {
    var length = 0;
    for (var i = 0; i < way.length - 1; i++) {
        var from = way[i];
        var to = way[i + 1];
        length += (0, _utils.getDist)(from, to);
    }
    return length;
}

function pointToString(p) {
    return '' + p.x + ':' + p.y;
}

function getConvexHull(nodes) {
    var points = [].concat(nodes);
    points.sort(function (a, b) {
        return a.x != b.x ? a.x - b.x : a.y - b.y;
    });

    var n = points.length;
    var hull = [];

    for (var i = 0; i < 2 * n; i++) {
        var j = i < n ? i : 2 * n - 1 - i;
        while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j])) {
            hull.pop();
        }hull.push(points[j]);
    }
    hull.pop();

    var filterDublication = {};
    return hull.filter(function (p) {
        var id = getId(p);
        if (filterDublication[id]) return false;
        filterDublication[id] = p;
        return true;
    });

    function removeMiddle(a, b, c) {
        var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
        // const dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
        return cross < 0; // || (cross == 0 && dot <= 0);
    }

    function getId(point) {
        return point.x + ':' + point.y;
    }
}

},{"../../utils/lineageDiagramUtils":68,"../../utils/utils":69}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.LINK_LABEL_FONT_SIZE = undefined;
exports.Node = Node;
exports.Link = Link;
exports.GraphNode = GraphNode;
exports.GraphCrossNode = GraphCrossNode;
exports.GraphLink = GraphLink;
exports.GraphCrossLink = GraphCrossLink;
exports.getPortId = getPortId;
exports.getLinkMarkerTarget = getLinkMarkerTarget;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('../../data/resourceProvider');

var _lineRouting = require('./lineRouting');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = 'derivation-link';
var MARKER_TARGET = {
    fill: 'black',
    stroke: 'black',
    d: 'M 10 0 L 0 5 L 10 10 z'
};
var LINK_LABEL_FONT_SIZE = exports.LINK_LABEL_FONT_SIZE = 16;
var Z_INDEXES = exports.Z_INDEXES = {
    NODE: 30,
    SELECTED_ELEMENT: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5
};

joint.routers.dmrouter = _lineRouting.dmrouter;

/**
 * Node
 * @private
 * @class
 * ==========================================
 * @fires element-click
 * @fires collapse-button-click
 * @fires ports-state-changed
 * @fires element-state-changed
 * @fires position-changed
 */
function Node(options, parameters) {
    _subscribeable2.default.apply(this);

    /**
     * It fires when user click on node.
     * @event element-click
     * @type {Object}
     * @property {MouseEvent} event - origin MouseEvtnt
    */

    var self = this;
    var _graphNode = options.graphNode || new GraphNode(options.model, parameters);

    self.id = options.id;
    self.endpointId = options.endpointId;
    self.resourceType = options.resourceType;
    self.parent = options.parent;
    self.label = options.label;
    self.children = options.children;
    self.orderedPossibleIds = options.orderedPossibleIds;
    self.resource = options.resource;

    self.highlighting = function (value) {
        if (value !== undefined) {
            if (value) {
                _graphNode.setHighlightedId(self.id);
            } else if (self.id === _graphNode.highlightedId) {
                _graphNode.setHighlightedId(undefined);
            }
        }
        return _graphNode.highlightedId === self.id;
    };

    self.collapse = function () {
        _graphNode._collapseElement(self.id);
    };

    self.expand = function () {
        _graphNode._expandElement(self.id);
    };

    self.show = function () {
        // not implemented..
    };

    self.hide = function () {
        // not implemented..
    };

    self.isVisible = function () {
        return true;
    };

    self.getCells = function () {
        return [_graphNode];
    };

    self.getPort = function () {
        return {
            id: _getAvailablePortId(),
            primitive: _graphNode
        };
    };

    self.getModel = _getModel;

    self.getPortPosition = function (direction) {
        var svgObject = _graphNode.attr('.' + getPortId(_getAvailablePortId(), direction));
        var primitivePosition = self.getPort().primitive.position();
        if (svgObject) {
            return {
                x: svgObject['ref-x'] + primitivePosition.x,
                y: svgObject['ref-y'] + primitivePosition.y
            };
        } else {
            return primitivePosition;
        }
    };

    self.onPaperCellPointerDown = function () {
        // ...
    };

    _graphNode.on('ports-state-changed', function () {
        self.trigger('ports-state-changed');
    });

    _graphNode.on('elements-state-changed', function () {
        self.trigger('element-state-changed');
    });

    _graphNode.on('body-click', function (_ref) {
        var event = _ref.event,
            elementId = _ref.elementId;

        if (self.id === elementId) {
            self.trigger('element-click', event);
        }
    });

    _graphNode.on('change:position', function () {
        self.trigger('position-changed');
    });

    _graphNode.on('collapse-button-click', function (elementId) {
        if (elementId === self.id) {
            self.trigger('collapse-button-click');
        }
    });

    function _getModel() {
        return _graphNode.elementsMap[self.id];
    }

    function _getAvailablePortId() {
        var model = _getModel();
        if (!model.invisible) {
            return self.id;
        }
        for (var i = 0; i < self.orderedPossibleIds.length; i++) {
            var curId = self.orderedPossibleIds[i];
            if (_graphNode.elementsMap[curId].invisible) {
                var prevId = self.orderedPossibleIds[i - 1];
                return prevId;
            }
        }
        return self.orderedPossibleIds[self.orderedPossibleIds.length - 1];
    }
}

/**
 * Link
 * @private
 * @class
 * ==========================================
 */
function Link(options, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;

    self.source = options.source;
    self.target = options.target;
    self.label = options.label;
    self.typeId = options.typeId;
    self.groupedBy = options.groupedBy; // source | target | undefined

    var _getConnectionParamet = _getConnectionParameters(),
        source = _getConnectionParamet.source,
        target = _getConnectionParamet.target;

    var primitivesAreDefined = options.graphPrimitives && options.graphPrimitives.length > 0;
    var _graphPrimitives = primitivesAreDefined ? options.graphPrimitives : [new GraphLink({
        typeId: options.typeId,
        source: source,
        target: target,
        label: _getLabel()
    }, parameters)];

    _refreshPorts();

    self.getCells = function () {
        return _graphPrimitives;
    };

    var _highlighted = false;
    self.highlighting = function (value) {
        if (value !== undefined) {
            _highlighted = value;
            _graphPrimitives.forEach(function (primitive) {
                if (value) {
                    primitive.highlight();
                } else {
                    primitive.unhighlight();
                }
            });
        }
        return _highlighted;
    };

    self.show = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.show();
        });
    };

    self.hide = function () {
        _graphPrimitives.forEach(function (primitive) {
            return primitive.hide();
        });
    };

    self.isVisible = function () {
        return !self.get('hidden');
    };

    self.onPaperCellPointerDown = function (cell) {
        var cellIsMyPrimitive = _graphPrimitives.indexOf(cell) !== -1;
        if (cellIsMyPrimitive) {
            self.trigger('element-click', event);
        }
    };

    self.alignCrossNode = _alignCrossNode;
    self.getCrossNode = _getCrossNode;

    function _getCrossNode() {
        var isCrossed = _graphPrimitives.length > 1;
        if (isCrossed) {
            return _graphPrimitives[0];
        } else {
            return undefined;
        }
    }

    function _alignCrossNode() {
        var crossNode = _getCrossNode();
        if (!crossNode) return;

        var crossedElements = crossNode.getCrossedElements();
        var firstCrossedElement = crossedElements[0];
        var groupedBySource = firstCrossedElement.groupedBy === 'source';
        var DEFAULT_PADDING = 30;
        var sumY = 0;
        var minX = Infinity;
        var maxX = -Infinity;

        crossedElements.forEach(function (crossedLinks) {
            var allignTo = groupedBySource ? crossedLinks.target.getPortPosition('in') : crossedLinks.source.getPortPosition('out');

            sumY += allignTo.y;
            minX = Math.min(minX, allignTo.x);
            maxX = Math.max(maxX, allignTo.x);
        });
        var xPosition = groupedBySource ? minX - DEFAULT_PADDING : maxX + DEFAULT_PADDING;
        var yPosition = sumY / crossedElements.length;
        crossNode.position(xPosition, yPosition);
    }

    function _getLabel() {
        return joint.util.breakText(self.label, {
            width: parameters.defaultLinkLabelLength
        }, { 'font-size': LINK_LABEL_FONT_SIZE });
    }

    function _refreshPorts() {
        var _getConnectionParamet2 = _getConnectionParameters(),
            targetTopId = _getConnectionParamet2.targetTopId,
            source = _getConnectionParamet2.source,
            target = _getConnectionParamet2.target;

        var sourcePrimitive = _graphPrimitives[1] || _graphPrimitives[0];
        var targetPrimitive = _graphPrimitives[2] || _graphPrimitives[0];

        var targetLinkStyle = targetPrimitive.getLinkStyle();
        if (target.id === targetTopId) {
            targetPrimitive.attr('.marker-target', getLinkMarkerTarget(targetLinkStyle));
            targetPrimitive.trigger('updateMarkers');
        } else {
            targetPrimitive.removeAttr('.marker-target');
            targetPrimitive.trigger('updateMarkers');
        }

        sourcePrimitive.prop({ source: source });
        targetPrimitive.prop({ target: target });

        _alignCrossNode();
    }

    function _getConnectionParameters() {
        var sourcePort = self.source.getPort();
        var targetPort = self.target.getPort();

        var sourcePosition = sourcePort.primitive.position();
        var targetPosition = targetPort.primitive.position();

        var reverse = sourcePosition.x > targetPosition.x;
        var source = {
            id: sourcePort.primitive.id,
            port: getPortId(sourcePort.id, reverse ? 'in' : 'out')
        };
        var target = {
            id: targetPort.primitive.id,
            port: getPortId(targetPort.id, reverse ? 'out' : 'in')
        };

        return {
            sourceTopId: sourcePort.id,
            targetTopId: targetPort.id,
            source: source,
            target: target
        };
    }

    self.source.on('element-state-changed', _refreshPorts);
    self.target.on('element-state-changed', _refreshPorts);
    self.source.on('ports-state-changed', _alignCrossNode);
    self.target.on('ports-state-changed', _alignCrossNode);
    self.source.on('position-changed', _refreshPorts);
    self.target.on('position-changed', _refreshPorts);
}

/**
 * JointNode
 * @private
 * @class
 * ==========================================
 * @fires body-click
 * @fires highlighted-id
 */
function GraphNode(model, parameters) {
    var self = this;

    /**
     * It fires when user click on node.
     * @event body-click
     * @type {Object}
     * @property {
     *  event: MouseEvent, // original mouse event
     *  elementId: string, // id of the clicked element
     * }
    */

    self.elementsMap = _getFlatElementsMap(model);
    self.model = model;
    self.scale = 1;
    self.activePorts = {};

    joint.shapes.basic.Generic.apply(self, [{
        id: model.id,
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <rect class="body"/>\n            </g>\n            ' + _portsTemplate() + '\n        </g>',
        type: 'graph-derivation-node.GraphNode',
        position: { x: 0, y: 0 },
        z: Z_INDEXES.NODE,
        size: {
            width: parameters.defaultElementWidth,
            height: parameters.defaultElementHeight
        },
        attrs: {
            rect: {
                stroke: 'transparent'
            },
            circle: {
                r: 0,
                fill: 'red'
            },
            '.dn-in-port': {
                ref: '.body',
                'ref-x': 0,
                'ref-y': 0
            },
            '.dn-out-port': {
                ref: '.body',
                'ref-x': parameters.defaultElementWidth + 20,
                'ref-y': 0
            }
        }
    }]);

    self.set('collapsed', false);
    self.sctollTop = 0;

    self.setHighlightedId = function (targetId) {
        self.highlightedId = targetId;
        var changedIds = _updateState(this.model);
        changedIds.concat(_updateVisibility(this.model));
        self.trigger('elements-state-changed', [changedIds]);
        self.prop({ z: Z_INDEXES.NODE });
    };

    self._collapseElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = true;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', true);
        }
    };

    self._expandElement = function (elementId) {
        if (elementId) {
            self.elementsMap[elementId].collapsed = false;
            var changedIds = _updateVisibility(self.elementsMap[elementId]);
            changedIds.push(elementId);
            if (changedIds.length > 0) self.trigger('elements-state-changed', [changedIds]);
        } else {
            self.set('collapsed', false);
        }
    };

    self.onClickCollapseButton = function (elementId) {
        self.trigger('collapse-button-click', elementId);
    };

    self.updatePorts = function () {
        self.trigger('ports-state-changed');
    };

    self.fireClickEvent = function (event, elementId) {
        self.trigger('body-click', {
            event: event,
            elementId: elementId
        });
    };

    self.getAllChildren = _getAllChildren;

    self.activePorts = {};
    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };

    self.setSearchKey = function (searchKey) {
        self.searchKey = searchKey ? searchKey.toLowerCase() : undefined;

        var changedIds = _updateVisibility(this.model);
        self.trigger('elements-state-changed', [changedIds]);
    };

    function _updateState(rootModel) {
        var highlightedId = self.highlightedId;
        var changedIds = [];

        updateState(rootModel);

        return changedIds;

        function updateState(model) {
            var isSelected = model.id === highlightedId;

            var containSelectedElement = false;
            model.children.forEach(function (child) {
                containSelectedElement = updateState(child) || containSelectedElement;
            });

            var newCollapsedState = model.collapsed && !containSelectedElement;
            if (Boolean(newCollapsedState) !== Boolean(model.collapsed)) changedIds.push(model.id);
            model.collapsed = newCollapsedState;

            return isSelected || containSelectedElement;
        }
    }

    function _updateVisibility(rootModel) {
        var searchKey = self.searchKey;
        var changedIds = [];

        updateVisibility(rootModel, false);

        return changedIds;

        function updateVisibility(model, parentInvisible) {
            var notContainKey = !searchKey || model.label.toLowerCase().indexOf(searchKey) === -1;
            var invisible = parentInvisible && notContainKey;

            var noVisibleChildren = true;
            model.children.forEach(function (child) {
                noVisibleChildren = updateVisibility(child, parentInvisible || model.collapsed) && noVisibleChildren;
            });
            var newVisibiblity = invisible && noVisibleChildren;
            if (Boolean(newVisibiblity) !== Boolean(model.invisible)) changedIds.push(model.id);
            model.invisible = invisible && noVisibleChildren;

            return model.invisible;
        }
    }

    function _getAllChildren() {
        return Object.keys(self.elementsMap).map(function (id) {
            return self.elementsMap[id];
        });
    }

    function _getFlatElementsMap(model) {
        var elementsMap = {};
        recursion(model, false);
        return elementsMap;

        function recursion(element, invisible) {
            if (!elementsMap[element.id]) {
                elementsMap[element.id] = element;
                element.invisible = invisible;
                element.children.map(function (child) {
                    recursion(child, element.collapsed);
                });
            }
        }
    }

    function _portsTemplate() {
        return _getAllChildren().map(function (element) {
            var inPortId = getPortId(element.id, 'in');
            var outPortId = getPortId(element.id, 'out');

            return '\n                <circle class="dn-in-port ' + inPortId + '" port="' + inPortId + '"/>\n                <circle class="dn-out-port ' + outPortId + '" port="' + outPortId + '"/>\n            ';
        }).join('');
    }
}
GraphNode.prototype = Object.create(joint.shapes.devs.Model.prototype);

var DEFAULT_CROSS_NODE_SIZE = {
    width: 1, height: 1
};
/**
 * JointCrossNode
 * @private
 * @class
 * ==========================================
 */
function GraphCrossNode(model) {
    var self = this;

    self.model = model;
    self.hidden = false;

    joint.shapes.basic.Generic.apply(self, [{
        type: 'derivationCrossNode',
        markup: '<g class="rotatable">\n            <g class="scalable export-anchor">\n                <circle class="body"/>\n            </g>\n        </g>',
        size: DEFAULT_CROSS_NODE_SIZE,
        z: Z_INDEXES.LINK,
        attrs: {
            circle: {
                r: '5px',
                stroke: 'black',
                'stroke-width': 3
            }
        }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };

    self.refresh = function () {
        self.trigger('redraw-view');
    };

    self.setScale = function (scale) {
        self.scale = scale;
    };
}
GraphCrossNode.prototype = Object.create(joint.shapes.basic.Generic.prototype);

/**
 * DMLinkModel - data model for a {@link Link} object
 * @typedef {Object} DMLinkModel
 * @property {string} typeId - Link type identifyer
 * @property {GraphNode} target - Target Node
 * @property {GraphNode} source - Source Node
 * @property {string} label - Text in the middle of the link
 * @property {string} linktype - Type of the Link
 * @property {GraphLink[]} crossedElements - in case of the link is a part of grouped links
*/

/**
 * JointLink
 * @private
 * @class
 * @param {DMLinkModel} model
 * @param {Paramters} parameters
 * ==========================================
 */
function GraphLink(model, parameters) {
    var self = this;

    self.model = model;
    self.hidden = false;

    var _res = new _resourceProvider.ResourceProvider(parameters);
    var _linkStyle = _res.getLinkStyle(model.typeId);
    var types = [DEFAULT_LINK_TYPE];

    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        z: Z_INDEXES.LINK,
        source: model.source,
        target: model.target,
        attrs: _getLinkAttributes(_linkStyle),
        labels: [{
            position: .5,
            attrs: {
                rect: { fill: _linkStyle.textBackgroundColor },
                text: { fill: _linkStyle.textColor, text: model.label }
            }
        }],
        connector: { name: 'rounded' },
        // connector: { name: 'jumpover', args: { type: 'gap' }},
        router: {
            name: 'dmrouter'
        }
    }]);

    self.highlight = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    self.unhighlight = function () {
        self.prop({ z: Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    self.getLinkStyle = function () {
        return _linkStyle;
    };

    self.show = function () {
        self.hidden = false;
        self.prop({ z: Z_INDEXES.LINK });
        self.trigger('update-state');
    };

    self.hide = function () {
        self.hidden = true;
        self.prop({ z: Z_INDEXES.BLURED_LINK });
        self.trigger('update-state');
    };

    function _getLinkAttributes(linkStyle, hasArrow) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        attributes['.marker-target'] = hasArrow ? getLinkMarkerTarget(linkStyle) : undefined;
        return attributes;
    }
}
GraphLink.prototype = Object.create(joint.dia.Link.prototype);

/**
 * JointLink
 * @private
 * @class
 * ==========================================
 */
function GraphCrossLink(model, paramters) {
    var self = this;

    self.model = model;

    GraphLink.apply(self, [model, paramters]);

    self.getCrossedElements = function () {
        return self.model.crossedElements;
    };
}
GraphCrossLink.prototype = Object.create(GraphLink.prototype);

function getPortId(portId, direction) {
    var isTarget = direction === 'in';
    return (isTarget ? 'In_' : 'Out_') + 'Port_' + encodeURI(portId);
}

function getLinkMarkerTarget(linkStyle) {
    return {
        fill: linkStyle.color,
        stroke: linkStyle.color,
        d: MARKER_TARGET.d,
        'stroke-width': linkStyle.thickness
    };
}

},{"../../data/resourceProvider":29,"../../subscriptionAPI/subscribeable":65,"./lineRouting":41,"rappid":"rappid"}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapLayout = MapLayout;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _mapViews = require('./mapViews');

var _mapElements = require('./mapElements');

var _toSvg = require('../toSvg');

var _subscribeable = require('../../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _sankey = require('../../layout/sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _layout = require('../../layout/layout');

var _layoutUtils = require('../../utils/layoutUtils');

var _dataUtils = require('../../utils/dataUtils');

var _lineageDiagramUtils = require('../../utils/lineageDiagramUtils');

var _utils = require('../../utils/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

joint.shapes['graph-derivation-node'] = {
    GraphNode: _mapElements.GraphNode,
    GraphNodeView: _mapViews.GraphNodeView
};

/**
 * Set of options for derivation map layout class.
 * @typedef {Object} DMLayoutOptions
 * @property {HTMLElement} rootElement
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {string} textColor - Color of the text on the line
 * @property {string} textBackgroundColor - Color of the background of the text on the line
 * @property {number} thickness
*/

/**
 * @private
 * @param {DMLayoutOptions} properties
 * @fires blank-click
 */
function MapLayout(properties, parameters) {
    _subscribeable2.default.apply(this);

    var self = this;
    var _graph = new joint.dia.Graph();
    var _startPoint = undefined;

    var _paper = new joint.dia.Paper({
        model: _graph,
        // elementView: GraphNodeView,
        linkView: _mapViews.GraphLinkView,
        gridSize: 1,
        preventContextMenu: false,
        interactive: function interactive() {
            return { vertexAdd: false };
        },
        width: 5000,
        height: 5000
    });
    var _paperScroller = new joint.ui.PaperScroller({
        paper: _paper,
        autoResizePaper: true
    });

    var _nodes = [];
    var _links = [];

    properties.rootElement.innerHTML = '';
    properties.rootElement.appendChild(_paperScroller.render().el);

    // Initialization
    // =======================================================
    // =======================================================
    // =======================================================

    /**
     * Handling multiple link situations - bends them so they don't cross
     * @private
    */

    // Just refreshes related elements on changes.
    _graph.on('change:source change:target', _refreshRelatedElement);

    _paper.on('blank:pointerdown', function (event, x, y) {
        _startPoint = { x: event.pageX, y: event.pageY };
        _paperScroller.startPanning(event, x, y);
    });
    _paper.on('blank:pointerclick', function (event) {
        if (!_startPoint) return;

        var newPoint = { x: event.pageX, y: event.pageY };
        var OFFSET_THRESHOLD = 5;
        var offsetExceedThreshold = Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD || Math.abs(newPoint.x - _startPoint.x) < OFFSET_THRESHOLD;
        if (offsetExceedThreshold) {
            self.trigger('blank-click', event);
        }
        _startPoint = undefined;
    });
    _paper.on('cell:pointerdown', function (cellView) {
        _nodes.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
        _links.forEach(function (el) {
            if (el.onPaperCellPointerDown) el.onPaperCellPointerDown(cellView.model);
        });
    });

    var onMouseWheel = function onMouseWheel(evt, x, y, delta) {
        if (evt.ctrlKey) {
            self.zoom(0.1 * (delta < 0 ? -1 : 1), { max: 4 });
            evt.preventDefault();
        }
    };
    _paper.on('cell:mousewheel', function (cell, evt, x, y, delta) {
        return onMouseWheel(evt, x, y, delta);
    });
    _paper.on('blank:mousewheel', onMouseWheel);

    // =======================================================
    // =======================================================
    // =======================================================

    self.getNodes = function () {
        return _nodes;
    };

    self.getLinks = function () {
        return _links;
    };

    self.getGraphNodes = function () {
        return _graph.getElements();
    };

    self.getGraphLinks = function () {
        return _graph.getLinks();
    };

    self.clear = function () {
        _nodes = [];
        _links = [];
        _graph.clear();
    };

    self.zoom = function (scaleDiff, opt) {
        if (!scaleDiff) {
            _paperScroller.zoomToFit();
            _paperScroller.zoom(-0.2, { max: 2, min: 0.2 });
        } else {
            _paperScroller.zoom(scaleDiff, opt);
        }
        var newScale = _paperScroller._sx;

        _graph.getElements().forEach(function (node) {
            node.setScale(newScale);
            node.refresh();
        });
    };

    self.setElements = function (newElements, diagramInfo) {
        var newNodes = [];
        var newLinks = [];
        newElements.forEach(function (el) {
            if (el instanceof _mapElements.Node) {
                newNodes.push(el);
            } else if (el instanceof _mapElements.Link) {
                newLinks.push(el);
            }
        });

        _nodes = _nodes.concat(newNodes);
        _links = _links.concat(newLinks);

        var processedIds = {};
        var cells = [];

        newElements.forEach(function (element) {
            var elementCells = element.getCells();
            elementCells.forEach(function (cell) {
                if (!processedIds[cell.id]) {
                    processedIds[cell.id] = true;
                    cells.push(cell);
                }
            });
        });
        cells.sort(function (cell1, cell2) {
            var c1 = cell1 instanceof joint.shapes.basic.Generic ? 1 : 0;
            var c2 = cell2 instanceof joint.shapes.basic.Generic ? 1 : 0;
            return c2 - c1;
        });
        _graph.addCells(cells);

        cells.forEach(function (cell) {
            return _refreshRelatedElement(cell);
        });
        _subscribeOnElements();
        _doLayout(diagramInfo);
        setTimeout(function () {
            _doLayout(diagramInfo);
            self.zoom();
        }, 100);
    };

    /**
     * Exports graph to png or svg file
     * @param {
     *  name?: string - file name
     *  type?: string - (png/svg)
     * } options
    */
    self.export = function (options) {
        var fileName = options.name || 'DM_lineage_diagram_snapshot_' + (0, _dataUtils.date2String)(new Date());

        if (options.type === 'png') {
            (0, _toSvg.toDataURL)(_paper, {
                backgroundColor: 'white',
                svgOptions: {
                    elementsToRemoveSelector: '',
                    convertHtml: true
                }
            }).then(function (base64URL) {
                saveData(base64URL, fileName, 'png');
            }).catch(function (error) {
                if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
                console.error(error);
            });
        } else {
            (0, _toSvg.exportToSVG)(_paper, {
                elementsToRemoveSelector: '',
                convertHtml: true
            }).then(function (svgString) {
                saveData(svgString, fileName, 'svg');
            }).catch(function (error) {
                alert(error);
                console.error(error);
            });
        }

        function saveData(data, fileName, type) {
            var blob = void 0;
            if (type === 'svg') {
                blob = new Blob([data], { type: type });
            } else if (type === 'png') {
                blob = (0, _dataUtils.png2Blob)(data);
            }
            (0, _fileSaverjs2.default)(blob, fileName + '.' + type);
        }
    };

    /**
     * Shows print dialog.
    */
    self.print = function () {
        (0, _toSvg.toDataURL)(_paper, {
            backgroundColor: 'white',
            svgOptions: {
                elementsToRemoveSelector: '',
                convertHtml: true
            }
        }).then(function (base64URL) {
            var printWindow = window.open('', undefined, 'width=1280,height=720');
            if (printWindow) {
                printWindow.document.write('\n                    <html>\n                        <body>\n                            <img src="' + base64URL + '"/>\n                        </body>\n                    </html>\n                ');
                printWindow.document.querySelector('img').onload = function () {
                    printWindow.document.close();
                    printWindow.print();
                };
            } else {
                alert('You should unblock popup windows for the current url to be able to print this diagram!');
            }
        }).catch(function (error) {
            if (typeof error === 'string') alert(error);else alert('This type of export is not supported in the Internet Explorer');
            console.error(error);
        });
    };

    self.setSearchKey = function (searchKey) {
        _graph.getElements().forEach(function (node) {
            node.setSearchKey(searchKey);
        });
    };

    function _doLayout(diagramInfo) {
        // todo: refactor this algorithm
        var sourceId = diagramInfo ? diagramInfo.sourceId : undefined;
        var targetId = diagramInfo ? diagramInfo.targetId : undefined;
        var centerX = _paperScroller.options.baseWidth / 2;
        var centerY = _paperScroller.options.baseHeight / 2;

        var elements = (0, _layoutUtils.convertDMElementsToLayoutModels)(_nodes, _links);
        (0, _layout.removeCycles)(elements.nodes, elements.links);
        tqSankeyLayout(elements.nodes, elements.links, sourceId, targetId);

        var jointElements = (0, _layoutUtils.convertJointElementsToLayoutModels)(_graph.getElements(), _graph.getLinks());
        (0, _layout.removeCycles)(jointElements.nodes, jointElements.links);
        tqSankeyLayout(jointElements.nodes, jointElements.links, sourceId, targetId);

        var depthMap = (0, _utils.arrayToMap)(jointElements.nodes.map(function (je) {
            return { id: je.id, depth: je.y };
        }));

        var maxCol = -Infinity;
        elements.nodes.forEach(function (n) {
            maxCol = Math.max(n.x, maxCol);
        });

        var possibleXes = {};
        var order = {};
        elements.nodes.forEach(function (node) {
            possibleXes[node.x] = true;
        });
        var possibleColumnsList = Object.keys(possibleXes).map(function (px) {
            return Math.round(+px);
        });
        possibleColumnsList.sort(function (x1, x2) {
            if (x1 > x2) {
                return 1;
            } else if (x1 < x2) {
                return -1;
            } else {
                return 0;
            }
        }).forEach(function (x, index) {
            return order[x] = index;
        });

        var stepX = parameters.defaultElementWidth + parameters.defaultLayoutStep;
        var startPosition = centerX - stepX * (possibleColumnsList.length + 1) / 2;

        var columns = {};
        elements.nodes.forEach(function (node) {
            var originalNode = node.originalNode;
            var x = startPosition + stepX * order[Math.round(node.x)];
            if (!columns[x]) columns[x] = [];
            columns[x].push(originalNode);
        });

        var BOTTOM_MARGIN = 50;
        Object.keys(columns).forEach(function (key) {
            var column = columns[key];
            var totalHeight = 0;
            column.forEach(function (el, index) {
                var theLast = index === column.length - 1;
                var step = theLast ? 0 : BOTTOM_MARGIN;
                totalHeight += el.get('size').height + step;
            });
            column.sort(function (e1, e2) {
                var e1Depth = depthMap[e1.id] ? depthMap[e1.id].depth : 0;
                var e2Depth = depthMap[e2.id] ? depthMap[e2.id].depth : 0;

                if (e1Depth > e2Depth) {
                    return 1;
                } else if (e1Depth < e2Depth) {
                    return -1;
                } else {
                    return 0;
                }
            });
            var startY = centerY - totalHeight / 2;
            var x = +key;
            var curY = 0;
            column.forEach(function (el, index) {
                var isLast = index === column.length - 1;
                var step = isLast ? 0 : BOTTOM_MARGIN;
                el.position(x, startY + curY);
                curY += el.get('size').height + step;
            });
        });

        _paperScroller.center(centerX, centerY);

        // We hide dublications using highlighter.
        // That's why we need to be sure that nodes are
        // on the page, so we use requestAnimationFrame
        setTimeout(function () {
            _alignCrossNodes();
            _graph.getLinks().forEach(function (link) {
                _adjustAllVertices(link);
            });
            _hideDublications();
        }, 300);
    }

    // adjusting vertices
    // =============================================

    _graph.on('change:source change:target update-vertices', _adjustVertices);
    _paper.on('cell:pointerup', _adjustVertices);

    function _adjustAllVertices() {
        setTimeout(function () {
            _graph.getLinks().forEach(function (link) {
                (0, _lineageDiagramUtils.adjustVertices)(_graph, link);
            });
        }, 100);
    }

    function _adjustVertices(cell) {
        setTimeout(function () {
            (0, _lineageDiagramUtils.adjustVertices)(_graph, cell);
        }, 100);
    }

    // =============================================

    function _subscribeOnElements() {
        _nodes.forEach(function (node) {
            node.on('element-state-changed', function () {
                _adjustVertices(node.getPort().primitive);
            });
        });
    }

    function _refreshRelatedElement(cell) {
        if (cell instanceof _mapElements.GraphLink) {
            var elementsToUpdate = {};

            var link = cell;
            var prevSourceDescriptor = link.previous('source');
            var prevTargetDescriptor = link.previous('target');
            var prevSource = prevSourceDescriptor ? _graph.getCell(prevSourceDescriptor.id) : undefined;
            var prevTarget = prevTargetDescriptor ? _graph.getCell(prevTargetDescriptor.id) : undefined;

            var sourceDescriptor = link.get('source');
            var targetDescriptor = link.get('target');
            var source = _graph.getCell(sourceDescriptor.id);
            var target = _graph.getCell(targetDescriptor.id);

            if (prevSource && prevSource.activePorts) {
                elementsToUpdate[prevSource.id] = prevSource;
                var portId = prevSourceDescriptor.port;
                prevSource.activePorts[portId] = prevSource.activePorts[portId] || {};
                delete prevSource.activePorts[portId][link.id];
            }
            if (prevTarget && prevTarget.activePorts) {
                elementsToUpdate[prevTarget.id] = prevTarget;
                var _portId = prevTargetDescriptor.port;
                prevTarget.activePorts[_portId] = prevTarget.activePorts[_portId] || {};
                delete prevTarget.activePorts[_portId][link.id];
            }

            if (source.activePorts) {
                elementsToUpdate[source.id] = source;
                source.activePorts[sourceDescriptor.port] = source.activePorts[sourceDescriptor.port] || {};
                source.activePorts[sourceDescriptor.port][link.id] = link;
            }

            if (target.activePorts) {
                elementsToUpdate[target.id] = target;
                target.activePorts[targetDescriptor.port] = target.activePorts[targetDescriptor.port] || {};
                target.activePorts[targetDescriptor.port][link.id] = link;
            }

            Object.keys(elementsToUpdate).forEach(function (elId) {
                return elementsToUpdate[elId].refresh();
            });
            _hideDublications();
            _alignCrossNodes();
        }
    }

    function _alignCrossNodes() {
        var tempMap = {};
        var uniqueCrossLinks = [];
        _links.forEach(function (link) {
            var crossNode = link.getCrossNode();
            if (crossNode && !tempMap[crossNode.id]) {
                tempMap[crossNode.id] = true;
                uniqueCrossLinks.push(link);
            }
        });

        uniqueCrossLinks.forEach(function (l) {
            return l.alignCrossNode();
        });
    }

    function _hideDublications() {
        var uniqueMap = {};
        _links.forEach(function (link) {
            var typeId = /*link.typeId ||*/link.label;
            var sourcePortId = link.source.getPort().id;
            var targetPortId = link.target.getPort().id;
            var cacheKey = cacheFunction(typeId, sourcePortId, targetPortId);
            var isHighlighted = link.highlighting();
            if (isHighlighted || !uniqueMap[cacheKey]) {
                if (uniqueMap[cacheKey]) {
                    uniqueMap[cacheKey].hide();
                }
                uniqueMap[cacheKey] = link;
                link.show();
            } else {
                link.hide();
            }
        });

        function cacheFunction(label, sourcePortId, targetPortId) {
            return label + '~#tqDMLink#~' + sourcePortId + '~#tqDMLink#~' + targetPortId;
        }
    }
}
exports.default = MapLayout;


function tqSankeyLayout(nodes, links, sourceId, targetId, saveOrder) {
    var sankeyLayout = (0, _sankey2.default)().step([10, 10]).groups([{
        nodes: nodes,
        links: links
    }]).nodeWidth(1).nodeHeight(1).nodes(nodes).saveOrder(saveOrder).links(links);

    if (sourceId && targetId) {
        sankeyLayout.computeNodeBreadths = function (nodes) {
            nodes.forEach(function (node) {
                var nodeId = node.originalNode.model.resource;
                node.x = nodeId === sourceId ? 0 : nodeId === targetId ? 2 : 1;
                node.dx === 1;
            });
        };
    }
    sankeyLayout.layout(2000);
}

},{"../../layout/layout":56,"../../layout/sankey":57,"../../subscriptionAPI/subscribeable":65,"../../utils/dataUtils":66,"../../utils/layoutUtils":67,"../../utils/lineageDiagramUtils":68,"../../utils/utils":69,"../toSvg":53,"./mapElements":42,"./mapViews":44,"file-saverjs":2,"rappid":"rappid"}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSS_CLASS_NUMBER = exports.MAX_NODE_HEIGHT = undefined;
exports.GraphNodeView = GraphNodeView;
exports.GraphLinkView = GraphLinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _mapElements = require('./mapElements');

var _utils = require('../../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function GraphNodeView() {
    joint.dia.ElementView.apply(this, arguments);
}

var MAX_NODE_HEIGHT = exports.MAX_NODE_HEIGHT = 200;
var CSS_CLASS_NUMBER = exports.CSS_CLASS_NUMBER = 3;

GraphNodeView.prototype = Object.create(joint.dia.ElementView.prototype);
GraphNodeView.prototype._processedIds; // prevent cycles
GraphNodeView.prototype._scale = 1; // default scale

GraphNodeView.prototype.initialize = function () {
    var _this = this;

    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this._processedIds = {};
    this.parts = {};

    var box = document.createElement('DIV');
    box.className = 'derivation-node';
    box.id = this.model.id;
    box.onmousedown = function (event) {
        (0, _utils.onDragStart)(event, function (diff) {
            var curPos = _this.model.position();
            _this.model.position(curPos.x + diff.x / _this._scale, curPos.y + diff.y / _this._scale);
            event.stopPropagation();
        }, function (event) {
            if (_this.model.graph) _this.model.graph.trigger('update-vertices', event);
        });
        event.stopPropagation();
    };

    this.parts['box'] = box;

    var scroller = this._createScroller();
    box.appendChild(scroller);
    this.parts['scroller'] = scroller;

    var header = this._createHeader(this.model.model);
    box.appendChild(header);
    this.parts['header'] = header;

    var body = this._createBody(this.model.model);
    box.appendChild(body);
    this.parts['body'] = body;

    var collapseButton = this._createCollapseButton();
    header.appendChild(collapseButton);
    this.parts['collapseButton'] = collapseButton;

    this.model.on('change', this._updateBox, this);
    this.model.on('remove', this._removeBox, this);
    this.model.on('redraw-view', this.debouncedRender, this);
    this.model.on('elements-state-changed', this.debouncedRender, this);
    this.model.on('ports-state-changed', this._updatePorts, this);
    this.model.on('change:collapsed', this.debouncedRender, this);

    this._update();
};

GraphNodeView.prototype.debouncer;
GraphNodeView.prototype.debouncedRender = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        _this2.render();
    });
};

GraphNodeView.prototype.render = function () {
    this._processedIds = {};
    joint.dia.ElementView.prototype.render.apply(this, arguments);
    var box = this.parts['box'];
    if (this.paper) {
        this._update();
        this.paper.$el.prepend(box);
        this._updateScroller();
        return this;
    } else {
        return this;
    }
};

GraphNodeView.prototype._update = function (components) {
    var _this3 = this;

    this._updateBody();

    components = components || this.model.getAllChildren();
    components.forEach(function (model) {
        return _this3._updateModel(model);
    });

    this._updateCollapseButton();
    this._updateBox();
    this._updatePorts();
};

GraphNodeView.prototype._updateBox = function () {
    var box = this.parts['box'];

    var elementBBox = this.model.getBBox();
    var height = box.getBoundingClientRect().height / this._scale;

    //FF is returning 0 0 0 0 for getBoundningClientRect resulting in a 0 height
    //down stream this will cause scaling and alignment issues for the in/out ports
    if (height == 0) {
        height = 1;
    }

    box.style.width = elementBBox.width + 'px';
    this.model.resize(elementBBox.width, height);

    var x_error = elementBBox.width / 2;
    var y_error = height / 2;
    box.style.left = (elementBBox.x + x_error) * this.model.scale - x_error + 'px';
    box.style.top = (elementBBox.y + y_error) * this.model.scale - y_error + 'px';

    this._scale = this.model.scale;
    box.style.transform = 'scale(' + this._scale + ')';
};

GraphNodeView.prototype._updatePorts = function () {
    var box = this.parts['box'];
    var body = this.parts['body'];
    var freshPorts = {};
    var size = this.model.get('size');
    this.model.getAllChildren().forEach(function (element) {
        var inPortId = (0, _mapElements.getPortId)(element.id, 'in');
        var outPortId = (0, _mapElements.getPortId)(element.id, 'out');
        var htmlElement = box.querySelector('#' + element.id);

        var header = htmlElement ? htmlElement.querySelector('.dn-group_header') : undefined;
        var portHtmlElement = void 0;
        if (header) {
            portHtmlElement = header;
        } else {
            portHtmlElement = htmlElement;
        }
        if (portHtmlElement) {
            var offsetTop = getOffsetTop(portHtmlElement);
            var clientHeight = portHtmlElement.clientHeight;
            var scrollToTop = body.scrollTop;
            var minY = body.offsetTop;
            var maxY = body.clientHeight + minY;
            var middlePoint = -scrollToTop + offsetTop + clientHeight / 2;
            var refY = Math.max(Math.min(middlePoint, maxY), minY);

            freshPorts['.' + inPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': 0
            };
            freshPorts['.' + outPortId] = {
                ref: '.body',
                'ref-y': refY,
                'ref-x': size.width
            };
        }
    });

    this.model.attr(freshPorts);

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }
};

GraphNodeView.prototype._createScroller = function () {
    var _this4 = this;

    var scroller = document.createElement('DIV');
    scroller.className = 'derivation-node_body-scroller';
    scroller.onscroll = function () {
        _this4.parts['body'].scrollTop = _this4.model.sctollTop = scroller.scrollTop;
        _this4.model.updatePorts();
    };
    var bodySize = document.createElement('DIV');
    bodySize.className = 'derivation-node_body-scroller__size';
    scroller.appendChild(bodySize);

    return scroller;
};

GraphNodeView.prototype._updateScroller = function () {
    var scroller = this.parts['scroller'];
    var body = this.parts['body'];
    var collapseButton = this.parts['collapseButton'];

    var bbox = body.firstChild.getBoundingClientRect();
    var bodyHeight = bbox.height / this._scale;
    var bodyWidth = bbox.width / this._scale;
    if (scroller.firstChild) {
        // for IE11
        scroller.firstChild.style.height = bodyHeight + 'px';
        scroller.firstChild.style.width = bodyWidth + 'px';
    }
    var exceedSize = bodyHeight <= MAX_NODE_HEIGHT;
    var isScrollable = exceedSize || !this.model.get('collapsed');
    collapseButton.style.display = exceedSize ? 'none' : null;
    scroller.style.display = isScrollable ? 'none' : null;

    body.scrollTop = this.model.sctollTop;
    scroller.scrollTop = this.model.sctollTop;
};

GraphNodeView.prototype._removeBox = function () {
    this.parts['box'].parentNode.removeChild(this.parts['box']);
    this.parts = {};
};

GraphNodeView.prototype._createBody = function (model) {
    var body = document.createElement('DIV');
    body.className = 'derivation-node_body';
    var renderedModel = this._createModel(model, 0);
    body.appendChild(renderedModel);

    return body;
};

GraphNodeView.prototype._updateBody = function () {
    var body = this.parts['body'];

    if (this.model.get('collapsed')) {
        body.style.maxHeight = MAX_NODE_HEIGHT + 'px';
    } else {
        body.style.maxHeight = null;
    }
};

GraphNodeView.prototype._createCollapseButton = function () {
    var _this5 = this;

    var collapseButton = document.createElement('IMG');
    collapseButton.alt = "collapse button";
    collapseButton.className = 'derivation-node-collapse-button';
    collapseButton.onclick = function () {
        if (_this5.model.get('collapsed')) {
            _this5.model._expandElement();
        } else {
            _this5.model._collapseElement();
        }
    };

    return collapseButton;
};

GraphNodeView.prototype._updateCollapseButton = function () {
    var collapseButton = this.parts['collapseButton'];
    if (this.model.get('collapsed')) {
        collapseButton.classList.add('collapsed');
    } else {
        collapseButton.classList.remove('collapsed');
    }
};

GraphNodeView.prototype._createHeader = function (model) {
    var header = document.createElement('DIV');
    header.className = 'derivation-node_header';

    var label = document.createElement('LABEL');
    label.className = 'derivation-node_header__label';
    label.innerText = model.title || '';

    header.appendChild(label);

    return header;
};

GraphNodeView.prototype._createModel = function (model, deep) {
    if (!this._processedIds[model.id]) {
        this._processedIds[model.id] = true;

        var modelView = void 0;
        if (model.children.length > 0) {
            modelView = this._createGroup(model, deep);
        } else {
            modelView = this._createElement(model, deep);
        }
        this.parts[model.id] = modelView;
        return modelView;
    }
};

GraphNodeView.prototype._updateModel = function (model) {
    if (model.children.length > 0) {
        this._updateGroup(model);
    } else {
        this._updateElement(model);
    }
};

GraphNodeView.prototype._createGroup = function (rootModel, deep) {
    var _this6 = this;

    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';
    var groupElement = document.createElement('div');
    var cssClass = 'derivation-node_group_' + deep % (CSS_CLASS_NUMBER + 1);
    groupElement.id = rootModel.id;
    groupElement.className = cssClass + ' dn-group';
    groupElement.innerHTML = '\n        <div class="dn-group_header">\n            <span class="dn-arrow dn__incoming-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n            <img alt="Collapse Group" title="Collapse Group"/>\n            <div class="dn-group_header__label"  title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + icon + '\n                <label>' + rootModel.label + '</label>\n            </div>\n            <span class="dn-arrow dn__outgoing-arrow">\n                <div class="dn-arrow-triangle"></div>\n            </span>\n        </div>\n        <ul class="derivation-node_list-of-elements"></ul>\n    ';

    var activeHeaderArea = groupElement.querySelector('.dn-group_header__label');
    activeHeaderArea.onclick = function (event) {
        _this6.model.fireClickEvent(event, groupElement.id);
        event.stopPropagation();
    };

    var children = groupElement.querySelector('.derivation-node_list-of-elements');
    rootModel.children.forEach(function (element) {
        var renderedModel = _this6._createModel(element, deep + 1);
        if (renderedModel) {
            children.appendChild(renderedModel);
        }
    });

    var collapseButton = groupElement.querySelector('.dn-group img');
    collapseButton.onclick = function (event) {
        event.stopPropagation();
        _this6.model.onClickCollapseButton(rootModel.id);
    };

    return groupElement;
};

GraphNodeView.prototype._updateGroup = function (rootModel) {
    var groupElement = this.parts[rootModel.id];

    groupElement.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var noVisibleChildren = !rootModel.children || rootModel.children.filter(function (child) {
        return !child.invisible;
    }).length === 0;
    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    if (rootModel.collapsed && noVisibleChildren) {
        groupElement.classList.add('dn-collapsed');
    } else {
        groupElement.classList.remove('dn-collapsed');
    }

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        groupElement.classList.add('tq-dm-highlighted');
    } else {
        groupElement.classList.remove('tq-dm-highlighted');
    }

    var htmlInPorts = groupElement.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = groupElement.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var img = groupElement.querySelector('.dn-group_header img');
    img.className = rootModel.collapsed ? 'dn-collapsed' : '';
    img.alt = rootModel.collapsed ? 'Expand Group' : 'Collapse Group';
    img.title = img.alt;

    var label = groupElement.querySelector('.dn-group_header__label label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

GraphNodeView.prototype._createElement = function (rootModel, deep) {
    var _this7 = this;

    var element = document.createElement('div');
    var icon = rootModel.icon ? '<span class="dn-header-icon"><i class="' + rootModel.icon + '"></i></span>' : '';

    element.className = 'dn-element derivation-node_element_' + deep;
    element.id = rootModel.id;
    element.onclick = function (event) {
        _this7.model.fireClickEvent(event, element.id);
        event.stopPropagation();
    };
    element.innerHTML = '\n        <span class="dn-arrow dn__incoming-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n        <div class="dn-element_center">\n            ' + icon + '\n            <label title="' + (rootModel.endpointId + '(type: ' + rootModel.type + ')') + '">\n                ' + rootModel.label + '\n            </label>\n        </div>\n        <span class="dn-arrow dn__outgoing-arrow">\n            <div class="dn-arrow-triangle"></div>\n        </span>\n    ';

    return element;
};

GraphNodeView.prototype._updateElement = function (rootModel) {
    var element = this.parts[rootModel.id];

    element.style.display = rootModel.invisible ? 'none' : null;
    if (rootModel.invisible) return;

    var htmlInPorts = element.querySelector('.dn-arrow.dn__incoming-arrow');
    var htmlInTriangel = htmlInPorts.querySelector('.dn-arrow-triangle');
    var inPortId = (0, _mapElements.getPortId)(rootModel.id, 'in');
    var incomingLinksMap = this.model.activePorts[inPortId] || {};
    var activeInLinks = Object.keys(incomingLinksMap).map(function (key) {
        return incomingLinksMap[key];
    });
    var inPortVisible = activeInLinks.length > 0 && rootModel !== this.model.model;
    var needInArrow = activeInLinks && checkArrow(this.model, activeInLinks);
    htmlInPorts.style.display = inPortVisible ? null : 'none';
    htmlInTriangel.style.display = needInArrow ? null : 'none';

    var htmlOutPorts = element.querySelector('.dn-arrow.dn__outgoing-arrow');
    var htmlOutTriangel = htmlOutPorts.querySelector('.dn-arrow-triangle');
    var outPortId = (0, _mapElements.getPortId)(rootModel.id, 'out');
    var outgoingLinksMap = this.model.activePorts[outPortId] || {};
    var activeOutLinks = Object.keys(outgoingLinksMap).map(function (key) {
        return outgoingLinksMap[key];
    });
    var needOutArrow = activeOutLinks && checkArrow(this.model, activeOutLinks);
    var outPortVisible = activeOutLinks.length > 0 && rootModel !== this.model.model;
    htmlOutPorts.style.display = outPortVisible ? null : 'none';
    htmlOutTriangel.style.display = needOutArrow ? null : 'none';

    var isHighlighted = this.model.highlightedId === rootModel.id;
    if (isHighlighted) {
        element.classList.add('tq-dm-highlighted');
    } else {
        element.classList.remove('tq-dm-highlighted');
    }

    var label = element.querySelector('.dn-element_center label');
    label.innerHTML = getColoredLabel(rootModel.label, this.model.searchKey);
};

function getColoredLabel(label, key) {
    if (!key) return label;
    var lowerCaseLabel = label.toLowerCase();
    var keyIndex = lowerCaseLabel.indexOf(key);

    if (keyIndex === -1) {
        return label;
    } else if (keyIndex === 0) {
        var firstPart = label.substring(0, key.length);
        var secondPart = label.substring(key.length, label.length);
        return '<i class="tq-dm-highlighted-key">' + firstPart + '</i>' + secondPart;
    } else if (keyIndex + key.length === label.length) {
        var _firstPart = label.substring(0, keyIndex);
        var _secondPart = label.substring(keyIndex, label.length);
        return _firstPart + '<i class="tq-dm-highlighted-key">' + _secondPart + '</i>';
    } else {
        var _firstPart2 = label.substring(0, keyIndex);
        var _secondPart2 = label.substring(keyIndex, keyIndex + key.length);
        var thirdPart = label.substring(keyIndex + key.length, label.length);
        return _firstPart2 + '<i class="tq-dm-highlighted-key">' + _secondPart2 + '</i>' + thirdPart;
    }
}

/**
 * @private
 * The GraphLinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function GraphLinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
GraphLinkView.prototype = Object.create(joint.dia.LinkView.prototype);
GraphLinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, 'change:highlighted change:blured update-state', onEvent);
    this.listenTo(this.model, 'updateMarkers', this.updateMarkers);
};

GraphLinkView.prototype.updateMarkers = function () {
    this._markerCache = {};
    this.render();
};

GraphLinkView.prototype.render = function () {
    joint.dia.LinkView.prototype.render.apply(this, arguments);
};

var LG_DM_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-highlighted'
        }
    }
};
var LG_DM_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-blured'
        }
    }
};

var LG_DM_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-dm-hidden'
        }
    }
};

function onEvent() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_DM_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_DM_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_DM_CELL_BLURER);
    }
    if (this.model.hidden) {
        this.highlight(null, LG_DM_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_DM_CELL_HIDDEN);
    }
}

function checkArrow(self, links) {
    for (var i = 0; i < links.length; i++) {
        var link = links[i];

        if (link.get('target').id === self.id) {
            return true;
        }
    }
    return false;
}

},{"../../utils/utils":69,"./mapElements":42,"rappid":"rappid"}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AspectLink = AspectLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * AspectLinkModel - data model of an AspectLink object
 * @typedef {Object} AspectLinkModel
 * @property {Node | TerminationNode} target - Target Node
 * @property {Node | TerminationNode} source - Source Node
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * @param {AspectLinkModel} options
 * @param {Parameters} parameters - The set of parameters
 * @property {SimpleLinkModel} model - Data model 
*/
function AspectLink(options, parameters) {
    var self = this;

    var _res = new _resourceProvider.ResourceProvider(parameters);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('aspectLink');

    joint.dia.Link.apply(self, [{
        id: options.id,
        type: 'aspect-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.ASPECT_LINK,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-dasharray': '10, 10',
                'stroke-width': '5px'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            }
        },
        // variants for the experimenting
        connector: { name: 'rounded' }
    }]);

    /**
     * Blurs the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.blure = function () {
        self.set('blured', true);
    };

    /**
     * Removes blur from the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.unblure = function () {
        self.set('blured', false);
    };

    /**
     * Hides the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.hide = function () {
        self.set('hidden', true);
    };

    /**
     * Shows the AspectLink.
     * @memberof AspectLink
     * @method
    */
    self.show = function () {
        self.set('hidden', false);
    };

    self.model = { source: options.source.id, target: options.target.id };
}
AspectLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":29,"./elements":46,"rappid":"rappid"}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Z_INDEXES = exports.AspectLink = exports.TerminationLink = exports.TerminationNode = exports.Link = exports.Node = undefined;
exports.NodeView = NodeView;
exports.LinkView = LinkView;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _node = require('./node');

var _link = require('./link');

var _terminationLink = require('./terminationLink');

var _terminationNode = require('./terminationNode');

var _aspectLink = require('./aspectLink');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Node = _node.Node;
exports.Link = _link.Link;
exports.TerminationNode = _terminationNode.TerminationNode;
exports.TerminationLink = _terminationLink.TerminationLink;
exports.AspectLink = _aspectLink.AspectLink;


var V = joint.V;
var g = joint.g;

var Z_INDEXES = exports.Z_INDEXES = {
    ASPECT_LINK: 25,
    TERMINATION_ELEMENT: 25,
    SELECTED_ELEMENT: 30,
    NODE: 20,
    LINK: 15,
    BLURED_NODE: 10,
    BLURED_LINK: 5,
    VIEW_FRAME: 1
};

var LG_CELL_HIGHLIGHTER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-highlighted'
        }
    }
};
var LG_CELL_HIDDEN = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-hidden-element'
        }
    }
};
var LG_CELL_BLURER = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-blured'
        }
    }
};
var LG_SHORT_LABEL = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-short-label'
        }
    }
};
var LG_DRAGGED_NODE = {
    highlighter: {
        name: 'addClass',
        options: {
            className: 'tq-lg-dragged-node'
        }
    }
};

function getClass() {
    if (this.model.get('highlighted')) {
        this.highlight(null, LG_CELL_HIGHLIGHTER);
    } else {
        this.unhighlight(null, LG_CELL_HIGHLIGHTER);
    }
    if (this.model.get('blured')) {
        this.highlight(null, LG_CELL_BLURER);
    } else {
        this.unhighlight(null, LG_CELL_BLURER);
    }
    if (this.model.get('hidden')) {
        this.highlight(null, LG_CELL_HIDDEN);
    } else {
        this.unhighlight(null, LG_CELL_HIDDEN);
    }
    if (this.model.get('short-label')) {
        this.highlight(null, LG_SHORT_LABEL);
    } else {
        this.unhighlight(null, LG_SHORT_LABEL);
    }
    if (this.model.get('dragged')) {
        this.highlight(null, LG_DRAGGED_NODE);
    } else {
        this.unhighlight(null, LG_DRAGGED_NODE);
    }
}

/**
 * @private
 * The LinkView class. Mainly in charge of node highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {ver} parameters - The set of parameters
*/
function NodeView() {
    joint.dia.ElementView.apply(this, arguments);
}
NodeView.prototype = Object.create(joint.dia.ElementView.prototype);
NodeView.prototype.initialize = function () {
    joint.dia.ElementView.prototype.initialize.apply(this, arguments);
    this.listenTo(this.model, ['change:dragged', 'change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting', 'change:short-label'].join(' '), this.debouncedHighlighting);
};
NodeView.prototype.debouncer;
NodeView.prototype.debouncedHighlighting = function () {
    var _this = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this);
    });
};

/**
 * @private
 * The LinkView class. Mainly in charge of link highlighting.
 * Listen to events and apply highlighters.
 * @class
 * @augments joint.dia.LinkView
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
*/
function LinkView() {
    joint.dia.LinkView.apply(this, arguments);
}
LinkView.prototype.render = function () {
    joint.dia.LinkView.prototype.render.apply(this, arguments);
};
LinkView.prototype = Object.create(joint.dia.LinkView.prototype);
LinkView.prototype.initialize = function () {
    joint.dia.LinkView.prototype.initialize.apply(this, arguments);

    this.listenTo(this.model, ['change:highlighted', 'change:blured', 'change:hidden', 'refresh-highlighting'].join(' '), this.debouncedHighlighting);
};
LinkView.prototype.getPointAtLength = function (k) {
    return this._V.connection.node.getPointAtLength(this._V.connection.node.getTotalLength() * k);
};
LinkView.prototype.debouncer;
LinkView.prototype.debouncedHighlighting = function () {
    var _this2 = this;

    cancelAnimationFrame(this.debouncer);
    this.debouncer = requestAnimationFrame(function () {
        getClass.call(_this2);
    });
};
LinkView.prototype.updateToolsPosition = function () {
    var _this3 = this;

    if (!this._V.linkTools) return this;

    // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.
    // Note that the offset is hardcoded here. The offset should be always
    // more than the `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
    // this up all the time would be slow.

    var scale = '';
    var connectionLength = this.getConnectionLength();

    // Firefox returns connectionLength=NaN in odd cases (for bezier curves).
    // In that case we won't update tools position at all.
    if (!_.isNaN(connectionLength)) {

        // If the link is too short, make the tools half the size and the offset twice as low.
        if (connectionLength < this.options.shortLinkLength) {
            scale = 'scale(.5)';
        }

        this._toolCache.forEach(function (tool, index, arr) {
            var i = index + 1;
            var l = arr.length + 1;
            var k = i / l;
            var toolPosition = _this3.getPointAtLength(k);
            if (tool.node instanceof SVGGElement) {
                tool.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);

                if (_this3.options.doubleLinkTools && connectionLength >= _this3.options.longLinkLength) {
                    var newPosition = _this3.getPointAtLength(k /*connectionLength - doubleLinkToolsOffset*/);
                    _this3._tool2Cache.attr('transform', 'translate(' + newPosition.x + ', ' + newPosition.y + ') ' + scale);
                    _this3._tool2Cache.attr('visibility', 'visible');
                } else if (_this3.options.doubleLinkTools) {
                    _this3._tool2Cache.attr('visibility', 'hidden');
                }
            }
        });
    }

    return this;
};

LinkView.prototype.renderTools = function () {

    if (!this._V.linkTools) return this;

    // Tools are a group of clickable elements that manipulate the whole link.
    // A good example of this is the remove tool that removes the whole link.
    // Tools appear after hovering the link close to the `source` element/point of the link
    // but are offset a bit so that they don't cover the `marker-arrowhead`.

    var htmlTools = this._V.linkTools.node;
    var toolTemplate = joint.util.template(this.model.get('toolMarkup') || this.model.toolMarkup);
    var vTools = V(toolTemplate());

    var tools;
    if (vTools instanceof Array) {
        tools = vTools;
    } else {
        tools = [vTools];
    }

    tools.forEach(function (tool) {
        htmlTools.appendChild(tool.node);
    });

    // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.
    this._toolCache = tools;

    return this;
};

var overridedFunction = LinkView.prototype.getConnectionPoint;
LinkView.prototype.getConnectionPoint = function (end, selectorOrPoint, referenceSelectorOrPoint) {
    var connectionPoint = overridedFunction.apply(this, arguments);

    var limitBox = void 0;
    _.isEmpty(selectorOrPoint) && (selectorOrPoint = { x: 0, y: 0 });
    _.isEmpty(referenceSelectorOrPoint) && (referenceSelectorOrPoint = { x: 0, y: 0 });

    if (!selectorOrPoint.id) {
        var point = g.point(selectorOrPoint);
        limitBox = {
            x: point.x,
            y: point.y,
            width: 0,
            height: 0,
            center: function center() {
                return point;
            }
        };
    } else {
        limitBox = end === 'source' ? this.sourceBBox : this.targetBBox;
    }
    var limitCeter = limitBox.center();

    var rightBorder = Math.round(limitCeter.x + limitBox.width / 2);
    var leftBorder = Math.round(limitCeter.x - limitBox.width / 2);
    var bottomBorder = Math.round(limitCeter.y + limitBox.height / 2);
    var topBorder = Math.round(limitCeter.y - limitBox.height / 2);

    var xInside = leftBorder < connectionPoint.x && connectionPoint.x < rightBorder;
    var yInside = topBorder < connectionPoint.y && connectionPoint.y < bottomBorder;
    var isInTheBody = xInside && yInside;

    if (isInTheBody) {
        var rightDist = rightBorder - connectionPoint.x;
        var leftDist = connectionPoint.x - leftBorder;
        var bottomDist = bottomBorder - connectionPoint.y;
        var topDist = connectionPoint.y - topBorder;

        var minDist = Math.min(rightDist, leftDist, bottomDist, topDist);

        if (rightDist === minDist) {
            connectionPoint.offset(rightDist, 0);
        } else if (leftDist === minDist) {
            connectionPoint.offset(-leftDist, 0);
        } else if (topDist === minDist) {
            connectionPoint.offset(0, -topDist);
        } else if (bottomDist === minDist) {
            connectionPoint.offset(0, bottomDist);
        }
    }

    var reference = void 0;
    var spotBbox = end === 'source' ? this.sourceBBox : this.targetBBox;
    if (!referenceSelectorOrPoint.id) {
        reference = g.point(referenceSelectorOrPoint);
    } else {
        var referenceBbox = end === 'source' ? this.targetBBox : this.sourceBBox;

        reference = g.rect(referenceBbox).intersectionWithLineFromCenterToPoint(g.rect(spotBbox).center());
        reference = reference || g.rect(referenceBbox).center();
    }

    var alignX = Math.abs(reference.x - connectionPoint.x);
    var alignY = Math.abs(reference.y - connectionPoint.y);

    var routerId = this.model.get('router') && this.model.get('router').name;
    var specialRouter = routerId && (routerId === 'lgrouter' || routerId === 'metro');
    if (this.model instanceof _link.Link && specialRouter) {
        if (alignX <= alignY) {
            connectionPoint.offset(reference.x - connectionPoint.x, 0);
        } else {
            connectionPoint.offset(0, reference.y - connectionPoint.y);
        }
    }

    connectionPoint = g.point({
        x: Math.max(Math.min(Math.round(connectionPoint.x), rightBorder), leftBorder),
        y: Math.max(Math.min(Math.round(connectionPoint.y), bottomBorder), topBorder)
    });

    return connectionPoint;
};

},{"./aspectLink":45,"./link":47,"./node":48,"./terminationLink":49,"./terminationNode":50,"lodash":"lodash","rappid":"rappid"}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ALWAYS_VISIBLE_TOOL_BUTTONS = exports.DEFAULT_LINK_TYPE = undefined;
exports.Link = Link;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DEFAULT_LINK_TYPE = exports.DEFAULT_LINK_TYPE = 'lineage-gram-link';
var ALWAYS_VISIBLE_TOOL_BUTTONS = exports.ALWAYS_VISIBLE_TOOL_BUTTONS = 'lg-visible-tool-buttons';

/**
 * LinkModel - data model for a {@link Link} object
 * @typedef {Object} LinkModel
 * @property {string} id - Link identifyer
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
 * @property {string} linktype - Type of the Link
*/

/**
 * The graph Link class which is  based on joint.dia.Link. Is the one of the main elements of the LineageFram.
 * Represents existing relation of the parts of the dataset.  Has specific type and id.
 * @class
 * @private
 * @augments joint.dia.Link
 * 
 * @param {LinkModel} dataModel - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {LinkModel} model - Data model
 * @property {TerminationLink} terminationLink - Termination link which
 * represents this link, when the node is out of the viewFrame
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
*/
function Link(dataModel, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.terminationLinks = [];
    self.highlighted = false;
    self.blured = false;

    var _linkStyle = void 0;
    var _toolMarkup = void 0;
    if (dataModel.group) {
        var existedTypeIds = [];
        var groupTools = dataModel.group.filter(function (model) {
            var decision = existedTypeIds.indexOf(model.linkType) === -1;
            if (decision) {
                existedTypeIds.push(model.linkType);
            }
            return decision;
        }).map(function (model) {
            return {
                linkType: model.linkType,
                linkStyle: _res.getLinkStyle(model.linkType)
            };
        });

        if (groupTools.length === 1) _linkStyle = groupTools[0].linkStyle;else _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup(groupTools);
    } else {
        _linkStyle = _res.getLinkStyle(dataModel.linkType);
        _toolMarkup = _getToolMarkup([{
            linkType: dataModel.linkType,
            linkStyle: _linkStyle
        }]);
    }

    var types = [DEFAULT_LINK_TYPE];
    if (_linkStyle.cssClass && _linkStyle.cssClass !== DEFAULT_LINK_TYPE) {
        types.push(_linkStyle.cssClass);
    }

    if (_linkStyle.toolButton.alwaysVisible) {
        types.push(ALWAYS_VISIBLE_TOOL_BUTTONS);
    }

    joint.dia.Link.apply(self, [{
        type: types.join(' '),
        source: { id: dataModel.source, port: 'clipRectPort' },
        target: { id: dataModel.target, port: 'clipRectPort' },
        z: _elements.Z_INDEXES.LINK,
        attrs: _getLinkAttributes(_linkStyle),
        connector: { name: 'rounded' },
        // connector: { name: 'jumpover', args: { type: 'gap' }},
        router: {
            name: dataModel.routing,
            args: {
                excludeTypes: ['viewFrame', 'terminationLink', 'terminationNode', 'view-frame-splitter', 'view-frame-splitter-vertical', 'aspectLink'],
                maximumLoops: 3000,
                maxAllowedDirectionChange: 3000
            }
        },
        toolMarkup: _toolMarkup
    }]);

    function _getLinkAttributes(linkStyle) {
        var attributes = {};
        attributes['.connection'] = {
            stroke: linkStyle.color,
            'stroke-width': linkStyle.thickness,
            'stroke-dasharray': linkStyle.lineType === 'solid' ? undefined : '5,5'
        };
        if (linkStyle.hasArrow) {
            attributes['.marker-source'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0',
                'stroke-width': linkStyle.thickness
            };
            attributes['.marker-target'] = {
                fill: linkStyle.color,
                stroke: linkStyle.color,
                d: 'M 10 0 L 0 5 L 10 10 z',
                'stroke-width': linkStyle.thickness
            };
        }
        return attributes;
    }

    function _getToolMarkup(linkTools) {
        return linkTools.map(function (linkTool) {
            var linkTypeId = linkTool.linkType;
            var tool = linkTool.linkStyle.toolButton;
            var width = tool.width || 30;
            var hieght = tool.hieght || 30;
            return '<g class="link-tool">\n                <g class="tool-options" event="link:options" linkType="' + linkTypeId + '">\n                    <image\n                        width="' + width + '"\n                        height="' + hieght + '"\n                        x="-' + width / 2 + '"\n                        y="-' + hieght / 2 + '"\n                        xlink:href="' + tool.image + '"\n                        onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage('default-link-options') + '\' );"\n                    />\n                    <title>Open derivation map' + (linkTypeId ? ' for ' + linkTypeId : '') + '</title>\n                </g>\n            </g>';
        }).join();
    }

    /**
     * Tells us whether the link is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    /**
     * Highlights the Link.
     * @memberof Link
     * @method
    */
    self.select = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Link.
     * @memberof Link
     * @method
    */
    self.unselect = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Link.
     * @memberof Link
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationLinks.forEach(function (tl) {
            return tl.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Link.
     * @memberof Link
     * @method
    */
    self.unblure = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.LINK });
        self.set('blured', false);
    };

    /**
     * Hides the Link.
     * @memberof Link
     * @method
    */
    self.hide = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Link.
     * @memberof Link
     * @method
    */
    self.show = function () {
        self.terminationLinks.forEach(function (tl) {
            return tl.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    self.model = dataModel;
}
Link.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":29,"./elements":46,"rappid":"rappid"}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXPANDED_NODE_GROWING = exports.FONT_SIZE = exports.IMG_PADDING = exports.BODY_PADDING = exports.LABEL_LINE_HEIGHT = exports.LABEL_TOP_BOTTOM_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = undefined;
exports.Node = Node;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var LABEL_LEFT_RIGHT_PADDING = exports.LABEL_LEFT_RIGHT_PADDING = 5;
var LABEL_TOP_BOTTOM_PADDING = exports.LABEL_TOP_BOTTOM_PADDING = 10;
var LABEL_LINE_HEIGHT = exports.LABEL_LINE_HEIGHT = 20;
var BODY_PADDING = exports.BODY_PADDING = 25;
var IMG_PADDING = exports.IMG_PADDING = 10;
var FONT_SIZE = exports.FONT_SIZE = 16;
var EXPANDED_NODE_GROWING = exports.EXPANDED_NODE_GROWING = 1.5;

/**
 * NodeModel - data model for a {@link Node} object
 * @typedef {Object} NodeModel
 * @property {string} id - Node identifyer
 * @property {string} label - Title of the Node,
 * @property {string} viewFrame - Id of ViewFrame wich will include this node
 * @property {string} typeId - Type identifyer
*/

/**
 * The graph Node class which is based on joint.shapes.basic.Generic. Is the one of the main elements of the LineageFram.
 * Represents existing part of the dataset with specified image, color, type and id and placed in separated ViewFrame.
 * @class
 * @private
 * @augments joint.shapes.basic.Generic
 * @param {NodeModel} dataModel - Model of graph node
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node[]} aspects - Copies of this node in other frames
 * @property {NodeModel} model - Data model
 * @property {TerminationNode[]} terminationNodes - Termination nodes which exists on in the frame
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {ViewFrame} viewFrameOwnerId - Exists only if element was dragged from one to another frame
 * @property {boolean} dragged - If somebody is dragging this Node now, then true.
*/
function Node(dataModel, parameters) {
    var self = this;
    var _size = parameters.elementSize;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    var _isVerticalOriented = parameters.graphOrientation === 'top-to-bottom' || parameters.graphOrientation === 'bottom-to-top';

    self.model = dataModel;
    self.terminationNodes = [];
    self.aspects = [];
    self.viewFrameOwnerId = null;
    self.dragged = false;
    self.blured = false;
    self.highlighted = false;
    self.size = { width: _size.width, height: _size.height, maxWidth: _size.width, maxHeight: _size.height };
    self.collapsedSize = self.size;

    var image = _res.getImage(dataModel.typeId);

    var ID = (0, _lodash.uniqueId)('Node');
    joint.shapes.basic.Generic.apply(self, [{
        type: 'lineage-gram-node',
        id: ID,
        position: { x: 0, y: 0 },
        markup: '<g class="rotatable" clip-path="url(' + ('#' + ID + '_clipPath') + ')">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"></rect>\n                    <image class="scalable" onerror="this.setAttribute( \'xlink:href\', \'' + _res.getImage() + '\' );"/>\n                    <text class="label"/>\n                </g>\n                <rect class="clipRect"></rect>\n                <defs>\n                    <clipPath id="' + (ID + '_clipPath') + '">\n                        <rect class="clipRect"></rect>\n                    </clipPath>\n                </defs>',
        size: self.size,
        attrs: {
            'circle': {
                fill: 'transparent',
                stroke: 'transparent',
                r: 1
            },
            '.clipRect': {
                port: 'clipRectPort',
                width: self.size.width,
                height: self.size.height,
                fill: 'transparent',
                opacity: 0,
                'stroke-width': 0,
                rx: 5,
                ry: 5
            },
            '.body': {
                'stroke-width': 0,
                fill: 'transparent',
                rx: 5,
                ry: 5
            },
            '.label': {
                fill: _res.getColor('text'),
                'font-size': FONT_SIZE,
                'alignment-baseline': 'hanging',
                ref: '.body',
                tooltip: self.model.label,
                y: 0
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'x-alignment': 'middle',
                'y-alignment': 'top',
                ref: '.body',
                rx: 5,
                ry: 5,
                stroke: _res.getColor(dataModel.typeId)
            },
            image: {
                'xlink:href': image,
                'ref-x': .5,
                ref: '.body',
                'x-alignment': 'middle',
                'y-alignment': 'top'
            },
            '.label tspan': {
                dy: LABEL_LINE_HEIGHT
            }
        },
        z: _elements.Z_INDEXES.NODE
    }]);

    // =====================================

    //trigger expanded before attaching the events
    self.set('expanded', true);

    var _blockSubscription = false;
    var oldPosition = self.position;

    self.position = function (x, y) {
        _blockSubscription = true;
        var result = oldPosition.call(self, x, y);
        _blockSubscription = false;
        return result;
    };

    self.on('change:position', function () {
        if (_blockSubscription) return;
        self.setClipping(undefined);
    });

    self.on('change:size', function (cell, size) {
        self.attr({
            '.clipRect': {
                width: size.width,
                height: size.height
            }
        });
    });

    self.on('change:expanded', function () {
        _refreshSize(self.collapsedSize);
    });

    // =====================================

    _refreshSize(self.size);

    self.setSize = function (size) {
        if (self.collapsedSize.width !== size.width || self.collapsedSize.height !== size.height || self.size.maxWidth !== size.maxWidth || self.size.maxHeight !== size.maxHeight) {
            _refreshSize(size);
        }
    };

    self.setOrientation = function (orientation) {
        _isVerticalOriented = orientation === 'top-to-bottom' || orientation === 'bottom-to-top';
    };

    /**
     * Tells us whether the node is currently
     * on the graph (in the any of view frames) or not
     * @returns {boolena}
     */
    self.isOnTheGraph = function () {
        return self.graph ? true : false;
    };

    self.calculateSize = function (size) {
        var calculations = _calculateNode(size);
        return {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };
    };

    /**
     * Highlights the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.select = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.select(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.select(true);
        });
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the Node.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof Node
     * @method
    */
    self.unselect = function (once) {
        self.terminationNodes.forEach(function (tn) {
            return tn.unselect(true);
        });
        if (!once) self.aspects.forEach(function (a) {
            return a.unselect(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('highlighted', false);
    };

    /**
     * Blurs the Node.
     * @memberof Node
     * @method
    */
    self.blure = function () {
        if (self.get('highlighted')) return;
        self.terminationNodes.forEach(function (tn) {
            return tn.blure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the Node.
     * @memberof Node
     * @method
    */
    self.unblure = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.unblure(true);
        });
        self.prop({ z: _elements.Z_INDEXES.NODE });
        self.set('blured', false);
    };

    /**
     * Hides the Node.
     * @memberof Node
     * @method
    */
    self.hide = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.hide(true);
        });
        self.set('hidden', true);
    };

    /**
     * Shows the Node.
     * @memberof Node
     * @method
    */
    self.show = function () {
        self.terminationNodes.forEach(function (tn) {
            return tn.show(true);
        });
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Sets offset and size of clipping rectangle.
     * @param {Point} point - Offset of the clipping rectangle
     * @memberof Node
     * @method
    */
    self.setClipping = function (point) {
        point = point || { x: 0, y: 0 };

        var x = point.x > 0 ? point.x : 0;
        var y = point.y > 0 ? point.y : 0;
        var width = self.size.width - Math.abs(point.x);
        var height = self.size.height - Math.abs(point.y);

        self.attr({
            '.clipRect': {
                x: x,
                y: y,
                width: width > 0 ? width : 0,
                height: height > 0 ? height : 0
            }
        });
    };

    function _refreshSize(size) {
        // self.collapsedSize = size;

        var calculations = _calculateNode(size);
        self.size = {
            width: calculations.width,
            height: calculations.height,
            maxWidth: calculations.maxWidth,
            maxHeight: calculations.maxHeight
        };

        var scale = calculations.scale;
        var bodyPadding = BODY_PADDING * scale;
        var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        self.attr({
            '.tq-lg-body': {
                width: calculations.rectWidth,
                height: calculations.rectHeight,
                'ref-y': bodyPadding
            },
            image: {
                width: Math.max(0, calculations.rectWidth - IMG_PADDING * 2),
                height: Math.max(0, calculations.rectHeight - IMG_PADDING * 2),
                'ref-y': bodyPadding + IMG_PADDING
            },
            '.label': {
                text: calculations.label,
                'ref-y': bodyPadding + topBottomPadding + calculations.rectHeight + FONT_SIZE * scale - labelLineHeight
            },
            '.label tspan': {
                'font-size': FONT_SIZE * scale,
                dy: labelLineHeight
            }
        });

        self.resize(self.size.width, self.size.height);
        self.set('short-label', calculations.shortLabel);
    }

    var _catchedResult = null;
    function _calculateNode(size) {
        if (_catchedResult && _catchedResult.inSize.width === size.width && _catchedResult.inSize.height === size.height && _catchedResult.inSize.maxWidth === size.maxWidth && _catchedResult.inSize.maxHeight === size.maxHeight && _catchedResult.expanded === self.get('expanded')) {
            return _catchedResult.outSize;
        }

        var width = void 0;
        var height = void 0;
        if (!self.get('expanded')) {
            width = size.width;
            height = size.height;
        } else {
            width = Math.min(size.maxWidth, size.width * EXPANDED_NODE_GROWING);
            height = Math.min(size.maxHeight, size.height * EXPANDED_NODE_GROWING);
        }

        var xScale = size.width / parameters.elementSize.width;
        var yScale = size.height / parameters.elementSize.height;
        var scale = Math.min(xScale, yScale);
        var bodyPadding = BODY_PADDING * scale;
        var labelLineHeight = LABEL_LINE_HEIGHT * scale;

        var calculations = {
            width: width,
            height: height,
            maxWidth: size.maxWidth,
            maxHeight: size.maxHeight,
            rectWidth: width - bodyPadding * 2,
            rectHeight: height - bodyPadding * 2,
            scale: scale,
            shortLabel: false
        };

        if (self.model.label) {
            calculations.height -= bodyPadding;

            var fontSize = FONT_SIZE * scale;
            var leftRightPadding = LABEL_LEFT_RIGHT_PADDING * scale * 2;
            var topBottomPadding = LABEL_TOP_BOTTOM_PADDING * scale * 2;

            var label = _breakTextByLines(self.model.label, width - leftRightPadding, fontSize);

            var labelHeight = 0;
            var substrings = label.split('\n');

            if (substrings.length > 1) {
                var maxRowCount = (_isVerticalOriented ? 2 : 3) + (self.get('expanded') ? 1 : 0);

                if (substrings.length > maxRowCount) calculations.shortLabel = true;

                substrings = substrings.slice(0, maxRowCount);

                if (_isVerticalOriented) {
                    var finalLabel = substrings.join(' ') + (calculations.shortLabel ? '...' : '');
                    var labelWidth = _getTextWidth(finalLabel, fontSize + 'px sans-serif');
                    calculations.width = labelWidth + leftRightPadding * substrings.length;
                    calculations.label = finalLabel;
                    labelHeight = fontSize + topBottomPadding;
                } else {
                    // We use dy property for each line that's why font-size goes only one time into acount.
                    // Because dx is distance between top lines of each text line. And for a full text height we add font size of lust line.
                    labelHeight = fontSize + topBottomPadding + (substrings.length - 1) * labelLineHeight;
                    calculations.label = substrings.join('\n') + (calculations.shortLabel ? '...' : '');
                }
            } else {
                labelHeight = fontSize + topBottomPadding;
                calculations.label = self.model.label;
            }

            calculations.height += labelHeight;
            calculations.labelHeight = labelHeight;
            calculations.expanded = self.get('expanded');
        }
        _catchedResult = {
            inSize: size,
            outSize: calculations,
            expanded: calculations.expanded
        };

        return calculations;
    }

    function _breakTextByLines(label, width, fontSize) {
        var brokenText = joint.util.breakText(label, {
            width: width
        }, { 'font-size': fontSize });

        var lines = brokenText.split('\n');

        if (lines.length > 1) {
            var lastChild = lines[lines.length - 1];
            var MIN_CHARACTER_NUMBER = 4;

            if (lastChild.length < MIN_CHARACTER_NUMBER) {
                var diff = MIN_CHARACTER_NUMBER - lastChild.length;
                var threshold = lines.length - (diff + 1);
                // max error is 3 extra letters, so I hope it's OK.
                var numberOfStealedNodes = Math.round(diff / Math.min(diff, lines.length - 1));

                var prevRest = '';
                var offset = 0;
                var newLines = lines.map(function (line, index, arr) {
                    if (index >= threshold) {
                        var isLastLine = index === arr.length - 1;
                        var fullLine = prevRest + line;
                        offset += numberOfStealedNodes;
                        if (isLastLine) {
                            return fullLine;
                        } else {
                            prevRest = fullLine.substring(fullLine.length - offset, fullLine.length);
                            return fullLine.substring(0, fullLine.length - offset);
                        }
                    } else {
                        return line;
                    }
                });

                return newLines.join('\n');
            } else {
                return brokenText;
            }
        } else {
            return label;
        }
    }

    /**
     * @private
     * Update size of element. Takes collapsed size,
     * and if element are expanded trying to set a twise size.
     * @param {Size} size 
    */

    /**
     * @private
     * @param {string} text 
     * @param {string} font 
    */
    function _getTextWidth(text, font) {
        var canvas = _getTextWidth.canvas || (_getTextWidth.canvas = document.createElement('CANVAS'));
        var context = canvas.getContext('2d');
        context.font = font;
        var metrics = context.measureText(text);
        return metrics.width;
    }
}

Node.prototype = Object.create(joint.shapes.devs.Model.prototype);

},{"../../data/resourceProvider":29,"./elements":46,"lodash":"lodash","rappid":"rappid"}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationLink = TerminationLink;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationLinkOptions - options for TerminationLink object
 * @typedef {Object} TerminationLinkOptions
 * @property {Link} link - Original link
 * @property {Node} target - Target Node
 * @property {Node} source - Source Node
*/

/**
 * @private
 * SimpleLinkModel - data model of a TerminationLink object
 * @typedef {Object} SimpleLinkModel - Data model
 * @property {string} target - Target Node id
 * @property {string} source - Source Node id
*/

/**
 * @private
 * The graph Link based on joint.dia.Link.
 * @class
 * @augments joint.dia.Link
 * 
 * @param {TerminationLinkOptions} options - options for TerminationLink object
 * @param {Parameters} parameters - the set of parameters
 * 
 * @property {Link} originalLink - Original Link - the link to a node which is out of the ViewFrmae
 * @property {boolean} highlighted - Tells wheter highlighted link or not (use method get to get this property, e.g. link.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured link or not (use method get to get this property, e.g. link.get('blured'))
 * @property {SimpleLinkModel} model - Data model 
*/
function TerminationLink(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalLink = options.link;
    self.highlighted = false;
    self.blured = false;
    self.originalLink.terminationLinks.push(self);

    var source = { id: options.source.id, port: 'clipRectPort' };
    var target = { id: options.target.id, port: 'clipRectPort' };

    var linkColor = _res.getColor('terminationLink');

    joint.dia.Link.apply(self, [{
        type: 'termination-link',
        source: source,
        target: target,
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT,
        attrs: {
            '.connection': {
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                'stroke-dasharray': '5,5'
            },
            '.marker-source': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M0,3a3,3 0 1,0 6,0a3,3 0 1,0 -6,0'
            },
            '.marker-target': {
                fill: linkColor,
                stroke: linkColor,
                'stroke-width': parameters.linkThickness * (1 + (self.originalLink.model.thickness || 0)),
                d: 'M 10 0 L 0 5 L 10 10 z'
            }
        },
        connector: { name: 'rounded' }
    }]);

    /**
     * Highlights the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.select = function (once) {
        if (!once) self.originalLink.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unselect = function (once) {
        if (!once) self.originalLink.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
     * Blurs the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (!once) self.originalLink.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_LINK });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.unblure = function (once) {
        if (!once) self.originalLink.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
     * Hides the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.hide = function (once) {
        if (!once) self.originalLink.hide(true);
        self.set('hidden', true);
    };

    /**
     * Shows the TerminationLink.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationLink
     * @method
    */
    self.show = function (once) {
        if (!once) self.originalLink.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    /**
     * Reset highlighting for the TerminationLink.
     * @memberof TerminationLink
     * @method
    */
    function _synchronizeWithOrigin() {
        if (self.originalLink.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalLink.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    self.model = { source: options.source.id, target: options.target.id };
    self.refreshHighlighting();

    var onRemove = self.remove;

    /**
     * Removes link from the paper.
     * @memberof TerminationLink
     * @method
    */
    self.remove = function () {
        var index = self.originalLink.terminationLinks.indexOf(self);
        self.originalLink.terminationLinks.splice(index, 1);
        onRemove.call(self);
    };
}
TerminationLink.prototype = Object.create(joint.dia.Link.prototype);

},{"../../data/resourceProvider":29,"./elements":46,"rappid":"rappid"}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerminationNode = TerminationNode;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _resourceProvider = require('../../data/resourceProvider');

var _elements = require('./elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * TerminationNodeModel - data model of a TerminationNode object
 * @typedef {Object} TerminationNodeModel
 * @property {Point} position - Node identifyer
 * @property {Node} node - Original node
*/

/**
 * @private
 * The graph TerminationNode based on joint.shapes.basic.Rect.
 * @class
 * @augments joint.shapes.basic.Rect
 * 
 * @param {TerminationNodeModel} options - Data model
 * @param {Parameters} parameters - The set of parameters
 * 
 * @property {Node} originalNode - The original node,
 * which is out of the viewFrame so we use termination instead
 * @property {Node[]} related - List of the nodes related with this node
 * @property {boolean} highlighted - Tells wheter highlighted node or not (use method get to get this property, e.g. node.get('highlighted'))
 * @property {boolean} blured - Tells wheter blured node or not (use method get to get this property, e.g. node.get('blured'))
 * @property {boolean} removed - Is the node removed from the paper
*/
function TerminationNode(options, parameters) {
    var self = this;
    var _res = new _resourceProvider.ResourceProvider(parameters);

    self.originalNode = options.node;
    self.highlighted = false;
    self.blured = false;
    self.related = [];
    self.size = parameters.terminationNodeSize;

    options.node.terminationNodes.push(self);

    joint.shapes.basic.Generic.apply(self, [{
        markup: '<g class="rotatable">\n                    <g class="scalable">\n                        <rect class="body"/>\n                    </g>\n                    <rect class="tq-lg-body"/>\n                    <text/>\n                </g>',
        type: 'termination-node',
        position: options.position,
        size: parameters.terminationNodeSize,
        attrs: {
            '.body': {
                port: 'clipRectPort',
                fill: 'transparent',
                'stroke-width': 0,
                rx: 10,
                ry: 10
            },
            '.tq-lg-body': {
                'ref-x': .5,
                'ref-y': .5,
                'x-alignment': 'middle',
                'y-alignment': 'middle',
                width: parameters.terminationNodeSize.width - 10,
                height: parameters.terminationNodeSize.height - 10,
                ref: '.body',
                rx: 2,
                ry: 2,
                stroke: _res.getColor(options.node.model.typeId),
                fill: 'white',
                port: 'clipRectPort'
            },
            text: {
                text: 'С',
                fill: _res.getColor(options.node.model.typeId),
                stroke: _res.getColor(options.node.model.typeId),
                'ref-x': .5,
                'ref-y': .55,
                ref: '.body',
                tooltip: self.originalNode.model.label // see the line 221 at lineageGram.js
            }

        },
        z: _elements.Z_INDEXES.TERMINATION_ELEMENT
    }]);

    var _isDragging = true;
    var oldPosition = self.position;
    self.position = function (x, y) {
        _isDragging = false;
        var result = oldPosition.call(self, x, y);
        _isDragging = true;
        return result;
    };
    self.on('change:position', function () {
        if (_isDragging) self.set('dragged', _isDragging);
    });
    self.on('change:dragged', function () {
        var oldSize = self.size;
        var oldPos = self.position();

        if (self.get('dragged')) {
            self.size = {
                width: self.originalNode.size.width,
                height: self.originalNode.size.height
            };
            self.attr({
                text: {
                    text: '+',
                    'ref-y': .51
                },
                '.body': {
                    rx: 0,
                    ry: 0
                }
            });
            self.resize(self.size.width, self.size.height);
            self.position(oldPos.x - (self.size.width - oldSize.width) / 2, oldPos.y - (self.size.height - oldSize.height) / 2);
        } else {
            self.size = {
                width: parameters.terminationNodeSize.width,
                height: parameters.terminationNodeSize.height
            };
            self.attr({
                text: {
                    text: 'C',
                    'ref-y': .55
                },
                '.body': {
                    rx: 10,
                    ry: 10
                }
            });
            self.resize(self.size.width, self.size.height);

            self.position(oldPos.x + (self.size.width - oldSize.width) / 2, oldPos.y + (self.size.height - oldSize.height) / 2);
        }
    });

    /**
     * Highlights the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.select = function (once) {
        if (self.originalNode && !once) self.originalNode.select(true);
        if (self.get('blured')) self.unblure();
        if (self.get('hidden')) self.show();
        self.prop({ z: _elements.Z_INDEXES.SELECTED_ELEMENT });
        self.set('highlighted', true);
    };

    /**
     * Removes highlighting from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unselect = function (once) {
        if (self.originalNode && !once) self.originalNode.unselect(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('highlighted', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.blure = function (once) {
        if (self.get('highlighted')) return;
        if (self.originalNode && !once) self.originalNode.blure(true);
        self.prop({ z: _elements.Z_INDEXES.BLURED_NODE });
        self.set('blured', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.unblure = function (once) {
        if (self.originalNode && !once) self.originalNode.unblure(true);
        self.prop({ z: _elements.Z_INDEXES.TERMINATION_ELEMENT });
        self.set('blured', false);
    };

    /**
      * Blurs the TerminationNode.
      * @param {boolean} once - Boolean flag to protect code from recursion (optional)
      * @memberof TerminationNode
      * @method
     */
    self.hide = function (once) {
        if (self.originalNode && !once) self.originalNode.hide(true);
        self.set('hidden', true);
    };

    /**
     * Removes blur from the TerminationNode.
     * @param {boolean} once - Boolean flag to protect code from recursion (optional)
     * @memberof TerminationNode
     * @method
    */
    self.show = function (once) {
        if (self.originalNode && !once) self.originalNode.show(true);
        self.set('hidden', false);
    };

    /**
     * Refreshes highlighters of the view of this element.
     * @memberof Link
     * @method
    */
    self.refreshHighlighting = function () {
        _synchronizeWithOrigin();
        self.trigger('refresh-highlighting', self);
    };

    function _synchronizeWithOrigin() {
        if (self.originalNode.get('highlighted')) {
            self.set('highlighted', true, { silent: true });
        } else {
            self.set('highlighted', false, { silent: true });
        }
        if (self.originalNode.get('blured')) {
            self.set('blured', true, { silent: true });
        } else {
            self.set('blured', false, { silent: true });
        }
    }

    var onRemove = self.remove;

    /**
     * Removes node from the paper.
     * @memberof TerminationNode
     * @method
    */
    self.remove = function () {
        var index = self.originalNode.terminationNodes.indexOf(self);
        self.originalNode.terminationNodes.splice(index, 1);
        onRemove.call(self);
    };

    self.refreshHighlighting();
}
TerminationNode.prototype = Object.create(joint.shapes.basic.Rect.prototype);

},{"../../data/resourceProvider":29,"./elements":46,"rappid":"rappid"}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LineageDiagram;

var _rappid = require("rappid");

var joint = _interopRequireWildcard(_rappid);

var _fileSaverjs = require("file-saverjs");

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _lodash = require("lodash");

var _ = _interopRequireWildcard(_lodash);

var _viewManager2 = require("./viewManager");

var _routingManager2 = require("./linkRoutingManager/routingManager");

var _viewFrame = require("./viewFrame");

var _elements = require("./graphElements/elements");

var _viewFramesUI2 = require("../htmlUI/viewFramesUI");

var _viewFramesUI3 = _interopRequireDefault(_viewFramesUI2);

var _subscribeable = require("../subscriptionAPI/subscribeable");

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _toSvg = require("./toSvg");

var _layout = require("../layout/layout");

var _dataUtils = require("../utils/dataUtils");

var _utils = require("../utils/utils");

var _lineageDiagramUtils = require("../utils/lineageDiagramUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DIRECTION = {
  UP: 38,
  DOWN: 40,
  LEFT: 37,
  RIGHT: 39
};

/**
 * @private
 * @class
 * Manages the main view of application (View-2)
 * All changes goes through the render function.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  graphPlace: HTMLElement
 *  viewFrames: ViewFrameModels
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 *
 * Public methods:
 * ========================================
 * redraw: (options: {
    viewFrames: ViewFramePublicModel[];
    selectedElement: (Node|Link);
    path: { [id: string]: (Node|Link) };
    quickUpdate: boolean;
    updateBounds: boolean;
    paperOptions: {
        orientation: Orientation;
        width: number;
        height:number;
        scale: Point;
    };
    elementOptions: {
        elementSize: ElementSize;
 * }) => void;
 * delayedRedraw: (options: { ... see redraw}) => void;
 * openViewFrame: (id:string) => void;
 * closeViewFrame: (id:string) => void;
 * openOverViewFrame: () => void;
 * closeOverViewFrame: () => void;
 * updateNodesPositions: (nodes: Node[]) => void;
 * combine: () => void;
 * resetLayout: () => void;
 * refresh: () => void;
 * getSelectedElement: () => (Node|Link);
 * getVisibleCells: () => (Node|Link|ViewFrame|TerminationNode|TerminationLink);
 * getVisibleNodes: () => (Node|ViewFrame|TerminationNode);
 * getVisibleLinks: () => (Link|TerminationLink);
 * setSelectedElement: (element: (Node|Link|undefined), focusOn: boolean) => void;
 * positionViewPort: (vf: ViewFramePublicModel, point: Point, animation: boolean) => void;
 * export: () => void;
 * print: () => void;
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrameDefinition[]) => void;
 * scale: (scale: Point) => void; - Sets and limits value of the scale of the graph
 * zoomIn: () => void;
 * zoomOut: () => void;
 * zoomToFit: () => void;
 * setOrientation: (orientation: Orientation) => void; Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * getViewFrames: () => ViewFramePublicModel[];
 * translateViewPort (vf: ViewFrame, dx: number, dy: number, animation: boolean)
 * ----------------------------------------
 * on (event: string, callback: function) => void
 * unsubscribe (callback: function) => void
 * trigger (event: string, parameters: any) => void
 *
 * Events:
 * ========================================
 * @fires selected-element-changed (Node|Link)
 * @fires scale-changed (scale)
 * @fires view-frames-state-changed (ViewFrame, boolean)
 * @fires view-frames-size-or-position-changed (ViewFrame, boolean)
 * @fires cell-double-click (cell)
 * @fires cell-single-click (cell)
 * @fires link-options-click (Link)
 * @fires nodes-position-changed
 */
function LineageDiagram(options, parameters) {
  // Init
  // ===================================================================
  // ===================================================================
  _subscribeable2.default.apply(this); // make this class Subscribable

  var _base = _createBase(options.graphPlace);

  // Creating a joint graph and joint paper
  var _graph = new joint.dia.Graph();
  var _paper = new joint.dia.Paper({
    el: _base.diagram,
    model: _graph,
    elementView: _elements.NodeView,
    linkView: _elements.LinkView,
    gridSize: 1,
    interactive: function interactive() {
      return { vertexAdd: false };
    },
    preventContextMenu: false,
    width: "100%",
    height: "100%"
  });

  var _scale = parameters.defaultScale;
  var _dataContainer = void 0;

  var _orientation = parameters.graphOrientation;
  var _fullScreenMode = parameters.fullScreenMode;
  var _path = null; // highlighting path
  var _mask = parameters.mask; // highlighting path
  var _selectedElement = null;
  var _routingManager = void 0;
  var _viewFramesUI = void 0;
  var _viewManager = void 0;

  var self = this;
  var _keyboard = new joint.ui.Keyboard();
  var _scaleBounds = _.clone(parameters.scaleBounds);
  var _overViewScaleBounds = _.clone(parameters.overViewScaleBounds);
  var _scaleStep = parameters.scaleStep;

  _setData(options.dataContainer, options.viewFrames);
  _subscribeOnEvents();
  // ===================================================================
  // ===================================================================

  /**
   * Drawing options (deprecated)
   * @typedef {Object} DrawingOptions
   * @param {boolean} quickUpdate - don't updates links and remove them.
   * @param {Array of ViewFrame} viewFrames - update only limitted number of viewFrames.
   */

  /**
   * @private
   * Updates the graph's state, - Add/remove
   * visible Nodes and TerminationNodes
   * @param {DrawingOptions} options
   */
  self.redraw = _redraw;
  /**
   * Same as redraw but it's quick update
   * with delayed full redraw (debouncer).
   */
  self.delayedRedraw = _delayedRedraw;

  /**
   * Opens ViewFrame with specified id
   * @param {string} viewFrameId
   */
  self.openViewFrame = _openViewFrame;

  /**
   * Closes ViewFrame with specified id
   * @param {string} viewFrameId
   */
  self.closeViewFrame = _closeViewFrame;

  /**
   * Changes mode fullScreen/viewFrame.
   * @param {boolean} value
   */
  self.setFullScreenMode = _setFullScreenMode;

  /**
   * Opens OverViewFrame
   * @param {string} viewFrameId
   */
  self.openOverViewFrame = function () {
    return _openViewFrame(_viewManager.getOverViewFrame().id);
  };

  /**
   * Closes OverViewFrame
   * @param {string} viewFrameId
   */
  self.closeOverViewFrame = function () {
    return _closeViewFrame(_viewManager.getOverViewFrame().id);
  };

  /**
   * Updates layout positions of the nodes using paper positions
   * @param {Node[]} nodes
   */
  self.updateNodesPositions = _updateNodesPositions;

  /**
   * Groups nodes around selected
   * and highlights neighbours
   */
  self.combine = _combine;

  /**
   * Restore nodes positions
   */
  self.resetLayout = _resetLayout;

  /**
   * Refreshes all viewFrames bounds.
   */
  self.refresh = _refresh;

  /**
   * @returns {Node|Link}.
   */
  self.getSelectedElement = function () {
    return _selectedElement;
  };

  /**
   * @returns {(Node|Link|ViewFrame|TerminationNode|TerminationLink)}.
   */
  self.getVisibleCells = function () {
    return _graph.getCells();
  };

  /**
   * @returns {(Node|ViewFrame|TerminationNode)}.
   */
  self.getVisibleNodes = function () {
    return _graph.getElements();
  };

  /**
   * @returns {(Link|TerminationLink)}.
   */
  self.getVisibleLinks = function () {
    return _graph.getLinks();
  };

  /**
   * Sets selected element
   * @param {Node|Link|undefined}.
   */
  self.setSelectedElement = function (element, focusOn) {
    if (element) {
      _select(element, focusOn);
    } else {
      _unselect();
    }
  };

  /**
   * It sets offset for all elements into the viewPort.
   * @param {ViewFrame} viewFrame
   * @param {Point} point
   * @param {boolean} animation - it's optional
   * @param {function} callback - it's called after focus
   * @fires view-frames-size-or-position-changed
   */
  self.positionViewPort = function (viewFramePublicModel, point, animation, callback) {
    var relevantViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
    _positionViewPort(relevantViewFrame, point, animation, function () {
      callback();
      var changedViewFrame = _viewManager.getViewFrameById(viewFramePublicModel.id);
      self.trigger("view-frames-size-or-position-changed", [[changedViewFrame]]);
    });
  };

  /**
   * Exports graph to png or svg file.
   * @param {
   *  name?: string - file name
   *  type?: string - (png/svg)
   * } options
   */
  self.export = function (options) {
    if (!options) options = {};
    var fileName = options.name || "LG_lineage_diagram_snapshot_" + (0, _dataUtils.date2String)(new Date());

    if (options.type === "png") {
      (0, _toSvg.toDataURL)(_paper, {
        backgroundColor: "white",
        svgOptions: {
          elementsToRemoveSelector: "",
          convertImagesToDataUris: true
        }
      }).then(function (base64URL) {
        saveData(base64URL, fileName, "png");
      }).catch(function (error) {
        if (typeof error === "string") alert(error);else alert("This type of export is not supported in the Internet Explorer");
        console.error(error);
      });
    } else {
      (0, _toSvg.exportToSVG)(_paper, {
        elementsToRemoveSelector: "",
        convertImagesToDataUris: true
      }).then(function (svgString) {
        saveData(svgString, fileName, "svg");
      }).catch(function (error) {
        alert(error);
        console.error(error);
      });
    }

    function saveData(data, fileName, type) {
      var blob = void 0;
      if (type === "svg") {
        blob = new Blob([data], { type: type });
      } else if (type === "png") {
        blob = (0, _dataUtils.png2Blob)(data);
      }
      (0, _fileSaverjs2.default)(blob, fileName + "." + type);
    }
  };

  /**
   * Shows print dialog.
   */
  self.print = function () {
    (0, _toSvg.exportToSVG)(_paper, {
      preserveDimensions: false,
      elementsToRemoveSelector: "",
      convertImagesToDataUris: true,
      pdfMode: true
    }).then(function (svgString) {
      var printWindow = window.open("", undefined, "width=1280,height=720");
      if (printWindow) {
        printWindow.document.write(svgString);
        printWindow.document.close();
        printWindow.print();
      } else {
        alert("You should unblock popup windows for the current url to be able to print this diagram!");
      }
    });
  };

  /**
   * Define data container with nodes and links for the Jointjs view (view-2)
   * and path it to the forms
   * @param {DataContainer} dataContainer - data for the graph
   * @param {ViewFramePublicModel[]} viewFrames - view frames
   */
  self.setData = _setData;

  self.setRouting = function (routingId) {
    _routingManager.setRouting(routingId);
  };

  self.getRouting = function () {
    return _routingManager.getRouting();
  };

  self.scale = function (scale) {
    if (scale) {
      _updateScale(scale);
      _limitViewPortsPostions(_viewManager.getViewFrames());
    }
    return _scale;
  };

  /**
   * Increases scale of the graph.
   * And redraw it after that.
   */
  self.zoomIn = function () {
    _updateScale({
      x: _scale.x + _scaleStep,
      y: _scale.y + _scaleStep
    });
    _delayedRedraw(undefined, function () {
      _limitViewPortsPostions(_viewManager.getViewFrames());
      self.trigger("scale-changed", _scale);
    });
  };

  /**
   * Decreases scale of the graph.
   * And redraw it after that.
   */
  self.zoomOut = function () {
    _updateScale({
      x: _scale.x - _scaleStep,
      y: _scale.y - _scaleStep
    });
    _delayedRedraw(undefined, function () {
      _limitViewPortsPostions(_viewManager.getViewFrames());
      self.trigger("scale-changed", _scale);
    });
  };

  /**
   * Increases scale of the graph.
   * And redraw it after that.
   */
  self.zoomToFit = function () {
    var overViewFrame = _viewManager.getOverViewFrame();
    var nodeBounds = overViewFrame.nodeBounds;
    var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
    var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

    var scale = overViewFrame.scale;
    var necessarySize = (0, _utils.globalToScaledSize)({
      width: nodeBounds.width,
      height: nodeBounds.height
    }, scale);
    var xRatio = width / (necessarySize.width + parameters.framePadding.x * 2);
    var yRatio = height / (necessarySize.height + parameters.framePadding.y * 2);
    var minRatio = Math.min(xRatio, yRatio);
    _updateScale({
      x: _scale.x * minRatio,
      y: _scale.y * minRatio
    });
    _delayedRedraw(undefined, function () {
      _limitViewPortsPostions(_viewManager.getViewFrames());
      self.trigger("scale-changed", _scale);
    });
  };

  /**
   * It changes orientation of the graph.
   * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
   * @memberof LineageDiagram
   * @method
   */
  self.setOrientation = function (orientation) {
    _orientation = orientation;
    _redraw();
    _viewFramesUI.setOrientation(orientation);
  };

  /**
   * Returns all ViewFrames
   * @memberof LineageDiagram
   * @method
   * @returns {ViewFramePublicModel[]}
   */
  self.getViewFrames = function () {
    return _viewManager.getViewFrames();
  };

  /**
   * Returns one ViewFrame by id
   * @memberof LineageDiagram
   * @method
   * @param {string} viewFrameId
   * @returns {ViewFramePublicModel}
   */
  self.getViewFrameById = function (viewFrameId) {
    return _viewManager.getViewFrameById(viewFrameId);
  };

  /**
   * Returns one ViewFrame by id
   * @memberof LineageDiagram
   * @method
   * @returns {ViewFramePublicModel}
   */
  self.getOverViewFrame = function () {
    return _viewManager.getOverViewFrame();
  };

  self.setMask = function (mask) {
    _mask = mask;
    _redraw();
  };

  self.getMask = function () {
    return _mask;
  };

  self.isFullScreenMode = function () {
    return _viewManager.isFullScreenMode();
  };

  function _redraw(options) {
    _routingManager.resetRouting();
    _routingManager.setBounds({
      x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
      y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
      width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
      height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
    });

    options = options || {};
    var renderOptions = {
      viewFrames: options.viewFrames,
      fullScreenMode: options.fullScreenMode,
      selectedElement: _selectedElement,
      path: _path,
      mask: _mask,
      quickUpdate: options.quickUpdate,
      updateBounds: options.updateBounds,
      paperOptions: {
        orientation: _orientation,
        width: _paper.el.clientWidth,
        height: _paper.el.clientHeight,
        scale: _scale
      },
      elementOptions: {
        elementSize: options.elementSize
      }
    };

    if (!renderOptions.quickUpdate) clearTimeout(_timeoutRef);

    _graph.startBatch("remove");
    if (renderOptions.quickUpdate) _graph.removeCells(_graph.getLinks());

    var renderData = _viewManager.prepareRenderData(renderOptions);

    renderData = _removeDeprecatedAndExistingCells(renderData);
    _graph.stopBatch("remove");

    _graph.startBatch("add");
    _graph.addCells(renderData);
    _graph.stopBatch("add");

    _updateHighlighting(renderData);
    _viewFramesUI.refresh();
    // console.log('Redraw' + (renderOptions.quickUpdate ? ' (quick)' : ''));
  }

  var _timeoutRef = 0;
  var _blockMultipleQueries = false;
  function _delayedRedraw(options, callback) {
    if (_blockMultipleQueries) return;
    clearTimeout(_timeoutRef);
    options = options || {};

    var quickOptions = _.cloneDeep(options) || {};
    quickOptions.quickUpdate = true;

    _blockMultipleQueries = true;
    requestAnimationFrame(function () {
      _blockMultipleQueries = false;
    });
    _redraw(quickOptions);

    _timeoutRef = setTimeout(function () {
      options.quickUpdate = false;
      // console.log(`Redraw (delay:start-${_timeoutRef}) => `);
      _redraw(options);
      if (callback) callback();
    }, 150);
    // console.log(`Redraw (delay:wait-${_timeoutRef})`);
  }

  function _removeDeprecatedAndExistingCells(newCells) {
    var oldCells = _graph.getCells();
    var cellMap = {};

    newCells.forEach(function (cell) {
      cellMap[cell.id] = cell;
    });
    oldCells.forEach(function (cell) {
      if (!cellMap[cell.id]) {
        cell.remove();
      } else {
        delete cellMap[cell.id];
      }
    });

    return Object.keys(cellMap).map(function (key) {
      return cellMap[key];
    });
  }

  function _updateHighlighting(cells) {
    cells.forEach(function (cell) {
      if (cell.refreshHighlighting) {
        cell.refreshHighlighting();
      }
    });
  }

  function _combine() {
    var selectedElementIsNode = _selectedElement instanceof _elements.Node;
    if (selectedElementIsNode) {
      var selectedNode = _selectedElement;
      var nodeMap = _dataContainer.maps.nodeMap;
      var sourceMap = _dataContainer.maps.sourceMap;
      var targetMap = _dataContainer.maps.targetMap;

      var relativeLinks = (sourceMap[selectedNode.id] || []).concat(targetMap[selectedNode.id] || []);
      var relativeNodes = relativeLinks.map(function (l) {
        if (l.model.source !== selectedNode.id) return nodeMap[l.model.source];else if (l.model.target !== selectedNode.id) return nodeMap[l.model.target];else if (l.model.source === l.model.target) return nodeMap[l.model.source];
      });

      var newPositions = (0, _layout.combineOperation)({
        selectedNode: selectedNode,
        relativeLinks: relativeLinks,
        relativeNodes: relativeNodes,
        scale: _scale
      }, parameters);

      var targetViewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(selectedNode);
      var newPath = {};
      var affectedViewFramesMap = {};
      relativeNodes.forEach(function (node) {
        var curPosition = (0, _utils.getGlobalNodePosition)(node);
        node.model.position = newPositions[node.id];
        _dataContainer.updateZonesForNode(node, curPosition);

        var viewFrame = _viewManager.getViewFrameForNode(node);
        affectedViewFramesMap[viewFrame.id] = viewFrame;
        node.viewFrameOwnerId = targetViewFrameId;
        newPath[node.id] = node;
      });
      newPath[selectedNode.id] = selectedNode;

      relativeLinks.forEach(function (link) {
        newPath[link.id] = link;
      });

      _path = newPath;

      var affectedViewFrames = Object.keys(affectedViewFramesMap).map(function (key) {
        return affectedViewFramesMap[key];
      });
      _redraw({ viewFrames: affectedViewFrames, updateBounds: true });
      _limitViewPortsPostions(affectedViewFrames);
    }
  }

  /**
   * Removes all from the paper besides viewFrames.
   */
  function _clear() {
    _unselect();
    _graph.clear();
    _viewManager = undefined;
  }

  /**
   * Define data container with nodes and links for the Jointjs view (view-2)
   * and path it to the forms
   * @param {DataContainer} dataContainer - data for the graph
   * @param {ViewFramePublicModel[]} viewFrames - view frames
   */
  function _setData(dataContainer, viewFrames) {
    _clear();

    _dataContainer = dataContainer;
    _routingManager = new _routingManager2.RoutingManager({
      links: _dataContainer.links,
      bounds: {
        x: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
        y: _viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth,
        width: _paper.el.clientWidth - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2,
        height: _paper.el.clientHeight - (_viewManager2.FRAME_OUT_MARGIN + parameters.frameBorderWidth) * 2
      }
    }, parameters);
    _viewManager = new _viewManager2.ViewManager({
      dataContainer: dataContainer,
      viewFrames: viewFrames,
      fullScreenMode: _fullScreenMode
    }, parameters);

    _viewFramesUI = _createViewFramesUI(_viewManager);

    _viewManager.on("change-view-port-position", function (viewFrame) {
      _redraw({ viewFrames: [viewFrame], quickUpdate: true });
    });

    _correctScale();
    _redraw();
  }

  /**
   * @param {string} viewFrameId
   * @fires view-frames-size-or-position-changed
   */
  function _openViewFrame(viewFrameId) {
    var viewFrame = _viewManager.getViewFrameById(viewFrameId);
    if (!viewFrame) return;

    viewFrame.expanded = true;
    var viewFrames = [viewFrame];

    _redraw({ viewFrames: viewFrames });

    self.trigger("view-frames-state-changed", [viewFrames]);

    _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
      return vf.active;
    }));
  }

  function _closeViewFrame(viewFrameId) {
    var viewFrame = _viewManager.getViewFrameById(viewFrameId);
    if (!viewFrame) return;

    viewFrame.expanded = false;
    var viewFrames = [viewFrame];

    _redraw({ viewFrames: viewFrames });

    self.trigger("view-frames-state-changed", [viewFrames]);

    _limitViewPortsPostions(_viewManager.getViewFrames().filter(function (vf) {
      return vf.active;
    }));
  }

  function _setFullScreenMode(value) {
    _fullScreenMode = value;

    if (!_fullScreenMode) {
      _scale = {
        x: Math.max(Math.min(_scale.x, _scaleBounds.max), _scaleBounds.min),
        y: Math.max(Math.min(_scale.y, _scaleBounds.max), _scaleBounds.min)
      };
    }

    _redraw({ fullScreenMode: value });

    var viewFrames = _viewManager.getViewFrames();
    self.trigger("view-frames-state-changed", [viewFrames]);

    if (value) {
      var overViewFrame = _viewManager.getOverViewFrame();
      _limitViewPortPostion(overViewFrame, function () {
        _redraw();
        self.trigger("view-frames-size-or-position-changed", [[overViewFrame]]);
      });
    } else {
      _limitViewPortsPostions(viewFrames.filter(function (vf) {
        return vf.active;
      }));
    }
  }

  /**
   * Sets and limits value of the scale of the graph.
   * @param {number} scale
   * @returns {number}
   * =================
   * @fires scale-changed
   */
  function _updateScale(scale) {
    var fullScreen = _viewManager.isFullScreenMode();

    scale = scale || _scale;
    if (fullScreen) {
      _scale = {
        x: Math.max(Math.min(scale.x, _overViewScaleBounds.max), _overViewScaleBounds.min),
        y: Math.max(Math.min(scale.y, _overViewScaleBounds.max), _overViewScaleBounds.min)
      };
    } else {
      _scale = {
        x: Math.max(Math.min(scale.x, _scaleBounds.max), _scaleBounds.min),
        y: Math.max(Math.min(scale.y, _scaleBounds.max), _scaleBounds.min)
      };
    }
    return _scale;
  }

  function _correctScale() {
    var viewFramesNumber = _viewManager.getViewFrames().length;
    var width = _paper.el.clientWidth - _viewManager2.FRAME_OUT_MARGIN * 2;
    var height = _paper.el.clientHeight - _viewManager2.FRAME_OUT_MARGIN * 2;

    var cutedWidth = width - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);
    var cutedHeight = height - _viewManager2.DISTANCE_BETWEEN_FRAMES * (viewFramesNumber - 1);

    var minHorNum = 4; // it's for max scale because when we have max scale we also have minimum node number
    var minVertNum = 3;

    var maxHorNum = 8; // it's for min scale because when we have min scale we also have maximum node number
    var maxVertNum = 7;

    var nodeSize = {
      width: parameters.elementSize.width,
      height: parameters.elementSize.height
    };
    var step = {
      x: parameters.layoutStep.x,
      y: parameters.layoutStep.y
    };

    var minScale = getScaleForNodeNumber(maxHorNum, maxVertNum);
    var maxScale = getScaleForNodeNumber(minHorNum, minVertNum);

    // parameters.defaultScale = scale;
    _scaleBounds.min = Math.max(minScale.x, minScale.y);
    _scaleBounds.max = Math.min(maxScale.x, maxScale.y);
    // _setScale(scale);

    function getScaleForNodeNumber(horNum, vertNum) {
      var curXValue = horNum * nodeSize.width + (horNum - 1) * step.x;
      var curYValue = vertNum * nodeSize.height + (horNum - 1) * step.y;

      var scale = void 0;
      if (Math.abs(cutedWidth - curXValue) >= Math.abs(cutedHeight - curYValue)) {
        scale = {
          x: cutedWidth / curXValue,
          y: cutedWidth / curXValue
        };
      } else {
        scale = {
          x: cutedHeight / curYValue,
          y: cutedHeight / curYValue
        };
      }

      return scale;
    }
  }

  function _findNextNode(direction) {
    if (!_selectedElement) return undefined;
    var curPos = void 0;
    if (_selectedElement instanceof _elements.Node) {
      curPos = (0, _utils.getGlobalNodePosition)(_selectedElement);
    } else {
      var source = _dataContainer.maps.nodeMap[_selectedElement.model.source];
      var sourcePos = source.model.position;
      var target = _dataContainer.maps.nodeMap[_selectedElement.model.target];
      var targetPos = target.model.position;
      if (direction === DIRECTION.UP) {
        if (source.model.y < target.model.y) {
          return source;
        } else {
          return target;
        }
      } else if (direction === DIRECTION.DOWN) {
        if (source.model.y > target.model.y) {
          return source;
        } else {
          return target;
        }
      } else if (direction === DIRECTION.LEFT) {
        if (sourcePos.x < targetPos.x) {
          return source;
        } else {
          return target;
        }
      } else if (direction === DIRECTION.RIGHT) {
        if (sourcePos.x > targetPos.x) {
          return source;
        } else {
          return target;
        }
      }
    }

    var prevNodes = []; // to break cycling
    return getNextNode(curPos);

    function getNextNode(curPos) {
      function diffToNode(node) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);
        return {
          x: curPos.x - nodePosition.x,
          y: curPos.y - nodePosition.y
        };
      }

      var X_STEP = parameters.dataZoneSize.width;
      var Y_STEP = parameters.dataZoneSize.height;
      var rect = {
        x: curPos.x - X_STEP / 2,
        y: curPos.y - Y_STEP / 2,
        width: X_STEP,
        height: Y_STEP
      };

      var nodes = _dataContainer.getElementsForRectangle(rect).nodes.filter(function (n) {
        return prevNodes.indexOf(n) === -1;
      });
      if (nodes.length === 0) return _selectedElement;
      prevNodes = nodes;

      var nextElements = void 0;
      if (direction === DIRECTION.UP) {
        nextElements = nodes.filter(function (n) {
          var dist = diffToNode(n);
          return dist.y > 0 && Math.abs(dist.y) > Math.abs(dist.x);
        });
        if (nextElements.length === 0) {
          return getNextNode({
            x: curPos.x,
            y: curPos.y - Y_STEP
          });
        }
      } else if (direction === DIRECTION.DOWN) {
        nextElements = nodes.filter(function (n) {
          var dist = diffToNode(n);
          return dist.y < 0 && Math.abs(dist.y) > Math.abs(dist.x);
        });
        if (nextElements.length === 0) {
          return getNextNode({
            x: curPos.x,
            y: curPos.y + Y_STEP
          });
        }
      } else if (direction === DIRECTION.LEFT) {
        nextElements = nodes.filter(function (n) {
          var dist = diffToNode(n);
          return dist.x > 0 && Math.abs(dist.y) < Math.abs(dist.x);
        });
        if (nextElements.length === 0) {
          return getNextNode({
            x: curPos.x - X_STEP,
            y: curPos.y
          });
        }
      } else if (direction === DIRECTION.RIGHT) {
        nextElements = nodes.filter(function (n) {
          var dist = diffToNode(n);
          return dist.x < 0 && Math.abs(dist.y) < Math.abs(dist.x);
        });
        if (nextElements.length === 0) {
          return getNextNode({
            x: curPos.x + X_STEP,
            y: curPos.y
          });
        }
      }
      nextElements.sort(function (a, b) {
        var aPos = (0, _utils.getGlobalNodePosition)(a);
        var bPos = (0, _utils.getGlobalNodePosition)(b);
        var aDist = (0, _utils.getDist)(aPos, curPos);
        var bDist = (0, _utils.getDist)(bPos, curPos);

        if (aDist > bDist) {
          return 1;
        } else if (aDist < bDist) {
          return -1;
        } else {
          return 0;
        }
      });
      return nextElements[0];
    }
  }

  /**
   * Subscribes on paper and Keyboard events.
   */
  function _subscribeOnEvents() {
    var queryAnimationFrame = void 0;

    _paper.on("link:options", function (cellView, event) {
      var linkType = event.target.parentNode.getAttribute("linkType");
      self.trigger("link-options-click", {
        link: cellView.model,
        linkType: linkType
      });
    });

    _keyboard.on({
      "up down left right": function upDownLeftRight(evt) {
        cancelAnimationFrame(queryAnimationFrame);
        queryAnimationFrame = requestAnimationFrame(function () {
          _select(_findNextNode(evt.keyCode), true);
          evt.stopPropagation();
        });
      }
    });

    var _clickCounter = 0;
    _paper.on("cell:pointerup", function (cellView, event) {
      var isViewFrame = cellView.model instanceof _viewFrame.ViewFrame;
      if (isViewFrame) {
        onSingleClick(cellView, event);
        _clickCounter = 0;
      } else {
        if (_clickCounter > 1) {
          onDoubleClick(cellView, event);
          _clickCounter = 0;
        } else {
          setTimeout(function () {
            if (_clickCounter === 1) onSingleClick(cellView, event);
            _clickCounter = 0;
          }, 200);
        }
      }

      function onSingleClick(cellView, event) {
        var isDragging = Math.abs(_mouseDownPosition.x - event.pageX) > 5 || Math.abs(_mouseDownPosition.y - event.pageY);
        var cell = cellView.model;
        if (cell instanceof _viewFrame.ViewFrame) {
          var viewFrame = _viewManager.getViewFrameById(cell.id);
          // ViewFrame click
          // ================================
          if (!isDragging) _unselect();
          _limitViewPortPostion(viewFrame, function () {
            _redraw();
            self.trigger("view-frames-size-or-position-changed", [[_viewManager.getViewFrameById(cell.id)]]);
          });
          // ================================
        } else {
          // Node/Link click
          // ================================
          var draggingNode = isDragging && (cell instanceof _elements.Node || cell instanceof _elements.TerminationNode);
          var clickTerminationNode = cell instanceof _elements.TerminationNode;
          var clickOnNodeOrLink = !(cell instanceof _elements.AspectLink); // Exclude AspectLink
          if (draggingNode) {
            _updateNodesPositions([cell]);
          } else if (clickTerminationNode) {
            _select(cell, true);
          } else if (clickOnNodeOrLink) {
            _select(cell);
          }
          // ================================
        }
        self.trigger("cell-single-click", cellView.model);
      }

      function onDoubleClick(cellView) {
        var element = cellView.model;
        if (element instanceof _elements.Node) {
          element.set("expanded", !cellView.model.get("expanded"));
          _updateNodesPositions([element]);
        }
        self.trigger("cell-double-click", cellView.model);
      }
    });

    var _mouseDownPosition = { x: 0, y: 0 };
    _paper.on("cell:pointerdown", function (cell, event) {
      _mouseDownPosition = { x: event.pageX, y: event.pageY };
      _clickCounter++;
    });

    _paper.on("cell:mousewheel", function (cell, evt, x, y, delta) {
      var SCROLL_STEP = 100;
      var viewFrame = _viewManager.getVieFrameByScreenPoint({ x: x, y: y });

      if (viewFrame) {
        if (evt.shiftKey) {
          viewFrame.viewPortPosition.x += (delta < 0 ? 1 : -1) * SCROLL_STEP;
          viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
          _delayedRedraw({ viewFrames: [viewFrame] }, function () {
            self.trigger("view-frames-size-or-position-changed", [[viewFrame]]);
          });
        } else if (evt.ctrlKey) {
          var diff = delta > 0 ? _scaleStep : -_scaleStep;
          var scale = {
            x: _scale.x + diff,
            y: _scale.y + diff
          };
          _updateScale(scale);
          _delayedRedraw(undefined, function () {
            _limitViewPortsPostions(_viewManager.getViewFrames());
            self.trigger("scale-changed", scale);
          });
        } else {
          viewFrame.viewPortPosition.y += (delta < 0 ? 1 : -1) * SCROLL_STEP;
          viewFrame.viewPortPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
          _delayedRedraw({ viewFrames: [viewFrame] }, function () {
            self.trigger("view-frames-size-or-position-changed", [[viewFrame]]);
          });
        }
        evt.preventDefault();
      }
    });

    window.onresize = function () {
      _correctScale();
      _delayedRedraw(undefined, function () {
        self.trigger("scale-changed");
      });
    };
  }

  function _updateNodesPositions(nodes) {
    var changedViewFrames = [];
    var overViewFrame = _viewManager.getOverViewFrame();

    nodes.forEach(function (n) {
      var node = (0, _dataUtils.getBaseElement)(n);
      var isTerminationNode = n instanceof _elements.TerminationNode;
      var viewFrameByPosition = _viewManager.getVieFrameForNodeByPosition(n);

      var prevOwnerFrame = _viewManager.getViewFrameOwner(node) || overViewFrame;
      var viewFrame = void 0;

      viewFrame = viewFrameByPosition || prevOwnerFrame;
      var draggedElementPosition = n.position(); // could be termination node

      if (isTerminationNode) {
        draggedElementPosition.x -= (node.size.width - n.size.width) / 2;
        draggedElementPosition.y -= (node.size.height - n.size.height) / 2;
      }

      var newGlobalPosition = (0, _utils.localToGlobalPoint)(draggedElementPosition, _fullScreenMode ? overViewFrame.scale : viewFrame.scale, _fullScreenMode ? overViewFrame : viewFrame);
      var oldGlobalPosition = (0, _utils.getGlobalNodePosition)(node);

      node.model.position = newGlobalPosition;
      node.viewFrameOwnerId = viewFrame.id;

      _dataContainer.updateZonesForNode(node, oldGlobalPosition);

      var addedFrameIds = changedViewFrames.map(function (vf) {
        return vf.id;
      });
      var prevOwnerNotAddedInList = addedFrameIds.indexOf(prevOwnerFrame.id) === -1;
      var viewFrameNotAddedInList = addedFrameIds.indexOf(viewFrame.id) === -1;
      if (prevOwnerNotAddedInList && prevOwnerFrame.active) {
        prevOwnerFrame.updateBounds = true;
        changedViewFrames.push(prevOwnerFrame);
      }
      if (viewFrameNotAddedInList && viewFrame.active) {
        viewFrame.updateBounds = true;
        changedViewFrames.push(viewFrame);
      }
    });

    if (_fullScreenMode) {
      overViewFrame.updateBounds = true;
      changedViewFrames.push(overViewFrame);
    }

    _redraw({ viewFrames: changedViewFrames });
    _limitViewPortsPostions(changedViewFrames, function () {
      self.trigger("nodes-position-changed", [nodes]);
    });
  }

  /**
   * Creates ui for ViewFrames.
   */
  function _createViewFramesUI(viewManager) {
    if (_base.ui) {
      var viewFramesUI = new _viewFramesUI3.default({
        rootEl: _base.ui,
        viewManager: viewManager
      }, parameters);

      viewFramesUI.on("splitter-position-changed", function (s, diffObj) {
        var isHorizontalOrientated = _orientation === "left-to-right" || _orientation === "right-to-left";
        var diff = diffObj.diff;
        var vfA = s.model.viewFrameA;
        var vfB = s.model.viewFrameB;
        var thereIsDifference = diff !== undefined && diff !== null;
        if (thereIsDifference) {
          if (isHorizontalOrientated) {
            vfA.size.width += diff;
            vfB.size.width -= diff;
            vfB.position.x += diff;
          } else {
            vfA.size.height += diff;
            vfB.size.height -= diff;
            vfB.position.y += diff;
          }
          vfA.customeSized;
          vfB.customeSized;
        }
        if (diffObj.lastChange) {
          _redraw({ viewFrames: [vfA, vfB], quickUpdate: false });
          _limitViewPortsPostions([vfA, vfB]);
        } else if (thereIsDifference) {
          _redraw({ viewFrames: [vfA, vfB], quickUpdate: true });
        }
      });

      viewFramesUI.on("view-port-position-changed", function (viewFrame) {
        var relevantViewFrame = _viewManager.getViewFrameById(viewFrame.id);
        _positionViewPort(relevantViewFrame, viewFrame.viewPortPosition, parameters.animation, function () {
          var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
          self.trigger("view-frames-size-or-position-changed", [[changedViewFrame]]);
        });
      });

      viewFramesUI.on("view-frame-collapsed", function (viewFrame) {
        viewFrame.expanded = false;
        _closeViewFrame(viewFrame.id);
      });

      return viewFramesUI;
    }
  }

  /**
   * Creates html base for diagram.
   */
  function _createBase(baseDiv) {
    baseDiv.innerHTML = "";

    var diagram = document.createElement("DIV");
    diagram.className = "tq-lg-lineage-diagram";
    diagram.id = "tq_lg-lineage-graph";
    baseDiv.appendChild(diagram);

    var ui = document.createElement("DIV");
    ui.className = "tq-lg-lineage-ui";
    baseDiv.appendChild(ui);

    return { ui: ui, diagram: diagram };
  }

  /**
   * Clears selected object.
   * @param {boolean} silent - blocks throwing of event
   * @fires selected-element-changed
   */
  function _unselect(silent) {
    if (_selectedElement) {
      _path = null;
      _selectedElement.unselect();
      _selectedElement = null;

      if (!silent) {
        _redraw();
        self.trigger("selected-element-changed", null);
      }
    }
  }

  /**
   * Sets selected object and changes viewPort position if it's needed.
   * @param {Node|Link} element
   * @param {boolean} focusOn
   * ========================
   * @fires selected-element-changed
   */
  function _select(element, focusOn) {
    var selectedElement = (0, _dataUtils.getBaseElement)(element);

    if (selectedElement !== _selectedElement) {
      if (_selectedElement) _selectedElement.unselect();
      _selectedElement = selectedElement;
      _selectedElement.select();
    }

    if (focusOn) {
      _focusOnElement(_selectedElement, function () {
        _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
        _redraw();
        self.trigger("selected-element-changed", element);
      });
    } else {
      setTimeout(function () {
        _path = (0, _lineageDiagramUtils.getPath)(_selectedElement, _dataContainer);
        _redraw();
        self.trigger("selected-element-changed", element);
      }, 0);
    }
  }

  /**
   * It moves position of the viewPort so that
   * the selected element appears in the senter of the viewPort
   * @param {Node|Link} element
   * @param {function} callback - _focusOnElement can be asynchronous depends on animation mode
   */
  function _focusOnElement(element, callback) {
    var focusNode = null;
    if (element instanceof _elements.Link) {
      focusNode = _dataContainer.maps.nodeMap[element.model.source];
    } else if (element instanceof _elements.Node) {
      focusNode = element;
    }
    if (focusNode) {
      var viewFrame = _viewManager.getViewFrameForNode(focusNode);
      if (!viewFrame.active) {
        _redraw({
          viewFrames: [{ id: viewFrame.id, expanded: true }],
          quickUpdate: true
        });
        viewFrame = _viewManager.getViewFrameById(viewFrame.id);
        self.trigger("view-frames-state-changed", [[viewFrame]]);
      }
      var nodeSize = (0, _utils.getGlobalNodeSize)(focusNode, viewFrame.scale);
      var nodePosition = (0, _utils.getGlobalNodePosition)(focusNode);
      var viewPortSize = (0, _utils.scaledToGlobalSize)(viewFrame.size, viewFrame.scale);

      var targetPosition = {
        // Global
        x: nodePosition.x + (nodeSize.width - viewPortSize.width) / 2,
        y: nodePosition.y + (nodeSize.height - viewPortSize.height) / 2
      };

      _positionViewPort(viewFrame, targetPosition, parameters.animation, function () {
        callback();
        var changedViewFrame = _viewManager.getViewFrameById(viewFrame.id);
        self.trigger("view-frames-size-or-position-changed", [[changedViewFrame]]);
      });
    }
  }

  /**
   * All viewPort position changes should be performed through this methods.
   * _positionViewPort (exclude scale)
   * It's needed to stop animation in case of animation haven't been done.
   */

  /**
   * It sets offset for all elements into the viewPort.
   * @param {ViewFrame} viewFrame
   * @param {Point} point
   * @param {boolean} animation - it's optional
   * @param {function} callback - it's called after focus
   */
  function _positionViewPort(viewFrame, point, animation, callback) {
    var relevatnViewFrame = _viewManager.getViewFrameById(viewFrame.id);
    var targetPos = (0, _utils.limitPointPosition)(point, relevatnViewFrame.viewPortPositionBounds);
    var viewPortPosition = relevatnViewFrame.viewPortPosition;
    var targetIsReached = viewPortPosition.x === targetPos.x && viewPortPosition.y === targetPos.y;

    if (!animation || targetIsReached || !viewFrame.active) {
      cancelAnimationFrame(_animationId);
      viewFrame.viewPortPosition = targetPos;
      _redraw({ viewFrames: [viewFrame], quickUpdate: true });
      if (callback) callback();
    } else {
      _animatedViewPortChanging(relevatnViewFrame, targetPos, callback);
    }
  }

  function _limitViewPortsPostions(viewFrames, callback) {
    recursiveCall(0);

    function recursiveCall(index) {
      var viewFrame = viewFrames[index];
      if (!viewFrame) {
        if (callback) callback();
        return;
      }

      var targetViewFrame = _viewManager.getViewFrameById(viewFrame.id);
      if (!targetViewFrame) {
        if (callback) callback();
        return;
      }

      _limitViewPortPostion(targetViewFrame, function () {
        if (index < viewFrames.length) {
          recursiveCall(index + 1);
        } else {
          var changedViewFramesModels = viewFrames.map(function (vf) {
            return _viewManager.getViewFrameById(vf.id);
          });
          self.trigger("view-frames-size-or-position-changed", [changedViewFramesModels]);
          if (callback) callback();
        }
      });
    }
  }

  function _limitViewPortPostion(viewFrame, callback) {
    var limittedPosition = (0, _utils.limitPointPosition)(viewFrame.viewPortPosition, viewFrame.viewPortPositionBounds);
    var positionIsIncorrect = limittedPosition.x !== viewFrame.viewPortPosition.x || limittedPosition.y !== viewFrame.viewPortPosition.y;
    if (positionIsIncorrect) {
      _positionViewPort(viewFrame, limittedPosition, parameters.animation, callback);
    } else if (callback) {
      callback();
    }
  }

  /**
   * Chages viewPort position smoothly from current position to target.
   * @param {ViewFrame} vf
   * @param {Point} targetPos
   * @param {function} callback
   */
  var _animationId = undefined;
  function _animatedViewPortChanging(viewFrame, targetPos, callback) {
    var startPos = viewFrame.viewPortPosition;

    var diffX = (0, _utils.getDiff)(startPos.x, targetPos.x);
    var diffY = (0, _utils.getDiff)(startPos.y, targetPos.y);
    var scale = viewFrame.scale || _scale;
    var defaultStepX = parameters.animationStep / scale.x;
    var defaultStepY = parameters.animationStep / scale.y;

    var stepX = void 0,
        stepY = void 0;
    if (diffX > diffY) {
      stepX = defaultStepX;
      stepY = defaultStepX * (diffY / diffX);
    } else {
      stepX = defaultStepY * (diffX / diffY);
      stepY = defaultStepY;
    }

    var startDistance = (0, _utils.getDist)(viewFrame.viewPortPosition, targetPos);

    cancelAnimationFrame(_animationId);

    var time = void 0;
    reqursiveAnimation();

    function reqursiveAnimation(oldPos) {
      _animationId = requestAnimationFrame(function () {
        var now = new Date().getTime();
        var timeRate = 1000 / (now - time) || parameters.minFrameRate;

        var tModifier = 1;
        if (parameters.minFrameRate > timeRate) {
          tModifier = parameters.minFrameRate / timeRate;
        }
        if (timeRate > parameters.maxFrameRate) {
          tModifier = parameters.maxFrameRate / timeRate;
        }
        time = now;

        var curPos = viewFrame.viewPortPosition;
        var targetIsReached = curPos.x === targetPos.x && curPos.y === targetPos.y;
        var weAreNotMoving = oldPos && curPos.x === oldPos.x && curPos.y === oldPos.y;

        if (targetIsReached || weAreNotMoving) {
          _delayedRedraw({ viewFrames: [viewFrame] });
          // _redraw({ viewFrames: [viewFrame], quickUpdate: false });
          cancelAnimationFrame(_animationId);
          if (callback) callback();
          return;
        } else {
          var _diffX = (0, _utils.getDiff)(curPos.x, targetPos.x);
          var _diffY = (0, _utils.getDiff)(curPos.y, targetPos.y);

          var newPos = { x: curPos.x, y: curPos.y };

          var curDistance = (0, _utils.getDist)(curPos, targetPos);
          var k = 1 - Math.cos(Math.PI * (startDistance - curDistance) / startDistance) * 0.3;

          var finalStepX = stepX;
          var finalStepY = stepY;

          if (newPos.x !== targetPos.x) {
            var d = Math.min(_diffX, finalStepX * k * tModifier);
            newPos.x += curPos.x < targetPos.x ? d : -d;
          }
          if (newPos.y !== targetPos.y) {
            var _d = Math.min(Math.abs(_diffY), finalStepY * k * tModifier);
            newPos.y += curPos.y < targetPos.y ? _d : -_d;
          }
          viewFrame.viewPortPosition = newPos;

          _redraw({ viewFrames: [viewFrame], quickUpdate: true });

          reqursiveAnimation(curPos);
        }
      });
    }
  }

  /**
   * Refreshes all viewFrames bounds.
   */
  function _refresh(viewFrames) {
    viewFrames = viewFrames || _viewManager.getViewFrames();
    _redraw({ viewFrames: viewFrames, updateBounds: true });
    _limitViewPortsPostions(viewFrames);
  }

  function _resetLayout() {
    var viewFrameAffectedIds = {};
    var overViewFrameId = _viewManager.getOverViewFrame().id;

    _dataContainer.nodes.forEach(function (node) {
      if (node.model.defaultPosition) {
        var curPos = (0, _utils.getGlobalNodePosition)(node);
        node.model.position = node.model.defaultPosition;
        _dataContainer.updateZonesForNode(node, curPos);
        if (node.viewFrameOwnerId) viewFrameAffectedIds[node.viewFrameOwnerId] = true;

        var isFullScreenMode = _viewManager.isFullScreenMode();
        viewFrameAffectedIds[isFullScreenMode ? overViewFrameId : node.model.viewFrame] = true;
        delete node.viewFrameOwnerId;
      }
    });
    var viewFrames = Object.keys(viewFrameAffectedIds).map(function (key) {
      return {
        id: key,
        updateBounds: true
      };
    });
    _redraw({ viewFrames: viewFrames });
    _limitViewPortsPostions(viewFrames);
  }
}

},{"../htmlUI/viewFramesUI":38,"../layout/layout":56,"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./graphElements/elements":46,"./linkRoutingManager/routingManager":52,"./toSvg":53,"./viewFrame":54,"./viewManager":55,"file-saverjs":2,"lodash":"lodash","rappid":"rappid"}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ENABLE_ROUTINGS = undefined;
exports.RoutingManager = RoutingManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var g = joint.g;
var LINK_OFFSET = 7;

var ENABLE_ROUTINGS = exports.ENABLE_ROUTINGS = ['metro', 'normal', 'manhattan', 'orthogonal', 'lgrouter'];

/**
 * RoutingManager
 * @private
 * @param {linkRouting, links, bounds} options 
 * @param {*} parameters 
 */
function RoutingManager(options, parameters) {
    var self = this;

    var _links = void 0;
    var _routing = options.linkRouting || parameters.linkRouting;

    var _vertexMap = {};
    var _idToVertex = {};
    var _bounds = options.bounds;

    self.setData = _setData;
    self.setRouting = _setRouting;
    self.resetRouting = _resetRouting;
    self.setBounds = _setBounds;

    self.getRouting = function () {
        return _routing;
    };

    function _init() {
        _setData(options.links);
        joint.routers.lgrouter = lgrouter;
        joint.routers.metro = newMetro;
    }

    function _setBounds(bounds) {
        _bounds = bounds;
    }

    function _setData(links) {
        _links = links;
        _updateLinkRouting();
    }

    function _setRouting(routing) {
        var isUnknownRoutingId = ENABLE_ROUTINGS.indexOf(routing) === -1;
        if (isUnknownRoutingId) {
            routing = 'metro';
        }
        if (routing !== _routing) {
            _routing = routing;
            _updateLinkRouting();
        }
    }

    function _updateLinkRouting() {
        _vertexMap = {};
        _idToVertex = {};
        _links.forEach(function (link) {
            var router = {
                name: _routing,
                args: link.get('router').args
            };
            link.set('router', router, link.isOnTheGraph() ? {} : { silent: true });
        });
    }

    function _resetRouting() {
        _vertexMap = {};
        _idToVertex = {};
    }

    // Routers
    // =========================================

    var lgrouter = function () {
        return function (manualVertices, opts, linkView) {
            var defaultCofig = {
                step: 10
            };
            var vertices = joint.routers.manhattan(manualVertices, _.extend({}, defaultCofig, opts), linkView);

            this._findConnectionPoints(vertices);

            var allVertices = findIntermediateVertices([this.sourcePoint].concat(vertices).concat([this.targetPoint]),
            // vertices.length > 0 ? vertices : [this.sourceBBox.center(), this.targetBBox.center()],
            defaultCofig.step);

            var translatedVertices = [];
            clearVertices(linkView);

            var maxOffset = { x: 0, y: 0 };
            for (var i = 0; i < allVertices.length; i++) {
                var prevVertex = allVertices[i - 1];
                var vertex = allVertices[i];
                var nextVertex = allVertices[i + 1];
                vertex.type = getPositionType(prevVertex, vertex, nextVertex);
                maxOffset = getOffset(vertex, maxOffset);
            }

            allVertices.forEach(function (vertex) {
                var newVertex = storeVeertex(vertex, maxOffset, linkView);
                if (vertices.indexOf(vertex) !== -1) {
                    translatedVertices.push(newVertex);
                }
            });

            return translatedVertices.map(function (vertex) {
                return {
                    x: Math.min(Math.max(vertex.x, _bounds.x), _bounds.x + _bounds.width),
                    y: Math.min(Math.max(vertex.y, _bounds.y), _bounds.y + _bounds.height)
                };
            });
        };
    }();

    var newMetro = function () {
        var config = {
            // cost of a diagonal step (calculated if not defined).
            diagonalCost: null,
            // an array of directions to find next points on the route
            directions: function directions() {
                var step = this.step;
                var diagonalCost = this.diagonalCost || Math.ceil(Math.sqrt(step * step << 1));

                return [{ offsetX: step, offsetY: 0, cost: step }, { offsetX: step, offsetY: step, cost: diagonalCost }, { offsetX: 0, offsetY: step, cost: step }, { offsetX: -step, offsetY: step, cost: diagonalCost }, { offsetX: -step, offsetY: 0, cost: step }, { offsetX: -step, offsetY: -step, cost: diagonalCost }, { offsetX: 0, offsetY: -step, cost: step }, { offsetX: step, offsetY: -step, cost: diagonalCost }];
            },
            maxAllowedDirectionChange: 45,
            // a simple route used in situations, when main routing method fails
            // (exceed loops, inaccessible).
            fallbackRoute: function fallbackRoute(from, to) {
                // Find a route which breaks by 45 degrees ignoring all obstacles.
                var theta = from.theta(to);

                var a = { x: to.x, y: from.y };
                var b = { x: from.x, y: to.y };

                if (theta % 180 > 90) {
                    var t = a;
                    a = b;
                    b = t;
                }

                var p1 = theta % 90 < 45 ? a : b;
                var l1 = g.line(from, p1);
                var alpha = 90 * Math.ceil(theta / 90);
                var p2 = g.point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);
                var l2 = g.line(to, p2);
                var point = l1.intersection(l2);

                return point ? [point.round(), to] : [to];
            }
        };

        // public function
        return function (vertices, opts, linkView) {
            return lgrouter.call(this, vertices, _.extend({}, config, opts), linkView);
        };
    }();

    // =========================================

    function getPositionType(prevVertex, vertex, nextVertex) {
        if (prevVertex || nextVertex) {
            var x = Math.round(vertex.x);
            var y = Math.round(vertex.y);
            var equalX = (!prevVertex || Math.round(prevVertex.x) === x) && (!nextVertex || Math.round(nextVertex.x) === x);
            var equalY = (!prevVertex || Math.round(prevVertex.y) === y) && (!nextVertex || Math.round(nextVertex.y) === y);
            if (equalX) {
                return 'vertical';
            } else if (equalY) {
                return 'horizontal';
            } else {
                return 'point';
            }
        } else {
            return 'point';
        }
    }

    function applyOffset(vertex, offset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';
        return {
            x: vertex.x + (isHorizontal ? 0 : offset.x),
            y: vertex.y + (isVerical ? 0 : offset.y),
            type: vertex.type
        };
    }

    function getId(vertex) {
        return Math.round(vertex.x) + '@' + Math.round(vertex.y) + ':' + vertex.type;
    }

    // function getOffset (vertex, defaultOffset) {
    //     const curVertex = applyOffset(vertex, defaultOffset);
    //     const vId = getId(curVertex);

    //     if (_vertexMap[vId]) {
    //         const isHorizontal = vertex.type === 'horizontal'; 
    //         const isVerical = vertex.type === 'vertical';
    //         return getOffset (vertex, {
    //             x: defaultOffset.x + (isHorizontal ? 0 : -LINK_OFFSET),
    //             y: defaultOffset.y + (isVerical ? 0 : LINK_OFFSET),
    //         });
    //     } else {
    //         return defaultOffset;
    //     }
    // }

    function getOffset(vertex, defaultOffset) {
        var isHorizontal = vertex.type === 'horizontal';
        var isVerical = vertex.type === 'vertical';

        var curOffset = defaultOffset;
        var curVertex = applyOffset(vertex, defaultOffset);
        var curId = getId(curVertex);

        var xType = defaultOffset.x === 0 ? 'trigger' : defaultOffset.x > 0 ? 'rise' : 'fall';
        var yType = defaultOffset.y === 0 ? 'trigger' : defaultOffset.y > 0 ? 'rise' : 'fall';
        var xTrigger = 1;
        var yTrigger = 1;
        var xStep = 0;
        var yStep = 0;
        while (_vertexMap[curId]) {
            curOffset = { x: defaultOffset.x, y: defaultOffset.y };
            if (xType === 'trigger') {
                xTrigger = -xTrigger;
                if (xTrigger < 0) {
                    xStep++;
                }
            } else if (xType === 'rise') {
                xStep++;
            } else {
                xStep--;
            }
            if (yType === 'trigger') {
                yTrigger = -yTrigger;
                if (yTrigger < 0) {
                    yStep++;
                }
            } else if (yType === 'rise') {
                yStep++;
            } else {
                yStep--;
            }
            curOffset = {
                x: defaultOffset.x + (isHorizontal ? 0 : xStep * LINK_OFFSET * xTrigger),
                y: defaultOffset.y + (isVerical ? 0 : yStep * LINK_OFFSET * yTrigger)
            };

            curVertex = applyOffset(vertex, curOffset);
            curId = getId(curVertex);
        }

        return curOffset;
    }

    function clearVertices(linkView) {
        if (_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id].forEach(function (vertexId) {
                delete _vertexMap[vertexId];
            });
            delete _idToVertex[linkView.model.id];
        }
    }

    function storeVeertex(vertex, offset, linkView) {
        var newVertex = applyOffset(vertex, offset);

        var vertexId = getId(newVertex);
        _vertexMap[vertexId] = newVertex;

        if (!_idToVertex[linkView.model.id]) {
            _idToVertex[linkView.model.id] = [];
        }
        _idToVertex[linkView.model.id].push(vertexId);
        return newVertex;
    }

    function findIntermediateVertices(vertices, step) {
        var allVertices = [];
        var prev = undefined;
        vertices.forEach(function (vertex) {
            if (prev !== undefined) {
                var isVertical = prev.x === vertex.x;
                var isHorizontal = prev.y === vertex.y;

                if (isVertical) {
                    if (prev.y < vertex.y) {
                        for (var y = prev.y + step; y < vertex.y; y += step) {
                            allVertices.push({ x: vertex.x, y: y });
                        }
                    } else {
                        for (var _y = prev.y - step; _y > vertex.y; _y -= step) {
                            allVertices.push({ x: vertex.x, y: _y });
                        }
                    }
                } else if (isHorizontal) {
                    if (prev.x < vertex.x) {
                        for (var x = prev.x + step; x < vertex.x; x += step) {
                            allVertices.push({ x: x, y: vertex.y });
                        }
                    } else {
                        for (var _x = prev.x - step; _x > vertex.x; _x -= step) {
                            allVertices.push({ x: _x, y: vertex.y });
                        }
                    }
                }
            }
            allVertices.push(vertex);
            prev = vertex;
        });

        return allVertices;
    }

    _init();
}

},{"lodash":"lodash","rappid":"rappid"}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EXCLUDED_ELEMENTS = exports.PNG_CONTENT_PADDING = exports.FOREIGN_OBJECT_PADDING = undefined;
exports.exportToSVG = exportToSVG;
exports.toDataURL = toDataURL;
exports.fitRectKeepingAspectRatio = fitRectKeepingAspectRatio;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var FOREIGN_OBJECT_PADDING = exports.FOREIGN_OBJECT_PADDING = 2; // in px
var PNG_CONTENT_PADDING = exports.PNG_CONTENT_PADDING = 1; // in px
var EXCLUDED_ELEMENTS = exports.EXCLUDED_ELEMENTS = ['.dn-arrow', 'img', '.derivation-node_body-scroller'];

function exportToSVG(paper, props) {
    props = props || {};

    var vpTransform = paper.viewport.getAttribute('transform');
    paper.viewport.removeAttribute('transform');

    // const paperBoundingBox = paper.viewport.getBBox();
    var paperBoundingBox = paper.getContentBBox();
    var svgCopy = props.convertHtml ? createSVGCopy(paper) : simpleClone(paper);

    paper.viewport.setAttribute('transform', vpTransform || '');

    if (props.pdfMode) {
        svgCopy.removeAttribute('style');
        svgCopy.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgCopy.removeAttribute('height');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
        }

        var PADDING = 40;
        svgCopy.setAttribute('viewBox', [paperBoundingBox.x - PADDING, paperBoundingBox.y - PADDING, paperBoundingBox.x + paperBoundingBox.width + PADDING, paperBoundingBox.y + paperBoundingBox.height + PADDING].join(' '));
    } else {
        svgCopy.removeAttribute('style');
        if (props.preserveDimensions) {
            svgCopy.setAttribute('width', paperBoundingBox.width.toString());
            svgCopy.setAttribute('height', paperBoundingBox.height.toString());
        } else {
            svgCopy.setAttribute('width', '100%');
            svgCopy.setAttribute('height', '100%');
        }

        svgCopy.setAttribute('viewBox', '' + paperBoundingBox.x + ' ' + paperBoundingBox.y + ' ' + paperBoundingBox.width + ' ' + paperBoundingBox.height);
    }

    var isIE = !window.ActiveXObject && 'ActiveXObject' in window;

    if (isIE) {
        alignText(svgCopy.querySelectorAll('text'));

        //Shim SVGElement classList
        if (!Object.getOwnPropertyDescriptor(SVGElement.prototype, 'classList')) {
            if (HTMLElement && Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList')) {
                var descriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList');
                Object.defineProperty(SVGElement.prototype, 'classList', descriptor);
            }
        }
    }

    // workaround to include only ontodia-related stylesheets
    var cssStrings = extractCSSFromPaper(svgCopy);

    var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.id = 'extracted-styles'; // For IE-EDGE
    cssStrings.forEach(function (cssString, index) {
        var mocDiv = document.createElement('DIV');
        mocDiv.id = 'extracted-file-' + index;
        mocDiv.innerHTML = '<style>' + cssStrings + '</style>';
        defs.appendChild(mocDiv.firstChild);
    });
    svgCopy.insertBefore(defs, svgCopy.firstChild);

    if (props.elementsToRemoveSelector) {
        processNodes(svgCopy.querySelectorAll(props.elementsToRemoveSelector), function (node) {
            return node.remove();
        });
    }
    return convertImages(svgCopy.querySelectorAll('image')).then(function () {
        return new XMLSerializer().serializeToString(svgCopy);
    });
}

function alignText(textBlocks) {
    processNodes(textBlocks, function (text) {
        var anchor = text.getAttribute('text-anchor');
        var transform = text.getAttribute('transform');
        if (anchor === 'middle' && transform.indexOf('translate')) {
            text.removeAttribute('text-anchor');
            var y = transform.match(/,([\d,.]+)\)/)[1];
            text.setAttribute('transform', 'translate(' + _elements.LABEL_LEFT_RIGHT_PADDING + ', ' + y + ')');
        }
    });
}

function convertImages(images) {
    var promises = [];
    processNodes(images, function (image) {
        promises.push(new Promise(function (resolve) {
            if (!image) resolve();

            // Firefox uses `href`, all the others 'xlink:href'
            var url = image.getAttribute('xlink:href') || image.getAttribute('href');

            joint.util.imageToDataUri(url, function (err, dataUri) {
                image.setAttribute('xlink:href', dataUri);
                resolve();
            });
        }));
    });
    return Promise.all(promises);
}

var EXCLUDED_SELECTORS = ['body'];
function extractCSSFromPaper(paper) {
    var cssTexts = [];
    var allElements = paper.querySelectorAll('*');

    var allowedCssClasses = [];
    for (var i = 0; i < allElements.length; i++) {
        var element = allElements[i];

        var classesList = element.classList;
        for (var j = 0; j < classesList.length; j++) {
            allowedCssClasses.push(classesList[j]);
        }
    }

    for (var _i = 0; _i < document.styleSheets.length; _i++) {
        var cssClasses = void 0;
        try {
            var cssFile = document.styleSheets[_i];
            cssClasses = cssFile.cssRules || cssFile.rules;
            if (!cssClasses) {
                continue;
            }
        } catch (e) {
            continue;
        }

        var cssClassText = [];

        for (var _j = 0; _j < cssClasses.length; _j++) {
            var rule = cssClasses[_j];
            var doesContainAllowedClass = containsAllowedClass(rule.selectorText, allowedCssClasses);
            var allowedSelector = EXCLUDED_SELECTORS.indexOf(rule.selectorText) === -1 && doesContainAllowedClass;
            if (rule instanceof CSSStyleRule && allowedSelector) {
                cssClassText.push(rule.cssText);
            }
        }

        cssTexts.push(cssClassText.join('\n'));
    }

    function containsAllowedClass(cssSelector, allowedCssClasses) {
        if (!cssSelector) return true;
        for (var _i2 = 0; _i2 < allowedCssClasses.length; _i2++) {
            if (cssSelector.indexOf(allowedCssClasses[_i2]) !== -1) {
                return true;
            }
        }
        return false;
    }

    return cssTexts;
}

function simpleClone(paper) {
    var svgClone = paper.svg.cloneNode(true);
    return svgClone;
}

function createSVGCopy(paper) {
    var svgClone = paper.svg.cloneNode(true);
    var cells = paper.model.get('cells');
    processNodes(svgClone.querySelectorAll('g.element'), function (cellView) {
        var id = cellView.getAttribute('model-id');
        var htmlView = paper.el.querySelector('.derivation-node[id=\'' + id + '\']');
        if (!htmlView) {
            return;
        }

        var content = void 0;
        var isItIE11 = Boolean(navigator.userAgent.match(/Trident.*rv\:11\./));
        if (isItIE11) {
            content = processHTML(htmlView, EXCLUDED_ELEMENTS);
        } else {
            content = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            var cell = cells.get(id);
            var cellSize = cell.get('size');

            content.setAttribute('width', cellSize.width + FOREIGN_OBJECT_PADDING);
            content.setAttribute('height', cellSize.height + FOREIGN_OBJECT_PADDING);

            var htmlContent = htmlView.cloneNode(true);
            htmlContent.style.transform = null;

            var body = htmlView.querySelector('.derivation-node_body');
            var newBodies = htmlContent.querySelector('.derivation-node_body');
            if (body.scrollTop !== 0) {
                newBodies.firstChild.style.marginTop = -body.scrollTop + 'px';
            }
            content.appendChild(htmlContent);
        }

        cellView.setAttribute('class', cellView.getAttribute('class'));

        var anchor = cellView.querySelector('.export-anchor');
        anchor.removeAttribute('transform');

        var root = cellView.querySelector('.body');
        anchor.removeChild(root);
        anchor.appendChild(content);
    });

    return svgClone;
}

function processHTML(htmlView, excludedElements) {
    var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

    function recursion(htmlRoot) {
        if (htmlRoot instanceof HTMLElement) {
            if (checkElement(htmlRoot)) {
                var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                var offsetTop = getOffsetTop(htmlRoot);
                var offsetLeft = getOffsetLeft(htmlRoot);
                var style = window.getComputedStyle(htmlRoot);

                // svgRect.setAttribute('className', htmlRoot.className);
                rect.setAttribute('fill', style.backgroundColor);
                rect.setAttribute('stroke', style.borderColor);
                rect.setAttribute('stroke-width', style.borderWidth);
                rect.setAttribute('x', offsetLeft);
                rect.setAttribute('y', offsetTop);
                rect.setAttribute('width', style.width);
                rect.setAttribute('height', style.height);

                g.appendChild(rect);
                processNodes(htmlRoot.childNodes, function (child) {
                    recursion(child, true);
                });
            }
        } else if (htmlRoot instanceof Text) {
            var textContent = htmlRoot.textContent.trim();
            if (textContent.length === 0) return;

            var text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            var parent = htmlRoot.parentNode;

            var _offsetTop = getOffsetTop(parent);
            var _offsetLeft = getOffsetLeft(parent);
            var _style = window.getComputedStyle(parent);

            text.setAttribute('fill', _style.color);
            text.setAttribute('alignment-baseline', 'hanging');
            text.setAttribute('x', _offsetLeft);
            text.setAttribute('y', _offsetTop);

            var maxCharNumber = getMaxCharNumber(textContent, +_style.width.substring(0, _style.width.length - 2), _style.font);
            if (maxCharNumber === textContent.length) {
                text.textContent = textContent;
            } else {
                var ELIPSIS_LENGTH = 2;
                text.textContent = textContent.substring(0, maxCharNumber - ELIPSIS_LENGTH) + '...';
            }

            g.appendChild(text);
        }
    }

    function checkElement(element) {
        for (var i = 0; i < excludedElements.length; i++) {
            // IE11 fix
            var matches = element.matches ? element.matches : element.msMatchesSelector;
            if (matches.apply(element, [excludedElements[i]])) {
                return false;
            }
        }
        return true;
    }

    function getOffsetTop(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetTop + element.clientTop + (element.offsetParent ? getOffsetTop(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getOffsetLeft(element) {
        if (element.className !== 'derivation-node') {
            return element.offsetLeft + element.clientLeft + (element.offsetParent ? getOffsetLeft(element.offsetParent) : 0);
        } else {
            return 0;
        }
    }

    function getMaxCharNumber(text, maxWidth, font) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.font = font;

        var textWidth = ctx.measureText(text).width;
        if (textWidth <= maxWidth) {
            return text.length;
        } else {
            var FIT_CORRECTION = 0.85;
            return Math.floor(text.length * (maxWidth / textWidth) * FIT_CORRECTION);
        }
    }

    recursion(htmlView);

    return g;
}

function processNodes(nodes, callback) {
    for (var i = 0; i < nodes.length; i++) {
        callback(nodes[i]);
    }
}

function toDataURL(paper, options) {
    return new Promise(function (resolve) {
        var svgOptions = _.clone(options.svgOptions);

        var oldToSvg = paper.toSVG;
        paper.toSVG = function (callback) {
            exportToSVG(paper, svgOptions).then(function (svgString) {
                callback(svgString);
            });
        };
        paper.toPNG(function (image) {
            resolve(image);
        });
        paper.toSVG = oldToSvg;
    });
}

function fitRectKeepingAspectRatio(sourceWidth, sourceHeight, targetWidth, targetHeight) {
    if (!targetWidth && !targetHeight) {
        return { width: sourceWidth, height: sourceHeight };
    }
    var ratio = sourceWidth / sourceHeight;
    targetWidth = targetWidth || targetHeight * ratio;
    targetHeight = targetHeight || targetWidth / ratio;

    if (targetHeight * ratio <= targetWidth) {
        return { width: targetHeight * ratio, height: targetHeight };
    } else {
        return { width: targetWidth, height: targetWidth / ratio };
    }
}

exports.default = exportToSVG;

},{"./graphElements/elements":46,"lodash":"lodash","rappid":"rappid"}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewFrame = ViewFrame;
exports.OverViewFrame = OverViewFrame;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _utils = require('../utils/utils');

var _elements = require('./graphElements/elements');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var HOR_LABEL_PADDING = 8;
var VERT_LABEL_PADDING = 6;
var FONT_SIZE = 11;
var DEFAULT_FRAME_SIZE = { width: 50, height: 50 };

/**
 * Bounds
 * @typedef {Object} Bounds
 * @property {number} maxX
 * @property {number} minX
 * @property {number} maxY
 * @property {number} minY
 * @property {number} width
 * @property {number} height
*/

/**
 * @private
 * @class
 * ViewFrame of the main view (View-2).
 * Provides visible elements to the LineageDiagram.
 * Based on joint.shapes.basic.Rect.
 *
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  id: string
 *  backgroundColor: string
 *  borderColor: string
 *  spaceShare: number
 * } options
 * @param {Parameters} parameters - parameters set
 *
 * Public properties:
 * ========================================
 * id: string
 * model: @param options
 * constPosition: Point
 * size: Size (width, height)
 * movingByItself: boolena - it's flag to block a moving
 *
 * Public methods:
 * ========================================
 * refreshNodeState: (node: Node) => void;
 * getNodes: () => Node[];
 * updateBounds: () => void;
 * clear: () => void;
 * getNodeBounds: () => Bounds;
 * getViewPortBounds: () => Bounds;
 * setData: (dataContainer: DataContainer) => void
 * getVisibleCells: () => { nodes: Node[], link: Link[] };
 * calculateVisibleCells: () => void;
 * setPosition: (pos: Point) => void;
 * setSize: (size: Size) => void;
 * positionViewPort: (x: number, y: number) => Point;
 * resetSize: () => void;
 * hitScaledPointTest (point: Point) => boolean;
 * hitTest (node: Node, partialHit: boolean) => boolean;
 * ownerTest (node: Node) => boolean;
 * setScale: (scale: Point) => void;
 * getScale: () => Point;
 * setElementSize: (size: ElementSize) => void;
 * getElementSize: () => ElementSize;
 * limitNodePosition: (node: Node) => void;
 *
 * Events
 * ========================================
 * @fires change:correctPostion (limittedPoint: Point)
 * @fires change-view-port-position (newPosition: Point)
 *
 */
function ViewFrame(options, parameters) {
    // Init
    // ===================================================================
    // ===================================================================

    var self = this;
    self.id = options.id;
    self.model = options;
    self.constPosition = { x: 0, y: 0 };

    self.size = DEFAULT_FRAME_SIZE;
    self.movingByItself = false;

    if (options.singleMode) {
        options.dataContainer.nodes.forEach(function (n) {
            return n.viewFrameOwnerId = self.id;
        });
    }

    self.selectedElement;

    var _cachedResult = void 0;
    var _nodeBounds = void 0;
    var _viewPortPositionBounds = void 0;
    var _dataContainer = options.dataContainer;
    var _scale = void 0;
    var _viewPortPosition = { x: 0, y: 0 }; // global coordinates
    var _defaultElementSize = parameters.elementSize;
    var _referenceSize = _defaultElementSize;
    var _viewPortBounds = void 0;

    var _framePadding = parameters.framePadding;
    var label = joint.util.breakText(options.label, {
        width: self.size.width - HOR_LABEL_PADDING * 2
    });

    joint.shapes.basic.Rect.apply(self, [{
        id: options.id,
        type: 'viewFrame',
        position: { x: 0, y: 0 },
        size: self.size,
        attrs: {
            rect: {
                fill: options.backgroundColor,

                stroke: options.borderColor,
                class: 'body view-frame',
                width: self.size.width,
                height: self.size.height,
                'stroke-width': parameters.frameBorderWidth
            },
            text: {
                'x-alignment': 'left',
                'text-anchor': 'left',
                'font-weight': 'bold',
                ref: 'rect',
                'ref-x': HOR_LABEL_PADDING,
                'ref-y': VERT_LABEL_PADDING + FONT_SIZE,
                text: label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...',
                fill: options.borderColor
            }
        },
        z: _elements.Z_INDEXES.VIEW_FRAME
    }]);

    if (self.model.width) self.model.width = Math.abs(Math.max(self.model.width, parameters.framePadding.x * 2 + 1));
    if (self.model.height) self.model.height = Math.abs(Math.max(self.model.height, parameters.framePadding.y * 2 + 1));

    self.on('change:position', function (cell, position) {
        if (!self.movingByItself) {
            self.movingByItself = true;
            self.position(self.constPosition.x, self.constPosition.y);
            self.movingByItself = false;

            var scaledOffset = {
                x: self.constPosition.x - position.x,
                y: self.constPosition.y - position.y
            };
            var globalOffset = (0, _utils.scaledToGlobalPoint)(scaledOffset, _scale);

            var newViewPortPosition = {
                x: _viewPortPosition.x + globalOffset.x,
                y: _viewPortPosition.y + globalOffset.y
            };
            self.trigger('change-view-port-position', newViewPortPosition);
        }
    });

    _init(options, parameters);

    self.set('correctPostion', null);

    // ===================================================================
    // ===================================================================

    // CallBack to override
    // self._onChangeBounds = undefined;

    /**
     * Update position and size of the node.
     * @param {Node} node
    */
    self.refreshNodeState = _refreshNodeState;

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    self.getNodes = _getNodes;

    /**
     * Recaclulate viewPort bounds
    */
    self.updateBounds = _updateBounds;

    /**
     * Clear caches.
    */
    self.clear = _clear;

    /**
     * ViewFrame public model
     * @typedef {Object} Bounds
     * @property {number} minX
     * @property {number} maxX
     * @property {number} minY
     * @property {number} maxY
     * @property {number} width
     * @property {number} height
    */

    /**
     * Returns bounds of viewFrame in paper coordinates without padding.
     * @returns {Bounds}
    */
    self.getNodeBounds = function () {
        return _nodeBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortBounds = function () {
        return _viewPortBounds;
    };

    /**
     * Returns bounds of viewFrame in paper coordinates.
    */
    self.getViewPortPositionBounds = function () {
        return _viewPortPositionBounds;
    };

    /**
     * Returns all visible in this viewport cells (Links|Nodes e.t.c.)
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.getVisibleCells = function () {
        if (!_cachedResult) self.calculateVisibleCells();
        return _cachedResult;
    };

    /**
     * Calculate list of all visible in this viewport cells
     * @param {ViewFrameRenderOptions} options
     */
    self.calculateVisibleCells = function (options) {
        options = options || {};
        _referenceSize = _calculateReferenceNodeSize(options.elementSize || _defaultElementSize);
        _viewPortBounds = _getViewPortBounds();

        var globalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var globalRectangle = {
            x: _viewPortPosition.x,
            y: _viewPortPosition.y,
            width: globalSize.width,
            height: globalSize.height
        };
        var activeElements = _dataContainer.getElementsForRectangle(globalRectangle);

        var visibleNodeMap = {};
        var visibleNodes = activeElements.nodes.filter(function (node) {
            var isNodeVisible = _ownerTest(node) && _hitTestByGlobalPosition(node);
            if (isNodeVisible) visibleNodeMap[node.id] = node;
            return isNodeVisible;
        });

        visibleNodes.forEach(function (node) {
            _refreshNodeState(node);
        });

        _cachedResult = {
            nodes: visibleNodes,
            links: activeElements.links
        };
    };

    /**
     * Sets position of the viewFrame on the paper
     * @returns {
     *  nodes: Node[],
     *  links: Link[],
     * }
     */
    self.setPosition = function (pos) {
        self.movingByItself = true;
        self.constPosition = pos;
        self.position(self.constPosition.x, self.constPosition.y);
        self.movingByItself = false;
    };

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    self.setSize = _setSize;

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    self.positionViewPort = _positionViewPort;

    /**
     * Resets size.
     */
    self.resetSize = function () {
        self.model.width = undefined;
        self.model.height = undefined;
    };

    /**
     * Tells us whether the
     * point is in the viewPort of ViewFrame or not
     * @param {number} scale
     * @returns {boolean}
    */
    self.hitScaledPointTest = _hitScaledPointTest;

    /**
     * Tells us whether the
     * node is in the viewPort of ViewFrame or not
     * @param {Node} node
     * @returns {boolean}
    */
    self.hitTestByScaledPosition = _hitTestByScaledPosition;

    self.hitTestByGlobalPosition = _hitAreaTestByGlobalPosition;

    /**
     * Tells us whether the
     * ViewFrame is owner of the passed node or not
     * function for overriding
     * @param {Node} node
     * @returns {boolean}
    */
    // self._ownerTest - to override

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    self.setScale = _setScale;
    // self._scaleWillApplied; - to override

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    self.getScale = _getScale;

    /**
     * Sets the default element size.
     * @param {ElementSize} elementSize
    */
    self.setElementSize = function (elementSize) {
        _defaultElementSize = elementSize;
        _updateBounds();
        _limitViewPortPosition();
    };

    /**
     * Returns the default element size.
    */
    self.getElementSize = function () {
        return _defaultElementSize;
    };

    self.limitNodePosition = function (node) {
        var nodeScaledSize = node.calculateSize(_referenceSize); // scaled
        var scaledViewPortBounds = (0, _utils.globalToScaledBounds)(_viewPortPositionBounds);
        var nodeMinScaledPosition = (0, _utils.getScaledNodePosition)(node, _scale);

        var limitByMin = (0, _utils.limitPointPosition)(nodeMinScaledPosition, scaledViewPortBounds);
        var nodeMaxScaledPosition = {
            x: limitByMin.x + nodeScaledSize.width,
            y: limitByMin.y + nodeScaledSize.height
        };
        var limitByMax = (0, _utils.limitPointPosition)(nodeMaxScaledPosition, scaledViewPortBounds);
        var position = (0, _utils.scaledToGlobalPoint)(limitByMax, _scale);

        node.model.position = position;
    };

    function _init(options) {
        if (options.scale) {
            _scale = options.scale;
        } else if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(parameters.defaultScale);
        } else {
            _scale = parameters.defaultScale;
        }
        if (options.nodeBounds) {
            _nodeBounds = options.nodeBounds;
        } else {
            _nodeBounds = _calculateBounds();
        }
        if (options.viewPortPosition) {
            _viewPortPosition = options.viewPortPosition;
        }
        if (options.viewPortPositionBounds) {
            _viewPortPositionBounds = options.viewPortPositionBounds;
        } else {
            _viewPortPositionBounds = _calculateViewPortPositionBounds();
        }
        _viewPortBounds = _getViewPortBounds();
    }

    /**
     * Sets the scale of the viewFrame.
     * @param {Point} scale
    */
    function _setScale(scale) {
        if (self._scaleWillApplied) {
            _scale = self._scaleWillApplied(scale);
        } else {
            _scale = scale;
        }
        _updateBounds();
        _limitViewPortPosition();
    }

    /**
     * Returns the scale of the viewFrame.
     * @returns {number}
    */
    function _getScale() {
        return _scale;
    }

    function _clear() {
        _cachedResult = undefined;
    }

    /**
     * It sets offset for all elements into the viewPort.
     * @param {number} x
     * @param {number} y
     * @param {boolean} force - disables the limit
     * @returns {Point}
     */
    function _positionViewPort(x, y) {
        if (x !== undefined) _viewPortPosition.x = x;
        if (y !== undefined) _viewPortPosition.y = y;

        return { x: _viewPortPosition.x, y: _viewPortPosition.y };
    }

    /**
     * Returns list of nodes which viewFrame owns.
     * @returns {Array of Node}
    */
    function _getNodes() {
        return _dataContainer.nodes.filter(function (n) {
            return _ownerTest(n);
        });
    }

    /**
     * Changes size of the view-port-jointjs element.
     * @param {Size} size
     * @param {boolean} remember
     */
    function _setSize(size) {
        self.movingByItself = true;

        // it's best solution to fix the svg exporting
        // and for better compatibility IE11
        self.attr({
            'rect': {
                width: size.width,
                height: size.height
            }
        });
        // =================================
        self.resize(size.width, size.height);
        self.size = size;
        self.model.width = size.width;
        self.model.height = size.height;

        self.movingByItself = false;

        var label = joint.util.breakText(options.label, {
            width: self.size.width - HOR_LABEL_PADDING * 2
        });
        var completeLabel = label.indexOf('\n') === -1 ? label : label.substring(0, label.indexOf('\n')) + '...';
        self.attr('text/text', completeLabel);
    }

    /**
     * Update position and size of the node.
    */
    function _refreshNodeState(node) {
        var nodePosition = (0, _utils.getLocalNodePosition)(node, _scale, self);
        node.position(nodePosition.x, nodePosition.y);
        node.setSize(_referenceSize);
        if (parameters.clipNodes) {
            _clipNode(node);
        }
    }

    function _updateBounds() {
        _nodeBounds = _calculateBounds();
        _viewPortPositionBounds = _calculateViewPortPositionBounds();
    }

    /**
     * Recalculate bounds of view port.
    */
    function _calculateBounds() {
        var bounds = {
            minX: Infinity,
            maxX: -Infinity,
            minY: Infinity,
            maxY: -Infinity,
            width: undefined,
            height: undefined
        };

        var nodes = _getNodes();
        if (nodes.length !== 0) {

            nodes.forEach(function (node) {
                var pos = (0, _utils.getGlobalNodePosition)(node);
                var size = (0, _utils.scaledToGlobalSize)(node.calculateSize(_referenceSize), _scale);

                bounds.minX = Math.min(bounds.minX, pos.x);
                if (bounds.minX === pos.x) bounds.minXNode = node;

                bounds.maxX = Math.max(bounds.maxX, pos.x + size.width);
                if (bounds.maxX === pos.x + size.width) bounds.maxXNode = node;

                bounds.minY = Math.min(bounds.minY, pos.y);
                if (bounds.minY === pos.y) bounds.minYNode = node;

                bounds.maxY = Math.max(bounds.maxY, pos.y + size.height);
                if (bounds.maxY === pos.y + size.height) bounds.maxYNode = node;
            });

            bounds.width = bounds.maxX - bounds.minX;
            bounds.height = bounds.maxY - bounds.minY;
        } else {
            bounds.minX = 0;
            bounds.minY = 0;
            bounds.maxX = 0;
            bounds.maxY = 0;
            bounds.width = 0;
            bounds.height = 0;
        }

        return bounds;
    }

    /**
     * Returns bounds of view port.
     * @returns {
     *  maxX: number
     *  minX: number
     *  maxY: number
     *  minY: number
     * }
    */
    function _calculateViewPortPositionBounds() {
        if (!_nodeBounds) return null;
        // _bounds - global coord
        var viewFrameGlobalSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        var boundsWithPadding = (0, _utils.extendBounds)(_nodeBounds, _framePadding);

        var viewPortBounds = {
            minX: boundsWithPadding.minX,
            maxX: boundsWithPadding.maxX - viewFrameGlobalSize.width,
            minY: boundsWithPadding.minY,
            maxY: boundsWithPadding.maxY - viewFrameGlobalSize.height,
            width: boundsWithPadding.maxX - viewFrameGlobalSize.width - boundsWithPadding.minX,
            height: boundsWithPadding.maxY - viewFrameGlobalSize.height - boundsWithPadding.minY
        };

        if (viewPortBounds.width < 0) {
            var diffX = (viewFrameGlobalSize.width - boundsWithPadding.width) / 2;
            viewPortBounds.minX = boundsWithPadding.minX - diffX;
            viewPortBounds.maxX = viewPortBounds.minX;
            viewPortBounds.width = 0;
        }

        if (viewPortBounds.height < 0) {
            var diffY = (viewFrameGlobalSize.height - boundsWithPadding.height) / 2;
            viewPortBounds.minY = boundsWithPadding.minY - diffY;
            viewPortBounds.maxY = viewPortBounds.minY;
            viewPortBounds.height = 0;
        }

        return viewPortBounds;
    }

    /**
    * Returns bounds of view port.
    * @returns {
    *  maxX: number
    *  minX: number
    *  maxY: number
    *  minY: number
    * }
    */
    function _getViewPortBounds() {
        var globalViewPortSize = (0, _utils.scaledToGlobalSize)(self.size, _scale);
        return {
            minX: _viewPortPosition.x,
            maxX: _viewPortPosition.x + globalViewPortSize.width,
            minY: _viewPortPosition.y,
            maxY: _viewPortPosition.y + globalViewPortSize.height,
            width: _viewPortPosition.x + globalViewPortSize.width - _viewPortPosition.x,
            height: _viewPortPosition.y + globalViewPortSize.height - _viewPortPosition.y
        };
    }

    /**
     * Limits position of the view port.
     * @returns {Point}
    */
    function _limitViewPortPosition() {
        _viewPortPosition = (0, _utils.limitPointPosition)(_viewPortPosition, _viewPortPositionBounds);
    }

    /**
     * Tells us whether a Node fall into the viewport or no.
     * @param {Node} node
     * @param {boolean} partialHit
     * @returns {boolean}
    */
    function _hitTestByGlobalPosition(node, partialHit) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitGlobalPointTest(p1);
        var hitP2 = _hitGlobalPointTest(p2);
        var hitP3 = _hitGlobalPointTest(p3);
        var hitP4 = _hitGlobalPointTest(p4);

        var fullHit = hitP1 && hitP2 && hitP3 && hitP4;
        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        if (parameters.clipNodes) {
            return borderHit;
        } else {
            return partialHit && borderHit || !partialHit && fullHit;
        }
    }

    function _hitAreaTestByGlobalPosition(node, viewFrame) {
        var scaledPosition = node.position();
        var nodePosition = (0, _utils.localToGlobalPoint)(scaledPosition, _scale, viewFrame || self);

        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var hitP1 = _hitAreaGlobalPointTest(p1);
        var hitP2 = _hitAreaGlobalPointTest(p2);
        var hitP3 = _hitAreaGlobalPointTest(p3);
        var hitP4 = _hitAreaGlobalPointTest(p4);

        var borderHit = hitP1 || hitP2 || hitP3 || hitP4;

        return borderHit;
    }

    function _hitTestByScaledPosition(node) {
        var scaledPosition = node.position();

        var p1 = scaledPosition;
        var p2 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y };
        var p3 = { x: scaledPosition.x, y: scaledPosition.y + node.size.height };
        var p4 = { x: scaledPosition.x + node.size.width, y: scaledPosition.y + node.size.height };

        var hitP1 = _hitScaledPointTest(p1);
        var hitP2 = _hitScaledPointTest(p2);
        var hitP3 = _hitScaledPointTest(p3);
        var hitP4 = _hitScaledPointTest(p4);

        return hitP1 || hitP2 || hitP3 || hitP4;
    }

    function _hitGlobalPointTest(p) {
        return _viewPortBounds.minX <= p.x && p.x <= _viewPortBounds.maxX && _viewPortBounds.minY <= p.y && p.y <= _viewPortBounds.maxY;
    }

    function _hitAreaGlobalPointTest(p) {
        return _nodeBounds.minX <= p.x && p.x <= _nodeBounds.maxX && _nodeBounds.minY <= p.y && p.y <= _nodeBounds.maxY;
    }

    function _hitScaledPointTest(p) {
        return self.constPosition.x <= p.x && self.constPosition.x + self.size.width >= p.x && self.constPosition.y <= p.y && self.constPosition.y + self.size.height >= p.y;
    }

    function _ownerTest(node) {
        if (self._ownerTest) {
            return self._ownerTest(node);
        }
        var customeOwner = node.viewFrameOwnerId;
        var ownerIsMe = node.viewFrameOwnerId === self.id;
        var meIsNativeOwner = self.id === node.model.viewFrame;
        return customeOwner && ownerIsMe || meIsNativeOwner && !customeOwner;
    }

    /**
     * Calculate the clip point, which
     * tells us how far the node go out of the border of viewFrame.
     * And after calculation the function pass this point into the node.
     * @param {Node} node
    */
    function _clipNode(node) {
        var nodePosition = (0, _utils.getGlobalNodePosition)(node);
        var nodeScaledSize = node.calculateSize(_referenceSize);
        var nodeSize = (0, _utils.scaledToGlobalSize)(nodeScaledSize, _scale);

        var p1 = nodePosition;
        var p2 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y };
        var p3 = { x: nodePosition.x, y: nodePosition.y + nodeSize.height };
        var p4 = { x: nodePosition.x + nodeSize.width, y: nodePosition.y + nodeSize.height };

        var globalOffset = { x: 0, y: 0 };

        var o = getPointOffset(p1);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p2);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p3);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        o = getPointOffset(p4);
        globalOffset.x = Math.abs(o.x) > Math.abs(globalOffset.x) ? o.x : globalOffset.x;
        globalOffset.y = Math.abs(o.y) > Math.abs(globalOffset.y) ? o.y : globalOffset.y;

        var scaledOffset = (0, _utils.globalToScaledPoint)(globalOffset, _scale);
        node.setClipping(scaledOffset);

        function getPointOffset(p) {
            var offset = { x: 0, y: 0 };
            if (_viewPortBounds.minX > p.x) {
                offset.x = _viewPortBounds.minX - p.x;
            } else if (_viewPortBounds.maxX < p.x) {
                offset.x = _viewPortBounds.maxX - p.x;
            }
            if (_viewPortBounds.minY > p.y) {
                offset.y = _viewPortBounds.minY - p.y;
            } else if (_viewPortBounds.maxY < p.y) {
                offset.y = _viewPortBounds.maxY - p.y;
            }
            return offset;
        }
    }

    /**
     * Returns current size for node with considering scale.
     * @param {Node} node
     * @returns {Size}
    */
    function _calculateReferenceNodeSize(elementSize) {
        var minScale = Math.min(_scale.x, _scale.y);
        var scaledElementSize = (0, _utils.globalToScaledSize)(elementSize, {
            x: minScale, y: minScale
        });
        // const scaledElementSize = globalToScaledSize(elementSize, _scale);

        var maxBoundedWidth = self.size.width - parameters.framePadding.x;
        var maxWidth = maxBoundedWidth >= elementSize.minWidth / 3 ? maxBoundedWidth : self.size.width;

        var maxBoundedHeight = self.size.height - parameters.framePadding.y;
        var maxHeight = maxBoundedHeight >= elementSize.minHeight ? maxBoundedHeight : self.size.height;

        var referenceSize = {
            width: Math.min(Math.max(elementSize.minWidth, Math.min(scaledElementSize.width, elementSize.maxWidth)), maxWidth),
            height: Math.min(Math.max(elementSize.minHeight, Math.min(scaledElementSize.height, elementSize.maxHeight)), maxHeight),
            maxWidth: maxWidth,
            maxHeight: maxHeight
        };

        return referenceSize;
    }
}
ViewFrame.prototype = Object.create(joint.shapes.basic.Rect.prototype);
exports.default = ViewFrame;

/**
 * @private
 * @class
 * It's special viewFrame to show all Nodes selected nodes.
 * All nodes are passed with options for parent class.
 * @augments ViewFrame.
 * And this class has the same methods, fields and parameters as ViewFrame.
 */

function OverViewFrame(options, parameters) {
    var self = this;
    var _ratioModifyer = 1;

    self._ownerTest = function () {
        return true;
    };

    self._scaleWillApplied = function (scale) {
        if (_ratioModifyer > 1) {
            return {
                x: scale.x,
                y: scale.x * _ratioModifyer
            };
        } else {
            return {
                x: scale.y / _ratioModifyer,
                y: scale.y
            };
        }
    };

    ViewFrame.apply(self, [options, parameters]);
    _init();

    function _init() {
        var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
        var nodeBounds = self.getNodeBounds();

        var widthIsScalable = nodeBounds.width && nodeBounds.minXNode !== nodeBounds.maxXNode;
        var heightIsScalable = nodeBounds.height && nodeBounds.minYNode !== nodeBounds.maxYNode;
        if (widthIsScalable && heightIsScalable) {
            var xRatio = paperSize.width / nodeBounds.width;
            var yRatio = paperSize.height / nodeBounds.height;

            if (xRatio !== yRatio) {
                _ratioModifyer = yRatio / xRatio;
            }
        }
    }
}
OverViewFrame.prototype = Object.create(ViewFrame.prototype);

},{"../utils/utils":69,"./graphElements/elements":46,"rappid":"rappid"}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FRAME_OUT_MARGIN = exports.DISTANCE_BETWEEN_FRAMES = undefined;
exports.ViewManager = ViewManager;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _viewFrame = require('./viewFrame');

var _elements = require('./graphElements/elements');

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

var _utils = require('../utils/utils');

var _dataUtils = require('../utils/dataUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DISTANCE_BETWEEN_FRAMES = exports.DISTANCE_BETWEEN_FRAMES = 20;
var FRAME_OUT_MARGIN = exports.FRAME_OUT_MARGIN = 20;

/**
 * ViewManager options.
 * @typedef {Object} ViewMangerOptions
 * @property {DataContainer} dataContainer
 * @property {ViewFramePublicModel[]} viewFrames
*/

/**
 * Manage ViewFrames and collect data
 * from them to return to the lineageDiagram render
 * @private
 * @param {ViewMangerOptions} options 
 * @param {Parameters} parameters 
 * @fires change-view-port-position
 * Public methods:
 * ========================================
 * prepareRenderData: (renderOptions) => (Node|Link|ViewFrame)[]
 * getViewFrameForNode: () => ViewFramePublicModel;
 * getVieFrameForNodeByPosition: (node) => ViewFramePublicModel;
 * getViewFrameById: () => ViewFramePublicModel;
 * getOverViewFrame: () => ViewFramePublicModel;
 * fullScreenMode: () => boolean;
 * getViewFrames: () => ViewFramePublicModel[];
 */
function ViewManager(options, parameters) {
    _subscribeable2.default.apply(this); // make this class Subscribable
    var self = this;

    var _terminationNodeSize = parameters.terminationNodeSize;

    var _terminationCellCache = {};
    var _aspectLinksCahe = {};
    var _renderOptions = {};
    var _viewFramesMap = {};
    var _state = {};
    var _dataContainer = void 0;
    var _overViewFrame = void 0;
    var _viewFrames = void 0;
    var _allFrames = void 0;

    var _fullScreenMode = void 0; // changeable

    _init(options, parameters);

    // ===================================================================
    // ===================================================================

    /**
     * Paper render options.
     * @typedef {Object} PaperRenderOptions
     * @property orientation: _orientation,
     * @property width: _paper.el.clientWidth,
     * @property height: _paper.el.clientHeight,
     * @property scale: _scale,
    */

    /**
     * Element render options.
     * @typedef {Object} ElementRenderOptions
     * @property {ElementSize} elementSize
    */

    /**
     * Render options.
     * @typedef {Object} RenderOptions
     * @property {ViewFramePublicModel[]} viewFrames
     * @property {boolean} fullScreenMode
     * @property {Object.<string, (Node|Link)>} path
     * @property {Object.<string, (Node|Link)>} mask
     * @property {boolean} updateBounds
     * @property {boolean} quickUpdate
     * @property {PaperRenderOptions} paperOptions
     * @property {ElementRenderOptions} elementOptions
    */

    /**
     * 1. Takes render data from the ViewFrames,
     * 2. Updates ViewFrames state
     * 3. Changes size and scale of viewFrames
     * 4. Updates highlighting
     * @param {RenderOptions} renderOptions
     * @returns {(Node|Link|ViewFrame)[]}
     */
    self.prepareRenderData = function (renderOptions) {
        _updateViewFrames(renderOptions);

        var visibleViewFrames = _getVisibleViewFrames();
        var viewFrameResults = visibleViewFrames.map(function (vf) {
            return vf.getVisibleCells();
        });
        var renderResults = _calculateRenderData(viewFrameResults, renderOptions);
        _setHighlighting(renderResults, renderOptions);

        return visibleViewFrames.concat(renderResults);
    };

    /**
     * Returns ViewFrame for the node which currently renders this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameForNode = function (node) {
        return _getViewFramePublicModel(_getViewFrameForNode(node));
    };

    /**
     * Returns ViewFrame which currently owns this node.
     * @param {Node} node
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameOwner = function (node) {
        var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Node} node
     * @returns {ViewFramePublicModel | undefined}
    */
    self.getVieFrameForNodeByPosition = function (node) {
        if (_fullScreenMode) return undefined;

        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];

            if (vf.hitTestByScaledPosition(node)) return _getViewFramePublicModel(vf);
        }
        return undefined;
    };

    /**
     * Returns ViewFrame for the node by his position.
     * @param {Point} point
     * @returns {ViewFramePublicModel}
    */
    self.getVieFrameByScreenPoint = function (point) {
        var visibleFrames = _getVisibleViewFrames();
        for (var i = 0; i < visibleFrames.length; i++) {
            var vf = visibleFrames[i];
            if (vf.hitScaledPointTest(point)) {
                return _getViewFramePublicModel(vf);
            }
        }
        return undefined;
    };

    /**
     * Restores default size of ViewFrames
     */
    self.resetFrameLayout = function () {
        _viewFrames.forEach(function (vf) {
            vf.resetSize();
        });
    };

    /**
     * Returns ViewFrame by id
     * @param {string} id
     * @returns {ViewFramePublicModel | undefined}
     */
    self.getViewFrameById = function (viewFrameId) {
        return _getViewFramePublicModel(_viewFramesMap[viewFrameId]);
    };

    /**
     * Returns OverViewFrame
     * @returns {ViewFramePublicModel}
     */
    self.getOverViewFrame = function () {
        return _getViewFramePublicModel(_overViewFrame);
    };

    /**
     * Tells us whether overView is active or not
     * @returns {boolean}
     */
    self.isFullScreenMode = function () {
        return _fullScreenMode;
    };

    /**
     * Returns all ViewFrames
     * @returns {ViewFramePublicModel[]}
    */
    self.getViewFrames = function () {
        return _allFrames.map(function (vf) {
            return _getViewFramePublicModel(vf);
        });
    };

    /**
     * ViewFrame public model
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifyer
     * @property {string} label - Label in the top-right corner
     * @property {string} backgroundColor - Bacground color
     * @property {string} borderColor - Border color
     * @property {boolean} active - Is on the screen
     * @property {boolean} expanded - Is expanded
     * @property {Point} position - Real position on the paper
     * @property {Point} viewPortPosition - Position of the viewPort
     * @property {Bounds} bounds - Real visual bounds of active zone of viewFrame (Zone around nodes)
     * @property {Size} size - Real size of viewFrame
     * @property {boolean} customeSized - Tells us whether size was changed by user or not
     * @property {Bounds} viewPortPositionBounds - Min max values of the position of the viewPort
     * @property {number} spaceShare - relative size of view frame (horizontal/vertical depends on orientation)
     * @property {boolean} updateBounds - Flag to pass into the render pipline
    */

    /**
     * @private
     * @param {ViewFrame} viewFrame
     * @returns {ViewFramePublicModel}
     */
    function _getViewFramePublicModel(viewFrame) {
        if (!viewFrame) return;
        var customeSized = viewFrame.model.width || viewFrame.model.height;

        var isActive = viewFrame === _overViewFrame ? _fullScreenMode : _fullScreenMode ? false : _state[viewFrame.model.id];

        var isExpanded = viewFrame === _overViewFrame ? _fullScreenMode : _state[viewFrame.model.id];

        return {
            id: viewFrame.model.id,
            label: viewFrame.model.label,
            backgroundColor: viewFrame.model.backgroundColor,
            borderColor: viewFrame.model.borderColor,
            active: isActive,
            expanded: isExpanded,
            position: viewFrame.position(), // local
            viewPortPosition: viewFrame.positionViewPort(), // global
            viewPortPositionBounds: viewFrame.getViewPortPositionBounds(), // global
            viewPortBounds: viewFrame.getViewPortBounds(), // global
            nodeBounds: viewFrame.getNodeBounds(), // global
            size: { width: viewFrame.size.width, height: viewFrame.size.height }, // local
            customeSized: customeSized,
            spaceShare: viewFrame.model.spaceShare,
            updateBounds: false,
            isOverView: viewFrame === _overViewFrame,
            scale: viewFrame.getScale()
        };
    }

    /**
     * Updates data model
     * @param {DataContainer} dataContainer - data for the graph
    */
    function _init(options, parameters) {
        _dataContainer = options.dataContainer;
        var map = {};
        var state = {};

        // Create OverView frame
        _overViewFrame = new _viewFrame.OverViewFrame({
            id: 'overViewFrame',
            label: 'Overview',
            dataContainer: _dataContainer,
            resurrectElements: true,
            borderColor: '#23b0f4',
            backgroundColor: '#f4f4ff',
            spaceShare: 1
        }, parameters);
        map[_overViewFrame.id] = _overViewFrame;

        // Create list of ViewFrames
        _viewFrames = options.viewFrames.map(function (model) {
            state[model.id] = model.expanded;
            var viewFrameOptions = _.cloneDeep(model);
            viewFrameOptions.dataContainer = options.dataContainer;
            var viewFrame = new _viewFrame.ViewFrame(viewFrameOptions, parameters);
            map[viewFrame.id] = viewFrame;
            return viewFrame;
        });
        _allFrames = _viewFrames.concat(_overViewFrame);

        _state = state;
        _viewFramesMap = map;
        _fullScreenMode = options.fullScreenMode;

        _subscribeOnViewFrameEvents(_allFrames);
    }

    /**
     * Updates states of viewFrames using renderOptions
     * @param {RenderOptions} renderOptions
    */
    function _updateViewFrames(renderOptions) {
        var newPaperOptions = renderOptions.paperOptions;
        var previousPaperOptions = _renderOptions.paperOptions || {};
        var viewFrameOptions = (0, _utils.arrayToMap)(renderOptions.viewFrames || []);

        var isScaleChanged = !previousPaperOptions.scale || previousPaperOptions.scale.x !== newPaperOptions.scale.x || previousPaperOptions.scale.y !== newPaperOptions.scale.y;
        var isPaperSizeChanged = previousPaperOptions.width !== newPaperOptions.width || previousPaperOptions.height !== newPaperOptions.height;
        var isOrientationChanged = previousPaperOptions.orientation !== newPaperOptions.orientation;

        var oldElementSize = (_renderOptions.elementOptions || {}).elementSize;
        var elementSize = renderOptions.elementOptions.elementSize;
        var isElementSizeChanged = elementSize && (!oldElementSize || elementSize.width !== oldElementSize.width || elementSize.height !== oldElementSize.height || elementSize.minWidth !== oldElementSize.minWidth || elementSize.minHeight !== oldElementSize.minHeight || elementSize.maxWidth !== oldElementSize.maxWidth || elementSize.maxHeight !== oldElementSize.maxHeight);

        var fullScreenModeChanged = renderOptions.fullScreenMode !== undefined && renderOptions.fullScreenMode !== _fullScreenMode;
        var viewFramesStateChanged = _updateViewFrameVisibility(viewFrameOptions) && !_fullScreenMode || fullScreenModeChanged;

        if (fullScreenModeChanged) {
            _fullScreenMode = renderOptions.fullScreenMode;
        }

        var paperOptionsChanged = renderOptions.updateBounds || isPaperSizeChanged || isOrientationChanged || isScaleChanged || viewFramesStateChanged;
        var resizeViewFrames = isPaperSizeChanged || isOrientationChanged || viewFramesStateChanged;

        if (isElementSizeChanged) {
            _setElementsSize(elementSize);
        }
        if (resizeViewFrames) {
            _resizeViewFrames(newPaperOptions);
        }
        if (isScaleChanged) {
            _scaleViewFrames(newPaperOptions.scale);
        }
        if (paperOptionsChanged || isElementSizeChanged || isScaleChanged) {
            _refreshViewFramesBounds();
        }

        _allFrames.forEach(function (viewFrame) {
            var recalculateVisibleElements = false;
            var newViewFrameData = viewFrameOptions[viewFrame.id];

            if (newViewFrameData) {
                var oldViewFrameData = _getViewFramePublicModel(viewFrame);

                var updateBounds = newViewFrameData.updateBounds;
                var portPositionChanged = newViewFrameData.viewPortPosition && (newViewFrameData.viewPortPosition.x !== oldViewFrameData.viewPortPosition.x || newViewFrameData.viewPortPosition.y !== oldViewFrameData.viewPortPosition.y);
                var sizeChanged = newViewFrameData.size && (newViewFrameData.size.width !== oldViewFrameData.size.width || newViewFrameData.size.height !== oldViewFrameData.size.height);
                var positionChanged = newViewFrameData.position && (newViewFrameData.position.x !== oldViewFrameData.position.x || newViewFrameData.position.y !== oldViewFrameData.position.y);

                if (sizeChanged && !resizeViewFrames) {
                    viewFrame.setSize(newViewFrameData.size, newViewFrameData.customeSized);
                    recalculateVisibleElements = true;
                }

                if (positionChanged && !resizeViewFrames) {
                    viewFrame.setPosition(newViewFrameData.position);
                }

                if (updateBounds || sizeChanged && !resizeViewFrames) {
                    viewFrame.updateBounds();
                    recalculateVisibleElements = true;
                }

                if (portPositionChanged && !resizeViewFrames) {
                    viewFrame.positionViewPort(newViewFrameData.viewPortPosition.x, newViewFrameData.viewPortPosition.y);
                    recalculateVisibleElements = true;
                }
            }
            var isExpanded = _state[viewFrame.id] || viewFrame === _overViewFrame && _fullScreenMode;
            var recalculateContent = isExpanded && (recalculateVisibleElements || paperOptionsChanged || isElementSizeChanged);
            if (recalculateContent) {
                viewFrame.calculateVisibleCells();
            }
        });

        _renderOptions = renderOptions;
    }

    /**
     * Updates state of viewFrames (visible/invisible)
     * @param {ViewFramePublicModel[]} viewFrameOptions
     */
    function _updateViewFrameVisibility(viewFrameOptions) {
        var atLeastOneVisibilityChanged = false;
        _viewFrames.forEach(function (viewFrame) {
            var newViewFrameData = viewFrameOptions[viewFrame.id];
            if (newViewFrameData && newViewFrameData.expanded !== undefined) {
                var visibilitiChanged = newViewFrameData.expanded !== _state[viewFrame.id];
                _state[viewFrame.id] = newViewFrameData.expanded;
                atLeastOneVisibilityChanged = atLeastOneVisibilityChanged || visibilitiChanged;
            }
        });
        return atLeastOneVisibilityChanged;
    }

    /**
     * Changes default element size for all ViewFrames
     * @param {ElementSize} elementSize 
     */
    function _setElementsSize(elementSize) {
        _allFrames.forEach(function (vf) {
            vf.setElementSize(elementSize);
        });
    }

    /**
     * Recalculates bounds for all ViewFrames
     * and allign ViewFrames
    */
    function _refreshViewFramesBounds() {
        _allFrames.forEach(function (vf) {
            vf.updateBounds();
            vf.positionViewPort();
        });
    }

    /**
     * Sets and limits value of the scale for the graph.
     * @param {number} scale
     */
    function _scaleViewFrames(scale) {
        if (scale) {
            _allFrames.forEach(function (vf) {
                var oldScale = vf.getScale();
                var pos = vf.positionViewPort();

                vf.setScale(scale);
                var newScale = vf.getScale(); // overViewFrame changes scale before apply

                var scaledSize = vf.get('size');
                var oldSize = (0, _utils.scaledToGlobalSize)(scaledSize, oldScale);
                var newSize = (0, _utils.scaledToGlobalSize)(scaledSize, newScale);

                var curCenter = {
                    x: pos.x + oldSize.width / 2,
                    y: pos.y + oldSize.height / 2
                };

                vf.positionViewPort(curCenter.x - newSize.width / 2, curCenter.y - newSize.height / 2);
            });
        }
    }

    /**
     * Refresh ViewFrames:
     * Adjust viewFrames size to a paper
     * @param {boolean} updateScale
     */
    function _resizeViewFrames(options) {
        var visibleFrames = _getVisibleViewFrames();
        var vfNumber = visibleFrames.length;
        var isHorizontalOrientated = options.orientation === 'left-to-right' || options.orientation === 'right-to-left';

        if (options.width === 0 || options.height === 0 || vfNumber <= 0) return;
        var totalShare = 0;
        visibleFrames.forEach(function (vf) {
            totalShare += vf.model.spaceShare;
        });

        var width = options.width - FRAME_OUT_MARGIN * 2;
        var height = options.height - FRAME_OUT_MARGIN * 2;

        var cutedWidth = width - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);
        var cutedHeight = height - DISTANCE_BETWEEN_FRAMES * (vfNumber - 1);

        var segmentWidth = cutedWidth / totalShare;
        var segmentHeight = cutedHeight / totalShare;

        var scale = 1;
        var length = 0;
        var freeLength = 0;
        visibleFrames.forEach(function (viewFrame) {
            if (isHorizontalOrientated) {
                if (viewFrame.model.width) {
                    length += viewFrame.model.width;
                } else {
                    freeLength += segmentWidth * (viewFrame.model.spaceShare || 1);
                }
            } else {
                if (viewFrame.model.height) {
                    length += viewFrame.model.height;
                } else {
                    freeLength += segmentHeight * (viewFrame.model.spaceShare || 1);
                }
            }
        });

        if (isHorizontalOrientated) {
            scale = (cutedWidth - freeLength) / length;
        } else {
            scale = (cutedHeight - freeLength) / length;
        }

        var curPoint = { x: FRAME_OUT_MARGIN, y: FRAME_OUT_MARGIN };

        if (options.orientation === 'top-to-bottom') {

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var MINIMAL_VF_SIZE = { width: 1, height: 1 };
                var size = {
                    width: Math.max(width, MINIMAL_VF_SIZE.width),
                    height: Math.max(vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1), MINIMAL_VF_SIZE.height)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            });
        } else if (options.orientation === 'bottom-to-top') {

            for (var i = visibleFrames.length - 1; i >= 0; i--) {
                var vf = visibleFrames[i];

                if (vf.model.width) vf.model.width = undefined;
                if (vf.model.height) vf.model.height *= scale;

                var size = {
                    width: width,
                    height: vf.model.height ? vf.model.height : segmentHeight * (vf.model.spaceShare || 1)
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: FRAME_OUT_MARGIN, y: curPoint.y + size.height + DISTANCE_BETWEEN_FRAMES };
            }
        } else if (options.orientation === 'right-to-left') {

            for (var _i = visibleFrames.length - 1; _i >= 0; _i--) {
                var _vf = visibleFrames[_i];

                if (_vf.model.width) _vf.model.width *= scale;
                if (_vf.model.height) _vf.model.height = undefined;

                var _size = {
                    width: _vf.model.width ? _vf.model.width : segmentWidth * (_vf.model.spaceShare || 1),
                    height: height
                };

                _vf.setPosition(curPoint);
                _vf.setSize(_size);

                curPoint = { x: curPoint.x + _size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            }
        } else {
            // horizontal

            visibleFrames.forEach(function (vf) {
                if (vf.model.width) vf.model.width *= scale;
                if (vf.model.height) vf.model.height = undefined;

                var size = {
                    width: vf.model.width ? vf.model.width : segmentWidth * (vf.model.spaceShare || 1),
                    height: height
                };

                vf.setPosition(curPoint);
                vf.setSize(size);

                curPoint = { x: curPoint.x + size.width + DISTANCE_BETWEEN_FRAMES, y: FRAME_OUT_MARGIN };
            });
        }

        visibleFrames.forEach(function (viewFrame) {
            viewFrame.updateBounds();
            // We want not to be in the empty space after resizing but somwhere near the nodes.
            var viewPortPositionBounds = viewFrame.getViewPortPositionBounds();
            var visibleCells = viewFrame.getVisibleCells();
            if (!visibleCells || visibleCells.nodes.length === 0) {
                var nodes = viewFrame.getNodes();
                if (nodes.length > 0) {
                    var nodeToFocus = nodes[Math.round(Math.random() * (nodes.length - 1))];
                    var nodeScaledPos = (0, _utils.getScaledNodePosition)(nodeToFocus, options.scale);
                    var newPosition = {
                        x: nodeScaledPos.x - (viewFrame.size.width - nodeToFocus.size.width) / 2,
                        y: nodeScaledPos.y - (viewFrame.size.height - nodeToFocus.size.height) / 2
                    };
                    var _limitedPoint = (0, _utils.limitPointPosition)(newPosition, viewPortPositionBounds);
                    viewFrame.positionViewPort(_limitedPoint.x, _limitedPoint.y);
                }
            }
            var limitedPoint = (0, _utils.limitPointPosition)(viewFrame.positionViewPort(), viewPortPositionBounds);
            viewFrame.positionViewPort(limitedPoint.x, limitedPoint.y);
        });
    }

    /**
     * Get data (Cells) from ViewFrames,
     * processes it (add termination and aspect elements)
     * and returns to the render pipline
     * @returns {(Link|Node|TerminationNode|TerminationLink|AspectLink)[]}
     */
    function _calculateRenderData(viewFrameResults, renderOptions) {
        var nodes = [];
        var links = [];
        var badLinks = [];
        var visibleNodeMap = {};

        viewFrameResults.forEach(function (result) {
            return result.nodes.forEach(function (node) {
                visibleNodeMap[node.id] = node;
                nodes.push(node);
            });
        });

        viewFrameResults.forEach(function (result) {
            return result.links.forEach(function (link) {
                if (visibleNodeMap[link.model.source] && visibleNodeMap[link.model.target]) {
                    if (!renderOptions.quickUpdate) links.push(link);
                } else if (visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) {
                    badLinks.push(link);
                }
            });
        });

        var terminationCellMap = {};
        var terminationNodes = [];
        var terminationLinks = [];
        if (renderOptions.selectedElement) {
            var selectedNodes = _getSelectedNodes(renderOptions.selectedElement);
            selectedNodes.forEach(function (selectedNode) {
                var terminationOrigins = _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks);
                var viewFrame = _getViewFrameForNode(selectedNode);

                if (viewFrame && (_state[viewFrame.id] || _fullScreenMode)) {
                    terminationOrigins.nodes.forEach(function (node) {
                        var nodeCacheId = node.id + '_at_' + viewFrame.id;
                        var terminationNode = _terminationCellCache[nodeCacheId];
                        if (terminationNode) {
                            terminationNode.set('dragged', false);
                        } else {
                            terminationNode = new _elements.TerminationNode({
                                node: node
                            }, parameters);
                        }
                        terminationCellMap[nodeCacheId] = terminationNode;
                        var position = _getTerminationNodePosition(terminationNode, viewFrame, renderOptions);
                        terminationNode.position(position.x, position.y);
                        terminationNodes.push(terminationNode);
                    });
                    if (!renderOptions.quickUpdate) {
                        terminationOrigins.links.forEach(function (link) {
                            var linkCacheId = link.id + '_at_' + viewFrame.id;
                            var sourceCacheId = link.model.source + '_at_' + viewFrame.id;
                            var targetCacheId = link.model.target + '_at_' + viewFrame.id;
                            var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                                link: link,
                                source: terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source],
                                target: terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target]
                            }, parameters);
                            terminationCellMap[linkCacheId] = terminationLink;
                            terminationLinks.push(terminationLink);
                        });
                    }
                }
            });

            var link = renderOptions.selectedElement;
            var addTerminationLinks = link instanceof _elements.Link && (!(visibleNodeMap[link.model.source] || visibleNodeMap[link.model.target]) || renderOptions.quickUpdate);
            if (addTerminationLinks) {
                var nodeMap = _dataContainer.maps.nodeMap;

                var sourceViewFrame = _getViewFrameForNode(nodeMap[link.model.source]);
                var targetViewFrame = _getViewFrameForNode(nodeMap[link.model.target]);

                if (sourceViewFrame && targetViewFrame) {
                    var sourceViewFrameId = sourceViewFrame.id;
                    var targetViewFrameId = targetViewFrame.id;

                    var sourceCacheId = link.model.source + '_at_' + sourceViewFrameId;
                    var targetCacheId = link.model.target + '_at_' + targetViewFrameId;

                    var source = terminationCellMap[sourceCacheId] || visibleNodeMap[link.model.source];
                    var target = terminationCellMap[targetCacheId] || visibleNodeMap[link.model.target];

                    var linkCacheId = source.id + '~#~' + target.id;
                    var terminationLink = _terminationCellCache[linkCacheId] || new _elements.TerminationLink({
                        link: link,
                        source: source,
                        target: target
                    }, parameters);
                    terminationCellMap[linkCacheId] = terminationLink;
                    terminationLinks.push(terminationLink);
                }
            }
        }
        _terminationCellCache = terminationCellMap;

        var visibleNodes = nodes.concat(terminationNodes);
        var aspectLinks = renderOptions.quickUpdate ? [] : _calculateAspectLinks(visibleNodes);
        var visibleLinks = links.concat(terminationLinks).concat(aspectLinks);

        return visibleNodes.concat(visibleLinks);
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node|Link} selectedElement
     * @returns {Node[]}
     */
    function _getSelectedNodes(selectedElement) {
        var nodeMap = _dataContainer.maps.nodeMap;
        var isNode = selectedElement instanceof _elements.Node;
        return isNode ? [selectedElement] : [nodeMap[selectedElement.model.source], nodeMap[selectedElement.model.target]];
    }

    /**
     * If the Link is selected then we represent
     * it as two selected nodes
     * @param {Node} selectedNode
     * @param {Object.<string, Node>} visibleNodeMap - Visible nodes
     * @param {Link[]} badLinks - Links which have either source either target is not visible
     * @returns {Node[], Link[]}
     */
    function _getTerminationOrigins(selectedNode, visibleNodeMap, badLinks) {
        var terminationOriginNodes = [];
        var terminationOriginLinks = [];
        var processedCellIds = {};
        var nodeMap = _dataContainer.maps.nodeMap;

        var isSelectedNodeVisible = visibleNodeMap[selectedNode.id];
        if (isSelectedNodeVisible) {
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    var terminationsHaveViewFrames = link.model.source === selectedNode.id ? _getViewFrameForNode(nodeMap[link.model.target]) : _getViewFrameForNode(nodeMap[link.model.source]);
                    if (isLinkConnectedToSelectedNode && terminationsHaveViewFrames) {
                        terminationOriginLinks.push(link);

                        var sourceIsntVisible = !visibleNodeMap[link.model.source];
                        if (sourceIsntVisible && !processedCellIds[link.model.source]) {
                            processedCellIds[link.model.source] = true;
                            terminationOriginNodes.push(nodeMap[link.model.source]);
                        }

                        var targetIsntVisible = !visibleNodeMap[link.model.target];
                        if (targetIsntVisible && !processedCellIds[link.model.target]) {
                            processedCellIds[link.model.target] = true;
                            terminationOriginNodes.push(nodeMap[link.model.target]);
                        }
                    }
                }
            });
        } else {
            terminationOriginNodes.push(selectedNode);
            badLinks.forEach(function (link) {
                if (!processedCellIds[link.id]) {
                    processedCellIds[link.id] = true;
                    var isLinkConnectedToSelectedNode = link.model.source === selectedNode.id || link.model.target === selectedNode.id;
                    if (isLinkConnectedToSelectedNode) {
                        terminationOriginLinks.push(link);
                    }
                }
            });
        }

        return {
            nodes: terminationOriginNodes,
            links: terminationOriginLinks
        };
    }

    /**
     * Returns position for the termination node.
     * @param {TerminationNode} terminationNode
     * @param {ViewFrame} viewFrame
     * @param {RenderOption} renderOptions
     * @returns {Point}
    */
    function _getTerminationNodePosition(terminationNode, viewFrame, renderOptions) {
        var originalNode = terminationNode.originalNode;
        var viewFrameSize = viewFrame.size; // local size
        var viewFramePosition = viewFrame.position(); // local position
        var nodeSize = originalNode.size; // local size

        var topLeft = viewFramePosition;
        var topRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y };
        var bottomLeft = { x: viewFramePosition.x, y: viewFramePosition.y + viewFrameSize.height };
        var bottomRight = { x: viewFramePosition.x + viewFrameSize.width, y: viewFramePosition.y + viewFrameSize.height };

        var calculationPoints = getCalculationPoints();
        var sourcePoint = calculationPoints.sourcePoint;
        var terminationPoint = calculationPoints.terminationPoint;

        // choose a side for termination node

        var crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, bottomLeft); // left

        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topLeft, topRight); // top
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, topRight, bottomRight); // right
        }
        if (!crossPoint) {
            crossPoint = (0, _lineageDiagramUtils.getCrosPoint)(sourcePoint, terminationPoint, bottomLeft, bottomRight); // bottom
        }

        if (crossPoint) {
            return {
                x: crossPoint.x - _terminationNodeSize.width / 2,
                y: crossPoint.y - _terminationNodeSize.height / 2
            };
        } else {
            return {
                x: Math.min(Math.max(terminationPoint.x + nodeSize.width / 2, viewFramePosition.x), viewFramePosition.x + viewFrameSize.width),
                y: Math.min(Math.max(terminationPoint.y + nodeSize.height / 2, viewFramePosition.y), viewFramePosition.y + viewFrameSize.height)
            };
        }

        function getCalculationPoints() {
            var sourcePoint = {
                x: viewFramePosition.x + viewFrameSize.width / 2,
                y: viewFramePosition.y + viewFrameSize.height / 2
            };

            var ownerViewFrame = _getViewFrameForNode(originalNode);
            var scale = ownerViewFrame.getScale();
            var nodePosition = (0, _utils.getLocalNodePosition)(originalNode, scale, ownerViewFrame);
            var terminationPoint = {
                x: nodePosition.x + nodeSize.width / 2,
                y: nodePosition.y + nodeSize.height / 2
            };

            var pointIsInTheFrame = viewFrame.hitScaledPointTest(terminationPoint);
            if (pointIsInTheFrame) {
                var distToLeft = terminationPoint.x - viewFramePosition.x;
                var distToTop = terminationPoint.y - viewFramePosition.y;
                var distToRight = viewFramePosition.x + viewFrameSize.width - terminationPoint.x;
                var distToBottom = viewFramePosition.y + viewFrameSize.height - terminationPoint.y;

                var min = Infinity;
                [distToLeft, distToTop, distToRight, distToBottom].forEach(function (dist) {
                    min = Math.min(min, dist);
                });

                if (min === distToLeft) {
                    terminationPoint.x -= min;
                } else if (min === distToRight) {
                    terminationPoint.x += min;
                } else if (min === distToTop) {
                    terminationPoint.y -= min;
                } else {
                    terminationPoint.y += min;
                }
            }

            // Sometime it's confusing for users when
            // nodes are in the leftViewFrame but termination nodes goes to the right
            if (ownerViewFrame.id !== viewFrame.id) {
                var ids = _allFrames.map(function (vf) {
                    return vf.id;
                });
                var viewFrameIndex = ids.indexOf(viewFrame.id);
                var ownerViewFrameIndex = ids.indexOf(ownerViewFrame.id);
                var orientation = renderOptions.paperOptions.orientation;
                var isHorizontalOrientated = orientation === 'left-to-right' || orientation === 'right-to-left';
                if (viewFrameIndex < ownerViewFrameIndex) {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = bottomRight.x;
                    } else {
                        terminationPoint.y = bottomRight.y;
                    }
                } else {
                    if (isHorizontalOrientated) {
                        terminationPoint.x = topLeft.x;
                    } else {
                        terminationPoint.y = topLeft.y;
                    }
                }
            }

            return {
                sourcePoint: sourcePoint,
                terminationPoint: terminationPoint
            };
        }
    }

    /**
     * Creates (or get from cache) aspect links
     * @param {Node[]} nodes - visible nodes
     * @returns {AspectLink[]}
    */
    function _calculateAspectLinks(nodes) {
        var aspectLinksCache = {};
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        nodes.forEach(function (node) {
            var aspects = (0, _dataUtils.getBaseElement)(node).aspects;
            aspects.forEach(function (aspect) {
                var visibleTerminations = aspect.terminationNodes.filter(function (tn) {
                    return nodeMap[tn.id];
                });
                var atLeastOneTermination = visibleTerminations.length > 0;
                var aspectWillOnThePaper = nodeMap[aspect.id] || atLeastOneTermination;
                var viewFrameOwner = _getViewFrameForNode(aspect);
                var viewFrameOwnerIsVisible = _state[viewFrameOwner.id] || _fullScreenMode;
                if (aspectWillOnThePaper && viewFrameOwnerIsVisible) {
                    var aspectInstances = nodeMap[aspect.id] ? [aspect] : visibleTerminations;

                    aspectInstances.forEach(function (aspectInstance) {
                        var cachedLink = getFromCahe(node, aspectInstance);
                        var aspectLink = cachedLink || createAspectLink(node, aspectInstance);

                        aspectLinksCache[aspectLink.id] = aspectLink;
                    });
                }
            });
        });
        _aspectLinksCahe = aspectLinksCache;
        var aspectLinks = Object.keys(aspectLinksCache).map(function (id) {
            return _aspectLinksCahe[id];
        });
        return aspectLinks;

        function createAspectLink(node, aspect) {
            var id = node.id + '~#~' + aspect.id;

            return new _elements.AspectLink({
                id: id,
                source: node,
                target: aspect
            }, parameters);
        }

        function getFromCahe(node, aspect) {
            var id = node.id + '~#~' + aspect.id;
            var reverseId = aspect.id + '~#~' + node.id;

            var linkFromLocal = aspectLinksCache[id] || aspectLinksCache[reverseId];
            var linkFromGlobal = _aspectLinksCahe[id] || _aspectLinksCahe[reverseId];
            return linkFromLocal || linkFromGlobal;
        }
    }

    /**
     * Changes highlighting of the elements
     * @param {(Node|Link|TerminationNode|TerminationLink)[]} cells
     * @param {RenderOption} renderOptions
    */
    function _setHighlighting(cells, renderOptions) {
        var path = renderOptions.path;
        var mask = renderOptions.mask;

        cells.forEach(function (cell) {
            var baseCell = (0, _dataUtils.getBaseElement)(cell);
            if (mask && baseCell !== renderOptions.selectedElement) {
                if (mask[baseCell.id]) {
                    baseCell.hide();
                } else {
                    baseCell.show();
                }
            }
            if (baseCell === renderOptions.selectedElement) {
                baseCell.select();
            } else if (path && !path[baseCell.id]) {
                baseCell.blure();
            } else {
                baseCell.unblure();
            }
        });
    }

    /**
     * Returns list of visible viewFrames
     * @returns {ViewFrame[]}
    */
    function _getVisibleViewFrames() {
        return _fullScreenMode ? [_overViewFrame] : _viewFrames.filter(function (vf) {
            return _state[vf.id];
        });
    }

    /**
     * Returns viewFrame for the node.
     * @param {Node} node
     * @returns {ViewFrame | undefined}
     */
    function _getViewFrameForNode(node) {
        if (_fullScreenMode) {
            return _overViewFrame;
        } else {
            var viewFrameId = (0, _lineageDiagramUtils.getViewFrameIdForNode)(node);
            return _viewFramesMap[viewFrameId];
        }
    }

    /**
     * Subscribes on viewFrame events
    */
    function _subscribeOnViewFrameEvents() {
        _allFrames.forEach(function (viewFrame) {
            viewFrame.on('change-view-port-position', function (newViewPortPosition) {
                if (viewFrame.movingByItself) return;

                var viewFramePublicModel = _getViewFramePublicModel(viewFrame);
                viewFramePublicModel.viewPortPosition = newViewPortPosition;

                self.trigger('change-view-port-position', viewFramePublicModel);
            });
        });
    }
}

exports.default = ViewManager;

},{"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/lineageDiagramUtils":68,"../utils/utils":69,"./graphElements/elements":46,"./viewFrame":54,"lodash":"lodash"}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.combineOperation = combineOperation;
exports.doLayout = doLayout;
exports.removeCycles = removeCycles;

var _webcola = require('webcola');

var cola = _interopRequireWildcard(_webcola);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _sankey = require('./sankey');

var _sankey2 = _interopRequireDefault(_sankey);

var _utils = require('../utils/utils');

var _layoutUtils = require('../utils/layoutUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * @param {{
 *  selectedNode: Node,
 *  relativeLinks: Link[],
 *  relativeNodes: Node[],
 * }} options 
 * @param {Parameters} parameters - parameters set
 */
function combineOperation(options, parameters) {
    var scale = options.scale;

    var startPosition = (0, _utils.getGlobalNodePosition)(options.selectedNode);
    var combinedNodes = [options.selectedNode].concat(options.relativeNodes);

    var elements = (0, _layoutUtils.convertLGElementsToLayoutModels)(combinedNodes, options.relativeLinks, {
        scale: scale
    });
    var nodes = elements.nodes;
    var links = elements.links;
    var selectedLayoutNode = nodes[0];

    var layoutOptions = {
        nodes: nodes,
        links: links,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };
    tqForceLayout(layoutOptions);

    var result = {};
    nodes.forEach(function (layoutNode) {
        if (layoutNode !== selectedLayoutNode) {
            layoutNode.x = startPosition.x + (layoutNode.x - selectedLayoutNode.x);
            layoutNode.y = startPosition.y + (layoutNode.y - selectedLayoutNode.y);
        }
        result[layoutNode.originalNode.id] = {
            x: layoutNode.x,
            y: layoutNode.y
        };
    });

    return result;
}

/**
 * @private 
 * 
 * Calculates positions for nodes.
 * @param {Array} nodeModels - list of the native nodes
 * @param {Array} nativeLinks - list of the native links
 * @param {Parameters} parameters - parameters set
 */
function doLayout(nodeModels, linkModels, viewFrames, parameters) {
    if (!parameters) return;

    var elements = (0, _layoutUtils.convertNativeToLayoutModels)(nodeModels, linkModels, parameters);
    var nodes = elements.nodes;
    var links = elements.links;
    var isHorizontal = parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'left-to-right';

    removeCycles(nodes, links);

    var groups = breakByGroups(nodes, links, viewFrames, parameters);

    var layoutOptions = {
        groups: groups,
        nodes: nodes,
        links: links,
        isHorizontal: isHorizontal,
        step: parameters.layoutStep,
        element: parameters.elementSize,
        iterations: parameters.layoutIterations
    };

    if (parameters.layoutAlgorithm === 'flow-directed') {
        tqFlowLayout(layoutOptions);
    } else {
        tqSankeyLayout(layoutOptions);
    }
    applyLayout();

    function applyLayout() {
        // Calculating min points
        var minX = Infinity,
            minY = Infinity;
        nodes.forEach(function (node) {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
        });

        var maxX = nodes.length > 0 ? -Infinity : 0;
        var canvasPadding = Math.max(parameters.elementSize.width, parameters.elementSize.height) * 2 * parameters.scaleBounds.max;
        nodes.forEach(function (node) {
            node.originalNode.position.x = node.x - minX + canvasPadding;
            node.originalNode.position.y = node.y - minY + canvasPadding;
            maxX = Math.max(maxX, node.originalNode.position.x);
        });

        if (parameters.graphOrientation === 'right-to-left' || parameters.graphOrientation === 'bottom-to-top') {
            nodeModels.forEach(function (node) {
                node.position.x = maxX - node.position.x;
            });
        }

        if (!isHorizontal) {
            nodeModels.forEach(function (node) {
                var x = node.position.x;
                node.position.x = node.position.y;
                node.position.y = x;
            });
        }

        nodeModels.forEach(function (node) {
            node.defaultPosition = _.clone(node.position);
        });
    }
}

function removeCycles(nodes, links) {
    nodes.forEach(function (n) {
        var repeatMap = {};
        var linksToRemove = [];

        recursion(n);

        linksToRemove.forEach(function (link) {
            links.splice(links.indexOf(link), 1);
            link.target.sourceLinks.splice(link.target.sourceLinks.indexOf(link), 1);
            link.source.targetLinks.splice(link.source.targetLinks.indexOf(link), 1);
        });

        function recursion(node) {
            repeatMap[node.id] = true;
            node.targetLinks.forEach(function (link) {
                if (!repeatMap[link.target.id]) {
                    recursion(link.target);
                } else {
                    linksToRemove.push(link);
                }
            });
            repeatMap[node.id] = false;
        }
    });
}

function breakByGroups(nodes, links, viewFrames, parameters) {
    var nodeMap = (0, _utils.arrayToMap)(nodes);
    var groups = {};
    var paperSize = (0, _utils.getElementSize)(parameters.graphPlace);
    var isHorizontal = parameters.graphOrientation === 'left-to-right' || parameters.graphOrientation === 'right-to-left';
    var totalShare = viewFrames.reduce(function (accumulator, viewFrame) {
        return accumulator + viewFrame.spaceShare;
    }, 0);
    viewFrames.forEach(function (viewFrame) {
        if (!groups[viewFrame.id]) groups[viewFrame.id] = {
            id: viewFrame.id,
            prefferedSize: {
                width: isHorizontal ? paperSize.width / totalShare * viewFrame.spaceShare : paperSize.height / totalShare * viewFrame.spaceShare,
                height: isHorizontal ? paperSize.height : paperSize.width
            },
            nodes: [],
            links: []
        };

        var lastNodes = [];
        nodes.forEach(function (node) {
            if (node.viewFrame === viewFrame.id) {
                groups[viewFrame.id].nodes.push(node);
            } else {
                lastNodes.push(node);
            }
        });
        nodes = lastNodes;

        var lastLinks = [];
        links.forEach(function (l) {
            if (nodeMap[l.source.id].viewFrame === viewFrame.id && nodeMap[l.target.id].viewFrame === viewFrame.id) {
                groups[viewFrame.id].links.push(l);
            } else if (nodeMap[l.source.id].viewFrame !== viewFrame.id && nodeMap[l.target.id].viewFrame !== viewFrame.id) {
                lastLinks.push(l);
            }
        });
        links = lastLinks;
    });
    groups['unknown'] = { id: 'unknown', nodes: nodes, links: links };
    return Object.keys(groups).map(function (key) {
        return groups[key];
    });
}

function tqSankeyLayout(options) {
    var step = options.isHorizontal ? [options.step.x || 100, options.step.y || 15] : [options.step.y || 15, options.step.x || 100];
    options.step = options.step || {};
    (0, _sankey2.default)().step(step).nodeWidth(options.element.width).nodeHeight(options.element.height).nodes(options.nodes).links(options.links).groups(options.groups).layout(options.iterations);
}

function tqFlowLayout(options) {
    tqSankeyLayout(options);

    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 2 || 400).flowLayout('x', options.step.x * 2 || 400).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

function tqForceLayout(options) {
    var layout = new cola.Layout().nodes(options.nodes).links(options.links).convergenceThreshold(1e-9).jaccardLinkLengths(options.step.x * 1.5 || 350).avoidOverlaps(true).handleDisconnected(true);
    layout.start(100, 0, 50, undefined, false);
}

},{"../utils/layoutUtils":67,"../utils/utils":69,"./sankey":57,"lodash":"lodash","webcola":5}],57:[function(require,module,exports){
'use strict';

var _layoutUtils = require('../utils/layoutUtils');

var utils = _interopRequireWildcard(_layoutUtils);

var _utils = require('../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Sankey = function Sankey() {
    var sankey = {},
        nodeWidth = 24,
        nodeHeight = 8,
        size = [1, 1],
        step = [100, 30],
        nodes = [],
        groups = [],
        saveOrder = false,
        links = [];

    sankey.nodeWidth = function (_) {
        if (!arguments.length) return nodeWidth;
        nodeWidth = +_;
        return sankey;
    };

    sankey.nodeHeight = function (_) {
        if (!arguments.length) return nodeHeight;
        nodeHeight = +_;
        return sankey;
    };

    sankey.nodes = function (_) {
        if (!arguments.length) return nodes;
        nodes = _;
        return sankey;
    };

    sankey.saveOrder = function (_) {
        if (!arguments.length) return saveOrder;
        saveOrder = _;
        return sankey;
    };

    sankey.groups = function (_) {
        if (!arguments.length) return groups;
        groups = _;
        return sankey;
    };

    sankey.links = function (_) {
        if (!arguments.length) return links;
        links = _;
        return sankey;
    };

    sankey.step = function (_) {
        if (!arguments.length) return step;
        step = _;
        return sankey;
    };

    sankey.computeNodeBreadths = undefined;

    sankey.layout = function (iterations) {
        computeNodeLinks();
        computeNodeValues();

        if (sankey.computeNodeBreadths) sankey.computeNodeBreadths(nodes, links, groups);else computeNodeBreadths();

        computeNodeDepths(iterations);
        computeLinkDepths();
        return sankey;
    };

    sankey.relayout = function () {
        computeLinkDepths();
        return sankey;
    };

    sankey.link = function () {
        var curvature = .5;

        function link(d) {
            var x0 = d.source.x + d.source.dx,
                x1 = d.target.x,
                xi = utils.interpolateNumber(x0, x1),
                x2 = xi(curvature),
                x3 = xi(1 - curvature),
                y0 = d.source.y + d.sy + d.dy / 2,
                y1 = d.target.y + d.ty + d.dy / 2;
            return 'M' + x0 + ',' + y0 + 'C' + x2 + ',' + y0 + ' ' + x3 + ',' + y1 + ' ' + x1 + ',' + y1;
        }

        link.curvature = function (_) {
            if (!arguments.length) return curvature;
            curvature = +_;
            return link;
        };

        return link;
    };

    // Populate the sourceLinks and targetLinks for each node.
    // Also, if the source and target are not objects, assume they are indices.
    function computeNodeLinks() {
        nodes.forEach(function (node) {
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        links.forEach(function (link) {
            var source = link.source,
                target = link.target;
            if (typeof source === 'number') source = link.source = nodes[link.source];
            if (typeof target === 'number') target = link.target = nodes[link.target];
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
    }

    // Compute the value (size) of each node by summing the associated links.
    function computeNodeValues() {
        nodes.forEach(function (node) {
            node.value = Math.max(utils.sum(node.sourceLinks, value), utils.sum(node.targetLinks, value)) || 1;
        });
    }

    // Iteratively assign the breadth (x-position) for each node.
    // Nodes are assigned the maximum breadth of incoming neighbors plus one;
    // nodes with no incoming links are assigned breadth zero, while
    // nodes with no outgoing links are assigned the maximum breadth.

    function computeNodeBreadths() {
        groups.forEach(function (group) {
            var nodesOfGrpoup = (0, _utils.arrayToMap)(group.nodes);
            var remainingNodes = group.nodes;
            var nextNodes = void 0;

            remainingNodes.sort(function (n1, n2) {
                var result = getLinks(n2.sourceLinks).length - getLinks(n1.sourceLinks).length;
                if (result === 0) {
                    return getLinks(n2.targetLinks).length - getLinks(n1.targetLinks).length;
                } else {
                    return result;
                }
            });

            var x = 0;
            var startX = x;
            while (remainingNodes.length > 0) {
                nextNodes = [];
                remainingNodes.forEach(function (node) {
                    node.x = x;
                    node.dx = nodeWidth;

                    // Here we are going to use iverse direction to make nodes closer to their targets
                    // so we pass targetLinks instead of sourceLinks
                    getLinks(node.targetLinks).forEach(function (link) {
                        if (nextNodes.indexOf(link.source) < 0) {
                            nextNodes.push(link.source);
                        }
                    });
                });
                remainingNodes = nextNodes;
                ++x;
            }
            group.breadth = x - startX;

            // Revert direction back
            group.nodes.forEach(function (node) {
                node.x = startX + (x - 1) - node.x;
            });

            function getLinks(links) {
                return links.filter(function (l) {
                    return nodesOfGrpoup[l.source.id];
                });
            }
        });

        var curXPosition = 0;
        groups.forEach(function (group) {
            var groupSize = calculateGroupWidth(group);

            if (group.prefferedSize && group.breadth > 1) {
                groupSize = Math.max(groupSize, group.prefferedSize.width /* * maxK */);
            }
            var kx = group.breadth > 1 ? groupSize / (group.breadth - 1) : 0;
            group.nodes.forEach(function (node) {
                node.x = curXPosition + node.x * kx;
            });
            curXPosition += groupSize + step[0] + nodeWidth;
        });

        function calculateGroupWidth(group) {
            return (group.breadth - 1) * (step[0] + nodeWidth);
        }
    }

    function computeHeight(nodesByBreadth) {
        var maxColumnHeight = 0;
        nodesByBreadth.forEach(function (nodes) {
            maxColumnHeight = Math.max(maxColumnHeight, nodes.length);
        });
        size[1] = maxColumnHeight * nodeHeight + (maxColumnHeight - 1) * step[1];
    }

    function computeNodeDepths(iterations) {
        var nodesByBreadth = utils.nest().key(function (d) {
            return d.x;
        }).sortKeys(function (a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }).entries(nodes).map(function (d) {
            return d.values;
        });

        computeHeight(nodesByBreadth);

        initializeNodeDepth();
        resolveCollisions();
        for (var alpha = 1; iterations > 0; --iterations) {
            relaxRightToLeft(alpha *= .99);
            resolveCollisions();
            relaxLeftToRight(alpha);
            resolveCollisions();
            if (saveOrder) restoreOrder();
        }
        floorToModule();

        function initializeNodeDepth() {
            var ky = utils.min(nodesByBreadth, function (nodes) {
                return (size[1] - (nodes.length - 1) * nodeHeight) / utils.sum(nodes, value);
            });

            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node, i) {
                    node.y = i;
                    node.dy = node.value * ky;
                });
            });

            links.forEach(function (link) {
                link.dy = link.value * ky;
            });
        }

        function relaxLeftToRight(alpha) {
            nodesByBreadth.forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.targetLinks.length) {
                        var y = utils.sum(node.targetLinks, weightedSource) / utils.sum(node.targetLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedSource(link) {
                return center(link.source) * link.value;
            }
        }

        function relaxRightToLeft(alpha) {
            nodesByBreadth.slice().reverse().forEach(function (nodes) {
                nodes.forEach(function (node) {
                    if (node.sourceLinks.length) {
                        var y = utils.sum(node.sourceLinks, weightedTarget) / utils.sum(node.sourceLinks, value);
                        node.y += (y - center(node)) * alpha;
                    }
                });
            });

            function weightedTarget(link) {
                return center(link.target) * link.value;
            }
        }

        function floorToModule() {
            nodesByBreadth.forEach(function (nodes) {
                var placeMap = {};
                nodes.forEach(function (node) {
                    var fullStep = step[1] + nodeHeight;
                    var y = node.y - node.y % fullStep;
                    while (placeMap[y]) {
                        y += fullStep;
                    }
                    node.y = y;
                    placeMap[y] = true;
                });
            });
        }

        function restoreOrder() {
            nodesByBreadth.forEach(function (nodes) {
                for (var i = 0; i < nodes.length; i++) {
                    var nodeA = nodes[i];
                    for (var j = i; j < nodes.length; j++) {
                        var nodeB = nodes[j];
                        if (nodeA.order < nodeB.order && nodeA.y > nodeB.y) {
                            var tempY = nodeA.y;
                            nodeA.y = nodeB.y;
                            nodeB.y = tempY;
                        }
                    }
                }
            });
        }

        function resolveCollisions() {
            nodesByBreadth.forEach(function (nodes) {
                var node,
                    dy,
                    y0 = 0,
                    n = nodes.length,
                    i;

                // Push any overlapping nodes down.
                nodes.sort(ascendingDepth);
                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    dy = y0 - node.y;
                    if (dy > 0) node.y += dy;
                    y0 = node.y + node.dy + nodeHeight;
                }

                // If the bottommost node goes outside the bounds, push it back up.
                dy = y0 - nodeHeight - size[1];
                if (dy > 0) {
                    y0 = node.y -= dy;

                    // Push any overlapping nodes back up.
                    for (i = n - 2; i >= 0; --i) {
                        node = nodes[i];
                        dy = node.y + node.dy + nodeHeight - y0;
                        if (dy > 0) node.y -= dy;
                        y0 = node.y;
                    }
                }
            });
        }

        function ascendingDepth(a, b) {
            return a.y - b.y;
        }
    }

    function computeLinkDepths() {
        nodes.forEach(function (node) {
            node.sourceLinks.sort(ascendingTargetDepth);
            node.targetLinks.sort(ascendingSourceDepth);
        });
        nodes.forEach(function (node) {
            var sy = 0,
                ty = 0;
            node.sourceLinks.forEach(function (link) {
                link.sy = sy;
                sy += link.dy;
            });
            node.targetLinks.forEach(function (link) {
                link.ty = ty;
                ty += link.dy;
            });
        });

        function ascendingSourceDepth(a, b) {
            return a.source.y - b.source.y;
        }

        function ascendingTargetDepth(a, b) {
            return a.target.y - b.target.y;
        }
    }

    function center(node) {
        return node.y + node.dy / 2;
    }

    function value(link) {
        return link.value;
    }

    return sankey;
};
module.exports = Sankey;

},{"../utils/layoutUtils":67,"../utils/utils":69}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getDefaultParametersSet = getDefaultParametersSet;
exports.LineageGram = LineageGram;

var _visualizationsLibrary = require('visualizations-library');

var _visualizationsLibrary2 = _interopRequireDefault(_visualizationsLibrary);

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _layout = require('./layout/layout');

var layout = _interopRequireWildcard(_layout);

var _elements = require('./jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _lineageDiagram2 = require('./jointViews/lineageDiagram');

var _lineageDiagram3 = _interopRequireDefault(_lineageDiagram2);

var _derivationMap2 = require('./jointViews/derivationMap/derivationMap');

var _derivationMap3 = _interopRequireDefault(_derivationMap2);

var _graphMap2 = require('./sigmaViews/graphMap');

var _graphMap3 = _interopRequireDefault(_graphMap2);

var _birdEye2 = require('./sigmaViews/birdEye');

var _birdEye3 = _interopRequireDefault(_birdEye2);

var _dataContainer2 = require('./data/dataContainer');

var _dataContainer3 = _interopRequireDefault(_dataContainer2);

var _stateStorage2 = require('./stateStorage');

var _stateStorage3 = _interopRequireDefault(_stateStorage2);

var _subscribeable = require('./subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _resourceProvider = require('./data/resourceProvider');

var _dataUtils = require('./utils/dataUtils');

var _dataProcessing = require('./data/dataProcessing');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class which provides data for the LineageGram.
 * @interface DataProvider
 */

/**
 * The function which returns nodes and link models for the graph.
 * @function
 * @name DataProvider#fetchData
 * @param {string} targetNodeId
 * @param {string} viewFrame
 * @param {string} lineageGramViewClass
 * @param {string} diagramType
   @param {number} offset
 * @returns {Promise<ServerData>} Promise which provides graph data.
 */

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewFrames
* @param {string} resource
* @returns {Promise<ViewFrameDefinition[]>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#getViewClassForResource
* @param {string} resource
* @returns {Promise<{dataProvider: string}>} Promise which provides graph data.
*/

/**
* The function which returns nodes and link models for the graph.
* @function
* @name DataProvider#relationInfo
* @param {Link} relation
* @returns {Promise<DerivationMapData>} Promise which provides graph data.
*/

/**
* Represents a node model which is extended by diagramType field
* @typedef {Object} PublicNodeModel
* @property {string} id
* @property {string} label
* @property {string} resource
* @property {string} resourceType
* @property {string} diagramType
* @property {string} typeId
* @property {string} viewFrame
* @property {any} data
*/

/**
* Represents a link model which is extended by diagramType field
* @typedef {Object} PublicLinkModel
* @property {string} id
* @property {string} source
* @property {string} target
* @property {string} diagramType
* @property {string} linkType
* @property {any} data
*/

/**
 * Represents a dataProvider response which includes
 * links and nodes for the LineageGram
 * @typedef {Object} ServerData
 * @property {string} diagramType
 * @property {string} focusNode - IRI of focusNode
 * @property {LinkModel[]} links - Link models
 * @property {NodeModel[]} nodes - Node models
*/

/**
 * Represents a state
 * @typedef {Object} HistoryState
 * @property {Link[]} links - Links
 * @property {Node[]} nodes - Nodes
 * @property {ViewFrameDefinition[]} viewFrames
 * @property {Node} focusNode - Focus node for the state
*/

/**
 * Size
 * @typedef {Object} Size
 * @property {number} width - Width
 * @property {number} height - Height
*/

/**
 * Point
 * @typedef {Object} Point
 * @property {number} x - X
 * @property {number} y - Y
*/

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

/**
 * Link tool button definition
 * @typedef {Object} LinkToolButton
 * @property {string} image - path to image
 * @property {number} width
 * @property {number} height
*/

/**
 * Link style definition
 * @typedef {Object} LinkStyleDefinition
 * @property {string} cssClass - CSS class which will be attached to the svg component
 * @property {string} lineType - 'solid' or 'dashed'
 * @property {string} color - Color of the line
 * @property {number} thickness
 * @property {boolean} hasArrow - Tells us whether line has a termination arrow or not
 * @property {LinkToolButton} toolButton
*/

/**
 * Size of the nodes of the graph (maximum, minimum, default)
 * @typedef {Object} ElementSize
 * @property {number} width - Default width of the nodes
 * @property {number} height - Default height of the nodes
 * @property {number} minWidth - Minimum width of the nodes
 * @property {number} maxWidth - Maximum width of the nodes
 * @property {number} minHeight - Minimum height of the nodes
 * @property {number} maxHeight - Maximum height of the nodes
*/

/**
 * Scale bounds.
 * @typedef {Object} ScaleBounds
 * @property {number} min
 * @property {number} max
*/

/**
 * In fact the object is a map between colors and keys (ids) of elements,
 * but there are number of default color keys.
 * @typedef {Object.<string, string>} Colors
 * @property {string} terminationText - Color of the text on termination nodes
 * @property {string} text - Color of the text on the graph's nodes,
 * @property {string} unknown - Color for nodes whose id is unknown
 * @property {string} default - Default color for nodes
 * @property {string} selected - Color of elements which are selected
 * @property {string} blured - Color for blured elements
 * @property {string} link - Color for links
 * @property {string} terminationLink - Color for termination links
 * @property {string} aspectLink - Color for aspect links
*/

/**
 * Tool button.
 * @typedef {Object} LinkToolButton
 * @property {string} image - src or xhref for tool button
 * @property {number} width - button width
 * @property {string} height - button height
*/

/**
 * Default parameters set for LineageGram. You can pass any of these parameters into the constructor during the LineageGram initialization.
 * @typedef {Object} Parameters
 * @property {string|HTMLElement} graphPlace - Identifier of the root html element for binding graph or just root HTMLElement
 * @property {string|HTMLElement} mapRootHtml - Identifier of the root html element for binding map or just root html element
 * @property {DataProvider} dataProvider - Function that resieves and returns data for the graph
 * @property {string} focusNode - Focus node id
 *
 * @property {function} launchExternal - It can be called in order to get more information about some element in derivation map and in main class.
 *
 * @property {ElementSize} elementSize - Size of the nodes of the graph
 * @property {ElementSize} overViewElementSize - Size of the nodes of the graph in OverViewFrame
 *
 * @property {number} layoutStep - Distance between elements of the graph
 * @property {number} layoutIterations - How much iterations will be done during the layout algorithm
 * @property {number} offsetBetweenGroups - Additional offset between groups of nodes (viewFrame groups)
 *
 * @property {Colors} colors - Color map
 *
 * @property {boolean} animation - If it's true, the animation is allowed. By default - true
 * @property {number} maxFrameRate - Maximum speed of animation. By defaul - 50 frames per second
 * @property {number} minFrameRate - Minimum speed of animation. By defaul - 10 frames per second
 * @property {number} animationStep - How far viewFrame position is changing per animation frame
 *
 * @property {ViewFrameDefinition[]} - View frames definition
 * @property {boolean} fullScreenMode - Defines whether we want to open LG in full-screen-mode or in the regular mode
 *
 * @property {Object.<string, string>} images - Map between node types and image urls.
 * @property {Object.<string, string>} icons - Map between node types and icons (css).
 * @property {string} resourcePath - Prefix for resources like images (optional)
 * @property {boolean} usePOSTExecutor - to make able use post requests for sparqlProvider
 * @property {Point} framePadding - ViewPorts enabled area expanded by this value
 *
 * @property {boolean} clipNodes - Tells us do or not clipping nodes by viewFrames
 * @property {number} frameBorderWidth - Width of the frame border
 *
 * @property {boolean} showCollapsedFrames - Tells whether hide or show collapsed viewFrmaes in the bottom of the graph.
 *
 * @property {Point} defaultScale
 * @property {ScaleBounds} scaleBounds - Contains minimal(min) and maximum(max) values of the scale.
 * @property {ScaleBounds} overViewScaleBounds - Contains minimal(min) and maximum(max) values of the scale for OverViewFrame.
 * @property {number} scaleStep - How much scale changes per step.
 *
 * @property {Size} terminationNodeSize - Size of the termination nodes
 * @property {Size} dataZoneSize - Size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
 * @property {number} zonesInGroup - Grouping data zones in bigger groups by groups of (for example) four
 * @property {string} linkRouting - Links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)
 *
 * @property {Object.<string, LinkStyleDefinition>} linkStyles - Map between the linkTypes and LinkStyles.
 * @property {string} graphOrientation - Orientation of the graph. Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
 * @property {DerivationMapParameters} derivationMap - parameters set for DerivationMap
 * @property {Object.<string, boolean>} mask - map of elements. Elements in the mask will be hidden
 * @property {Function} errorCallBack - it is called in response to warnings and errors
*/

/**
 * Returns default set of parameters
 * @returns {Parameters}
 */
function getDefaultParametersSet() {
    return {
        // initialization
        graphPlace: undefined, // Identifier of the root html element for binding graph
        mapRootHtml: undefined, // Identifier of the root html element for binding map or just root HTMLElement
        dataProvider: undefined,
        focusNode: undefined,

        // Elements
        elementSize: { width: 120, height: 120, minWidth: 45, maxWidth: 550, minHeight: 45, maxHeight: 550 }, // default element size
        overViewElementSize: { width: 120, height: 120, minWidth: 5, maxWidth: 550, minHeight: 5, maxHeight: 550 }, // default element size for the OverViewFrame

        // Layout
        layoutStep: { x: 200, y: 100 }, // Distance between elements of the graph
        layoutIterations: 32, // How much iterations will have been done during the layout algorithm
        offsetBetweenGroups: 150, // Additional offset between groups of nodes (viewFrame groups)

        // Color scheme
        colors: { // color map
            'edg:DatabaseColumn': '#23b0f4',
            'edg:SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'green',
            'http://edg.topbraid.solutions/model/Report': '#23b0f4',
            'http://edg.topbraid.solutions/model/ReportColumn': '#ff7410',

            'terminationText': 'white',
            'text': 'black',
            'unknown': 'black',
            'default': 'black',
            'selected': 'red',
            'blured': 'rgba(100, 100, 100, 0.3)',
            'terminationLink': '#9094a8',
            'aspectLink': 'rgba(0, 255, 0, 0.5)'
        },

        // Animation
        animation: true, // swithc off/on the animation
        maxFrameRate: 50,
        minFrameRate: 10,
        animationStep: 60,

        // View frames definition
        fullScreenMode: true, // Defines whether we want to open LG in full-screen-mode or in the regular mode
        viewFrames: [
            // {
            //     id: 'fullPanel', // identifier of the frame must be unique
            //     label: 'All',   // label in the right-top corner
            //     borderColor: '#23b0f4',
            //     backgroundColor: '#f4f4ff',
            //     // It tells how much space will takes this frame on the paper.
            //     // |[1][ 2 ][  3   ]| or
            //     // |[  50  ][  50  ]| or
            //     // |[10][10][10][10]|
            //     spaceShare: 1,
            // }
        ],

        // Images for types
        images: { // map of images for types of elements
            'edg:DatabaseColumn': 'src/resources/images/table.png',
            'edg:Table': 'src/resources/images/table.png',
            'edg:SoftwareProgram': 'src/resources/images/app.png',
            'http://edg.topbraid.solutions/model/SoftwareProgram': 'src/resources/images/app.png',
            'edg:LineageModel': 'src/resources/images/form.png',
            'edg:Schedule': 'src/resources/images/column.png',
            // 'link-options': 'src/resources/images/derivation-map.png',
            // 'feed-pipe': 'src/resources/images/feed-pipe.png',
            'unknown': 'src/resources/images/unknown.png' // It will work only for unknown types
        }, // if you want change it for lost images,
        // you should change it in the bottom of './jointViews/graphElements.js'

        resourcePath: '', // prefix for resources like images (optional)
        launchExternal: null, //optional
        usePOSTExecutor: false, // to make able use post requests for sparqlProvider

        // Be careful! If you want to change it, you should remember about css (.tq_lineage_ui e.t.c.)
        framePadding: { x: 55, y: 55 }, // viewPorts enabled area expanded by this value

        clipNodes: false, // tells us do or not clipping nodes by viewFrames.
        frameBorderWidth: 3, // styling

        showCollapsedFrames: false,

        defaultScale: { x: 1.0, y: 1.0 }, // It's necessary for calculations
        scaleBounds: { min: 0.7, max: 1.5 },
        overViewScaleBounds: { min: 0.01, max: 2 }, // scale bounds for overView frame
        scaleStep: 0.1, // step of scale changing

        terminationNodeSize: { width: 30, height: 30 }, // size of the termination nodes
        dataZoneSize: { width: 800, height: 600 }, // size of zones in data container. Zones are grouping and sorting in special areas to implement binary searching
        zonesInGroup: 4, // grouping data zones in bigger groups by groups of (for example) four
        linkRouting: 'metro', // links routing (based on jointjs routings: metro/normal/manhattan/orthogonal)

        linkStyles: {
            'default-link-style': _resourceProvider.DEFAULT_LINK_STYLE,
            'feedpipe': _resourceProvider.FEED_PIPE_LINK_STYLE,
            'tq-lg-group': _resourceProvider.DEFAULT_GROUP_LINK_STYLE
            // Example:
            // 'feedpipe': {
            //     cssClass: 'lineage-gram-feed-pipe-link',
            //     lineType: 'solid', // 'dashed'
            //     color: '#3c4260',
            //     toolButton: {
            //         image: 'src/resources/images/feed-pipe.png',
            //         width: 30,
            //         height: 30,
            //         alwaysVisible: true,
            //     },
            //     thickness: 3,
            //     hasArrow: true,
            // },
        },
        diagramType: undefined,
        graphOrientation: 'left-to-right', // Can be: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
        layoutAlgorithm: 'sankey', // Can be: 'sankey', 'flow-directed'
        derivationMap: (0, _derivationMap2.getDefaultParametersSet)(),
        mask: undefined, // Map of elements. Elements in the mask will be hidden

        errorCallBack: undefined // It is called in response to warnings and errors
    };
}

/**
 * The main class of the library, that manage all views and data.
 * Creates two view on the initialization stage. The first view is a Lineage diagram view.
 * The second view is a Bird Eye view. Also the map can be placed on the page if the mapRootHtmlId
 * was specified in the passed parameters.
 * @class
 * @augments Subscribable
 * @param {Parameters} parameters - Parameters set
 *
 * @fires selected-element-changed
 * @fires history-state-changed
 * @fires focus-node-changed
 * @fires current-view-changed
 * @fires scale-value-changed
 * @fires diagram-state-changed
 * @fires view-frame-state-changed
 * @fires derivation-map-state-changed
 * @fires derivation-map-state-init
 */
function LineageGram(parameters) {
    var _this = this;

    // Events
    // ===================================================================
    // ===================================================================

    /**
     * Element selected event - fires when object changes element selection
     * Selected element is returned as a parameter of the event.
     * @event selected-element-changed
     * @type {Object}
     * @property {PublicNodeModel|PublicLinkModel|undefined} element - SelectedElement
    */

    /**
     * It fires when new element is selected as focusNode.
     * @event focus-node-changed
     * @type {Object}
     * @property {PublicNodeModel} element - FocusNode model
    */

    /**
     * View switched event - fires when current view is changed
     * View id is returned as a parameter of the event
     * @event current-view-changed
     * @type {Object}
     * @property {string} viewId - SelectedView can take the following values: 'lineageDiagram', 'birdEye' or 'none'
    */

    /**
     * Scale changed event - fires when scale value of the Lineage Diagram view is changed.
     * [New scale value]{@link Scale} is returned as a parameter of the event
     * @event scale-value-changed
     * @type {Object}
     * @property {Scale} scale - New scale object.
    */

    /**
     * State changed event - fires when LineageGram state is changed.
     * E.g. from a fetching state to a rendering state.
     * The state string identifier is returned as a parameter of the event
     * @event diagram-state-changed
     * @type {Object}
     * @property {string} state - Parameter can take the following values: 'fetching' | 'rendering' | 'completed' | 'error'
    */

    /**
     * It fires when user is navigating along the history.
     * @event history-state-changed
     * @type {Object}
     * @property {HistoryState[]} states - List of states
     * @property {number} currentIndex - order number of the current state in the list
    */

    /**
     * View frame state changed - fires when the View frame is being collapsed or expanded.
     * @event view-frame-state-changed
     * @type {Object}
     * @property {string} id - id of the changed ViewFrame
     * @property {boolean} value - true - expanded, false - collapsed
    */

    // Init
    // ===================================================================
    // ===================================================================
    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this; // Save pointer to a context

    var _state = 'initial';
    var _selectedElement = null;
    var _focusElement = void 0;
    var _currentView = 'lineageDiagram'; // Set the lineageDiagram view as a current view


    var defaultParameterSet = getDefaultParametersSet(); // Geting default parameters set
    // If the parameter set includes viewFrames definition, clear the viewFrames definition in the default set for a correct merging
    // (We don't want to get extra viewFrames from the default set.)
    if (parameters && parameters.viewFrames && parameters.viewFrames.length > 0) defaultParameterSet.viewFrames = undefined;
    // Merging default parameters set and custome parameters set
    var _parameters = _.merge(defaultParameterSet, parameters);

    var _errorCallback = function _errorCallback(e) {
        if (_parameters.errorCallback && _parameters.errorCallback instanceof Function) {
            var error = typeof e === 'string' ? new Error(e) : e;
            _parameters.errorCallback.call(_this, error);
        }
    };

    // If the graphPlace is undefined we stop the working process.
    if (!parameters.graphPlace) throw new Error('The graph place isn\'t specified');
    var graphPlaceHtml = void 0;
    if (typeof parameters.graphPlace === 'string') {
        graphPlaceHtml = document.getElementById(parameters.graphPlace);
    } else if (_typeof(parameters.graphPlace) === 'object') {
        graphPlaceHtml = parameters.graphPlace;
    } else {
        throw new Error('The graph place isn\'t specified or specided incorrectly');
    }
    // Creating html markup.
    var _base = _createBase(graphPlaceHtml);
    var _dataProvider = _parameters.dataProvider;
    var _stateStorage = new _stateStorage3.default(_parameters);
    var _progressScreen = new _visualizationsLibrary2.default.ProgressScreen({
        baseElement: _base.container
    });

    // Creating the data container.
    var _dataContainer = void 0;

    var _lineageDiagram = void 0; // Lineage diagram view
    var _birdEye = void 0; // BirdEye biew
    var _derivationMap = void 0;
    var _graphMap = void 0; // define variable
    var _derivationMapPanel = void 0;

    var _diagramType = _parameters.diagramType;

    self.launchExternal = _parameters.launchExternal;

    _createComponents();

    _fetchDiagram({
        focusNodeId: _parameters.focusNode,
        viewFrames: _parameters.viewFrames,
        lineageGramViewClass: _parameters.lineageGramViewClass,
        diagramType: _diagramType
    });

    // ===================================================================
    // ===================================================================

    /**
     * Recovers nodes positions to the initial.
     * @memberof LineageGram
     * @method
     */
    self.resetLayout = function () {
        if (_state !== 'completed') return;
        _lineageDiagram.resetLayout();
    };

    /**
     * @typedef {Object} Scale
     * @property {number} min - The minimum value
     * @property {number} max - The maximum value
     * @property {number} cur - The current value
    */

    /**
     * Changes scale of the main view by the step (defaul: ++0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomIn = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomIn();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main view to be able to fit whole diagram in the screen.
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomToFit = function () {
        if (_state === 'completed') {
            _zoomToFit();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Returns current view id
     * @return {string} currentViewId -'lineageDiagram' | 'birdEye' | 'none'
     * @memberof LineageGram
     * @method
     */
    self.getCurrentView = function () {
        return _currentView;
    };

    /**
     * Returns current state
     * @returns {string} state - 'fetching' | 'active' | 'completed' | 'error'
     * @memberof LineageGram
     * @method
     */
    self.getState = function () {
        return _state;
    };

    /**
     * Changes scale of the main view by the step (defaul: --0.1).
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoomOut = function () {
        if (_state === 'completed') {
            _lineageDiagram.zoomOut();
            if (_graphMap) _graphMap.redraw({ viewFrames: _lineageDiagram.getViewFrames() });
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Changes scale of the main Lineage Diagram view.
     * @param {Point} scale
     * @returns {Scale}
     * @memberof LineageGram
     * @method
     */
    self.zoom = function zoom(scale) {
        if (_state === 'completed') {
            if (scale) {
                _lineageDiagram.scale(scale);
            }
            _lineageDiagram.redraw();
        }
        return {
            min: _parameters.scaleBounds.min,
            max: _parameters.scaleBounds.max,
            cur: _state === 'completed' ? _lineageDiagram.scale() : _parameters.defaultScale
        };
    };

    /**
     * Object which passed into the export function in LineageGram
     * @typedef {Object} ExportParams
     * @property {string} name - The file name
     * @property {string} type - (png/svg)
     * @property {string} view - BirdEye / lineageGram
    */

    /**
     * Exports the graph in a png or svg file.
     * @param {ExportParams} options
     * @memberof LineageGram
     * @method
    */
    self.export = function (options) {
        if (_state !== 'completed') return;

        if (!options) options = {};
        options.view = options.view || _currentView;
        if (options.view === 'lineageDiagram') {
            _lineageDiagram.export({
                name: options.name,
                type: options.type
            });
        } else if (options.view === 'birdEye') {
            _birdEye.export();
        }
    };

    /**
     * Shows print dialog.
     * @memberof LineageGram
     * @method
    */
    self.print = function () {
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.print();
        } else if (_currentView === 'birdEye') {
            _birdEye.print();
        }
    };

    /**
     * Expands all nodes
     * @memberof LineageGram
     * @method
    */
    self.expandAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', true);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * Collapses all nodes
     * @memberof LineageGram
     * @method
    */
    self.collapseAllNodes = function () {
        var nodes = _dataContainer.nodes;
        nodes.forEach(function (node) {
            node.set('expanded', false);
        });
        if (_currentView === 'lineageDiagram') {
            _lineageDiagram.refresh();
        }
    };

    /**
     * This function creates map, using html element with specified ID as a root element.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @memberof LineageGram
     * @method
     */
    self.setRootHtmlForMap = function (mapRootHtml) {
        var mapHTMLElement = _getMapHTML(mapRootHtml);
        _parameters.mapRootHtml = mapRootHtml;
        _base.mapHTMLElement = mapHTMLElement;

        if (_state !== 'completed') return;

        _updateMap(_dataContainer, _lineageDiagram.getViewFrames());
    };

    /**
     * It changes layout algorithm for the graph.
     * @param {string} orientation - Values: 'sankey', 'flow-directed'
     * @memberof LineageGram
     * @method
     */
    self.setLayoutAlgorithm = function (algorithmId) {
        if (algorithmId === 'sankey' || algorithmId === 'flow-directed') {
            _parameters.layoutAlgorithm = algorithmId;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                delete model.defaultPosition;
                model.viewFrameOwnerId = null;
                return model;
            });
            var links = _dataContainer.links.map(function (l) {
                return {
                    id: l.model.id,
                    source: l.model.sourceType,
                    target: l.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.refresh();
            _birdEye.refresh();
            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * Returns layout algorithm which is currently used for diagram.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro/normal/manhattan
     */
    self.getLayoutAlgorithm = function () {
        return _parameters.layoutAlgorithm;
    };

    /**
     * Returns the configured reach from the data provider.
     * @memberof LineageGram
     * @method
     * @returns {number}
     */
    self.getReach = function () {
        return _dataProvider.getReach();
    };

    /**
     * Sets the reach for the data provider.
     * @memberof LineageGram
     * @method
     * @returns {number}
     */
    self.setReach = function (_reach) {
        if (_dataProvider) {
            _dataProvider.setReach(_reach);

            _refetchDiagram();
        }
    };

    /**
     * Returns the configured breadth from the data provider.
     * @memberof LineageGram
     * @method
     * @returns {number}
     */
    self.getBreadth = function () {
        return _dataProvider.getBreadth();
    };

    /**
     * Sets the breadth for the data provider.
     * @memberof LineageGram
     * @method
     * @returns {number}
     */
    self.setBreadth = function (_breadth) {
        if (_dataProvider) {
            _dataProvider.setBreadth(_breadth);

            _refetchDiagram();
        }
    };

    /**
     * It changes orientation of the graph
     * @param {string} orientation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     * @memberof LineageGram
     * @method
     */
    self.setOrientation = function (orientation) {
        if (_state !== 'completed') return;

        if (orientation && (orientation === 'left-to-right' || orientation === 'right-to-left' || orientation === 'top-to-bottom' || orientation === 'bottom-to-top')) {
            _parameters.graphOrientation = orientation;

            var nodes = _dataContainer.nodes.map(function (n) {
                var model = n.model;
                model.default_x = undefined;
                model.default_y = undefined;
                model.viewFrameOwnerId = null;
                n.setOrientation(orientation);
                return model;
            });
            var links = _dataContainer.links.map(function (link) {
                return {
                    id: link.model.id,
                    source: link.model.sourceType,
                    target: link.model.targetType
                };
            });

            var viewFrames = _lineageDiagram.getViewFrames();

            layout.doLayout(nodes, links, viewFrames, _parameters);
            _dataContainer.refresh();
            _lineageDiagram.setOrientation(orientation);
            _birdEye.refresh();
            if (_graphMap) _graphMap.refresh({
                viewFrames: _lineageDiagram.getViewFrames()
            });
        }
    };

    /**
     * It returns orientation of the graph
     * @memberof LineageGram
     * @method
     * @returns {string} oreintation - Values: 'left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'
     */
    self.getOrientation = function () {
        return _parameters.graphOrientation;
    };

    /**
     * Refreshes LineageGram - refreshes all views and adjust size of the canvas.
     * @memberof LineageGram
     * @param {string} target - 'lineageDiagram' | 'birdEye' | 'graphMap'
     * @method
     */
    self.refresh = function (target) {
        if (_state !== 'completed') return;

        if (_currentView === 'lineageDiagram') {
            if (!target || target === 'lineageDiagram') _lineageDiagram.redraw();
        } else {
            if (!target || target === 'birdEye') _birdEye.refresh();
        }
        if (_graphMap && (!target || target === 'graphMap')) _graphMap.refresh({
            viewFrames: _lineageDiagram.getViewFrames()
        });
    };

    /**
     * ViewFrmaes public data
     * @typedef {Object} ViewFramePublicModel
     * @property {string} id - Identifier
     * @property {string} label - Text label
     * @property {string} borderColor - CSS border color
     * @property {string} backgroundColor - CSS bacground color
    */

    /**
     * Get ViewFrames states.
     * @returns {ViewFramePublicModel[]} states - key -> id, value -> true - expanded, false - collapsed
     * @memberof LineageGram
     * @method
     */
    self.getViewFrames = function () {
        if (_state !== 'completed') return [];

        return _lineageDiagram.getViewFrames();
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @param {string} viewFrameId
     * @returns {ViewFramePublicModel}
    */
    self.getViewFrameById = function (viewFrameId) {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getViewFrameById(viewFrameId);
    };

    /**
     * Returns one ViewFrame by id
     * @memberof LineageGram
     * @method
     * @returns {ViewFramePublicModel}
    */
    self.getOverViewFrame = function () {
        if (_state !== 'completed') return undefined;

        return _lineageDiagram.getOverViewFrame();
    };

    /**
     * Collapse the ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.collapseViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.closeViewFrame(viewFrameId);
    };

    /**
     * Expand ViewFrame with specified Id.
     * @param {string} viewFrameId - id of the target ViewFrame
     * @memberof LineageGram
     * @method
     */
    self.expandViewFrame = function (viewFrameId) {
        if (_state !== 'completed') return;
        _lineageDiagram.openViewFrame(viewFrameId);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.setFullScreenMode = function (value) {
        if (_state !== 'completed') return;
        _lineageDiagram.setFullScreenMode(value);
    };

    /**
     * Collapses/Expands OverViewFrame.
     * @param {boolean} value
     * @memberof LineageGram
     * @method
    */
    self.isFullScreenMode = function () {
        if (_state !== 'completed') return _parameters.fullScreenMode;
        return _lineageDiagram.isFullScreenMode();
    };

    /**
     * Groups relative to selected node
     * nodes around  the selected node and highlight them.
     * @memberof LineageGram
     * @method
    */
    self.combine = function () {
        _lineageDiagram.combine();
    };

    /**
     * Finds elements by id(s) and sets it as selected.
     * @param {string|null} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
     * @memberof LineageGram
     * @method
     */
    self.setSelectedElement = function (id1, id2) {
        if (id1 === undefined) return;

        if (id1 !== null) {
            var selectedElement = _getElementById(id1, id2);
            _setSelectedElement(selectedElement);
        } else {
            _setSelectedElement(null);
        }
    };

    /**
     * Rebuilds diagramm with new focus node
     * @param {string} focusNode - Focus node id
     * @memberof LineageGram
     * @method
     */
    self.setFocusNode = function (focusNodeId) {
        var focusNode = _getElementById(focusNodeId);

        if (!(focusNode instanceof graphElements.Node)) {
            console.error('Incorrect value of element');
            return;
        }

        _stateStorage.updateState(_getHistoryState());
        _setDiagramState('fetching');

        var focusResource = focusNode.model.resource;

        if (focusNode.model.hasOwnProperty('activeResource')) {
            focusResource = focusNode.model.activeResource;
        }

        _fetchDiagram({
            focusNodeId: focusResource,
            viewFrame: focusNode.model.viewFrame,
            offset: focusNode.model.hasOwnProperty('offset') ? focusNode.model.offset : null,
            diagramType: _diagramType
        });
    };

    /**
     * Returns to previous selected node (Restores previous diagram)
     * @memberof LineageGram
     * @method
     */
    self.undoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var previousState = _stateStorage.undoState();
        if (previousState) _loadState(previousState);
    };

    /**
     * Returns to next selected node
     * (Node which had been selected before the state was restored)
     * @memberof LineageGram
     * @method
     */
    self.redoState = function () {
        _stateStorage.updateState(_getHistoryState());
        var nextState = _stateStorage.redoState();
        if (nextState) _loadState(nextState);
    };

    /**
     * Returns public model of selected element
     * @returns {PublicLinkModel|PublicNodeModel} selectedElement
     * @memberof LineageGram
     * @method
     */
    self.getSelectedElement = function () {
        return _getModel(_selectedElement);
    };

    /**
     * Returns public model of focus element.
     * Element which was used to build diagram around
     * @returns {PublicLinkModel|PublicNodeModel} focusElement
     * @memberof LineageGram
     * @method
     */
    self.getFocusElement = function () {
        return _getModel(_focusElement);
    };

    /**
    * Returns the current derivation map.
    * @returns {DerivationMap} derviationMap
    * @memberof lineageGram
    * @method
    */
    self.getDerivationMap = function () {
        if (_state === 'completed') {
            return _derivationMap;
        } else {
            return undefined;
        }
    };

    self.getNodes = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.nodes.map(function (n) {
            return _getModel(n);
        });
    };

    self.getLinks = function () {
        if (_state !== 'completed') return [];
        return _dataContainer.links.map(function (l) {
            return _getModel(l);
        });
    };

    /**
     * Graphs public maps
     * @typedef {Object} PublicGraphMaps
     * @property {Object.<string, PublicNodeModel>} nodeMap
     * @property {Object.<string, PublicLinkModel>} linkMap
     * @property {Object.<string, PublicLinkModel>} sourceMap
     * @property {Object.<string, PublicLinkModel>} targetMap
    */

    /**
     * Graph model
     * @typedef {Object} PublicGraphModel
     * @property {PublicNodeModel[]} nodes
     * @property {PublicLinkModel[]} links
     * @property {PublicGraphMaps} maps
    */

    /**
     * Returns a data model of LineagGram.
     * @returns {PublicGraphModel}
     * @memberof LineageGram
     * @method
     */
    self.getGraphModel = function () {
        if (_state !== 'completed') return {};

        var graphModel = {
            nodes: _dataContainer.nodes.map(function (n) {
                return _getModel(n);
            }),
            links: _dataContainer.links.map(function (l) {
                return _getModel(l);
            }),
            maps: {
                nodeMap: {},
                linkMap: {},
                sourceMap: {},
                targetMap: {}
            }
        };

        graphModel.nodes.forEach(function (nodeModel) {
            graphModel.maps.nodeMap[nodeModel.id] = nodeModel;
        });
        graphModel.links.forEach(function (linkModel) {
            graphModel.maps.linkMap[linkModel.id] = linkModel;

            if (!graphModel.maps.sourceMap[linkModel.target]) {
                graphModel.maps.sourceMap[linkModel.target] = [];
            }
            if (!graphModel.maps.targetMap[linkModel.source]) {
                graphModel.maps.targetMap[linkModel.source] = [];
            }

            graphModel.maps.sourceMap[linkModel.target].push(linkModel);
            graphModel.maps.targetMap[linkModel.source].push(linkModel);
        });

        return graphModel;
    };

    /**
     * Sets current view. Method takes string identifier of the view as a parameter
     * @param {string} - viewId can be 'lineageDiagram' or 'birdEye' or 'none'
     * @memberof LineageGram
     * @method
     */
    self.setCurrentView = function (viewId) {
        if (viewId === 'lineageDiagram') {
            _showJointGraph();
        } else if (viewId === 'birdEye') {
            _showSigmaGraph();
        } else if (viewId === 'none') {
            _hideViews();
        }
    };
    self.setCurrentView(_currentView);

    /**
     * Sets links routing which is based
     * on jointjs routings: metro | normal | manhattan | orthogonal
     * @param {string} routingId - metro | normal | manhattan | orthogonal
     * @memberof LineageGram
     * @method
     */
    self.setRouting = function (routingId) {
        if (_state === 'completed') {
            _lineageDiagram.setRouting(routingId);
        }
    };

    /**
     * Returns routing which is currently applied for all links.
     * @memberof LineageGram
     * @method
     * @returns {string} routing: metro | normal | manhattan | orthogonal
     */
    self.getRouting = function () {
        if (_state === 'completed') {
            return _lineageDiagram.getRouting();
        } else {
            return parameters.linkRouting;
        }
    };

    /**
     * Sets value of the parameter which tells us wheter we should
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @param {boolean} clipping
     * @method
     */
    self.setClipping = function (clipping) {
        _parameters.clipNodes = clipping;
        if (_state === 'completed') {
            _lineageDiagram.redraw();
        }
    };

    /**
     * Returns value of the parameter which tells us wheter we
     * trim nodes by the borders or not.
     * @memberof LineageGram
     * @method
     * @returns {boolean} clipping
     */
    self.getClipping = function () {
        return _parameters.clipNodes;
    };

    self.setMask = function (publicMask) {
        var idMap = _dataContainer.maps.idMap;
        var mask = {};
        Object.keys(publicMask).forEach(function (id) {
            var diagramId = idMap[id];
            mask[diagramId] = publicMask[id];
        });
        _lineageDiagram.setMask(mask);
    };

    self.getMask = function () {
        var mask = _lineageDiagram.getMask();
        var nodeMap = _dataContainer.maps.nodeMap;
        var linkMap = _dataContainer.maps.linkMap;
        var publicMask = {};
        if (mask) {
            Object.keys(mask).forEach(function (key) {
                if (mask[key]) {
                    var element = _getModel(nodeMap[key] || linkMap[key]);
                    if (element) {
                        publicMask[element.id] = element;
                    }
                }
            });
        }
        return publicMask;
    };

    /**
     * Fetches diagram using passed options
     * @param {{
     *      focusNodeId: string,
     *      viewFrames: ViewFrameDefinition[],
     *      viewFrame: string
     *      lineageGramViewClass: string,
     *      diagramType: string,
     * }}
     * @memberof LineageGram
     * @method
     * @private
     */
    function _fetchDiagram(options) {
        var targetNodeId = options.focusNodeId;
        var viewFrame = options.viewFrame;
        var diagramType = options.diagramType;
        var offset = options.hasOwnProperty('offset') ? options.offset : null;

        // Switch the loading indicator in state 'fetching'
        // Request data through data provider
        _setDiagramState('fetching');
        if (!_dataProvider) {
            var errorMessage = 'Data provider is not specified!';
            var error = new Error(errorMessage);
            _setDiagramState('error', errorMessage);
            _errorCallback(error);
            throw error;
        }
        if (!_dataProvider.fetchData) {
            var _errorMessage = 'Data provider has incorrect interface! (There is no \'fetchData\' method)';
            var _error = new Error(_errorMessage);
            _setDiagramState('error', _errorMessage);
            _errorCallback(_error);
            throw _error;
        }

        var viewFramesPromise = options.viewFrames && options.viewFrames.length > 0 ? Promise.resolve({ frames: options.viewFrames }) : _dataProvider.getViewFrames(targetNodeId);
        var viewClassPromise = options.lineageGramViewClass ? Promise.resolve(options.lineageGramViewClass) : _dataProvider.getViewClassForResource(targetNodeId);

        return Promise.all([viewFramesPromise, viewClassPromise]).then(function (values) {
            var viewFrames = values[0].frames;
            var viewClass = values[1].dataProvider;

            return _dataProvider.fetchData({
                targetNodeId: targetNodeId,
                viewFrame: viewFrame,
                lineageGramViewClass: viewClass,
                diagramType: diagramType,
                offset: offset
            }).then(function (rawData) {
                _setDiagramState('rendering');

                (0, _dataUtils.checkLgRawData)(rawData);

                var dataContainer = _createDataContainer(rawData, viewFrames);
                var viewFrameDefinitions = filterViewFrameList(viewFrames, dataContainer);
                var publicViewFrameModels = viewFrameDefinitions.map(function (d) {
                    return (0, _dataUtils.defenitionToPublicModel)(d, _lineageDiagram.isFullScreenMode());
                });

                _updateComponents(dataContainer, publicViewFrameModels);

                _diagramType = rawData.diagramType;
                _dataContainer = dataContainer;
                _stateStorage.pushState(_getHistoryState());

                var focusNodeId = rawData.focusNode || (rawData.nodes[0] ? rawData.nodes[0].id : focusNodeId);
                var focusElement = _getElementById(focusNodeId);
                _focusElement = focusElement;

                _setSelectedElement(focusElement);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            });
        }).catch(function (e) {
            var error = typeof e === 'string' ? new Error(e) : e;

            _setDiagramState('error', error.message);
            _errorCallback(error);

            console.error(error.message);
            console.error(error.stack);
        });

        /**
         * Removes empty viewFrames
         * @private
         * @param {ViewFrameDefinition[]} viewFrames
         * @param {DataContainer} dataContainer
         * @returns {ViewFrame[]}
         */
        function filterViewFrameList(viewFrames, dataContainer) {
            var activeViewFrames = {};
            dataContainer.nodes.forEach(function (n) {
                activeViewFrames[n.model.viewFrame] = true;
            });
            var result = viewFrames.filter(function (vf) {
                return activeViewFrames[vf.id];
            });
            if (result.length > 0) {
                return result;
            } else {
                return [];
            }
        }
    }

    /**
     * Forces a data refersh from the server.
     */
    function _refetchDiagram() {

        if (_focusElement) {

            var focusNode = _focusElement;
            var focusResource = focusNode.model.activeResource;

            _fetchDiagram({
                focusNodeId: focusResource,
                viewFrame: focusNode.model.viewFrame,
                offset: focusNode.model.hasOwnProperty('offset') ? focusNode.model.offset : null,
                diagramType: _diagramType
            });
        }
    }

    /**
     * @private
     * Finds elements by id(s).
     * @param {string} id1 - Selected element id or source element id of the link
     * @param {string} id2 - Target element id
     * @returns {Node|Link} - Selected element
    */
    function _getElementById(id1, id2) {
        if (!id2) {
            var elements = _dataContainer.nodes.concat(_dataContainer.links);
            for (var i = 0; i < elements.length; i++) {
                if (elements[i].model.resource === id1 || elements[i].model.id === id1) {
                    return elements[i];
                }
            }
        } else {
            var nodeMap = _dataContainer.maps.nodeMap;
            var links = _dataContainer.links;
            for (var _i = 0; _i < links.length; _i++) {
                var source = nodeMap[links[_i].model.source];
                var target = nodeMap[links[_i].model.target];
                if (source.resource === id1 && target.resource === id2 || source.resource === id2 && target.resource === id1 || source.id === id1 && target.id === id2 || source.id === id2 && target.id === id1) {
                    return links[_i];
                }
            }
        }
        return undefined;
    }

    /**
     * @private
     * Checks passed element and set it as a selected. Refreshes this value for the views.
     * @param {Node|Link} - Selected element
    */
    function _setSelectedElement(selectedElement) {
        // It shoudln't be undefined, but it can be null
        if (selectedElement === undefined) {
            throw Error('Incorrect value of selected element');
        }

        if (_graphMap) _graphMap.setSelectedElement(selectedElement);
        if (_currentView === 'lineageDiagram') _lineageDiagram.setSelectedElement(selectedElement, true);
        if (_currentView === 'birdEye') _birdEye.setSelectedElement(selectedElement);
    }

    /**
     * @private
     * Returns current state.
     * @returns {HistoryState} current state
    */
    function _getHistoryState() {
        var overViewFrame = _lineageDiagram.getOverViewFrame();
        return {
            nodes: _dataContainer.nodes,
            links: _dataContainer.links,
            focusElement: _focusElement,
            viewFrames: _lineageDiagram.getViewFrames().filter(function (vf) {
                return vf.id !== overViewFrame.id;
            }),
            selectedElement: _selectedElement
        };
    }

    /**
     * @private
     * Restores diagram using the passed state.
     * @param {HistoryState} state - target state
    */
    function _loadState(state) {
        try {
            _setDiagramState('rendering');
            setTimeout(function () {
                var dataContainer = new _dataContainer3.default({
                    nodes: state.nodes,
                    links: state.links
                }, _parameters);

                _updateComponents(dataContainer, state.viewFrames);

                _dataContainer = dataContainer;

                var elementToSelect = state.selectedElement === undefined ? state.focusElement : state.selectedElement;
                _focusElement = state.focusElement;

                _selectedElement = elementToSelect;
                _setSelectedElement(elementToSelect);
                _setDiagramState('completed');

                self.trigger('focus-node-changed', _getModel(state.focusElement));
                self.trigger('history-state-changed', _stateStorage.getHistory());
            }, 0);
        } catch (error) {
            _setDiagramState('error');
            if (typeof error === 'string') {
                console.error(error);
            } else {
                console.error(error.message);
                console.error(error.stack);
            }
        }
    }

    /**
     * @private
     * Changes scale of the main view to be able to fit whole diagram in the screen.
    */
    function _zoomToFit() {
        _lineageDiagram.zoomToFit();
        if (_graphMap) _graphMap.redraw({
            viewFrames: _lineageDiagram.getViewFrames(),
            scale: _lineageDiagram.scale()
        });
    }

    /**
     * @private
     * Creates dataContainer (diagram model) using passed raw data.
     * @param {ServerData} rawData - data
     * @param {ViewFrameDefinition[]} viewFrames - View frame defenitions
    */
    function _createDataContainer(rawData, viewFrames) {
        // if we don't get any data, we create an empty datat
        if (!rawData) rawData = { nodes: [], links: [] };
        if (!rawData.nodes) rawData.nodes = [];
        if (!rawData.links) rawData.links = [];

        // The function filters the data, sets authorities and collapses links.
        var data = (0, _dataProcessing.processData)(rawData);
        // Find and set place for each element of the data set
        layout.doLayout(data.nodes, data.links, viewFrames, _parameters);

        // This two lines create nodes and links from data models
        var jointNodes = (0, _dataUtils.createJointNodes)(data.nodes, _parameters);
        var jointLinks = (0, _dataUtils.createJointLinks)(data.links, jointNodes, _parameters);

        (0, _dataProcessing.createAspectRelations)(jointNodes);

        // Update data container by new nodes and links
        return new _dataContainer3.default({
            nodes: jointNodes,
            links: jointLinks
        }, _parameters);
    }

    /**
     * Initializes (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _createComponents() {
        var emptyDataContainer = new _dataContainer3.default({
            nodes: [],
            links: []
        }, _parameters);
        var emptyList = [];
        // Creates the first view - LineageDiagram
        _createLineageDiagram(emptyDataContainer, emptyList);
        // Creates a sigma graph map on the private root.
        // _createMap(emptyDataContainer, emptyList);
        // Creates the second view - BirdEye (Historically - SigmaPathView)
        _createBirdEye(emptyDataContainer);
        _createDerivationMap(_dataProvider);

        _addHoverHandler();
    }

    /**
     * Updates (or refreshes if not the first time)
     * the LineageGram - Creates (Refreshes) the main views.
     * @private
     */
    function _updateComponents(dataContainer, viewFrames) {
        // Updates the first view - LineageDiagram
        _updateLineageDiagram(dataContainer, viewFrames);
        // Updates a sigma graph map on the private root.
        _updateMap(dataContainer, _lineageDiagram.getViewFrames());
        // Updates the second view - BirdEye (Historically - SigmaPathView)
        _updateBirdEye(dataContainer);

        _zoomToFit();
    }

    // Inner functions
    // ==============================================
    function _createLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram = new _lineageDiagram3.default({
            graphPlace: _base.lineageDiagram,
            dataContainer: dataContainer,
            viewFrames: viewFrames,
            fullScreenMode: _parameters.fullScreenMode
        }, _parameters);

        _lineageDiagram.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram' && _state === 'completed') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _lineageDiagram.on('scale-changed', function (newScale) {
            if (_state !== 'completed') return;

            if (_graphMap) _graphMap.redraw({
                viewFrames: _lineageDiagram.getViewFrames(),
                scale: newScale
            });
            self.trigger('scale-value-changed', {
                min: _parameters.scaleBounds.min,
                max: _parameters.scaleBounds.max,
                cur: _lineageDiagram.scale()
            });
        });

        _lineageDiagram.on('view-frames-state-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
            self.trigger('view-frame-state-changed', viewFrames);
        });

        _lineageDiagram.on('view-frames-size-or-position-changed', function (viewFrames) {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw({ viewFrames: viewFrames });
            }
        });

        _lineageDiagram.on('nodes-position-changed', function () {
            if (_state !== 'completed') return;

            if (_graphMap) {
                _graphMap.redraw();
            }
            _birdEye.redraw();
        });

        _lineageDiagram.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'lineageDiagram') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _lineageDiagram.setSelectedElement(eventObject);
                    var link = eventObject.originalLink || eventObject;
                    _showDerivationMap(link);
                }
            }
        });

        _lineageDiagram.on('link-options-click', function (event) {
            if (_state !== 'completed') return;

            var link = event.link;
            var linkType = event.linkType;
            if (_currentView === 'lineageDiagram') {
                _showDerivationMap(link, linkType);
            }
        });
    }

    function _updateLineageDiagram(dataContainer, viewFrames) {
        _lineageDiagram.setData(dataContainer, viewFrames);
        _lineageDiagram.scale(_parameters.defaultScale);
    }

    function _addHoverHandler() {
        // Init the tooltip tool for termintation nodes.
        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.termination-node',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });

        new joint.ui.Tooltip({
            rootTarget: document.body,
            target: '.tq-lg-short-label',
            direction: 'auto',
            padding: 15,
            content: function content(cell) {
                return cell.getElementsByTagName('text')[0].attributes.tooltip.value;
            }
        });
    }

    function _createDerivationMap(dataProvider) {
        _derivationMapPanel = new _visualizationsLibrary2.default.FlyingPanel({
            baseElement: _base.derivationMap,
            active: false,
            header: 'Derivation Map',
            emptyBody: false,
            size: { width: 'calc(100% - 200px)', height: 'calc(100% - 200px)' },
            position: { x: '100px', y: '100px' },
            body: '',
            resizable: true
        });

        _derivationMapPanel.on('size-changed', function () {
            return _derivationMap.resetFocus();
        });

        _derivationMap = new _derivationMap3.default({
            rootElement: _derivationMapPanel.rootHtml.querySelector('.tq-ui-body_container'),
            dataProvider: dataProvider
        }, _parameters.derivationMap);

        self.trigger('derivation-map-state-changed');
        self.trigger('derivation-map-state-init', _derivationMap);
    }

    function _createBirdEye(dataContainer) {
        _birdEye = new _birdEye3.default({
            el: _base.sigmaGraph,
            scale: _lineageDiagram.scale(),
            dataContainer: dataContainer
        }, _parameters);

        _birdEye.on('selected-element-changed', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (_graphMap) _graphMap.setSelectedElement(eventObject);
                _selectedElement = (0, _dataUtils.getBaseElement)(eventObject);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            }
        });

        _birdEye.on('cell-double-click', function (eventObject) {
            if (_state !== 'completed') return;

            if (_currentView === 'birdEye') {
                if (eventObject instanceof graphElements.Link || eventObject instanceof graphElements.TerminationLink) {
                    _birdEye.setSelectedElement(eventObject);
                    var links = eventObject.originalLink || eventObject;
                    _showDerivationMap(links);
                }
            }
        });
    }

    function _updateBirdEye(dataContainer) {
        _birdEye.setData(dataContainer);
    }

    /**
     * Creates the map If not created.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _createMap(dataContainer, viewFrames) {
        if (_base.mapHTMLElement) {
            _graphMap = new _graphMap3.default({
                el: _base.mapHTMLElement,
                scale: _lineageDiagram.scale(),
                viewFrames: viewFrames,
                dataContainer: dataContainer
            }, _parameters);

            _graphMap.on('selected-element-changed', function (node) {
                if (_state !== 'completed') return;

                if (_currentView === 'lineageDiagram') {
                    var nodeIsInvisible = _lineageDiagram.getVisibleNodes().indexOf(node) === -1;
                    _lineageDiagram.setSelectedElement(node, nodeIsInvisible);
                }
                if (_currentView === 'birdEye') _birdEye.setSelectedElement(node);

                _selectedElement = (0, _dataUtils.getBaseElement)(node);
                self.trigger('selected-element-changed', _getModel(_selectedElement));
            });

            _graphMap.on('view-frames-position-changed', function (viewFrames) {
                if (_state !== 'completed') return;

                if (viewFrames.length === 0) return;
                var index = 0;

                recursion(viewFrames[index++]);

                function recursion(viewFrame) {
                    _lineageDiagram.positionViewPort(viewFrame, viewFrame.viewPortPosition, _parameters.animation, function () {
                        if (viewFrame[index]) {
                            recursion(viewFrames[index++]);
                        }
                    });
                }
            });
        }

        return _graphMap;
    }

    /**
     * Updates the map.
     * @private
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
     * @returns {ViewFrame[]}
     */
    function _updateMap(dataContainer, viewFrames) {
        if (_graphMap) {
            _graphMap.setData(dataContainer, viewFrames);
        } else {
            _createMap(dataContainer, viewFrames);
        }
    }

    /**
     *
     * @param {Link|Node|TerminationLink|TerminationNode} element
     * @returns {PublicNodeModel|PublicLinkModel}
     */
    function _getModel(element) {
        if (!element) return;

        var elementModel = _.cloneDeep(element.model);
        elementModel.blured = Boolean(element.get('blured'));
        elementModel.highlighted = Boolean(element.get('highlighted'));

        if (element instanceof graphElements.Node) {
            elementModel.diagramType = 'node';
        } else if (element instanceof graphElements.Link) {
            elementModel.source = elementModel.sourceType;
            elementModel.target = elementModel.targetType;
            delete elementModel.sourceType;
            delete elementModel.targetType;
            elementModel.diagramType = 'link';
        }
        return elementModel;
    }

    /**
     * Opens derivation map window.
     * @param {Link} link
     * @param {string} linkType
     * @private
     */
    function _showDerivationMap(link, linkType) {
        if (link instanceof graphElements.Link) {
            var nodeMap = _dataContainer.maps.nodeMap;

            var actualLink = null;
            if (Object.hasOwnProperty.call(link.model, 'group')) {
                var group = link.model.group;

                actualLink = group.filter(function (g) {
                    return g.source == link.model.sourceType && g.target == link.model.targetType && g.linkType == linkType;
                })[0];
            }

            _derivationMap.openWithRelation({
                source: nodeMap[link.model.source].model,
                target: nodeMap[link.model.target].model,
                linkType: linkType,
                activeResourcesList: actualLink ? actualLink.activeResourcesList : link.model.activeResourcesList
            });
            _derivationMapPanel.show();
        }
    }

    /**
     * Sets state of indicator
     * @private
     * @param {string} state - fetching | rendering | completed | error
     * @param {string} message - Custom message
     */
    function _setDiagramState(state, message) {
        _state = state;

        if (state === 'fetching') {
            _progressScreen.setState('active', message || 'Fetching data');
        } else if (state === 'rendering') {
            _progressScreen.setState('active', message || 'Rendering graph');
        } else if (state === 'completed') {
            _progressScreen.setState('completed');
        } else if (state === 'error') {
            _progressScreen.setState('error', message || 'Error has occurred!');
        }
        self.trigger('diagram-state-changed', state);
    }

    /**
     * Creates html markup.
     * @private
     * @param {HTMLElement} htmlNode - Root node for markup
     * @returns {Object.<string, HTMLElement>} - Map of html elements
     */
    function _createBase(htmlNode) {
        htmlNode.innerHTML = '';
        htmlNode.tabIndex = 0;

        var baseDiv = document.createElement('DIV');
        baseDiv.className = 'tq_lineage';
        baseDiv.id = 'tq_lineage';
        htmlNode.appendChild(baseDiv);

        var lineageDiagram = document.createElement('DIV');
        lineageDiagram.className = 'tq_lineage__graph';
        lineageDiagram.id = 'tq_lineage-graph';
        baseDiv.appendChild(lineageDiagram);

        var sigmaGraph = document.createElement('DIV');
        sigmaGraph.className = 'tq_lineage__sigma_graph';
        sigmaGraph.id = 'tq_lineage-sigma-graph';
        baseDiv.appendChild(sigmaGraph);

        var derivationMap = document.createElement('DIV');
        baseDiv.appendChild(derivationMap);

        return {
            container: htmlNode,
            baseDiv: baseDiv,
            lineageDiagram: lineageDiagram,
            sigmaGraph: sigmaGraph,
            derivationMap: derivationMap,
            mapHTMLElement: _getMapHTML(_parameters.mapRootHtml)
        };
    }

    /**
     * @private
     * Creates html markup for map.
     * @param {string|HTMLElement} mapRootHtml - ID of root element or HTMLElement
     * @returns {HTMLElement}
     */
    function _getMapHTML(mapRootHtml) {
        var mapRootHtmlHtml = void 0;
        if (typeof mapRootHtml === 'string') {
            mapRootHtmlHtml = document.getElementById(mapRootHtml);
        } else if ((typeof mapRootHtml === 'undefined' ? 'undefined' : _typeof(mapRootHtml)) === 'object') {
            mapRootHtmlHtml = mapRootHtml;
        } else {
            return {};
        }

        var mapHTMLElement = void 0;
        if (mapRootHtmlHtml) {
            // check element
            // Clear a content of the map root html element
            mapRootHtmlHtml.innerHTML = '';
            // Create a private root for map into the public root.
            // (User can change style of public root)
            mapHTMLElement = document.createElement('DIV');
            mapHTMLElement.className = 'tq-lg__map';
            mapRootHtmlHtml.appendChild(mapHTMLElement); // adding the private root into the public
        }
        return mapHTMLElement;
    }

    /**
     * @private
     * Makes the view-1 visible and the view-2 invisible.
     * @fires current-view-changed
     */
    function _showSigmaGraph() {
        _base.sigmaGraph.style.opacity = 1;
        _base.sigmaGraph.style.pointerEvents = 'auto';

        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                _birdEye.setSelectedElement(_lineageDiagram.getSelectedElement());
                _birdEye.refresh();
            } else {
                _lineageDiagram.resize();
                _birdEye.sigmaGraph.refresh();
            }
        }

        _currentView = 'birdEye';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 visible and the view-1 invisible.
     * @fires current-view-changed
     */
    function _showJointGraph() {
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';

        _base.lineageDiagram.style.opacity = 1;
        _base.lineageDiagram.style.pointerEvents = 'auto';

        if (_state === 'completed') {
            if (_currentView !== 'none') {
                if (_birdEye.selectedElement) {
                    var visibleNodes = _lineageDiagram.getVisibleNodes();
                    var isSelectedNode = _birdEye.selectedElement instanceof graphElements.Node;
                    var nodeIsInvisible = visibleNodes.indexOf(_birdEye.selectedElement) === -1;
                    var isSelectedLink = _birdEye.selectedElement instanceof graphElements.Link;
                    var allOfTheEndsIsInvisible = visibleNodes.indexOf(_dataContainer.maps.nodeMap[_birdEye.selectedElement.model.source]) === -1;
                    var focusOn = isSelectedNode && nodeIsInvisible || isSelectedLink && allOfTheEndsIsInvisible;

                    _lineageDiagram.setSelectedElement(_birdEye.selectedElement, focusOn);
                } else {
                    _lineageDiagram.redraw();
                }
            } else {
                _lineageDiagram.resize();
                _lineageDiagram.redraw();
            }
        }

        _currentView = 'lineageDiagram';
        self.trigger('current-view-changed', _currentView);
    }

    /**
     * @private
     * Makes the view-2 and the view-1 invisible.
     * @fires current-view-changed
     */
    function _hideViews() {
        // _base.container.className = 'tq_lineage_disable';
        _base.sigmaGraph.style.opacity = 0;
        _base.sigmaGraph.style.pointerEvents = 'none';
        _base.lineageDiagram.style.opacity = 0;
        _base.lineageDiagram.style.pointerEvents = 'none';

        _currentView = 'none';
        self.trigger('current-view-changed', _currentView);
    }
}
exports.default = LineageGram;

},{"./data/dataContainer":26,"./data/dataProcessing":27,"./data/resourceProvider":29,"./jointViews/derivationMap/derivationMap":40,"./jointViews/graphElements/elements":46,"./jointViews/lineageDiagram":51,"./layout/layout":56,"./sigmaViews/birdEye":60,"./sigmaViews/graphMap":61,"./stateStorage":64,"./subscriptionAPI/subscribeable":65,"./utils/dataUtils":66,"lodash":"lodash","rappid":"rappid","visualizations-library":70}],59:[function(require,module,exports){
'use strict';

var _lineageGram = require('./lineageGram');

var LineageGram = _interopRequireWildcard(_lineageGram);

var _defaultDataProvider = require('./data/defaultDataProvider');

var _defaultDataProvider2 = _interopRequireDefault(_defaultDataProvider);

var _infoPanel = require('./htmlUI/infoPanel');

var _infoPanel2 = _interopRequireDefault(_infoPanel);

var _optionsPanel = require('./htmlUI/optionsPanel');

var _optionsPanel2 = _interopRequireDefault(_optionsPanel);

var _map = require('./htmlUI/map');

var _map2 = _interopRequireDefault(_map);

var _defaultUI = require('./htmlUI/defaultUI');

var _defaultUI2 = _interopRequireDefault(_defaultUI);

var _derivationMap = require('./jointViews/derivationMap/derivationMap');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

require('es6-promise').Promise;
require('whatwg-fetch');

module.exports = {
    LineageGram: LineageGram.LineageGram,
    getDefaultParametersSet: LineageGram.getDefaultParametersSet,
    DefaultDataProvider: _defaultDataProvider2.default,
    DerivationMap: _derivationMap.DerivationMap,
    uiUtils: {
        DefaultUI: _defaultUI2.default,
        Map: _map2.default,
        InfoPanel: _infoPanel2.default,
        OptionsPanel: _optionsPanel2.default
    }
};

},{"./data/defaultDataProvider":28,"./htmlUI/defaultUI":30,"./htmlUI/infoPanel":33,"./htmlUI/map":34,"./htmlUI/optionsPanel":35,"./jointViews/derivationMap/derivationMap":40,"./lineageGram":58,"es6-promise":1,"whatwg-fetch":24}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BirdEye = BirdEye;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _lineageDiagramUtils = require('../utils/lineageDiagramUtils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
*/
function BirdEye(options, parameters) {
    var self = this;
    var _colors = parameters.colors;
    var _path = null;

    _sigmaBase2.default.apply(self, [options, parameters]);

    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        if (self.selectedElement !== selectedElement) {
            if (selectedElement) {
                _path = (0, _lineageDiagramUtils.getPath)(selectedElement, self._dataContainer);
            } else {
                _path = null;
            }
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;

        self.sigmaGraph.graph.nodes().forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var model = node.model;
                sigmaNode.x = model.position.x;
                sigmaNode.y = model.position.y;

                sigmaNode.color = self.selectedElement && (node.id === self.selectedElement.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === node.id;
                }).length > 0) ? _colors['selected'] : !_path || _path[node.id] ? _colors[model.typeId] : _colors['blured'];
            }
        });
    };

    self._refreshViewFrames = function () {};

    self._refreshLinks = function () {
        self.sigmaGraph.graph.edges().forEach(function (l) {
            l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = !_path || _path[l.id] ? self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'] : _colors['blured'];
        });
    };

    self._initialize();
}

BirdEye.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = BirdEye;

},{"../jointViews/graphElements/elements":46,"../utils/lineageDiagramUtils":68,"./sigmaBase":62}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraphMap = GraphMap;

var _sigmaBase = require('./sigmaBase');

var _sigmaBase2 = _interopRequireDefault(_sigmaBase);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * @private
 * @class
 * Mini map in the right-bottom corner,
 * which shows the full graph with viewFrame's positions without links
 * @augments SigmaBase
 * @fires view-frames-position-changed (params: ViewFramePublicModel[])
*/
function GraphMap(options, parameters) {
    var self = this;
    var _viewFramesMap = {};
    options.viewFrames.forEach(function (vf) {
        return _viewFramesMap[vf.id] = vf;
    });

    _sigmaBase2.default.apply(self, [options, parameters]);

    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: [] };
    };

    /**
     * Redefinition
     */
    var oldSetSelectedElement = self.setSelectedElement;
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var graph = self.sigmaGraph.graph;
        if (self.selectedElement instanceof graphElements.Link) {
            graph.dropEdge(self.selectedElement.id);
        }
        if (selectedElement instanceof graphElements.Link) {
            graph.addEdge(self._createLink(selectedElement));
        }
        oldSetSelectedElement.call(self, selectedElement);
    };

    var overrideRedraw = self.redraw;
    self.redraw = function (renderOptions) {
        overrideRedraw(renderOptions);
        renderOptions = renderOptions || {};
        if (renderOptions.viewFrames) renderOptions.viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    var overridedSetData = self.setData;
    self.setData = function (dataContainer, viewFrames) {
        overridedSetData(dataContainer, viewFrames);
        _viewFramesMap = {};
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel} viewFrames
     */
    var _oldImplementation = self._refreshViewFrames;
    self._refreshViewFrames = function (viewFrames) {
        _oldImplementation(viewFrames);
        viewFrames.forEach(function (vf) {
            return _viewFramesMap[vf.id] = vf;
        });
    };

    /**
     * Redefinition.
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickStage', function (e) {
            var globalClickPoint = _connvertPoint(e);
            var viewFrames = Object.keys(_viewFramesMap).map(function (key) {
                return _viewFramesMap[key];
            });
            for (var i = 0; i < viewFrames.length; i++) {
                var viewFrame = viewFrames[i];
                if (!viewFrame.active) continue;

                var bounds = {
                    minX: viewFrame.viewPortPositionBounds.minX,
                    minY: viewFrame.viewPortPositionBounds.minY,
                    maxX: viewFrame.viewPortPositionBounds.maxX + viewFrame.viewPortBounds.width,
                    maxY: viewFrame.viewPortPositionBounds.maxY + viewFrame.viewPortBounds.height
                };

                var pointHitsTheBounds = bounds.minX <= globalClickPoint.x && globalClickPoint.x <= bounds.maxX && bounds.minY <= globalClickPoint.y && globalClickPoint.y <= bounds.maxY;
                if (pointHitsTheBounds) {
                    var viewFrameOptions = {
                        id: viewFrame.id,
                        viewPortPosition: {
                            x: globalClickPoint.x - viewFrame.size.width / 2,
                            y: globalClickPoint.y - viewFrame.size.height / 2
                        }
                    };
                    self.trigger('view-frames-position-changed', [[viewFrameOptions]]);
                }
            }
        });

        self.sigmaGraph.bind('clickNode', function (evt) {
            var node = evt.data.node ? self._dataContainer.maps.nodeMap[evt.data.node.id] : null;
            self.setSelectedElement(node);
            self.trigger('selected-element-changed', node);
        });

        self.sigmaGraph.bind('clickEdge', function (evt) {
            var link = evt.data.edge ? self._dataContainer.maps.linkMap[evt.data.edge.id] : null;
            self.setSelectedElement(link);
            self.trigger('selected-element-changed', link);
        });
    };

    /** 
     * Calculates sigma paper point to joint paper point.
     * @param {
     *  data: {
     *      cptor: {
     *          clientX,
     *          clientY
     *      }
     *  }
     * } event
    */
    function _connvertPoint(event) {
        var renderer = self.sigmaGraph.renderers[0];
        var _prefix = renderer.options.prefix;
        return executeNodeMouseMove();

        function executeNodeMouseMove() {
            var offset = _calculateOffset(renderer.container),
                x = event.data.captor.clientX - offset.left,
                y = event.data.captor.clientY - offset.top,
                cos = Math.cos(self.sigmaGraph.camera.angle),
                sin = Math.sin(self.sigmaGraph.camera.angle),
                nodes = self.sigmaGraph.graph.nodes(),
                ref = [];

            // Getting and derotating the reference coordinates.
            for (var i = 0; i < 2; i++) {
                var n = nodes[i];
                var aux = {
                    x: n.x * cos + n.y * sin,
                    y: n.y * cos - n.x * sin,
                    renX: n[_prefix + 'x'],
                    renY: n[_prefix + 'y']
                };
                ref.push(aux);
            }

            // Applying linear interpolation.
            // if the nodes are on top of each other, we use the camera ratio to interpolate
            if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
                var xRatio = ref[0].renX === 0 ? 1 : ref[0].renX;
                var yRatio = ref[0].renY === 0 ? 1 : ref[0].renY;
                x = ref[0].x / xRatio * (x - ref[0].renX) + ref[0].x;
                y = ref[0].y / yRatio * (y - ref[0].renY) + ref[0].y;
            } else {
                xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
                yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

                // if the coordinates are the same, we use the other ratio to interpolate
                if (ref[1].x === ref[0].x) {
                    xRatio = yRatio;
                }

                if (ref[1].y === ref[0].y) {
                    yRatio = xRatio;
                }

                x = (x - ref[0].renX) / xRatio + ref[0].x;
                y = (y - ref[0].renY) / yRatio + ref[0].y;
            }

            return { x: x * cos - y * sin, y: y * cos + x * sin };
        }
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function _calculateOffset(element) {
        var style = window.getComputedStyle(element);
        var getCssProperty = function getCssProperty(prop) {
            return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
        };
        return {
            left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
            top: element.getBoundingClientRect().top + getCssProperty('padding-top')
        };
    }

    self._initialize();
}
GraphMap.prototype = Object.create(_sigmaBase2.default.prototype);

exports.default = GraphMap;

},{"../jointViews/graphElements/elements":46,"./sigmaBase":62}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigmaBase = SigmaBase;

var _sigma = require('sigma');

var _sigma2 = _interopRequireDefault(_sigma);

var _sigmaRenderers = require('./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot');

var SigmaSnapshotPlugin = _interopRequireWildcard(_sigmaRenderers);

var _subscribeable = require('../subscriptionAPI/subscribeable');

var _subscribeable2 = _interopRequireDefault(_subscribeable);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

var _fileSaverjs = require('file-saverjs');

var _fileSaverjs2 = _interopRequireDefault(_fileSaverjs);

var _dataUtils = require('../utils/dataUtils');

var _utils = require('../utils/utils');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

SigmaSnapshotPlugin.usePlugin(_sigma2.default);

/** 
 * @private
 * @class
 * It's the base class for sigma views.
 * 
 * Constructor parameters:
 * ========================================
 * @param {
 *  dataContainer: DataContainer
 *  viewFrames: ViewFramePublicModel[]
 *  el: HTMLElement
 *  selectedElement: Node|Link
 *  scale:number
 * } options
 * @param {Parameters} parameters - parameters set
 * 
 * Public properties:
 * ========================================
 * selectedElement: Node|Link
 * 
 * Public methods:
 * ========================================
 * setSelectedElement: (element: Node|Link) => void
 * setData: (dataContainer: DataContainer, viewFrames: ViewFrame[]) => void
 * setScale: (scale: number) => void
 * refresh: () => void
 * export: (name?: string) => void
 * print: () => void
 * redraw: () => void
 * ----------------------------------------
 * on (event: string, callback: function): void
 * unsubscribe (callback: function): void
 * trigger (event: string, parameters: any): void
 * 
 * Events:
 * ========================================
 * @fires selected-element-changed (params: Node|Link)
 * @fires cell-double-click (params: Node|Link)
*/
function SigmaBase(options, parameters) {

    _subscribeable2.default.apply(this); // make this class Subscribable

    var self = this;
    var _colors = parameters.colors;

    var _maxNodeSize = 0;
    var _rootElement = void 0;
    var _sigmaFrames = {};

    self._aspectLinks = {};
    self.selectedElement;
    self._dataContainer; // to override


    /**
     * Runs initialization. It's executed after creation by descendant
     */
    self._initialize = function () {
        _initialize(options.dataContainer, options.viewFrames, options.el, options.selectedElement, options.scale);
    };

    /**
     * It's kind of constructor, which called after creation the object.
     * @param {DataContainer} dataContainer
     * @param {Array of ViewFrame} viewFrames
     * @param {HTMLElement} rootElement
     * @param {Node|Link} selectedElement
     * @param {number} scale
    */
    function _initialize(dataContainer, viewFrames, rootElement, selectedElement) {
        _rootElement = rootElement;
        self.selectedElement = selectedElement;
        viewFrames = viewFrames || [];
        self._dataContainer = dataContainer;

        var data = self._getData();
        var g = {
            nodes: [],
            edges: []
        };

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            g.nodes.push(newNode);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            g.edges.push(newLink);
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            g.edges.push(al);
        });

        _maxNodeSize = _getNodeSize();

        self.sigmaGraph = new _sigma2.default({
            graph: g,
            container: _rootElement,
            settings: {
                minNodeSize: 0,
                maxNodeSize: _maxNodeSize,
                nodesPowRatio: 1,
                enableEdgeHovering: true,
                edgeHoverColor: 'edge',
                defaultEdgeHoverColor: '#000',
                edgeHoverSizeRatio: 4,
                edgeHoverExtremities: true,
                autoResize: false,
                clone: false,
                doubleClickZoomingRatio: 1
            }
        });
        self._subscribeOnEvents();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        self.sigmaGraph.refresh();
    }

    /**
     * Exports graph to png file
     * @param {string} diagramName
    */
    self.export = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });

        (0, _fileSaverjs2.default)((0, _dataUtils.png2Blob)(data), fileName + '.png');
    };

    /**
     * Exports graph to pdf file
     * @param {string} diagramName
    */
    self.print = function (diagramName) {
        var fileName = diagramName || 'LG_bird_eye_snapshot_' + (0, _dataUtils.date2String)(new Date());
        var data = self.sigmaGraph.renderers[0].snapshot({
            format: 'png',
            download: false,
            background: 'transparent',
            labels: true,
            filename: fileName
        });
        var printWindow = window.open('', undefined, 'width=1280,height=720');
        if (printWindow) {
            printWindow.document.write('\n                <html>\n                    <body>\n                        <img src="' + data + '"/>\n                    </body>\n                </html>\n            ');
            printWindow.document.querySelector('img').onload = function () {
                printWindow.document.close();
                printWindow.print();
            };
        } else {
            alert('You should unblock popup windows for the current url to be able to print this diagram!');
        }
    };

    /**
     * Sets selected element.
     * @param {Node|Link} element
    */
    self.setSelectedElement = function (element) {
        var selectedElement = void 0;
        if (element instanceof graphElements.Node || element instanceof graphElements.TerminationNode) {
            selectedElement = element.originalNode || element;
        } else if (element instanceof graphElements.Link) {
            var link = element.originalLink || element;
            selectedElement = link;
        } else {
            selectedElement = null;
        }

        var refresh = self.selectedElement !== selectedElement;
        self.selectedElement = selectedElement;
        if (refresh) self.redraw();
    };

    /**
     * Sets new data container
     * @param {DataContainer} dataContainer
     * @param {ViewFramePublicModel[]} viewFrames
    */
    self.setData = function (dataContainer, viewFrames) {
        self.selectedElement = null;
        self._dataContainer = dataContainer;
        viewFrames = viewFrames || [];

        var data = self._getData();

        self.sigmaGraph.graph.clear();
        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        data.nodes.forEach(function (node) {
            var newNode = self._createNode(node);
            self.sigmaGraph.graph.addNode(newNode);
        });

        viewFrames.forEach(function (viewFrame) {
            var frame = _createSigmaFrame(viewFrame);
            _sigmaFrames[viewFrame.id] = frame;
            if (viewFrame.active) {
                _addViewFrame(viewFrame);
            } else {
                _sigmaFrames[viewFrame.id] = _createSigmaFrame(viewFrame);
            }
        });

        var aspectLinks = _createAspectLinks(data.nodes);
        aspectLinks.forEach(function (al) {
            self.sigmaGraph.graph.addEdge(al);
        });

        data.links.forEach(function (link) {
            var newLink = self._createLink(link);
            self.sigmaGraph.graph.addEdge(newLink);
        });

        self.sigmaGraph.refresh();
        self.redraw();
    };

    var debouncer = void 0;
    /**
     * Redraws all graph. Mainly - updates colors of elements
     * @param {viewFrames, scale, nodes, fullScreenMode} options
     */
    self.redraw = function (options) {
        options = options || {};

        _maxNodeSize = _getNodeSize();
        self.sigmaGraph.settings('maxNodeSize', _maxNodeSize);

        cancelAnimationFrame(debouncer);
        debouncer = requestAnimationFrame(function () {
            self._refreshNodes();
            self._refreshLinks();

            if (options.viewFrames) {
                self._refreshViewFrames(options.viewFrames);
            }

            self.sigmaGraph.refresh();
        });
    };

    // can be overrided
    self.refresh = function () {
        self.redraw();
    };

    /**
     * Updates links states. 
     */
    self._refreshLinks = function () {
        var edges = self.sigmaGraph.graph.edges();
        edges.forEach(function (l) {
            if (l.id.indexOf('__top') === -1 && l.id.indexOf('__bottom') === -1 && l.id.indexOf('__left') === -1 && l.id.indexOf('__right') === -1) {
                l.size = self.selectedElement && l.id === self.selectedElement.id ? 5 : 1, l.color = self.selectedElement && l.id === self.selectedElement.id ? _colors['selected'] : self._aspectLinks[l.id] ? _colors['aspectLink'] : _colors['link'];
            }
        });
    };

    /**
     * Updates nodes states. 
     */
    self._refreshNodes = function () {
        var nodeMap = self._dataContainer.maps.nodeMap;
        var nodes = self.sigmaGraph.graph.nodes();
        nodes.forEach(function (sigmaNode) {
            if (nodeMap[sigmaNode.id]) {
                var node = nodeMap[sigmaNode.id];
                var position = (0, _utils.getGlobalNodePosition)(node);
                sigmaNode.x = position.x;
                sigmaNode.y = position.y;
                sigmaNode.color = self.selectedElement && (self.selectedElement.id === sigmaNode.id || self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                    return a.id === sigmaNode.id;
                }).length > 0) ? _colors['selected'] : _colors[node.model.typeId];
            }
        });
    };

    /**
     * Updates viewFrames state. 
     * @param {ViewFramePublicModel[]} viewFrames
     */
    self._refreshViewFrames = function (viewFrames) {
        viewFrames.forEach(function (viewFrame) {
            if (viewFrame.active) {
                var frame = _sigmaFrames[viewFrame.id];
                var points = _getFramesPoints(viewFrame);

                frame.p1.x = points.p1.x;
                frame.p1.y = points.p1.y;

                frame.p2.x = points.p2.x;
                frame.p2.y = points.p2.y;

                frame.p3.x = points.p3.x;
                frame.p3.y = points.p3.y;

                frame.p4.x = points.p4.x;
                frame.p4.y = points.p4.y;

                _addViewFrame(viewFrame);
            } else {
                _removeViewFrame(viewFrame);
            }
        });
    };

    /**
     * Adds viewFrame on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _addViewFrame(viewFrame) {
        var frame = _sigmaFrames[viewFrame.id] = _sigmaFrames[viewFrame.id] || _createSigmaFrame(viewFrame);
        if (!viewFrame || frame.active) return;

        self.sigmaGraph.graph.addNode(frame.p1);
        self.sigmaGraph.graph.addNode(frame.p2);
        self.sigmaGraph.graph.addNode(frame.p3);
        self.sigmaGraph.graph.addNode(frame.p4);

        self.sigmaGraph.graph.addEdge(frame.top);
        self.sigmaGraph.graph.addEdge(frame.bottom);
        self.sigmaGraph.graph.addEdge(frame.left);
        self.sigmaGraph.graph.addEdge(frame.right);

        frame.active = true;
    }

    /**
     * Removes viewFrame from the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _removeViewFrame(viewFrame) {
        if (!viewFrame || !_sigmaFrames[viewFrame.id].active) return;

        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__top');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__bottom');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__left');
        self.sigmaGraph.graph.dropEdge(viewFrame.id + '__right');

        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BL');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__TR');
        self.sigmaGraph.graph.dropNode(viewFrame.id + '__BR');

        _sigmaFrames[viewFrame.id].active = false;
    }

    /**
     * Returns links and nodes.
     * @returns {{Node[], Link[]}}
     */
    self._getData = function () {
        return { nodes: self._dataContainer.nodes, links: self._dataContainer.links };
    };

    /**
     * Creates sigma node from jointjs node.
     * @param {Node} node 
     */
    self._createNode = function (node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var model = node.model;
        return {
            id: node.id,
            label: model.label,
            x: position.x,
            y: position.y,
            size: 1,
            color: node === self.selectedElement || self.selectedElement && self.selectedElement.aspects && self.selectedElement.aspects.filter(function (a) {
                return a.id === node.id;
            }).length > 0 ? _colors['selected'] : _colors[model.typeId]
        };
    };

    /**
     * Creates sigma edge from jointjs link.
     * @param {Link} link 
     */
    self._createLink = function (link) {
        return {
            id: link.id,
            source: link.model.source,
            target: link.model.target,
            size: link === self.selectedElement ? 5 : 1,
            color: link === self.selectedElement ? _colors['selected'] : 'black'
        };
    };

    /**
     * Subscribes on events.
     * @fires: selected-element-changed (params: Node|Link)
     * @fires: cell-double-click (params: Node|Link)
     */
    self._subscribeOnEvents = function () {
        self.sigmaGraph.bind('clickNode clickStage', function (e) {
            return _onClick(e, function (event) {
                var node = event.data.node ? self._dataContainer.maps.nodeMap[event.data.node.id] : null;
                if (node || !event.data.captor.isDragging && !node) {
                    self.setSelectedElement(node);
                    self.trigger('selected-element-changed', node);
                }
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });

        self.sigmaGraph.bind('clickEdge', function (e) {
            return _onClick(e, function (event) {
                var link = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.setSelectedElement(link);
                self.trigger('selected-element-changed', link);
            }, function (event) {
                var element = event.data.edge ? self._dataContainer.maps.linkMap[event.data.edge.id] : null;
                self.trigger('cell-double-click', element);
            });
        });
    };

    /**
     * Returns default size for nodes. 
     */
    function _getNodeSize() {
        var result = void 0;
        if (self._dataContainer.nodes.length <= 0) return 0;
        if (self.sigmaGraph) {
            var renderer = self.sigmaGraph.renderers[0] || { width: _rootElement.clientWidth, height: _rootElement.clientHeight };
            if (parameters.elementSize.width > parameters.elementSize.height) {
                result = renderer.width / (parameters.elementSize.width + parameters.layoutStep.x);
            } else {
                result = renderer.height / (parameters.elementSize.height + parameters.layoutStep.y);
            }
        } else {
            result = 5;
        }
        if (self._getNodeSize) return self._getNodeSize(result);else return result;
    }

    /**
     * Creates aspect links.
     * @param {Node[]} nodes
     */
    function _createAspectLinks(nodes) {
        self._aspectLinks = {};
        var linksToReturn = [];
        nodes.forEach(function (node) {
            var aspects = node.aspects;

            aspects.forEach(function (aspect) {
                addLink(node, aspect);
            });
        });

        function addLink(node, aspect) {
            var id1 = node.id + '~#tqLgAspectLink#~' + aspect.id;
            var id2 = aspect.id + '~#tqLgAspectLink#~' + node.id;

            if (!self._aspectLinks[id1] && !self._aspectLinks[id2]) {
                var al = {
                    id: id1,
                    source: node.id,
                    target: aspect.id,
                    color: _colors['aspectLink']
                };
                self._aspectLinks[id1] = al;
                linksToReturn.push(al);
            }
        }

        return linksToReturn;
    }

    /**
     * Creates sigma notation of the joint viewFrame and places on the sigma graph.
     * @param {ViewFramePublicModel} viewFrame
     */
    function _createSigmaFrame(viewFrame) {
        var points = _getFramesPoints(viewFrame);
        var color = viewFrame.borderColor;

        // nodes

        var p1 = {
            id: viewFrame.id + '__TL',
            label: viewFrame.id,
            x: points.p1.x,
            y: points.p1.y,
            size: 0.3,
            color: color
        };

        var p2 = {
            id: viewFrame.id + '__BL',
            label: viewFrame.id,
            x: points.p3.x,
            y: points.p3.y,
            size: 0.3,
            color: color
        };

        var p3 = {
            id: viewFrame.id + '__TR',
            label: viewFrame.id,
            x: points.p2.x,
            y: points.p2.y,
            size: 0.3,
            color: color
        };

        var p4 = {
            id: viewFrame.id + '__BR',
            label: viewFrame.id,
            x: points.p4.x,
            y: points.p4.y,
            size: 0.3,
            color: color
        };

        // Edges

        var top = {
            id: viewFrame.id + '__top',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__TR',
            size: 10,
            color: color
        };

        var bottom = {
            id: viewFrame.id + '__bottom',
            source: viewFrame.id + '__BL',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        var left = {
            id: viewFrame.id + '__left',
            source: viewFrame.id + '__TL',
            target: viewFrame.id + '__BL',
            size: 10,
            color: color
        };

        var right = {
            id: viewFrame.id + '__right',
            source: viewFrame.id + '__TR',
            target: viewFrame.id + '__BR',
            size: 10,
            color: color
        };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4,

            top: top,
            bottom: bottom,
            left: left,
            right: right,

            active: false
        };
    }

    function _getFramesPoints(viewFrame) {
        var p1 = {
            x: viewFrame.viewPortBounds.minX,
            y: viewFrame.viewPortBounds.minY
        };
        var p2 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y };
        var p3 = { x: p1.x, y: p1.y + viewFrame.viewPortBounds.height };
        var p4 = { x: p1.x + viewFrame.viewPortBounds.width, y: p1.y + viewFrame.viewPortBounds.height };

        return {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4
        };
    }

    // Fixing the sigma bug with horizontal/vertical lines hovering.
    // ========================================================================
    _sigma2.default.utils.isPointOnSegment = function (x, y, x1, y1, x2, y2, epsilon) {
        // http://stackoverflow.com/a/328122
        var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
            d = _sigma2.default.utils.getDistance(x1, y1, x2, y2),
            nCrossProduct = crossProduct / d; // normalized cross product

        return nCrossProduct < epsilon && Math.min(x1, x2) - epsilon <= x && x <= Math.max(x1, x2) + epsilon && Math.min(y1, y2) - epsilon <= y && y <= Math.max(y1, y2) + epsilon;
    };

    var _clicks = 0;
    function _onClick(event, clickCallback, doubleClickCallback) {
        _clicks++;

        if (_clicks >= 2) {
            _clicks = 0;
            doubleClickCallback(event);
        } else if (_clicks === 1) {
            setTimeout(function () {
                if (_clicks === 1) {
                    clickCallback(event);
                }
                _clicks = 0;
            }, 250);
        }
    }
}
exports.default = SigmaBase;

},{"../jointViews/graphElements/elements":46,"../subscriptionAPI/subscribeable":65,"../utils/dataUtils":66,"../utils/utils":69,"./sigmaPlagins/sigma.renderers.snapshot/sigma.renderers.snapshot":63,"file-saverjs":2,"sigma":4}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.usePlugin = usePlugin;
function usePlugin(sigma) {

    /**
     * Sigma Renderer Snapshot Utility
     * ================================
     *
     * The aim of this plugin is to enable users to retrieve a static image
     * of the graph being rendered.
     *
     * Author: Guillaume Plique (Yomguithereal)
     * Version: 0.0.1
     */

    // Terminating if sigma were not to be found
    if (typeof sigma === 'undefined') throw 'sigma.renderers.snapshot: sigma not in scope.';

    // Constants
    var CONTEXTS = ['scene', 'edges', 'nodes', 'labels'],
        TYPES = {
        png: 'image/png',
        jpg: 'image/jpeg',
        gif: 'image/gif',
        tiff: 'image/tiff'
    };

    // Utilities
    function download(dataUrl, extension, filename) {

        // Anchor
        var anchor = document.createElement('a');
        anchor.setAttribute('href', dataUrl);
        anchor.setAttribute('download', filename || 'graph.' + extension);

        // Click event
        var event = document.createEvent('MouseEvent');
        event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

        anchor.dispatchEvent(event);
        anchor = undefined;
    }

    // Main function
    function snapshot(params) {
        params = params || {};

        // Enforcing
        if (params.format && !(params.format in TYPES)) throw Error('sigma.renderers.snaphot: unsupported format "' + params.format + '".');

        var self = this,
            webgl = this instanceof sigma.renderers.webgl,
            doneContexts = [];

        // Creating a false canvas where we'll merge the other
        var merged = document.createElement('canvas'),
            mergedContext = merged.getContext('2d'),
            sized = false;

        // Iterating through context
        CONTEXTS.forEach(function (name) {
            if (!self.contexts[name]) return;

            if (params.labels === false && name === 'labels') return;

            var canvas = self.domElements[name] || self.domElements['scene'],
                context = self.contexts[name];

            if (~doneContexts.indexOf(context)) return;

            if (!sized) {
                merged.width = webgl && context instanceof WebGLRenderingContext ? canvas.width / 2 : canvas.width;
                merged.height = webgl && context instanceof WebGLRenderingContext ? canvas.height / 2 : canvas.height;
                sized = true;

                // Do we want a background color?
                if (params.background) {
                    mergedContext.rect(0, 0, merged.width, merged.height);
                    mergedContext.fillStyle = params.background;
                    mergedContext.fill();
                }
            }

            if (context instanceof WebGLRenderingContext) mergedContext.drawImage(canvas, 0, 0, canvas.width / 2, canvas.height / 2);else mergedContext.drawImage(canvas, 0, 0);

            doneContexts.push(context);
        });

        var dataUrl = merged.toDataURL(TYPES[params.format || 'png']);

        if (params.download) download(dataUrl, params.format || 'png', params.filename);

        // Cleaning
        mergedContext = undefined;
        merged = undefined;
        doneContexts = undefined;

        return dataUrl;
    }

    // Extending canvas and webl renderers
    sigma.renderers.canvas.prototype.snapshot = snapshot;
    sigma.renderers.webgl.prototype.snapshot = snapshot;
}
exports.default = usePlugin;

},{}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StateStorage = StateStorage;

var _lodash = require('lodash');

var DEFAULT_DECK_LENGTH = 4;

/**
 * Store states of LG. States is a Diagrams rendered around focusNode.
 * @class
 * @private
 * Constructor parameters
 *  @param {Parameters} parameters

 * Public methods:
 * pushState: () => void
 * getHistory: () => {
 *  states: { nodes: Node[], links: Link[], focusNode: Node }[],
 *  currentIndex: number,
 * }
 * undoState: () => void
 * redoState: () => void
 */
function StateStorage(parameters) {
    var self = this;
    if (!parameters) parameters = {};

    var _stateDeck = [];
    var _maxDeckLength = parameters.deckLength || DEFAULT_DECK_LENGTH;
    var _currentIndex = -1;

    self.pushState = function (state) {
        if (_stateDeck.length - 1 > _currentIndex) {
            _stateDeck.splice(_currentIndex + 1, _stateDeck.length);
        }
        _stateDeck.push(state);
        _check();
        _currentIndex = _stateDeck.length - 1;
    };

    self.updateState = function (state) {
        _stateDeck[_currentIndex] = state;
    };

    self.getHistory = function () {
        return {
            states: (0, _lodash.cloneDeep)(_stateDeck),
            currentIndex: _currentIndex
        };
    };

    self.undoState = function () {
        if (_currentIndex > 0) {
            _currentIndex--;
            return _returnState();
        } else {
            return null;
        }
    };

    self.redoState = function () {
        if (_currentIndex + 1 < _stateDeck.length) {
            _currentIndex++;
            return _returnState();
        } else {
            return null;
        }
    };

    function _returnState() {
        return _stateDeck[_currentIndex];
    }

    function _check() {
        if (_stateDeck.length > _maxDeckLength) _stateDeck.shift();
    }
}

exports.default = StateStorage;

},{"lodash":"lodash"}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Subscribable = Subscribable;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/** 
 * It's base class which provides subscription API for successors.
 * @class
*/
function Subscribable() {
    var self = this;
    self._subscribtions = {};

    /**
     * Method allows to subscribe on a some specific event.
     * @param {string} event - event id
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.on = function (event, callback) {
        if (!self._subscribtions[event]) self._subscribtions[event] = [];
        if (callback && callback instanceof Function) {
            self._subscribtions[event].push(callback);
        } else {
            throw new Error('Illegal type of callback!');
        }
    };

    /**
     * Method allows to unsubscribe from a some specific event.
     * @param {function} callback - event handler
     * @memberof Subscribable
     * @method
    */
    self.unsubscribe = function (callback) {
        _.values(self._subscribtions).forEach(function (subscribers) {
            var index = subscribers.indexOf(callback);
            if (index !== -1) subscribers.splice(index, 1);
        });
    };

    /**
     * Method which fires the event.
     * @param {string} event - event id
     * @param {Object[]} parameters
     * @memberof Subscribable
     * @method
    */
    self.trigger = function (event, parameters) {
        var _this = this;

        if (!(parameters instanceof Array)) parameters = [parameters];
        if (self._subscribtions && self._subscribtions[event]) {
            self._subscribtions[event].forEach(function (c) {
                c.apply(_this, parameters);
            });
        }
    };
}
exports.default = Subscribable;

},{"lodash":"lodash"}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBaseElement = getBaseElement;
exports.checkLgRawData = checkLgRawData;
exports.checkDmRawData = checkDmRawData;
exports.defenitionToPublicModel = defenitionToPublicModel;
exports.createJointNodes = createJointNodes;
exports.createJointLinks = createJointLinks;
exports.date2String = date2String;
exports.png2Blob = png2Blob;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

var _elements = require('../jointViews/graphElements/elements');

var graphElements = _interopRequireWildcard(_elements);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function getBaseElement(element) {
    if (!element) return null;
    return element.originalLink || element.originalNode || element;
}

function checkLgRawData(data) {
    if (!data.links && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.links instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

function checkDmRawData(data) {
    if (!data.edges && !data.nodes) {
        throw new Error('There is no data to show!');
    }
    if (data.nodes) {
        if (!(data.nodes instanceof Array)) {
            throw new Error('\'nodes\' should be an Array, but it is object!');
        } else if (data.nodes.length === 0) {
            throw new Error('There is no data to show!');
        }
    } else {
        throw new Error('There is no nodes information in the data, so we have nothing to show!');
    }
    if (data.links && !(data.edges instanceof Array)) {
        throw new Error('\'links\' should be an Array, but it is object!');
    }
    return true;
}

/**
 * View frame definition,
 * @typedef {Object} ViewFrameDefinition
 * @property {string} id - View frame identifyer
 * @property {string} label - Title of the view frame,
 * @property {string} borderColor - Color of the border
 * @property {string} backgroundColor - Color of the background
 * @property {number} spaceShare - How much the view frame will take
 * @property {boolean} collapsed - Define default state
 * from whole space of the graph (You can take it as persents or flex grow)
*/

function defenitionToPublicModel(defenition, fullScreenMode) {
    var isActive = fullScreenMode ? false : !defenition.collapsed;

    return {
        id: defenition.id,
        label: defenition.label,
        backgroundColor: defenition.backgroundColor,
        borderColor: defenition.borderColor,
        active: isActive,
        expanded: !defenition.collapsed,
        position: undefined,
        viewPortPosition: undefined,
        viewPortPositionBounds: undefined,
        viewPortBounds: undefined,
        nodeBounds: undefined,
        size: undefined,
        customeSized: false,
        spaceShare: defenition.spaceShare,
        updateBounds: false,
        isOverView: false
    };
}

/**
 * @private
 * Cretes joint nodes from nodeModels
 * @param {
 *      Array of {
            id: string,
            label: string,
            viewFrame: string,
            typeId: string,
            resourceType: string,
            resource: string,
 *      }
 * } NodeModels - list of models
 * @returns {Array of Node} list of joint nodes
 */
function createJointNodes(nodeModels, parameters) {
    var jointNodes = [];
    nodeModels.forEach(function (node) {
        jointNodes.push(new graphElements.Node(node, parameters));
    });
    return jointNodes;
}

/**
 * @private
 * Cretes joint links from models (nativeLinks)
 * @param {
 *      Array of {
 *          id: string,
 *          target: string,
 *          source: string,
 *      }
 * } nativeLinks - list of models
 * @returns {Link[]} list of joint links
 */
function createJointLinks(linkModels, jointNodes, parameters) {
    var jointLinks = [];
    var idMap = {};
    jointNodes.forEach(function (node) {
        idMap[node.model.id] = node.id;
    });
    linkModels.forEach(function (link) {
        var linkModel = _.cloneDeep(link);
        linkModel.sourceType = link.source;
        linkModel.targetType = link.target;
        linkModel.source = idMap[link.source];
        linkModel.target = idMap[link.target];
        linkModel.activeResourcesList = link.activeResourcesList;
        linkModel.routing = parameters.linkRouting;
        var newLink = new graphElements.Link(linkModel, parameters);
        jointLinks.push(newLink);
    });
    return jointLinks;
}

function date2String(date) {
    return padStr(date.getFullYear()) + '_' + padStr(1 + date.getMonth()) + '_' + padStr(date.getDate()) + '_' + padStr(date.getHours()) + '_' + padStr(date.getMinutes()) + '_' + padStr(date.getSeconds());

    function padStr(i) {
        return i < 10 ? '0' + i : '' + i;
    }
}

function png2Blob(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var bb = new Blob([ab], { type: 'image/png' });
    return bb;
}

},{"../jointViews/graphElements/elements":46,"lodash":"lodash"}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertNativeToLayoutModels = convertNativeToLayoutModels;
exports.convertLGElementsToLayoutModels = convertLGElementsToLayoutModels;
exports.convertDMElementsToLayoutModels = convertDMElementsToLayoutModels;
exports.convertJointElementsToLayoutModels = convertJointElementsToLayoutModels;
exports.sum = sum;
exports.map$1 = map$1;
exports.nest = nest;
exports.reinterpolate = reinterpolate;
exports.min = min;

var _utils = require('./utils');

function convertNativeToLayoutModels(nodeModels, linkModels, parameters) {
    var size = parameters.elementSize;
    var nodes = nodeModelsToLayoutNodes(nodeModels, parameters.elementSize);
    var links = linkModelsToLayoutLinks(linkModels, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function nodeModelsToLayoutNodes(nodeModels) {
        return nodeModels.map(function (nodeModel) {
            return nodeModelToLayoutNode(nodeModel);
        });
    }

    function linkModelsToLayoutLinks(linkModels, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = linkModels.map(function (link) {
            return linkModelToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeModelToLayoutNode(nodeModel) {
        return {
            id: nodeModel.id,
            x: nodeModel.position.x || Math.random(),
            y: nodeModel.position.y || Math.random(),
            originalNode: nodeModel,
            width: size.width,
            height: size.height,
            targetLinks: [],
            sourceLinks: [],
            viewFrame: nodeModel.viewFrame
        };
    }

    function linkModelToLayoutLink(linkModel, nodeMap) {
        var source = nodeMap[linkModel.source];
        var target = nodeMap[linkModel.target];
        return {
            originalLink: linkModel,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertLGElementsToLayoutModels(lgNodes, lgLinks, options) {
    var scale = options.scale;
    var nodes = lgNodes.map(function (node) {
        return nodeToLayoutNode(node);
    });
    var links = linksToLayoutLinks(lgLinks, nodes);

    return {
        nodes: nodes,
        links: links
    };

    function linksToLayoutLinks(link, nodes) {
        var nodeMap = (0, _utils.arrayToMap)(nodes);
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var position = (0, _utils.getGlobalNodePosition)(node);
        var size = (0, _utils.scaledToGlobalSize)(node.size, scale);
        return {
            id: node.id,
            x: position.x,
            y: position.y,
            originalNode: node,
            width: size.width,
            heigth: size.heigth,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.model.source];
        var target = nodeMap[link.model.target];
        return {
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }
}

function convertDMElementsToLayoutModels(dmNodes, dmLinks) {
    var nodeMap = (0, _utils.arrayToMap)(dmNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(dmLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        var portPosition = node.getPortPosition();
        var portPrimitive = node.getPort().primitive;
        return {
            id: portPrimitive.id,
            x: 0,
            y: 0,
            originalNode: portPrimitive,
            targetLinks: [],
            sourceLinks: [],
            order: portPosition.y
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var sourcePrimitive = link.source.getPort().primitive;
        var targetPrimitive = link.target.getPort().primitive;

        var source = nodeMap[sourcePrimitive.id];
        var target = nodeMap[targetPrimitive.id];

        return {
            cacheId: cachLinkFunction(sourcePrimitive, targetPrimitive),
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }

    function cachLinkFunction(source, target) {
        return source.id + '~#tqDMLink#~' + target.id;
    }
}

function convertJointElementsToLayoutModels(jNodes, jLinks) {
    var nodeMap = (0, _utils.arrayToMap)(jNodes.map(function (node) {
        return nodeToLayoutNode(node);
    }));
    var links = linksToLayoutLinks(jLinks, nodeMap);

    return {
        nodes: (0, _utils.mapToArray)(nodeMap),
        links: links
    };

    function linksToLayoutLinks(link, nodeMap) {
        var links = link.map(function (link) {
            return linkToLayoutLink(link, nodeMap);
        }).filter(function (link) {
            return link.source && link.target && link.source !== link.target;
        });
        links.forEach(function (link) {
            link.source.targetLinks.push(link);
            link.target.sourceLinks.push(link);
        });
        return links;
    }

    function nodeToLayoutNode(node) {
        return {
            id: node.id,
            originalNode: node,
            x: 0,
            y: 0,
            targetLinks: [],
            sourceLinks: []
        };
    }

    function linkToLayoutLink(link, nodeMap) {
        var source = nodeMap[link.get('source').id];
        var target = nodeMap[link.get('target').id];

        return {
            originalLink: link,
            source: source,
            target: target,
            value: 1
        };
    }
}

function sum(array, f) {
    var s = 0,
        n = array.length,
        a = void 0,
        i = -1;

    if (f == null) {
        while (++i < n) {
            a = +array[i];
            if (a) s += a;
        }
    } else {
        while (++i < n) {
            a = +f(array[i], i, array);
            if (a) s += a;
        }
    }

    return s;
}

var prefix = '$';
function Map() {}
Map.prototype = map$1.prototype = {
    constructor: Map,
    has: function has(key) {
        return prefix + key in this;
    },
    get: function get(key) {
        return this[prefix + key];
    },
    set: function set(key, value) {
        this[prefix + key] = value;
        return this;
    },
    remove: function remove(key) {
        var property = prefix + key;
        return property in this && delete this[property];
    },
    clear: function clear() {
        for (var property in this) {
            if (property[0] === prefix) delete this[property];
        }
    },
    keys: function keys() {
        var keys = [];
        for (var property in this) {
            if (property[0] === prefix) keys.push(property.slice(1));
        }return keys;
    },
    values: function values() {
        var values = [];
        for (var property in this) {
            if (property[0] === prefix) values.push(this[property]);
        }return values;
    },
    entries: function entries() {
        var entries = [];
        for (var property in this) {
            if (property[0] === prefix) entries.push({ key: property.slice(1), value: this[property] });
        }return entries;
    },
    size: function size() {
        var size = 0;
        for (var property in this) {
            if (property[0] === prefix) ++size;
        }return size;
    },
    empty: function empty() {
        for (var property in this) {
            if (property[0] === prefix) return false;
        }return true;
    },
    each: function each(f) {
        for (var property in this) {
            if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
    }
};

function map$1(object, f) {
    var map = new Map();

    // Copy constructor.
    if (object instanceof Map) object.each(function (value, key) {
        map.set(key, value);
    });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
            var i = -1,
                n = object.length,
                o = void 0;

            if (f == null) while (++i < n) {
                map.set(i, object[i]);
            } else while (++i < n) {
                map.set(f(o = object[i], i, object), o);
            }
        }

        // Convert object to map.
        else if (object) for (var key in object) {
                map.set(key, object[key]);
            }return map;
}

function nest() {
    var keys = [],
        _sortKeys = [],
        _sortValues = void 0,
        _rollup = void 0,
        nest = void 0;

    function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) return _rollup != null ? _rollup(array) : _sortValues != null ? array.sort(_sortValues) : array;

        var i = -1,
            n = array.length,
            key = keys[depth++],
            keyValue = void 0,
            value = void 0,
            valuesByKey = map$1(),
            values = void 0,
            result = createResult();

        while (++i < n) {
            values = valuesByKey.get(keyValue = key(value = array[i]) + '');
            if (values) {
                values.push(value);
            } else {
                valuesByKey.set(keyValue, [value]);
            }
        }

        valuesByKey.each(function (values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult));
        });

        return result;
    }

    function _entries(map, depth) {
        if (++depth > keys.length) return map;
        var array = void 0,
            sortKey = _sortKeys[depth - 1];
        if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
            array.push({ key: k, values: _entries(v, depth) });
        });
        return sortKey != null ? array.sort(function (a, b) {
            return sortKey(a.key, b.key);
        }) : array;
    }

    return nest = {
        object: function object(array) {
            return apply(array, 0, createObject, setObject);
        },
        map: function map(array) {
            return apply(array, 0, createMap, setMap);
        },
        entries: function entries(array) {
            return _entries(apply(array, 0, createMap, setMap), 0);
        },
        key: function key(d) {
            keys.push(d);return nest;
        },
        sortKeys: function sortKeys(order) {
            _sortKeys[keys.length - 1] = order;return nest;
        },
        sortValues: function sortValues(order) {
            _sortValues = order;return nest;
        },
        rollup: function rollup(f) {
            _rollup = f;return nest;
        }
    };

    function createObject() {
        return {};
    }

    function setObject(object, key, value) {
        object[key] = value;
    }

    function createMap() {
        return map$1();
    }

    function setMap(map, key, value) {
        map.set(key, value);
    }
}

function reinterpolate(a, b) {
    return a = +a, b -= a, function (t) {
        return a + b * t;
    };
}

function min(array, f) {
    var i = -1,
        n = array.length,
        a = void 0,
        b = void 0;

    if (f == null) {
        while (++i < n) {
            if ((b = array[i]) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = array[i]) != null && a > b) a = b;
        }
    } else {
        while (++i < n) {
            if ((b = f(array[i], i, array)) != null && b >= b) {
                a = b;break;
            }
        }while (++i < n) {
            if ((b = f(array[i], i, array)) != null && a > b) a = b;
        }
    }

    return a;
}

},{"./utils":69}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GAP = undefined;
exports.cacheIdForViewFrameUI = cacheIdForViewFrameUI;
exports.getViewFrameIdForNode = getViewFrameIdForNode;
exports.checkPagination = checkPagination;
exports.getCrosPoint = getCrosPoint;
exports.adjustVertices = adjustVertices;
exports.getPath = getPath;

var _rappid = require('rappid');

var joint = _interopRequireWildcard(_rappid);

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function cacheIdForViewFrameUI(viewFrame) {
    return 'tq-lg-view-frame-ui-' + viewFrame.id;
}

function getViewFrameIdForNode(node) {
    return node.viewFrameOwnerId || node.model.viewFrame;
}

function checkPagination(viewFrame) {
    var viewPortPositionBounds = viewFrame.viewPortPositionBounds;
    var viewPortPosition = viewFrame.viewPortPosition;

    return {
        canMoveUp: viewPortPositionBounds && viewPortPosition.y > viewPortPositionBounds.minY,
        canMoveDown: viewPortPositionBounds && viewPortPosition.y < viewPortPositionBounds.maxY,
        canMoveLeft: viewPortPositionBounds && viewPortPosition.x > viewPortPositionBounds.minX,
        canMoveRight: viewPortPositionBounds && viewPortPosition.x < viewPortPositionBounds.maxX
    };
}

/**
 * @private
 * Returns point of crossing of two lines
 * @param {Point} p1 - the first point of line-1
 * @param {Point} p2 - the second point of line-1
 * @param {Point} p3 - the first point of line-2
 * @param {Point} p4 - the second point of line-2
 * @returns {Point}
 */
function getCrosPoint(p1, p2, p3, p4) {
    var x1 = p1.x;
    var y1 = p1.y;

    var x2 = p2.x;
    var y2 = p2.y;

    var x3 = p3.x;
    var y3 = p3.y;

    var x4 = p4.x;
    var y4 = p4.y;

    var k1 = void 0,
        k2 = void 0,
        b1 = void 0,
        b2 = void 0;
    var rx = void 0,
        ry = void 0,
        xx = void 0,
        yy = void 0;
    var res = {};

    if (x1 == x2 && x3 == x4) return null;
    if (x1 === x2) {
        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        rx = x1;
        ry = k2 * rx + b2;
    } else if (x3 === x4) {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        rx = x3;
        ry = k1 * rx + b1;
    } else {
        k1 = (y1 - y2) / (x1 - x2);
        b1 = y1 - k1 * x1;

        k2 = (y3 - y4) / (x3 - x4);
        b2 = y3 - k2 * x3;

        if (k1 == k2) {
            return null;
        }

        rx = (b2 - b1) / (k1 - k2);
        ry = k1 * rx + b1;
    }

    if (y2 < y1) {
        yy = y1;
        y1 = y2;
        y2 = yy;
    }
    if (y4 < y3) {
        yy = y3;
        y3 = y4;
        y4 = yy;
    }
    if (x2 < x1) {
        xx = x1;
        x1 = x2;
        x2 = xx;
    }
    if (x4 < x3) {
        xx = x3;
        x3 = x4;
        x4 = xx;
    }
    res.x = rx;
    res.y = ry;
    var error = 1;
    if (x1 - error <= res.x && res.x <= x2 + error && x3 - error <= res.x && res.x <= x4 + error && y1 - error <= res.y && res.y <= y2 + error && y3 - error <= res.y && res.y <= y4 + error) {
        return res;
    } else {
        return null;
    }
}

// This is the maximum distance between links
var GAP = exports.GAP = 10; // px
// Only for Derivation map
function adjustVertices(graph, cell) {
    if (!cell) {
        graph.getLinks().forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }
    // If the cell is a view, find its model.
    cell = cell.model && cell.model.get ? cell.model : cell;

    if (cell instanceof joint.dia.Element) {
        graph.getConnectedLinks(cell).forEach(function (link) {
            adjustVertices(graph, link);
        });
        return;
    }

    if (cell.hidden) return;
    cell.set('vertices', []);

    // The cell is a link. Let's find its source and target models.
    var srcId = cell.get('source').id || cell.previous('source').id;
    var trgId = cell.get('target').id || cell.previous('target').id;
    var srcPort = cell.get('source').port || cell.previous('source').port;
    var trgPort = cell.get('target').port || cell.previous('target').port;

    // If one of the ends is not a model, the link has no siblings.
    if (!srcId || !trgId) return;

    var siblings = graph.getLinks().filter(function (sibling) {
        if (sibling.hidden) return false;
        var _srcId = sibling.get('source').id;
        var _trgId = sibling.get('target').id;
        var _srcPort = sibling.get('source').port;
        var _trgPort = sibling.get('target').port;

        var sameEndsSameDirection = _srcId === srcId && _trgId === trgId && _srcPort === srcPort && _trgPort === trgPort;
        var sameEndsSameOppositeDirection = _srcId === trgId && _trgId === srcId && _srcPort === trgPort && _trgPort === srcPort;
        return sameEndsSameDirection || sameEndsSameOppositeDirection;
    });

    switch (siblings.length) {
        case 0:
        case 1:
            break;
        default:
            {
                // There is more than one siblings. We need to create vertices.
                // First of all we'll find the middle point of the link.
                var srcCell = graph.getCell(srcId);
                var srcPosition = srcCell.position();
                var _srcPort2 = srcCell.attr('.' + cell.get('source').port);
                if (!_srcPort2) return;
                var srcPortPosition = {
                    x: _srcPort2['ref-x'] + srcPosition.x,
                    y: _srcPort2['ref-y'] + srcPosition.y,
                    theta: joint.g.point.prototype.theta
                };
                var trgCell = graph.getCell(trgId);
                var trgPosition = trgCell.position();
                var _trgPort2 = trgCell.attr('.' + cell.get('target').port);
                if (!_trgPort2) return;
                var trgPortPosition = {
                    x: _trgPort2['ref-x'] + trgPosition.x,
                    y: _trgPort2['ref-y'] + trgPosition.y
                };
                var midPoint = joint.g.line(srcPortPosition, trgPortPosition).midpoint();

                // Then find the angle it forms.
                var theta = srcPortPosition.theta(trgPortPosition);
                var cellIndex = siblings.indexOf(cell);

                // We want the offset values to be calculated as follows 0, 20, 20, 40, 40, 60, 60 ..
                var offset = GAP * Math.ceil((cellIndex + (siblings.length % 2 === 0 ? 1 : 0)) / 2);

                // Now we need the vertices to be placed at points which are 'offset' pixels distant
                // from the first link and forms a perpendicular angle to it. And as index goes up
                // alternate left and right.
                //
                //  ^  odd indexes 
                //  |
                //  |---->  index 0 line (straight line between a source center and a target center.
                //  |
                //  v  even indexes
                var sign = cellIndex % 2 ? 1 : -1;
                var angle = joint.g.toRad(theta + sign * 90);

                // We found the vertex.
                var vertex = joint.g.point.fromPolar(offset, angle, midPoint);

                cell.set('vertices', [{ x: vertex.x, y: vertex.y }]);
            }}
}

function getPath(selectedElement, dataContainer) {
    var sourceMap = dataContainer.maps.sourceMap;
    var targetMap = dataContainer.maps.targetMap;
    var nodeMap = dataContainer.maps.nodeMap;

    var pathNodes = {};
    var pathLinksWest = {};
    var pathLinksEast = {};

    if (nodeMap[selectedElement.id]) {
        selectNode(selectedElement, true);
        selectNode(selectedElement, false);
    } else {
        pathLinksWest[selectedElement.id] = selectedElement;
        pathLinksEast[selectedElement.id] = selectedElement;
        selectNode(nodeMap[selectedElement.model.target], true);
        selectNode(nodeMap[selectedElement.model.source], false);
    }

    function selectNode(curNode, direction) {
        pathNodes[curNode.id] = curNode;
        curNode.aspects.forEach(function (aspect) {
            return pathNodes[aspect.id] = aspect;
        });
        var links = direction ? targetMap[curNode.id] : sourceMap[curNode.id];
        if (links) {
            links.forEach(function (link) {
                if (!pathLinksEast[link.id] && direction || !pathLinksWest[link.id] && !direction) {
                    if (direction) {
                        pathLinksEast[link.id] = link;
                    } else {
                        pathLinksWest[link.id] = link;
                    }
                    selectNode(nodeMap[direction ? link.model.target : link.model.source], direction);
                }
            });
        }
    }

    return _.merge(pathLinksEast, pathLinksWest, pathNodes);
}

},{"lodash":"lodash","rappid":"rappid"}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.limitPointPosition = limitPointPosition;
exports.getScaledViewFramePosition = getScaledViewFramePosition;
exports.getGlobalViewPortPosition = getGlobalViewPortPosition;
exports.getGlobalNodePosition = getGlobalNodePosition;
exports.getScaledNodePosition = getScaledNodePosition;
exports.getLocalNodePosition = getLocalNodePosition;
exports.getGlobalNodeSize = getGlobalNodeSize;
exports.getScaledNodeSize = getScaledNodeSize;
exports.globalToScaledPoint = globalToScaledPoint;
exports.scaledToGlobalPoint = scaledToGlobalPoint;
exports.globalToLocalPoint = globalToLocalPoint;
exports.localToGlobalPoint = localToGlobalPoint;
exports.localToScaledPoint = localToScaledPoint;
exports.scaledToLocalPoint = scaledToLocalPoint;
exports.globalToScaledSize = globalToScaledSize;
exports.scaledToGlobalSize = scaledToGlobalSize;
exports.globalToScaledBounds = globalToScaledBounds;
exports.scaledToGlobalBounds = scaledToGlobalBounds;
exports.shrinkBounds = shrinkBounds;
exports.extendBounds = extendBounds;
exports.getElementSize = getElementSize;
exports.arrayToMap = arrayToMap;
exports.mapToArray = mapToArray;
exports.getDist = getDist;
exports.getDiff = getDiff;
exports.onDragStart = onDragStart;

var _lodash = require('lodash');

var _ = _interopRequireWildcard(_lodash);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @private
 * Returns limitted by bounds point value
 * @param {Point} point 
 * @param {Bounds} bounds 
 */
function limitPointPosition(point, bounds) {
    if (!bounds) return point;

    var x = Math.max(Math.min(point.x, bounds.maxX), bounds.minX);
    var y = Math.max(Math.min(point.y, bounds.maxY), bounds.minY);

    return { x: x, y: y };
}

// global = {
//     x: 1,
//     y: 1,
// }
// scaled = {
//     x: global.x * scale,
//     y: global.y * scale,
// }
// local = {
//     x: scaled.x + viewFrameScaledPos.x - viewFrameViewPortPosition.x,
//     y: scaled.y + viewFrameScaledPos.y - viewFrameViewPortPosition.y,
// }
// ====================================================
function getScaledViewFramePosition(viewFrame) {
    if (viewFrame.position instanceof Function) {
        return viewFrame.position();
    } else if (viewFrame.position) {
        return viewFrame.position;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalViewPortPosition(viewFrame) {
    if (viewFrame.positionViewPort) {
        return viewFrame.positionViewPort();
    } else if (viewFrame.viewPortPosition) {
        return viewFrame.viewPortPosition;
    } else {
        throw new Error('Incorrect parameter!');
    }
}

function getGlobalNodePosition(node) {
    return _.clone(node.model.position);
}

function getScaledNodePosition(node, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToScaledPoint(position, scale);
}

function getLocalNodePosition(node, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var position = getGlobalNodePosition(node);
    return globalToLocalPoint(position, scale, viewFrame);
}

function getGlobalNodeSize(node, scale) {
    var scaledSize = getScaledNodeSize(node);

    return scaledToGlobalSize(scaledSize, scale);
}

function getScaledNodeSize(node) {
    return node.get('size');
}

function globalToScaledPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x * scale.x,
        y: point.y * scale.y
    };
}

function scaledToGlobalPoint(point, scale) {
    if (!scale) throw new Error('Scale is undefined!');

    return {
        x: point.x / scale.x,
        y: point.y / scale.y
    };
}

function globalToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = globalToScaledPoint(point, scale);

    return scaledToLocalPoint(scaledPoint, scale, viewFrame);
}

function localToGlobalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');
    var scaledPoint = localToScaledPoint(point, scale, viewFrame);

    return scaledToGlobalPoint(scaledPoint, scale, viewFrame);
}

function localToScaledPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x - scaledViewFrameOffset.x + scaledViewPortOffset.x,
        y: point.y - scaledViewFrameOffset.y + scaledViewPortOffset.y
    };
}

function scaledToLocalPoint(point, scale, viewFrame) {
    if (!scale) throw new Error('Scale is undefined!');

    var scaledViewFrameOffset = getScaledViewFramePosition(viewFrame);
    var globalViewPortOffset = getGlobalViewPortPosition(viewFrame);
    var scaledViewPortOffset = globalToScaledPoint(globalViewPortOffset, scale);

    return {
        x: point.x + scaledViewFrameOffset.x - scaledViewPortOffset.x,
        y: point.y + scaledViewFrameOffset.y - scaledViewPortOffset.y
    };
}

function globalToScaledSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width * scale.x,
        height: size.height * scale.y
    };
}

function scaledToGlobalSize(size, scale) {
    if (!scale) throw new Error('Scale is undefined!');
    return {
        width: size.width / scale.x,
        height: size.height / scale.y
    };
}

function globalToScaledBounds(bounds, scale) {
    var scaledMinPosition = globalToScaledPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = globalToScaledPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function scaledToGlobalBounds(bounds, scale) {
    var scaledMinPosition = scaledToGlobalPoint({ x: bounds.minX, y: bounds.minY }, scale);
    var scaledMaxPosition = scaledToGlobalPoint({ x: bounds.maxX, y: bounds.maxY }, scale);
    return {
        minX: scaledMinPosition.x,
        maxX: scaledMaxPosition.x,
        minY: scaledMinPosition.y,
        maxY: scaledMaxPosition.y,
        width: scaledMaxPosition.x - scaledMinPosition.x,
        height: scaledMaxPosition.y - scaledMinPosition.y
    };
}

function shrinkBounds(bounds, paddingRectangle) {
    return {
        minX: bounds.minX + paddingRectangle.x,
        maxX: bounds.maxX - paddingRectangle.x,
        minY: bounds.minY + paddingRectangle.y,
        maxY: bounds.maxY - paddingRectangle.y,
        width: bounds.maxX - bounds.minX - paddingRectangle.x * 2,
        height: bounds.maxY - bounds.minY - paddingRectangle.y * 2
    };
}

function extendBounds(bounds, extendBy) {
    return {
        minX: bounds.minX - extendBy.x,
        maxX: bounds.maxX + extendBy.x,
        minY: bounds.minY - extendBy.y,
        maxY: bounds.maxY + extendBy.y,
        width: bounds.maxX + extendBy.x * 2 - bounds.minX,
        height: bounds.maxY + extendBy.y * 2 - bounds.minY
    };
}

// ====================================================

function getElementSize(rootId) {
    var paper = document.getElementById(rootId);
    return {
        width: paper.clientWidth,
        height: paper.clientHeight
    };
}

function arrayToMap(array, useAsId) {
    useAsId = useAsId || 'id';
    var map = {};
    array.forEach(function (el) {
        map[el[useAsId]] = el;
    });
    return map;
}

function mapToArray(map) {
    return Object.keys(map).map(function (key) {
        return map[key];
    });
}

function getDist(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function getDiff(n1, n2) {
    var min = Math.min(n1, n2);
    if (min < 0) {
        n1 += -min;
        n2 += -min;
    }
    return Math.abs(n2 - n1);
}

function onDragStart(event, moveCallback, releaseCallback) {
    var startX = 0;
    var startY = 0;

    var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

    if (pointProvider.pageX) startX = pointProvider.pageX;else if (pointProvider.clientX) startX = pointProvider.clientX;

    if (pointProvider.pageY) startY = pointProvider.pageY;else if (pointProvider.clientY) startY = pointProvider.clientY;

    window.getSelection().removeAllRanges();

    document.body.addEventListener('mousemove', _onchange);
    document.body.addEventListener('mouseup', _onend);
    document.body.addEventListener('touchmove', _onchange);
    document.body.addEventListener('touchend', _onend);

    function _onchange(event) {
        var pointProvider = event instanceof MouseEvent ? event : event.touches[0];

        var endX = 0;
        if (pointProvider.pageX) endX = pointProvider.pageX;else if (pointProvider.clientX) endX = pointProvider.clientX;

        var diffX = endX - startX;
        startX = endX;

        var endY = 0;
        if (pointProvider.pageY) endY = pointProvider.pageY;else if (pointProvider.clientY) endY = pointProvider.clientY;

        var diffY = endY - startY;
        startY = endY;

        moveCallback({ x: diffX, y: diffY });
    }

    function _onend() {
        document.body.onmousemove = document.body.onmouseup = null;
        document.body.removeEventListener('mousemove', _onchange);
        document.body.removeEventListener('mouseup', _onend);
        document.body.removeEventListener('touchmove', _onchange);
        document.body.removeEventListener('touchend', _onend);
        if (releaseCallback) releaseCallback();
    }
}

},{"lodash":"lodash"}],70:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.TQGramUI=e()}}(function(){return function(){function e(t,n,o){function r(l,a){if(!n[l]){if(!t[l]){var s="function"==typeof require&&require;if(!a&&s)return s(l,!0);if(i)return i(l,!0);var u=new Error("Cannot find module '"+l+"'");throw u.code="MODULE_NOT_FOUND",u}var d=n[l]={exports:{}};t[l][0].call(d.exports,function(e){var n=t[l][1][e];return r(n?n:e)},d,d.exports,e,t,n,o)}return n[l].exports}for(var i="function"==typeof require&&require,l=0;l<o.length;l++)r(o[l]);return r}return e}()({1:[function(e,t,n){"use strict";function o(e){function t(){i.rootHtml.innerHTML="",i.rootHtml.style.borderTop=0!==i.buttons.length?"1px solid #cccccc":null,i.rootHtml.style.borderBottom=0!==i.buttons.length?"1px solid #cccccc":null,i.buttons.forEach(function(e){var t=document.createElement("BUTTON");t.title=e.label,t.className="tq-ui-toolbar__button tq-ui-colored-button",t.innerHTML='<span style="color: '+e.borderColor+'">'+n(e.label)+"</span>",t.style.backgroundColor=e.backgroundColor||"white",t.style.borderColor=e.borderColor||"black",t.onclick=function(t){e.callback(e,t)},i.rootHtml.appendChild(t)})}function n(e){if(e){var t=e.match(/[a-z'\-]+/gi);return t.filter(function(e){return"and"!==e.toLowerCase()&&"&"!==e}).map(function(e){return e[0]}).join("")}}function o(){var e=document.createElement("DIV");return e.className="tq-ui-colored-buttons-list",e.innerHTML="",e}var i=this;e||(e={}),i.rootHtml=o(),i.id=e.id||"coloredButtons-"+r++,i.rootHtml.id=i.id,i.buttons=e.buttons||[],t(),i.removeAll=function(){i.buttons=[],t()},i.addButton=function(e){i.buttons.map(function(e){return e.id}).indexOf(e.id)===-1&&(i.buttons.push(e),t())},i.removeButton=function(e){i.buttons.splice(i.buttons.indexOf(e),1),t()}}Object.defineProperty(n,"__esModule",{value:!0}),n.ColoredButtonsList=o;var r=0;n["default"]=o},{}],2:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){function t(){if(e.body instanceof Object){var t=r.rootHtml.querySelector(".tq-ui-body_container");t.appendChild(e.body.rootHtml)}var a=r.rootHtml.querySelector(".tq-ui-flying-panel_header");a.addEventListener("mousedown",o);var s=r.rootHtml.querySelector(".tq-ui-windows-collapse-button");if(s.onclick=r.hide,e.resizable){var u=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-border");u.addEventListener("mousedown",function(e){o(e,"n")});var d=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-right-border");d.addEventListener("mousedown",function(e){o(e,"e")});var c=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-border");c.addEventListener("mousedown",function(e){o(e,"s")});var f=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-left-border");f.addEventListener("mousedown",function(e){o(e,"w")});var p=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-right-border");p.addEventListener("mousedown",function(e){o(e,"ne")});var b=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-top-left-border");b.addEventListener("mousedown",function(e){o(e,"nw")});var m=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-right-border");m.addEventListener("mousedown",function(e){o(e,"se")});var y=r.rootHtml.querySelector(".tq-ui-flying-panel__border.tq-ui-bottom-left-border");y.addEventListener("mousedown",function(e){o(e,"sw")})}r._triggerButton=i(e.triggerButton),n(),r._triggerButton&&(r._triggerButton.onclick=function(){l?r.show():r.hide()})}function n(){l?(r._triggerButton&&(r._triggerButton.className=r._triggerButton.className.replace(/ tq-ui-selected/gi,"")),r.rootHtml.className=r.rootHtml.className+" tq-ui-collapsed"):(r._triggerButton&&(r._triggerButton.className=r._triggerButton.className+" tq-ui-selected"),r.rootHtml.className=r.rootHtml.className.replace(/ tq-ui-collapsed/gi,""))}function o(e,t){function n(e){r._mouseMove=!0;var n=0;e.pageX?n=e.pageX:e.clientX&&(n=e.clientX);var o=n-l;l=n,t||(r.rootHtml.style.left=r.rootHtml.offsetLeft+o+"px");var s=0;e.pageY?s=e.pageY:e.clientY&&(s=e.clientY);var u=s-a;a=s,t||(r.rootHtml.style.top=r.rootHtml.offsetTop+u+"px"),t?(i(o,u,t),r.trigger("size-changed",{width:r.rootHtml.offsetWidth,height:r.rootHtml.offsetHeight}),t.indexOf("n")===-1&&t.indexOf("w")===-1||r.trigger("position-changed",{x:r.rootHtml.offsetLeft,y:r.rootHtml.offsetTop})):r.trigger("position-changed",{x:r.rootHtml.offsetLeft,y:r.rootHtml.offsetTop})}function o(e){r._mouseMove&&(n(e,!0),r._mouseMove=!1),document.body.onmousemove=document.body.onmouseup=null,document.body.removeEventListener("mousemove",n),document.body.removeEventListener("mouseup",o)}function i(e,t,n){switch(n){case"n":r.rootHtml.style.height=r.rootHtml.offsetHeight-t+"px",r.rootHtml.style.top=r.rootHtml.offsetTop+t+"px";break;case"e":r.rootHtml.style.width=r.rootHtml.offsetWidth+e+"px";break;case"s":r.rootHtml.style.height=r.rootHtml.offsetHeight+t+"px";break;case"w":r.rootHtml.style.width=r.rootHtml.offsetWidth-e+"px",r.rootHtml.style.left=r.rootHtml.offsetLeft+e+"px";break;case"ne":r.rootHtml.style.width=r.rootHtml.offsetWidth+e+"px",r.rootHtml.style.height=r.rootHtml.offsetHeight-t+"px",r.rootHtml.style.top=r.rootHtml.offsetTop+t+"px";break;case"nw":r.rootHtml.style.height=r.rootHtml.offsetHeight-t+"px",r.rootHtml.style.top=r.rootHtml.offsetTop+t+"px",r.rootHtml.style.width=r.rootHtml.offsetWidth-e+"px",r.rootHtml.style.left=r.rootHtml.offsetLeft+e+"px";break;case"se":r.rootHtml.style.width=r.rootHtml.offsetWidth+e+"px",r.rootHtml.style.height=r.rootHtml.offsetHeight+t+"px";break;case"sw":r.rootHtml.style.height=r.rootHtml.offsetHeight+t+"px",r.rootHtml.style.width=r.rootHtml.offsetWidth-e+"px",r.rootHtml.style.left=r.rootHtml.offsetLeft+e+"px"}}var l=0,a=0;e.pageX?l=e.pageX:e.clientX&&(l=e.clientX),e.pageY?a=e.pageY:e.clientY&&(a=e.clientY),window.getSelection().removeAllRanges(),document.body.addEventListener("mousemove",n),document.body.addEventListener("mouseup",o)}s["default"].apply(this);var r=this;e||(e={});var l=!e.active;r.markup='\n        <div class="tq-ui-flying-panel"\n            style="\n                width: '+(e.size?e.size.width:"")+";\n                height: "+(e.size?e.size.height:"")+";\n                left: "+(e.position?e.position.x:"")+";\n                top: "+(e.position?e.position.y:"")+';\n            "\n        >\n            <div class="tq-ui-flying-panel_header">\n                <div class="tq-ui-flying-panel_header__header">\n                    <label class="tq-ui-window-header-label">'+(e.header?e.header:"")+'</label>\n                    <img alt="Collapse Button" class="tq-ui-windows-collapse-button"/>\n                </div>\n            </div>\n            <div class="tq-ui-body">\n                <div class="tq-ui-body_container '+(e.removeBackground?"tq-ui-body_empty-container":"tq-ui-body_default-container")+'">\n                    '+(e.body&&"string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n            "+(e.resizable?'\n                <div class="tq-ui-flying-panel__border tq-ui-top-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-top-right-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-left-border"></div>\n                <div class="tq-ui-flying-panel__border tq-ui-bottom-right-border"></div>\n            ':"")+"\n        </div>";var a=i(e.baseElement);a.innerHTML=r.markup,r.rootHtml=a.querySelector(".tq-ui-flying-panel"),r.id=e.id||"flyingPanel-"+u++,r.rootHtml.id=r.id,r.show=function(e){e&&e.stopPropagation(),l&&(l=!1,n())},r.hide=function(e){e&&e.stopPropagation(),l||(l=!0,n())},t()}function i(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":l(e))&&(t=e),t}Object.defineProperty(n,"__esModule",{value:!0});var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.FlyingPanel=r;var a=e("./subscriptionAPI/subscribeable"),s=o(a),u=0;n["default"]=r},{"./subscriptionAPI/subscribeable":8}],3:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){function t(e){function t(e){var t=e.label,n=e.label+" ("+e.id+")",o=document.createElement("LI");return o.className="tq-ui-property-button",o.title=n,o.innerText=t,o.onclick=function(){r.trigger("selected-element-changed",e.id)},o}var n=r.rootHtml.querySelector("#relatedElements");n.innerHTML="";var o=e.incomings||[];if(o.length){var i=document.createElement("LABEL");i.className="tq-label",i.innerText="Incoming nodes:",n.appendChild(i);var l=document.createElement("UL");l.className="tq-ui-info-panel_related-elements_list",n.appendChild(l),o.forEach(function(e){l.appendChild(t(e))})}var a=e.outgoings||[];if(a.length){var s=document.createElement("LABEL");s.className="tq-label",s.innerText="Outgoing nodes:",n.appendChild(s);var u=document.createElement("UL");u.className="tq-ui-info-panel_related-elements_list",n.appendChild(u),a.forEach(function(e){u.appendChild(t(e))})}}function n(e){var t="";return Object.keys(e).forEach(function(n){t+='<label for="'+n+'" class="tq-label">'+n+'</label>\n                        <input id="'+n+'" type="text" class="tq-ui-property" value="'+e[n]+'" disabled></input>'}),t}function o(){var e=document.createElement("DIV");return e.className="tq-ui-info-panel",e.innerHTML=r.markup,e}l["default"].apply(this),e||(e={});var r=this,i=e.placeholder||"Select a diagram element",s='<div class="tq-ui-info-panel_empty-stuff">'+i+"</div>";r.rootHtml=o(),r.rootHtml.innerHTML=s,r.id=e.id||"infoPanel-"+a++,r.rootHtml.id=r.id,r.setSelectedElement=function(o){if(o){if(r.rootHtml.innerHTML=""+(e.launchExternal&&"node"===o.diagramType?'<div class="tq-ui-group">\n                      <button id="tqLaunchExternalBtn" class="tq-button" title="View more in new tab.">\n                        More &nbsp;\n                      <span class="glyphicon glyphicon-new-window"></span></button>\n                     </div>':"")+(o.id?'\n                    <label class="tq-label">ID</label>\n                    <input value="'+o.id+'" type="text" aria-label="Input for ID" class="tq-ui-property" disabled></input>\n                ':"")+(o.label?'\n                    <label class="tq-label">Label</label>\n                    <input value="'+o.label+'" type="text" aria-label="Input for Label" class="tq-ui-property" disabled></input>\n                ':"")+(o.types?'\n                    <label class="tq-label">Types</label>\n                    <input value="'+o.types+'" type="text" aria-label="Input for Types" class="tq-ui-property" disabled></input>\n                ':"")+(o.source?'\n                    <label for="linkFrom" class="tq-label">Source</label>\n                    <div id="linkFrom" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.target?'\n                    <label for="linkTo" class="tq-label">Target</label>\n                    <div id="linkTo" type="text" class="tq-ui-property-button"></div>\n                ':"")+(o.thickness?'\n                    <label for="thickness" class="tq-label">Thickness</label>\n                    <input value="'+o.thickness+'" type="text" class="tq-ui-property" disabled></input>\n                ':"")+(o.data?n(o.data):"")+(o.relations?'\n                    <label for="relatedElements" class="tq-label">Related elements</label>\n                    <div   id="relatedElements" class="tq-ui-info-panel_related-elements"></div>\n                ':""),e.launchExternal&&"node"===o.diagramType){var i=document.getElementById("tqLaunchExternalBtn");i.onclick=function(){e.launchExternal(o)}}if(o.relations&&t(o.relations),o.source){var l=document.getElementById("linkFrom");l.innerText=o.source.label,l.title=o.source.label+"(ID: "+o.source.id+")",l.onclick=function(){r.trigger("selected-element-changed",o.source.id)}}if(o.target){var a=document.getElementById("linkTo");a.innerText=o.target.label,a.title=o.target.label+"(ID: "+o.target.id+")",a.onclick=function(){r.trigger("selected-element-changed",o.target.id)}}}else r.rootHtml.innerHTML=s},e.selectedElement&&r.setSelectedElement(e.selectedElement)}Object.defineProperty(n,"__esModule",{value:!0}),n.InfoPanel=r;var i=e("./subscriptionAPI/subscribeable"),l=o(i),a=0;n["default"]=r},{"./subscriptionAPI/subscribeable":8}],4:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.innerHTML=n.markup,e.querySelector(".tq-ui-legend-panel_body_legends")}var n=this;e||(e={});var o=e.legends||[];n.markup='\n        <div class="tq-ui-legend-panel_body_legends">\n        '+o.map(function(e){return'\n                <div class="tq-ui-legend-panel_body_legends_legend" title="'+e.description+'">\n                    <div class="tq-ui-legend-panel_body_legends_legend_img"><img src="'+e.image+'"></div>\n                    <label class="tq-label">'+e.label+"</label>\n                </div>\n            "}).join("")+"\n        </div>\n    ",n.rootHtml=t(),n.id=e.id||"legends-"+r++,n.rootHtml.id=n.id}Object.defineProperty(n,"__esModule",{value:!0}),n.Legends=o;var r=0;n["default"]=o},{}],5:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}var r=e("./coloredButtonsList"),i=o(r),l=e("./flyingPanel"),a=o(l),s=e("./infoPanel"),u=o(s),d=e("./legends"),c=o(d),f=e("./progressScreen"),p=o(f),b=e("./searchPanel"),m=o(b),y=e("./switcher"),v=o(y),g=e("./tabPanel"),h=o(g),H=e("./toolbar"),q=o(H);t.exports={ColoredButtonsList:i["default"],FlyingPanel:a["default"],InfoPanel:u["default"],Legends:c["default"],ProgressScreen:p["default"],SearchPanel:m["default"],Switcher:v["default"],TabPanel:h["default"],Toolbar:q["default"]}},{"./coloredButtonsList":1,"./flyingPanel":2,"./infoPanel":3,"./legends":4,"./progressScreen":6,"./searchPanel":7,"./switcher":9,"./tabPanel":10,"./toolbar":11}],6:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-progress-screen",e.innerHTML=o.markup,e}function n(e){var t=void 0;return"string"==typeof e?t=document.getElementById(e):"object"===("undefined"==typeof e?"undefined":i(e))&&(t=e),t}a["default"].apply(this);var o=this;e||(e={}),o.markup="",o.state="completed",o.rootHtml=t(),o.id=e.id||"tabPanel-"+s++,o.rootHtml.id=o.id;var r=n(e.baseElement);r.appendChild(o.rootHtml),o.setState=function(e,t){e&&(o.state=e,"active"===e?(o.rootHtml.innerHTML="<h1>"+(t||u)+'</h1><div class="tq-ui-progress-screen__progress"></div>',o.rootHtml.style.display=null):"completed"===e?(o.rootHtml.innerHTML="",o.rootHtml.style.display="none"):"error"===e&&(o.rootHtml.innerHTML="<h1>"+(t||d)+"</h1>",o.rootHtml.style.display=null),o.trigger("diagram-state-changed",e))},o.setState(e.state,e.text)}Object.defineProperty(n,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.ProgressScreen=r;var l=e("./subscriptionAPI/subscribeable"),a=o(l),s=Math.floor(50*Math.random())+1,u="Loading",d="Error has occurred!";n["default"]=r},{"./subscriptionAPI/subscribeable":8}],7:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){l["default"].apply(this),e||(e={});var t=e.searchButtonId||"tqLgSearchButton",n=e.searchId||"search",o=e.ariaLabel||"Search Flyout Panel";s["default"].apply(this,[{id:e.id,baseElement:e.baseElement,active:e.active,header:e.header||"Search panel",triggerButton:e.triggerButton,body:"\n            <span id="+t+' class="tq-ui-search-icon glyphicon glyphicon-search" aria-hidden="true"></span>\n            <input aria-label="'+o+'" id="'+n+'" placeHolder="Search..." class="tq-ui-search-input"></input>\n        ',removeBackground:!0,size:{width:"260px",height:"70px"}}])}Object.defineProperty(n,"__esModule",{value:!0}),n.SearchPanel=r;var i=e("./subscriptionAPI/subscribeable"),l=o(i),a=e("./flyingPanel"),s=o(a);n["default"]=r},{"./flyingPanel":2,"./subscriptionAPI/subscribeable":8}],8:[function(e,t,n){"use strict";function o(){var e=this;e._subscribtions={},e.on=function(t,n){e._subscribtions[t]||(e._subscribtions[t]=[]),e._subscribtions[t].push(n)},e.unsubscribe=function(t){Object.keys(e._subscribtions).map(function(t){return e._subscribtions[t]}).forEach(function(e){var n=e.indexOf(t);n!==-1&&e.splice(n,1)})},e.trigger=function(t,n){var o=this;n instanceof Array||(n=[n]),e._subscribtions&&e._subscribtions[t]&&e._subscribtions[t].forEach(function(e){e.apply(o,n)})}}Object.defineProperty(n,"__esModule",{value:!0}),n.Subscribable=o,n["default"]=o},{}],9:[function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e){function t(){var t=document.createElement("DIV");return t.className="tq-ui-switch-buttons"+(e.verticalOrientation?"-vertical":""),t.innerHTML=n.markup,t}l["default"].apply(this),e||(e={});var n=this,o=e.states||[];n.markup=o.map(function(t,n){return'<button id="'+t.id+'" '+(0!==n?"":"disabled")+' title="'+(t.label||t.id)+'">\n            '+(e.verticalOrientation&&t.icon?'<span class="'+t.icon+'" aria-hidden="true"></span>':t.label||t.id)+"\n        </button>"}).join(""),n.rootHtml=t(),n.id=e.id||"switcher-"+a++,n.rootHtml.id=n.id;var r=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id);0===t&&(r=o),o.onclick=function(){o.disabled=!0,r.disabled=!1,r=o,n.trigger("state-changed",e.id)}}),n.setState=function(e){var t=n.rootHtml.querySelector("#"+e);t&&e!==r.id&&(t.disabled=!0,r.disabled=!1,r=t)}}Object.defineProperty(n,"__esModule",{value:!0}),n.Switcher=r;var i=e("./subscriptionAPI/subscribeable"),l=o(i),a=0;n["default"]=r},{"./subscriptionAPI/subscribeable":8}],10:[function(e,t,n){"use strict";function o(e){function t(){var e=document.createElement("DIV");return e.className="tq-ui-tab-panel",e.innerHTML=n.markup,e}var n=this;e||(e={});var o=e.tabs||[];n.markup='\n        <div class="tq-ui-tab-switcher tq-ui-switch-buttons">'+o.map(function(e,t){return'\n            <button id="'+e.id+'" '+(0!==t?"":"disabled")+">\n                "+(e.label||e.id)+"\n            </button>  \n        "}).join("")+"</div>"+o.map(function(e,t){return'\n            <div id="'+e.id+'Panel" class="tq-ui-tab-panel_page" style="display: '+(0===t?"":"none")+'">\n                <div class="tq-ui-tab-panel_page_body">\n                    '+("string"==typeof e.body?e.body:"")+"\n                </div>\n            </div>\n        "}).join(""),n.rootHtml=t(),n.id=e.id||"tabPanel-"+r,n.rootHtml.id=n.id,o.map(function(e){if(e.body instanceof Object&&e.body.rootHtml){var t=n.rootHtml.querySelector("#"+e.id+"Panel .tq-ui-tab-panel_page_body");t.appendChild(e.body.rootHtml)}});var i=null;o.forEach(function(e,t){var o=n.rootHtml.querySelector("#"+e.id),r=n.rootHtml.querySelector("#"+e.id+"Panel");0===t&&(i={tabBtn:o,tabPanel:r}),o.onclick=function(){o.disabled=!0,r.style.display="",i.tabBtn.disabled=!1,i.tabPanel.style.display="none",i={tabBtn:o,tabPanel:r}}})}Object.defineProperty(n,"__esModule",{value:!0}),n.TabPanel=o;var r=Math.floor(50*Math.random())+1;n["default"]=o},{}],11:[function(e,t,n){"use strict";function o(e){function t(e){var t=void 0;if("string"==typeof e){var n=document.createElement("DIV");n.innerHTML=e,t=n.firstChild}else if(e.id&&e.icon){var o=document.createElement("DIV");if(o.innerHTML='<button id="'+e.id+'" title="'+(e.label||e.id)+'" class="tq-ui-toolbar__button">\n                <span class="'+e.icon+'" aria-hidden="true"></span>\n            </button>',t=o.firstChild,e.icon2){var r=!0;t.onclick=function(n){t.innerHTML='<span class="'+(r?e.icon2:e.icon)+'" aria-hidden="true"></span>',e.callback(n),r=!r}}else t.onclick=e.callback}else e.rootHtml&&(t=e.rootHtml);return t}function n(){var t=void 0;return"string"==typeof e.baseElement?t=document.getElementById(e.baseElement):"object"===r(e.baseElement)&&(t=e.baseElement),t?(t.innerHTML=o.markup,t):null}var o=this,l="toolbarRootElement-"+i++;if(e||(e={}),o.markup='\n        <div id="'+l+'" class="tq-ui-toolbar">\n        </div>\n    ',o.rootHtml=n(),o.id=e.id||"toolbar-"+i++,o.rootHtml.id=o.id,!o.rootHtml)throw new Error("The root element is not specified!");o.container=o.rootHtml.querySelector("#"+l),o.pushTool=function(e){var n=t(e);n&&("string"!=typeof n?a.push(e):a.push({id:"customhtml"+i++,markup:e,rootHtml:n}),o.container.appendChild(n))},o.insertTool=function(e,n){var r=Math.min(Math.max(n,0),a.length-1),i=o.container.querySelector("#"+a[r].id);if(i){var l=t(e);l&&(a.splice(r,0,e),o.container.insertBefore(l,i))}else o.pushTool(e)},o.removeTool=function(e){var t="string"==typeof e?e:e.id;a.splice(a.indexOf(e),1);var n=o.container.querySelector("#"+t);o.container.removeChild(n)};var a=[];e.tools.forEach(function(e){o.pushTool(e)})}Object.defineProperty(n,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n.Toolbar=o;var i=Math.floor(50*Math.random())+1;n["default"]=o},{}]},{},[5])(5)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[59])(59)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9maWxlLXNhdmVyanMvRmlsZVNhdmVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9idWlsZC9zaWdtYS5yZXF1aXJlLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2FkYXB0b3IuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9iYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2QzYWRhcHRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2QzdjNhZGFwdG9yLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZDN2NGFkYXB0b3IuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9kZXNjZW50LmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvZ2VvbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2dyaWRyb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9oYW5kbGVkaXNjb25uZWN0ZWQuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9sYXlvdXQuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy9sYXlvdXQzZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL2xpbmtsZW5ndGhzLmpzIiwibm9kZV9tb2R1bGVzL3dlYmNvbGEvZGlzdC9zcmMvcG93ZXJncmFwaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3BxdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3JidHJlZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3JlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJjb2xhL2Rpc3Qvc3JjL3Nob3J0ZXN0cGF0aHMuanMiLCJub2RlX21vZHVsZXMvd2ViY29sYS9kaXN0L3NyYy92cHNjLmpzIiwibm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9qcy9kYXRhL2Jhc2U2NEltYWdlcy5qcyIsInNyYy9qcy9kYXRhL2RhdGFDb250YWluZXIuanMiLCJzcmMvanMvZGF0YS9kYXRhUHJvY2Vzc2luZy5qcyIsInNyYy9qcy9kYXRhL2RlZmF1bHREYXRhUHJvdmlkZXIuanMiLCJzcmMvanMvZGF0YS9yZXNvdXJjZVByb3ZpZGVyLmpzIiwic3JjL2pzL2h0bWxVSS9kZWZhdWx0VUkuanMiLCJzcmMvanMvaHRtbFVJL2RtRGVmYXVsdFVJLmpzIiwic3JjL2pzL2h0bWxVSS9kbUluZm9QYW5lbC5qcyIsInNyYy9qcy9odG1sVUkvaW5mb1BhbmVsLmpzIiwic3JjL2pzL2h0bWxVSS9tYXAuanMiLCJzcmMvanMvaHRtbFVJL29wdGlvbnNQYW5lbC5qcyIsInNyYy9qcy9odG1sVUkvc3BsaXR0ZXIuanMiLCJzcmMvanMvaHRtbFVJL3ZpZXdGcmFtZUJ1dHRvbnMuanMiLCJzcmMvanMvaHRtbFVJL3ZpZXdGcmFtZXNVSS5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGF0YVByb2Nlc3NpbmcuanMiLCJzcmMvanMvam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL2Rlcml2YXRpb25NYXAuanMiLCJzcmMvanMvam9pbnRWaWV3cy9kZXJpdmF0aW9uTWFwL2xpbmVSb3V0aW5nLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9tYXBFbGVtZW50cy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvbWFwTGF5b3V0LmpzIiwic3JjL2pzL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9tYXBWaWV3cy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvYXNwZWN0TGluay5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvZWxlbWVudHMuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL2xpbmsuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL25vZGUuanMiLCJzcmMvanMvam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL3Rlcm1pbmF0aW9uTGluay5qcyIsInNyYy9qcy9qb2ludFZpZXdzL2dyYXBoRWxlbWVudHMvdGVybWluYXRpb25Ob2RlLmpzIiwic3JjL2pzL2pvaW50Vmlld3MvbGluZWFnZURpYWdyYW0uanMiLCJzcmMvanMvam9pbnRWaWV3cy9saW5rUm91dGluZ01hbmFnZXIvcm91dGluZ01hbmFnZXIuanMiLCJzcmMvanMvam9pbnRWaWV3cy90b1N2Zy5qcyIsInNyYy9qcy9qb2ludFZpZXdzL3ZpZXdGcmFtZS5qcyIsInNyYy9qcy9qb2ludFZpZXdzL3ZpZXdNYW5hZ2VyLmpzIiwic3JjL2pzL2xheW91dC9sYXlvdXQuanMiLCJzcmMvanMvbGF5b3V0L3NhbmtleS5qcyIsInNyYy9qcy9saW5lYWdlR3JhbS5qcyIsInNyYy9qcy9tYWluLmpzIiwic3JjL2pzL3NpZ21hVmlld3MvYmlyZEV5ZS5qcyIsInNyYy9qcy9zaWdtYVZpZXdzL2dyYXBoTWFwLmpzIiwic3JjL2pzL3NpZ21hVmlld3Mvc2lnbWFCYXNlLmpzIiwic3JjL2pzL3NpZ21hVmlld3Mvc2lnbWFQbGFnaW5zL3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdC9zaWdtYS5yZW5kZXJlcnMuc25hcHNob3QuanMiLCJzcmMvanMvc3RhdGVTdG9yYWdlLmpzIiwic3JjL2pzL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlLmpzIiwic3JjL2pzL3V0aWxzL2RhdGFVdGlscy5qcyIsInNyYy9qcy91dGlscy9sYXlvdXRVdGlscy5qcyIsInNyYy9qcy91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzLmpzIiwic3JjL2pzL3V0aWxzL3V0aWxzLmpzIiwiLi4vVmlzdWFsaXphdGlvbnNMaWJyYXJ5L2J1aWxkL2pzL25vZGVfbW9kdWxlcy92aXN1YWxpemF0aW9ucy1saWJyYXJ5L2J1aWxkL2pzL21haW4ubWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqb0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LE9BQXJCOztBQUVoQyxZQUFNLFFBQVEsT0FBTyxNQUFyQjtBQUNBLGlCQUFTLElBQVQ7O0FBRUEscUJBQWEsRUFBRSxHQUFHLEtBQUwsRUFBWSxHQUFHLEtBQWYsRUFBYjtBQUNIOztBQUVELGFBQVMsTUFBVCxHQUFtQjtBQUNmLGlCQUFTLElBQVQsQ0FBYyxXQUFkLEdBQTRCLFNBQVMsSUFBVCxDQUFjLFNBQWQsR0FBMEIsSUFBdEQ7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsV0FBbEMsRUFBK0MsU0FBL0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsU0FBbEMsRUFBNkMsTUFBN0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsV0FBbEMsRUFBK0MsU0FBL0M7QUFDQSxpQkFBUyxJQUFULENBQWMsbUJBQWQsQ0FBa0MsVUFBbEMsRUFBOEMsTUFBOUM7QUFDQSxZQUFJLGVBQUosRUFBcUI7QUFDeEI7QUFDRjs7OztBQ3ZTSCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4zLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJCkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShfaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJCA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkID09PSByZXNvbHZlKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcblByb21pc2UucmFjZSA9IHJhY2U7XG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5Qcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlO1xufVxuXG5wb2x5ZmlsbCgpO1xuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblxucmV0dXJuIFByb21pc2U7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXAiLCIvKiEgRmlsZVNhdmVyLmpzIHYxLjMuNlxuICpcbiAqIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEJ5IFRyYXZpcyBDbGFya2UsIGh0dHBzOi8vdHJhdmlzbWNsYXJrZS5jb21cbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqXG4gKiBMaWNlbnNlOiBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9jbGFya2V0bS9GaWxlU2F2ZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZClcbiAqL1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByb290LmRvY3VtZW50ID8gZmFjdG9yeShyb290LCB0cnVlKSA6IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICBpZiAoIXcuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlU2F2ZXIgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkodyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShyb290KTtcbiAgICB9XG59KHdpbmRvdyB8fCB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgLy8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhclxuICAgICAgICAgICAgZG9jID0gd2luZG93LmRvY3VtZW50XG4gICAgICAgICAgICAvLyBvbmx5IGdldCBVUkwgd2hlbiBuZWNlc3NhcnkgaW4gY2FzZSBCbG9iLmpzIGhhc24ndCBvdmVycmlkZGVuIGl0IHlldFxuICAgICAgICAgICAgLCBnZXRfVVJMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBzYXZlX2xpbmsgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcbiAgICAgICAgICAgICwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXG4gICAgICAgICAgICAsIGNsaWNrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIGlzX3NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3Qod2luZG93LkhUTUxFbGVtZW50KSB8fCB3aW5kb3cuc2FmYXJpXG4gICAgICAgICAgICAsIGlzX2Nocm9tZV9pb3MgPSAvQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgICwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uIChleCkge1xuICAgICAgICAgICAgICAgICh3aW5kb3cuc2V0SW1tZWRpYXRlIHx8IHdpbmRvdy5zZXRUaW1lb3V0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgLy8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuICAgICAgICAgICAgLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSAxMDAwICogNDAgLy8gaW4gbXNcbiAgICAgICAgICAgICwgcmV2b2tlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV2b2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7IC8vIGZpbGUgaXMgYW4gb2JqZWN0IFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0X1VSTCgpLnJldm9rZU9iamVjdFVSTChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV2b2tlciwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudF90eXBlcyA9IFtdLmNvbmNhdChldmVudF90eXBlcyk7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBldmVudF90eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93X291dHNpZGUoZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLCBhdXRvX2JvbSA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcbiAgICAgICAgICAgICAgICAvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuICAgICAgICAgICAgICAgIGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwge3R5cGU6IGJsb2IudHlwZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgRmlsZVNhdmVyID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub19hdXRvX2JvbSkge1xuICAgICAgICAgICAgICAgICAgICBibG9iID0gYXV0b19ib20oYmxvYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzYXZlciA9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLCB0eXBlID0gYmxvYi50eXBlXG4gICAgICAgICAgICAgICAgICAgICwgZm9yY2UgPSB0eXBlID09PSBmb3JjZV9zYXZlYWJsZV90eXBlXG4gICAgICAgICAgICAgICAgICAgICwgb2JqZWN0X3VybFxuICAgICAgICAgICAgICAgICAgICAsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG4gICAgICAgICAgICAgICAgICAgICwgZnNfZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzX2Nocm9tZV9pb3MgfHwgKGZvcmNlICYmIGlzX3NhZmFyaSkpICYmIHdpbmRvdy5GaWxlUmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGlzX2Nocm9tZV9pb3MgPyByZWFkZXIucmVzdWx0IDogcmVhZGVyLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcHVwKSB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkOyAvLyByZWxlYXNlIHJlZmVyZW5jZSBiZWZvcmUgZGlzcGF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hfYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNyZWF0ZSBtb3JlIG9iamVjdCBVUkxzIHRoYW4gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdF91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lZCA9IHdpbmRvdy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxlIGRvZXMgbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vVG9vbHMvQ29uY2VwdHVhbC9TYWZhcmlFeHRlbnNpb25HdWlkZS9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMuaHRtbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoX2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2b2tlKG9iamVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbl91c2Vfc2F2ZV9saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfbGluay5ocmVmID0gb2JqZWN0X3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljayhzYXZlX2xpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hfYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZva2Uob2JqZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZzX2Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgLCBzYXZlQXMgPSBmdW5jdGlvbiAoYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgLy8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICAgICAgc2F2ZUFzID0gZnVuY3Rpb24gKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIjtcblxuICAgICAgICAgICAgICAgIGlmICghbm9fYXV0b19ib20pIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgRlNfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgICAgIEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcbiAgICAgICAgRlNfcHJvdG8uV1JJVElORyA9IDE7XG4gICAgICAgIEZTX3Byb3RvLkRPTkUgPSAyO1xuXG4gICAgICAgIEZTX3Byb3RvLmVycm9yID1cbiAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG4gICAgICAgICAgICAgICAgRlNfcHJvdG8ub25wcm9ncmVzcyA9XG4gICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgRlNfcHJvdG8ub25hYm9ydCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRlNfcHJvdG8ub25lcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShcImZpbGUtc2F2ZXJqc1wiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYXZlQXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygbm9HbG9iYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2F2ZUFzID0gc2F2ZUFzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYXZlQXM7XG4gICAgfVxuKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfX2luc3RhbmNlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzaWdtYSBpbnN0YW5jZXMgY29uc3RydWN0b3IuIE9uZSBpbnN0YW5jZSBvZiBzaWdtYSByZXByZXNlbnRcbiAgICogb25lIGdyYXBoLiBJdCBpcyBwb3NzaWJsZSB0byByZXByZXNlbnQgdGhpcyBncmFwxKUgd2l0aCBzZXZlcmFsIHJlbmRlcmVyc1xuICAgKiBhdCB0aGUgc2FtZSB0aW1lLiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCByZW5kZXJlciAoV2ViR0wgKyBDYW52YXNcbiAgICogcG9seWZpbGwpIHdpbGwgYmUgdXNlZCBhcyB0aGUgb25seSByZW5kZXJlciwgd2l0aCB0aGUgY29udGFpbmVyIHNwZWNpZmllZFxuICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Pyp9ICAgIGNvbmYgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluc3RhbmNlLiBUaGVyZSBhcmUgYSBsb3Qgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50IHJlY29nbml6ZWQgZm9ybXMgdG8gaW5zdGFudGlhdGUgc2lnbWEsIGNoZWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZmlsZXMsIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGFuZCB1bml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHRlc3RzIHRvIGtub3cgbW9yZS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgVGhlIGZyZXNoIG5ldyBzaWdtYSBpbnN0YW5jZS5cbiAgICpcbiAgICogSW5zdGFuY2lhdGluZyBzaWdtYTpcbiAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICogSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgKiB3aXRob3V0IGFueSByZW5kZXJlciBvciBjYW1lcmEuIEl0IHdpbGwganVzdCBpbnN0YW50aWF0ZSB0aGUgZ3JhcGgsIGFuZFxuICAgKiBvdGhlciBtb2R1bGVzIHdpbGwgaGF2ZSB0byBiZSBpbnN0YW50aWF0ZWQgdGhyb3VnaCB0aGUgcHVibGljIG1ldGhvZHMsXG4gICAqIGxpa2UgXCJhZGRSZW5kZXJlclwiIGV0YzpcbiAgICpcbiAgICogID4gczAgPSBuZXcgc2lnbWEoKTtcbiAgICogID4gczAuYWRkUmVuZGVyZXIoe1xuICAgKiAgPiAgIHR5cGU6ICdjYW52YXMnLFxuICAgKiAgPiAgIGNvbnRhaW5lcjogJ215LWNvbnRhaW5lci1pZCdcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEluIG1vc3Qgb2YgdGhlIGNhc2VzLCBzaWdtYSB3aWxsIHNpbXBseSBiZSB1c2VkIHdpdGggdGhlIGRlZmF1bHQgcmVuZGVyZXIuXG4gICAqIFRoZW4sIHNpbmNlIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlciBpcyB0aGUgRE9NIGNvbnRhaW5lciwgdGhlcmUgYXJlXG4gICAqIHNvbWUgc2ltcGxlciB3YXkgdG8gY2FsbCB0aGUgY29uc3RydWN0b3IuIFRoZSBmb3VyIGZvbGxvd2luZyBjYWxscyBkbyB0aGVcbiAgICogZXhhY3Qgc2FtZSB0aGluZ3M6XG4gICAqXG4gICAqICA+IHMxID0gbmV3IHNpZ21hKCdteS1jb250YWluZXItaWQnKTtcbiAgICogID4gczIgPSBuZXcgc2lnbWEoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpKTtcbiAgICogID4gczMgPSBuZXcgc2lnbWEoe1xuICAgKiAgPiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXG4gICAqICA+IH0pO1xuICAgKiAgPiBzNCA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgcmVuZGVyZXJzOiBbe1xuICAgKiAgPiAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gICB9XVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzLCB3aGVuIGNhbGxpbmcgdGhlXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggdG8gdG9wIGxldmVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChmb3VydGggY2FzZSBpbiB0aGVcbiAgICogcHJldmlvdXMgZXhhbXBsZXMpOlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSBpZCAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnN0YW5jZS4gSXQgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgaWYgbm90IHNwZWNpZmllZC5cbiAgICogICB7P2FycmF5fSAgcmVuZGVyZXJzIEFuIGFycmF5IGNvbnRhaW5pbmcgb2JqZWN0cyBkZXNjcmliaW5nIHJlbmRlcmVycy5cbiAgICogICB7P29iamVjdH0gZ3JhcGggICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIG5vZGVzIGFuZCBhbiBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2YgZWRnZXMsIHRvIGF2b2lkIGhhdmluZyB0byBhZGQgdGhlbSBieSBoYW5kIGxhdGVyLlxuICAgKiAgIHs/b2JqZWN0fSBzZXR0aW5ncyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5zdGFuY2Ugc3BlY2lmaWMgc2V0dGluZ3MgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvbmVzIGRlZmluZWQgaW4gdGhlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEuc2V0dGluZ3MuXG4gICAqL1xuICB2YXIgc2lnbWEgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgLy8gTG9jYWwgdmFyaWFibGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKipcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgbyxcbiAgICAgICAgaWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKioqKipcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfY29uZiA9IGNvbmYgfHwge307XG5cbiAgICAvLyBMaXR0bGUgc2hvcnRjdXQ6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIC8vIFRoZSBjb25maWd1cmF0aW9uIGlzIHN1cHBvc2VkIHRvIGhhdmUgYSBsaXN0IG9mIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb2JqZWN0cyBmb3IgZWFjaCByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gY29uZmlndXJhdGlvbiBhdCBhbGwsIHRoZW4gbm90aGluZyBpcyBkb25lLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyByZW5kZXJlciBsaXN0LCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3Qgd2lsbCBiZVxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgZGVzY3JpYmluZyB0aGUgZmlyc3QgYW5kIG9ubHkgcmVuZGVyZXIuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3Qgbm9yIFwiY29udGFpbmVyXCIgb2JqZWN0LCBpdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyB0aGUgY29udGFpbmVyIGl0c2VsZiAoYSBET00gZWxlbWVudCkuXG4gICAgLy8gIC0gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzaWdtYSgpIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWRcbiAgICAvLyAgICBhcyB0aGUgSUQgb2YgdGhlIERPTSBjb250YWluZXIuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIF9jb25mID09PSAnc3RyaW5nJyB8fFxuICAgICAgX2NvbmYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgIClcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IFtfY29uZl1cbiAgICAgIH07XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9jb25mKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IF9jb25mXG4gICAgICB9O1xuXG4gICAgLy8gQWxzbyBjaGVjayBcInJlbmRlcmVyXCIgYW5kIFwiY29udGFpbmVyXCIga2V5czpcbiAgICBvID0gX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVyIHx8IF9jb25mLmNvbnRhaW5lcjtcbiAgICBpZiAoIV9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgJ2NvbnRhaW5lcicgaW4gbylcbiAgICAgIClcbiAgICAgICAgX2NvbmYucmVuZGVyZXJzID0gW29dO1xuXG4gICAgLy8gUmVjZW5zZSB0aGUgaW5zdGFuY2U6XG4gICAgaWYgKF9jb25mLmlkKSB7XG4gICAgICBpZiAoX19pbnN0YW5jZXNbX2NvbmYuaWRdKVxuICAgICAgICB0aHJvdyAnc2lnbWE6IEluc3RhbmNlIFwiJyArIF9jb25mLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogX2NvbmYuaWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAoX19pbnN0YW5jZXNbaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6ICcnICsgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX2luc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvLyBJbml0aWFsaXplIHNldHRpbmdzIGZ1bmN0aW9uOlxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUoXG4gICAgICBzaWdtYS5zZXR0aW5ncyxcbiAgICAgIF9jb25mLnNldHRpbmdzIHx8IHt9XG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgbG9ja2VkIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCh0aGlzLnNldHRpbmdzKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWlkZGxld2FyZXMnLCB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVycycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzUGVyQ2FtZXJhJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFGcmFtZXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXNbMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdldmVudHMnLCB7XG4gICAgICB2YWx1ZTogW1xuICAgICAgICAnY2xpY2snLFxuICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICdjbGlja1N0YWdlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgJ2NsaWNrTm9kZScsXG4gICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXG4gICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICdvdmVyTm9kZXMnLFxuICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICdvdXROb2RlcycsXG4gICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgJ3VwTm9kZXMnXG4gICAgICBdLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBjdXN0b20gaGFuZGxlciwgdG8gcmVkaXNwYXRjaCBldmVudHMgZnJvbSByZW5kZXJlcnM6XG4gICAgdGhpcy5faGFuZGxlciA9IChmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgIGZvciAoayBpbiBlLmRhdGEpXG4gICAgICAgIGRhdGFba10gPSBlLmRhdGFba107XG5cbiAgICAgIGRhdGEucmVuZGVyZXIgPSBlLnRhcmdldDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLnR5cGUsIGRhdGEpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHJlbmRlcmVyczpcbiAgICBhID0gX2NvbmYucmVuZGVyZXJzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkUmVuZGVyZXIoYVtpXSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1pZGRsZXdhcmVzOlxuICAgIGEgPSBfY29uZi5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goXG4gICAgICAgIHR5cGVvZiBhW2ldID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEubWlkZGxld2FyZXNbYVtpXV0gOlxuICAgICAgICAgIGFbaV1cbiAgICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ3JhcGggdG8gZmlsbCBpbjpcbiAgICBpZiAodHlwZW9mIF9jb25mLmdyYXBoID09PSAnb2JqZWN0JyAmJiBfY29uZi5ncmFwaCkge1xuICAgICAgdGhpcy5ncmFwaC5yZWFkKF9jb25mLmdyYXBoKTtcblxuICAgICAgLy8gSWYgYSBncmFwaCBpcyBnaXZlbiB0byB0aGUgdG8gdGhlIGluc3RhbmNlLCB0aGUgXCJyZWZyZXNoXCIgbWV0aG9kIGlzXG4gICAgICAvLyBkaXJlY3RseSBjYWxsZWQ6XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfc2VsZi5zZXR0aW5ncylcbiAgICAgICAgX3NlbGYucmVmcmVzaCgpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IGNhbWVyYS4gSWYgbm8gaWQgaXNcbiAgICogc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgICAgIGlkIEV2ZW50dWFsbHkgdGhlIGNhbWVyYSBpZC5cbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgIFRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmFkZENhbWVyYSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYW1lcmE7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXNbJycgKyBpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBpZCA9ICcnICsgaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkQ2FtZXJhOiBUaGUgY2FtZXJhIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBjYW1lcmEgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jYW1lcmEoaWQsIHRoaXMuZ3JhcGgsIHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuY2FtZXJhc1tpZF0gPSBjYW1lcmE7XG5cbiAgICAvLyBBZGQgYSBxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGNhbWVyYS5xdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLnF1YWQoKTtcblxuICAgIC8vIEFkZCBhbiBlZGdlcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcbiAgICBpZiAoc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW1lcmEuZWRnZXF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQoKTtcbiAgICB9XG5cbiAgICBjYW1lcmEuYmluZCgnY29vcmRpbmF0ZXNVcGRhdGVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5yZW5kZXJDYW1lcmEoY2FtZXJhLCBjYW1lcmEuaXNBbmltYXRlZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtpZF0gPSBbXTtcblxuICAgIHJldHVybiBjYW1lcmE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgY2FtZXJhLCBhbmQgZXZlcnkgcmVuZGVyZXIgYXR0YWNoZWQgdG8gaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xjYW1lcmF9IHYgVGhlIGNhbWVyYSB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsQ2FtZXJhID0gZnVuY3Rpb24odikge1xuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLmNhbWVyYXNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxDYW1lcmE6IFRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuXG4gICAgZm9yIChsID0gYS5sZW5ndGgsIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcihhW2ldKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFGcmFtZXNbdi5pZF07XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhc1t2LmlkXTtcblxuICAgIGlmICh2LmtpbGwpXG4gICAgICB2LmtpbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IHJlbmRlcmVyLiBUaGUgXCJ0eXBlXCJcbiAgICogYXJndW1lbnQgY2FuIGJlIHRoZSBjb25zdHJ1Y3RvciBvciBpdHMgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIlxuICAgKiBwYWNrYWdlLiBJZiBubyB0eXBlIGlzIHNwZWNpZmllZCwgdGhlbiBcInNpZ21hLnJlbmRlcmVycy5kZWZcIiB3aWxsIGJlIHVzZWQuXG4gICAqIElmIG5vIGlkIGlzIHNwZWNpZmllZCwgdGhlbiBhbiBhdXRvbWF0aWMgaWQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlbmRlcmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHtyZW5kZXJlcn0gICAgICAgICBUaGUgZnJlc2ggbmV3IHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P3N0cmluZ30gICAgICAgICAgICBpZCAgICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgaWQuXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gdHlwZSAgIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNvbnN0cnVjdG9yIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiIHBhY2thZ2UuXG4gICAqICAgez8oY2FtZXJhfHN0cmluZyl9ICAgY2FtZXJhIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNhbWVyYSBvciBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICBmbixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBQb2x5bW9ycGhpc206XG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgIG8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobylcbiAgICAgIH07XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBvXG4gICAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzdGlsbCBpcyBhIHN0cmluZywgd2UgZ2V0IGl0IGJ5IGlkXG4gICAgaWYgKHR5cGVvZiBvLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpXG4gICAgICBvLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8uY29udGFpbmVyKTtcblxuICAgIC8vIFJlZmVyZW5jZSB0aGUgbmV3IHJlbmRlcmVyOlxuICAgIGlmICghKCdpZCcgaW4gbykpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVyc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9IGVsc2VcbiAgICAgIGlkID0gby5pZDtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSByZW5kZXJlciBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjb25zdHJ1Y3RvcjpcbiAgICBmbiA9IHR5cGVvZiBvLnR5cGUgPT09ICdmdW5jdGlvbicgPyBvLnR5cGUgOiBzaWdtYS5yZW5kZXJlcnNbby50eXBlXTtcbiAgICBmbiA9IGZuIHx8IHNpZ21hLnJlbmRlcmVycy5kZWY7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNhbWVyYTpcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyBpbiBvID9cbiAgICAgIChcbiAgICAgICAgby5jYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSA/XG4gICAgICAgICAgby5jYW1lcmEgOlxuICAgICAgICAgIHRoaXMuY2FtZXJhc1tvLmNhbWVyYV0gfHwgdGhpcy5hZGRDYW1lcmEoby5jYW1lcmEpXG4gICAgICApIDpcbiAgICAgIHRoaXMuYWRkQ2FtZXJhKCk7XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2NhbWVyYS5pZF0gIT09IGNhbWVyYSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIGNhbWVyYSBpcyBub3QgcHJvcGVybHkgcmVmZXJlbmNlZC4nO1xuXG4gICAgLy8gSW5zdGFudGlhdGU6XG4gICAgcmVuZGVyZXIgPSBuZXcgZm4odGhpcy5ncmFwaCwgY2FtZXJhLCB0aGlzLnNldHRpbmdzLCBvKTtcbiAgICB0aGlzLnJlbmRlcmVyc1tpZF0gPSByZW5kZXJlcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVuZGVyZXIsICdpZCcsIHtcbiAgICAgIHZhbHVlOiBpZFxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBldmVudHM6XG4gICAgaWYgKHJlbmRlcmVyLmJpbmQpXG4gICAgICByZW5kZXJlci5iaW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcbiAgICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlcycsXG4gICAgICAgICAgJ2NsaWNrRWRnZScsXG4gICAgICAgICAgJ2NsaWNrRWRnZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGUnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlcycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZXMnLFxuICAgICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICAgJ292ZXJFZGdlJyxcbiAgICAgICAgICAnb3ZlckVkZ2VzJyxcbiAgICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgICAnb3V0RWRnZScsXG4gICAgICAgICAgJ291dEVkZ2VzJyxcbiAgICAgICAgICAnZG93bk5vZGUnLFxuICAgICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAgICdkb3duRWRnZScsXG4gICAgICAgICAgJ2Rvd25FZGdlcycsXG4gICAgICAgICAgJ3VwTm9kZScsXG4gICAgICAgICAgJ3VwTm9kZXMnLFxuICAgICAgICAgICd1cEVkZ2UnLFxuICAgICAgICAgICd1cEVkZ2VzJ1xuICAgICAgICBdLFxuICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICApO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSByZW5kZXJlciBieSBpdHMgY2FtZXJhOlxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF0ucHVzaChyZW5kZXJlcik7XG5cbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xyZW5kZXJlcn0gdiBUaGUgcmVuZGVyZXIgdG8ga2lsbCBvciBpdHMgSUQuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsUmVuZGVyZXIgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMucmVuZGVyZXJzW3ZdIDogdjtcblxuICAgIGlmICghdilcbiAgICAgIHRocm93ICdzaWdtYS5raWxsUmVuZGVyZXI6IFRoZSByZW5kZXJlciBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5jYW1lcmEuaWRdLFxuICAgICAgICBpID0gYS5pbmRleE9mKHYpO1xuXG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGEuc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzW3YuaWRdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyLCB3aXRoIHRoZSBzYW1lXG4gICAqIGFyZ3VtZW50cyB0aGFuIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYnV0IHdpbGwgYWxzbyBjaGVjayBpZiB0aGUgcmVuZGVyZXJcbiAgICogaGFzIGEgXCJwcm9jZXNzXCIgbWV0aG9kLCBhbmQgY2FsbCBpdCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEl0IGlzIHVzZWZ1bCBmb3IgcXVhZHRyZWVzIG9yIFdlYkdMIHByb2Nlc3NpbmcsIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVmcmVzaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBcIm9wdGlvbnNcIlxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9ib29sZWFufSBza2lwSW5kZXhhdGlvbiBBIGZsYWcgc3BlY2lmeWluZyB3ZXRoZXIgb3Igbm90IHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVpbmRleCB0aGUgZ3JhcGggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkdHJlZXMgb3Igbm90IChkZWZhdWx0OiBmYWxzZSkuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBwcmVmaXggPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDYWxsIGVhY2ggbWlkZGxld2FyZTpcbiAgICBhID0gdGhpcy5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIChpID09PSAwKSA/ICcnIDogJ3RtcCcgKyBwcmVmaXggKyAnOicsXG4gICAgICAgIChpID09PSBsIC0gMSkgPyAncmVhZHk6JyA6ICgndG1wJyArICgrK3ByZWZpeCkgKyAnOicpXG4gICAgICApO1xuXG4gICAgLy8gVGhlbiwgZm9yIGVhY2ggY2FtZXJhLCBjYWxsIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlLCB1bmxlc3MgdGhlXG4gICAgLy8gc2V0dGluZ3Mgc3BlY2lmeSBub3QgdG86XG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcykge1xuICAgICAgYyA9IHRoaXMuY2FtZXJhc1trXTtcbiAgICAgIGlmIChcbiAgICAgICAgYy5zZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXS5sZW5ndGhcbiAgICAgIClcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdWzBdLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMuY29weS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgLy8gRmluZCBncmFwaCBib3VuZGFyaWVzOlxuICAgICAgICBib3VuZHMgPSBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBxdWFkdHJlZTpcbiAgICAgICAgYy5xdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLm5vZGVzKCksIHtcbiAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgYy5zZXR0aW5ncygnZHJhd0VkZ2VzJykgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLCB7XG4gICAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICB4OiBib3VuZHMubWluWCxcbiAgICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucHJvY2VzcygpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgYSA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJzKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciB0aGF0IGlzIGJvdW5kIHRvXG4gICAqIHRoZSBzcGVjaWZpZWQgY2FtZXJhLiBUbyBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZXMsIGlmIHRoaXMgbWV0aG9kIGlzXG4gICAqIGNhbGxlZCB0b28gb2Z0ZW4sIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIHJlbmRlcmluZ3MgaXMgbGltaXRhdGVkIHRvIG9uZVxuICAgKiBwZXIgZnJhbWUsIHVubGVzcyB5b3UgYXJlIHVzaW5nIHRoZSBcImZvcmNlXCIgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9IGNhbWVyYSBUaGUgY2FtZXJhIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59ICAgICAgICAgICAgIGZvcmNlICBJZiB0cnVlLCB3aWxsIHJlbmRlciB0aGUgY2FtZXJhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0bHkuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlckNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgZm9yY2UpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXS5pZCArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdKSB7XG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGFbaV0uaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwia2lsbFwiIG1ldGhvZCBvZiBlYWNoIG1vZHVsZSBhbmQgZGVzdHJveXMgYW55XG4gICAqIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGs7XG5cbiAgICAvLyBEaXNwYXRjaGluZyBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgna2lsbCcpO1xuXG4gICAgLy8gS2lsbCBncmFwaDpcbiAgICB0aGlzLmdyYXBoLmtpbGwoKTtcblxuICAgIC8vIEtpbGwgbWlkZGxld2FyZXM6XG4gICAgZGVsZXRlIHRoaXMubWlkZGxld2FyZXM7XG5cbiAgICAvLyBLaWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgZm9yIChrIGluIHRoaXMucmVuZGVyZXJzKVxuICAgICAgdGhpcy5raWxsUmVuZGVyZXIodGhpcy5yZW5kZXJlcnNba10pO1xuXG4gICAgLy8gS2lsbCBlYWNoIGNhbWVyYTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKVxuICAgICAgdGhpcy5raWxsQ2FtZXJhKHRoaXMuY2FtZXJhc1trXSk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnM7XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhcztcblxuICAgIC8vIEtpbGwgZXZlcnl0aGluZyBlbHNlOlxuICAgIGZvciAoayBpbiB0aGlzKVxuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIGRlbGV0ZSB0aGlzW2tdO1xuXG4gICAgZGVsZXRlIF9faW5zdGFuY2VzW3RoaXMuaWRdO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlcyBvYmplY3Qgb3IgYSBzcGVjaWZpYyBydW5uaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSBpZCBFdmVudHVhbGx5IGFuIGluc3RhbmNlIElELlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgcmVsYXRlZCBpbnN0YW5jZSBvciBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEuaW5zdGFuY2VzID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICBfX2luc3RhbmNlc1tpZF0gOlxuICAgICAgc2lnbWEudXRpbHMuZXh0ZW5kKHt9LCBfX2luc3RhbmNlcyk7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHNpZ21hOlxuICAgKi9cbiAgc2lnbWEudmVyc2lvbiA9ICcxLjIuMSc7XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnQW4gb2JqZWN0IGNhbGxlZCBzaWdtYSBpcyBhbHJlYWR5IGluIHRoZSBnbG9iYWwgc2NvcGUuJztcblxuICB0aGlzLnNpZ21hID0gc2lnbWE7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qKlxuICogY29ucmFkLmpzIGlzIGEgdGlueSBKYXZhU2NyaXB0IGpvYnMgc2NoZWR1bGVyLFxuICpcbiAqIFZlcnNpb246IDAuMS4wXG4gKiBTb3VyY2VzOiBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanNcbiAqIERvYzogICAgIGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qcyNyZWFkbWVcbiAqXG4gKiBMaWNlbnNlOlxuICogLS0tLS0tLS1cbiAqIENvcHlyaWdodCDCqSAyMDEzIEFsZXhpcyBKYWNvbXksIFNjaWVuY2VzLVBvIG3DqWRpYWxhYlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVGhlIFNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiwgd2l0aG91dCB3YXJyYW50eSBvZiBhbnkga2luZCwgZXhwcmVzcyBvclxuICogaW1wbGllZCwgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byB0aGUgd2FycmFudGllcyBvZiBtZXJjaGFudGFiaWxpdHksXG4gKiBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqIGF1dGhvcnMgb3IgY29weXJpZ2h0IGhvbGRlcnMgYmUgbGlhYmxlIGZvciBhbnkgY2xhaW0sIGRhbWFnZXMgb3Igb3RoZXJcbiAqIGxpYWJpbGl0eSwgd2hldGhlciBpbiBhbiBhY3Rpb24gb2YgY29udHJhY3QsIHRvcnQgb3Igb3RoZXJ3aXNlLCBhcmlzaW5nXG4gKiBmcm9tLCBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBzb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzXG4gKiBpbiB0aGUgU29mdHdhcmUuXG4gKi9cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRoYXQgY29ucmFkLmpzIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0OlxuICBpZiAoZ2xvYmFsLmNvbnJhZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnJhZCBhbHJlYWR5IGV4aXN0cycpO1xuXG5cbiAgLyoqXG4gICAqIFBSSVZBVEUgVkFSSUFCTEVTOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdmFyIF9sYXN0RnJhbWVUaW1lO1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBvZiByZWdpc3RlcmVkIGpvYnMuIEVhY2ggam9iIG11c3QgYXQgbGVhc3QgaGF2ZSBhIHVuaXF1ZSBJRFxuICAgKiB1bmRlciB0aGUga2V5IFwiaWRcIiBhbmQgYSBmdW5jdGlvbiB1bmRlciB0aGUga2V5IFwiam9iXCIuIFRoaXMgaGFzaFxuICAgKiBjb250YWlucyBlYWNoIHJ1bm5pbmcgam9iIGFuZCBlYWNoIHdhaXRpbmcgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9qb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3J1bm5pbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgcnVubmluZyBqb2JzLCBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhciBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSB3YWl0aW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3dhaXRpbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBmaW5pc2hlZCBqb2JzLiBUaGV5IGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHNpbmNlIHR3byBqb2JzXG4gICAqIHdpdGggdGhlIHNhbWUgXCJpZFwiIGNhbiBoYXBwZW4gYXQgdHdvIGRpZmZlcmVudCB0aW1lcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9kb25lSm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGRpcnR5IGZsYWcgdG8ga2VlcCBjb25yYWQgZnJvbSBzdGFydGluZzogSW5kZWVkLCB3aGVuIGFkZEpvYigpIGlzIGNhbGxlZFxuICAgKiB3aXRoIHNldmVyYWwgam9icywgY29ucmFkIG11c3QgYmUgc3RhcnRlZCBvbmx5IGF0IHRoZSBlbmQuIFRoaXMgZmxhZyBrZWVwc1xuICAgKiBtZSBmcm9tIGR1cGxpY2F0aW5nIHRoZSBjb2RlIHRoYXQgZWZmZWN0aXZlbHkgYWRkcyBhIGpvYi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX25vU3RhcnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQW4gaGFzaCBjb250YWluaW5nIHNvbWUgZ2xvYmFsIHNldHRpbmdzIGFib3V0IGhvdyBjb25yYWQuanMgc2hvdWxkXG4gICAqIGJlaGF2ZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcGFyYW1ldGVycyA9IHtcbiAgICBmcmFtZUR1cmF0aW9uOiAyMCxcbiAgICBoaXN0b3J5OiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGV2ZXJ5IGhhbmRsZXJzIGJvdW5kIHRvIGNvbnJhZCBldmVudHMuIEl0IGRvZXMgbm90XG4gICAqIHJlcXVpcmVhIGFueSBET00gaW1wbGVtZW50YXRpb24sIHNpbmNlIHRoZSBldmVudHMgYXJlIGFsbCBKYXZhU2NyaXB0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fG9iamVjdH0gZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gICAgaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2JpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5O1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0KGFyZ3VtZW50c1swXSkgPT09IGFyZ3VtZW50c1swXVxuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgX2JpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVBcnJheSA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIGlmICghX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gW107XG5cbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF91bmJpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBqLFxuICAgICAgICBqX2VuZCxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcbiAgICAgICAgICAgICAgYS5wdXNoKF9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSAmJiBfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHs/T2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaChldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgZGF0YTogZGF0YSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbW9zdCBwcmlvcml0YXJ5IGpvYiBvbmNlLCBhbmQgZGVhbHMgd2l0aCBmaWxsaW5nIHRoZSBzdGF0c1xuICAgKiAoZG9uZSwgdGltZSwgYXZlcmFnZVRpbWUsIGN1cnJlbnRUaW1lLCBldGMuLi4pLlxuICAgKlxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGhhcyB0byBiZSBraWxsZWQsIG51bGwgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjdXRlRmlyc3RKb2IoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGtpbGwsXG4gICAgICAgIHB1c2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lID0gX19kYXRlTm93KCksXG4gICAgICAgIGpvYiA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zaGlmdCgpO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGFuZCBsb29rIGF0IHRoZSByZXN1bHQ6XG4gICAgdGVzdCA9IGpvYi5qb2IoKTtcblxuICAgIC8vIERlYWwgd2l0aCBzdGF0czpcbiAgICB0aW1lID0gX19kYXRlTm93KCkgLSB0aW1lO1xuICAgIGpvYi5kb25lKys7XG4gICAgam9iLnRpbWUgKz0gdGltZTtcbiAgICBqb2IuY3VycmVudFRpbWUgKz0gdGltZTtcbiAgICBqb2Iud2VpZ2h0VGltZSA9IGpvYi5jdXJyZW50VGltZSAvIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIGpvYi5hdmVyYWdlVGltZSA9IGpvYi50aW1lIC8gam9iLmRvbmU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgam9iIGhhcyB0byBiZSBraWxsZWQ6XG4gICAga2lsbCA9IGpvYi5jb3VudCA/IChqb2IuY291bnQgPD0gam9iLmRvbmUpIDogIXRlc3Q7XG5cbiAgICAvLyBSZXNldCBwcmlvcml0aWVzOlxuICAgIGlmICgha2lsbCkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChfc29ydGVkQnlQcmlvcml0eUpvYnNbaV0ud2VpZ2h0VGltZSA+IGpvYi53ZWlnaHRUaW1lKSB7XG4gICAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNwbGljZShpLCAwLCBqb2IpO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFwdXNoZWQpXG4gICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtpbGwgPyBqb2IgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhIGpvYiwgYnkgYWRkaW5nIGl0IHRvIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0IGFuZCB0aGVcbiAgICogX3NvcnRlZEJ5UHJpb3JpdHlKb2JzIGFycmF5LiBJdCBhbHNvIGluaXRpYWxpemVzIGl0cyBjdXJyZW50VGltZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBqb2IgVGhlIGpvYiB0byBhY3RpdmF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZUpvYihqb2IpIHtcbiAgICB2YXIgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcnVubmluZyBqb2JzOlxuICAgIF9ydW5uaW5nSm9ic1tqb2IuaWRdID0gam9iO1xuICAgIGpvYi5zdGF0dXMgPSAncnVubmluZyc7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGllczpcbiAgICBpZiAobCkge1xuICAgICAgam9iLndlaWdodFRpbWUgPSBfc29ydGVkQnlQcmlvcml0eUpvYnNbbCAtIDFdLndlaWdodFRpbWU7XG4gICAgICBqb2IuY3VycmVudFRpbWUgPSBqb2Iud2VpZ2h0VGltZSAqIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGpvYiBhbmQgZGlzcGF0Y2g6XG4gICAgam9iLnN0YXJ0VGltZSA9IF9fZGF0ZU5vdygpO1xuICAgIF9kaXNwYXRjaCgnam9iU3RhcnRlZCcsIF9fY2xvbmUoam9iKSk7XG5cbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGxvb3Agb2YgY29ucmFkLmpzOlxuICAgKiAgLiBJdCBleGVjdXRlcyBqb2Igc3VjaCB0aGF0IHRoZXkgYWxsIG9jY3VwYXRlIHRoZSBzYW1lIHByb2Nlc3NpbmcgdGltZS5cbiAgICogIC4gSXQgc3RvcHMgam9icyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGV4ZWN1dGVkIGFueW1vcmUuXG4gICAqICAuIEl0IHRyaWdnZXJzIGNhbGxiYWNrcyB3aGVuIGl0IGlzIHJlbGV2YW50LlxuICAgKiAgLiBJdCBzdGFydHMgd2FpdGluZyBqb2JzIHdoZW4gdGhleSBuZWVkIHRvIGJlIHN0YXJ0ZWQuXG4gICAqICAuIEl0IGluamVjdHMgZnJhbWVzIHRvIGtlZXAgYSBjb25zdGFudCBmcmFwZXMgcGVyIHNlY29uZCByYXRpby5cbiAgICogIC4gSXQgc3RvcHMgaXRzZWxmIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgam9icyB0byBleGVjdXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG8sXG4gICAgICAgIGwsXG4gICAgICAgIGpvYixcbiAgICAgICAgdGltZSxcbiAgICAgICAgZGVhZEpvYjtcblxuICAgIC8vIERlYWwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgam9icyAodGhlIF9qb2JzIG9iamVjdCk6XG4gICAgZm9yIChrIGluIF9qb2JzKSB7XG4gICAgICBqb2IgPSBfam9ic1trXTtcblxuICAgICAgaWYgKGpvYi5hZnRlcilcbiAgICAgICAgX3dhaXRpbmdKb2JzW2tdID0gam9iO1xuICAgICAgZWxzZVxuICAgICAgICBfYWN0aXZhdGVKb2Ioam9iKTtcblxuICAgICAgZGVsZXRlIF9qb2JzW2tdO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgX2lzUnVubmluZyBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBydW5uaW5nIGpvYjpcbiAgICBfaXNSdW5uaW5nID0gISFfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBydW5uaW5nIGpvYnMgKHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0KTpcbiAgICB3aGlsZSAoXG4gICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoICYmXG4gICAgICBfX2RhdGVOb3coKSAtIF9sYXN0RnJhbWVUaW1lIDwgX3BhcmFtZXRlcnMuZnJhbWVEdXJhdGlvblxuICAgICkge1xuICAgICAgZGVhZEpvYiA9IF9leGVjdXRlRmlyc3RKb2IoKTtcblxuICAgICAgLy8gRGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBqb2IgaGFzIGVuZGVkOlxuICAgICAgaWYgKGRlYWRKb2IpIHtcbiAgICAgICAgX2tpbGxKb2IoZGVhZEpvYi5pZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdhaXRpbmcgam9iczpcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBpZiAoX3dhaXRpbmdKb2JzW2tdLmFmdGVyID09PSBkZWFkSm9iLmlkKSB7XG4gICAgICAgICAgICBfYWN0aXZhdGVKb2IoX3dhaXRpbmdKb2JzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfd2FpdGluZ0pvYnNba107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbnJhZCBzdGlsbCBoYXMgam9icyB0byBkZWFsIHdpdGgsIGFuZCBraWxsIGl0IGlmIG5vdDpcbiAgICBpZiAoX2lzUnVubmluZykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgIF9kaXNwYXRjaCgnZW50ZXJGcmFtZScpO1xuICAgICAgc2V0VGltZW91dChfbG9vcCwgMCk7XG4gICAgfSBlbHNlXG4gICAgICBfZGlzcGF0Y2goJ3N0b3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGpvYnMsIGFuZCBzdGFydHMgdGhlIGxvb3AgaWYgbm8gam9iIHdhcyBydW5uaW5nIGJlZm9yZS4gQVxuICAgKiBqb2IgaXMgYXQgbGVhc3QgYSB1bmlxdWUgc3RyaW5nIFwiaWRcIiBhbmQgYSBmdW5jdGlvbiwgYW5kIHRoZXJlIGFyZSBzb21lXG4gICAqIHBhcmFtZXRlcnMgdGhhdCB5b3UgY2FuIHNwZWNpZnkgZm9yIGVhY2ggam9iIHRvIG1vZGlmeSB0aGUgd2F5IGNvbnJhZCB3aWxsXG4gICAqIGV4ZWN1dGUgaXQuIElmIGEgam9iIGlzIGFkZGVkIHdpdGggdGhlIFwiaWRcIiBvZiBhbm90aGVyIGpvYiB0aGF0IGlzIHdhaXRpbmdcbiAgICogb3Igc3RpbGwgcnVubmluZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIFdoZW4gYSBqb2IgaXMgYWRkZWQsIGl0IGlzIHJlZmVyZW5jZWQgaW4gdGhlIF9qb2JzIG9iamVjdCwgYnkgaXRzIGlkLlxuICAgKiBUaGVuLCBpZiBpdCBoYXMgdG8gYmUgZXhlY3V0ZWQgcmlnaHQgbm93LCBpdCB3aWxsIGJlIGFsc28gcmVmZXJlbmNlZCBpblxuICAgKiB0aGUgX3J1bm5pbmdKb2JzIG9iamVjdC4gSWYgaXQgaGFzIHRvIHdhaXQsIHRoZW4gaXQgd2lsbCBiZSBhZGRlZCBpbnRvIHRoZVxuICAgKiBfd2FpdGluZ0pvYnMgb2JqZWN0LCB1bnRpbCBpdCBjYW4gc3RhcnQuXG4gICAqXG4gICAqIEtlZXAgcmVhZGluZyB0aGlzIGRvY3VtZW50YXRpb24gdG8gc2VlIGhvdyB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKlxuICAgKiBBZGRpbmcgb25lIGpvYjpcbiAgICogKioqKioqKioqKioqKioqXG4gICAqIEJhc2ljYWxseSwgYSBqb2IgaXMgZGVmaW5lZCBieSBpdHMgc3RyaW5nIGlkIGFuZCBhIGZ1bmN0aW9uICh0aGUgam9iKS4gSXRcbiAgICogaXMgYWxzbyBwb3NzaWJsZSB0byBhZGQgc29tZSBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywgbXlKb2JGdW5jdGlvbik7XG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCB7XG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxuICAgKiAgPiAgIHNvbWVQYXJhbWV0ZXI6IHNvbWVWYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgaWQ6ICdteUpvYklkJyxcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBBZGRpbmcgc2V2ZXJhbCBqb2JzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXaGVuIGFkZGluZyBzZXZlcmFsIGpvYnMgYXQgdGhlIHNhbWUgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeVxuICAgKiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgb3IgZm9yIGFsbDpcbiAgICpcbiAgICogID4gY29ucmFkLmFkZEpvYihbXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMScsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcbiAgICogID4gICB9LFxuICAgKiAgPiAgIHtcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDInLFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXG4gICAqICA+ICAgfVxuICAgKiAgPiBdLCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBteUpvYklkMTogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgbXlKb2JJZDI6IHssXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IH0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICBteUpvYklkMjogbXlKb2JGdW5jdGlvbjJcbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICB7P0Z1bmN0aW9ufSBlbmQgICAgICBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgam9iIGlzIGVuZGVkLiBJdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub3QgZXhlY3V0ZWQgaWYgdGhlIGpvYiBpcyBraWxsZWQgaW5zdGVhZCBvZiBlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hdHVyYWxseVwiLlxuICAgKiAgICB7P0ludGVnZXJ9ICBjb3VudCAgICBUaGUgbnVtYmVyIG9mIHRpbWUgdGhlIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQuXG4gICAqICAgIHs/TnVtYmVyfSAgIHdlaWdodCAgIElmIHNwZWNpZmllZCwgdGhlIGpvYiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGl0IHdhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCBcIndlaWdodFwiIHRpbWVzLlxuICAgKiAgICB7P1N0cmluZ30gICBhZnRlciAgICBUaGUgaWQgb2YgYW5vdGhlciBqb2IgKGV2ZW50dWFsbHkgbm90IGFkZGVkIHlldCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNwZWNpZmllZCwgdGhpcyBqb2Igd2lsbCBzdGFydCBvbmx5IHdoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCBcImFmdGVyXCIgam9iIGlzIGVuZGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZEpvYih2MSwgdjIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbztcblxuICAgIC8vIEFycmF5IG9mIGpvYnM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICBfbm9TdGFydCA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9hZGRKb2IodjFbaV0uaWQsIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xuXG4gICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYxID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gT25lIGpvYiAob2JqZWN0KTpcbiAgICAgIGlmICh0eXBlb2YgdjEuaWQgPT09ICdzdHJpbmcnKVxuICAgICAgICBfYWRkSm9iKHYxLmlkLCB2MSk7XG5cbiAgICAgIC8vIEhhc2ggb2Ygam9iczpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgaW4gdjEpXG4gICAgICAgICAgaWYgKHR5cGVvZiB2MVtpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQoe1xuICAgICAgICAgICAgICBqb2I6IHYxW2ldXG4gICAgICAgICAgICB9LCB2MikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgICAgX25vU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIE9uZSBqb2IgKHN0cmluZywgKik6XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoX2hhc0pvYih2MSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnW2NvbnJhZC5hZGRKb2JdIEpvYiB3aXRoIGlkIFwiJyArIHYxICsgJ1wiIGFscmVhZHkgZXhpc3RzLidcbiAgICAgICAgKTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBmdW5jdGlvbik6XG4gICAgICBpZiAodHlwZW9mIHYyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgaWQ6IHYxLFxuICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICB3ZWlnaHRUaW1lOiAwLFxuICAgICAgICAgIGpvYjogdjJcbiAgICAgICAgfTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBvYmplY3QpOlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdjIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBfX2V4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgICBkb25lOiAwLFxuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICAgIHdlaWdodFRpbWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHYyXG4gICAgICAgICk7XG5cbiAgICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgICAgLy8gRWZmZWN0aXZlbHkgYWRkIHRoZSBqb2I6XG4gICAgICBfam9ic1t2MV0gPSBvO1xuICAgICAgX2Rpc3BhdGNoKCdqb2JBZGRlZCcsIF9fY2xvbmUobykpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbG9vcCBoYXMgdG8gYmUgc3RhcnRlZDpcbiAgICAgIGlmICghX2lzUnVubmluZyAmJiAhX25vU3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIG9uZSBvciBtb3JlIGpvYnMsIGluZGljYXRlZCBieSB0aGVpciBpZHMuIEl0IGlzIG9ubHkgcG9zc2libGUgdG9cbiAgICoga2lsbCBydW5uaW5nIGpvYnMgb3Igd2FpdGluZyBqb2JzLiBJZiB5b3UgdHJ5IHRvIGtpbGwgYSBqb2IgdGhhdCBkb2VzIG5vdFxuICAgKiBleGlzdCBvciB0aGF0IGlzIGFscmVhZHkga2lsbGVkLCBhIHdhcm5pbmcgd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fFN0cmluZ30gdjEgQSBzdHJpbmcgam9iIGlkIG9yIGFuIGFycmF5IG9mIGpvYiBpZHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEpvYih2MSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBqb2IsXG4gICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBBcnJheSBvZiBqb2IgaWRzOlxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSlcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9raWxsSm9iKHYxW2ldKTtcblxuICAgIC8vIE9uZSBqb2IncyBpZDpcbiAgICBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhID0gW19ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzLCBfam9ic107XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgam9iIGZyb20gdGhlIGhhc2hlczpcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHYxIGluIGFbaV0pIHtcbiAgICAgICAgICBqb2IgPSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICAgICAgX2RvbmVKb2JzLnB1c2goam9iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ2pvYkVuZGVkJywgX19jbG9uZShqb2IpKTtcbiAgICAgICAgICBkZWxldGUgYVtpXVt2MV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGpvYi5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBqb2IuZW5kKCk7XG5cbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBwcmlvcml0aWVzIGFycmF5OlxuICAgICAgYSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icztcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGFbaV0uaWQgPT09IHYxKSB7XG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIEpvYiBcIicgKyB2MSArICdcIiBub3QgZm91bmQuJyk7XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nLCB3YWl0aW5nLCBhbmQganVzdCBhZGRlZCBqb2JzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2tpbGxBbGwoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGpvYnMgPSBfX2V4dGVuZChfam9icywgX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMpO1xuXG4gICAgLy8gVGFrZSBldmVyeSBqb2JzIGFuZCBwdXNoIHRoZW0gaW50byB0aGUgX2RvbmVKb2JzIG9iamVjdDpcbiAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSlcbiAgICAgIGZvciAoayBpbiBqb2JzKSB7XG4gICAgICAgIGpvYnNba10uc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICBfZG9uZUpvYnMucHVzaChqb2JzW2tdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGpvYnNba10uZW5kID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGpvYnNba10uZW5kKCk7XG4gICAgICB9XG5cbiAgICAvLyBSZWluaXRpYWxpemUgdGhlIGRpZmZlcmVudCBqb2JzIGxpc3RzOlxuICAgIF9qb2JzID0ge307XG4gICAgX3dhaXRpbmdKb2JzID0ge307XG4gICAgX3J1bm5pbmdKb2JzID0ge307XG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XG5cbiAgICAvLyBJbiBjYXNlIHNvbWUgam9icyBhcmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGtpbGw6XG4gICAgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgam9iIHdpdGggdGhlIHNwZWNpZmllZCBpZCBpcyBjdXJyZW50bHkgcnVubmluZyBvclxuICAgKiB3YWl0aW5nLCBhbmQgZmFsc2UgZWxzZS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWQgVGhlIGlkIG9mIHRoZSBqb2IuXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gX2hhc0pvYihpZCkge1xuICAgIHZhciBqb2IgPSBfam9ic1tpZF0gfHwgX3J1bm5pbmdKb2JzW2lkXSB8fCBfd2FpdGluZ0pvYnNbaWRdO1xuICAgIHJldHVybiBqb2IgPyBfX2V4dGVuZChqb2IpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUgc2V0dGluZyBzcGVjaWZpZWQgYnkgXCJ2MVwiIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICogYnkgXCJ2MlwiIGlmIGJvdGggYXJlIGdpdmVuLCBhbmQgZWxzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlXG4gICAqIHNldHRpbmdzIFwidjFcIi5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHYxIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtICB7Pyp9ICAgICAgIHYyIEV2ZW50dWFsbHksIGEgdmFsdWUgdG8gc2V0IHRvIHRoZSBzcGVjaWZpZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Kn0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIHZhbHVlIGlmIFwidjJcIiBpcyBub3RcbiAgICogICAgICAgICAgICAgICAgICAgIGdpdmVuLCBhbmQgY29ucmFkIGVsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0dGluZ3ModjEsIHYyKSB7XG4gICAgdmFyIG87XG5cbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzW2ExXTtcbiAgICBlbHNlIHtcbiAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/XG4gICAgICAgIGExIHx8IHt9IDpcbiAgICAgICAge307XG4gICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgb1thMV0gPSBhMjtcblxuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICBpZiAob1trXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9wYXJhbWV0ZXJzW2tdID0gb1trXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRlbGV0ZSBfcGFyYW1ldGVyc1trXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb25yYWQgaXMgY3VycmVudGx5IHJ1bm5pbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIF9pc1J1bm5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0SXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBfaXNSdW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVmZXJlbmNlIGV2ZXJ5IGpvYiB0aGF0IGlzIHN0b3JlZCBpbiB0aGUgX2RvbmVKb2JzIG9iamVjdC4gSXQgd2lsbFxuICAgKiBub3QgYmUgcG9zc2libGUgYW55bW9yZSB0byBnZXQgc3RhdHMgYWJvdXQgdGhlc2Ugam9icywgYnV0IGl0IHdpbGwgcmVsZWFzZVxuICAgKiB0aGUgbWVtb3J5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFySGlzdG9yeSgpIHtcbiAgICBfZG9uZUpvYnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgZXZlcnkgZGF0YSBhYm91dCBqb2JzIHRoYXQgd2FpdCB0byBiZSBzdGFydGVkLCBhcmVcbiAgICogY3VycmVudGx5IHJ1bm5pbmcgb3IgYXJlIGRvbmUuXG4gICAqXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBvbmx5IHJ1bm5pbmcsIHdhaXRpbmcgb3IgZG9uZSBqb2JzIGJ5IGdpdmluZ1xuICAgKiBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIgYXMgZmlzdCBhcmd1bWVudC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgZXZlcnkgam9iIHdpdGggYSBzcGVjaWZpZWQgaWQgYnkgZ2l2aW5nIGl0IGFzXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBbHNvLCB1c2luZyBhIFJlZ0V4cCBpbnN0ZWFkIG9mIGFuIGlkIHdpbGwgcmV0dXJuIGV2ZXJ5XG4gICAqIGpvYnMgd2hvc2UgaWRzIG1hdGNoIHRoZSBSZWdFeHAuIEFuZCB0aGVzZSB0d28gbGFzdCB1c2UgY2FzZXMgd29yayBhcyB3ZWxsXG4gICAqIGJ5IGdpdmluZyBiZWZvcmUgXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHRoZSBtYXRjaGluZyBqb2JzLlxuICAgKlxuICAgKiBTb21lIGNhbGwgZXhhbXBsZXM6XG4gICAqICoqKioqKioqKioqKioqKioqKipcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCd3YWl0aW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdkb25lJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdteUpvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygvdGVzdC8pXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsICdteVJ1bm5pbmdKb2InKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAvdGVzdC8pXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U3RhdHModjEsIHYyKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBpc1BhdHRlcm5TdHJpbmc7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHN0YXRzID0gW107XG5cbiAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgc3RhdHMucHVzaChfam9ic1trXSk7XG5cbiAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICBzdGF0cyA9IHN0YXRzLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKVxuICAgICAgc3dpdGNoICh2MSkge1xuICAgICAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF93YWl0aW5nSm9icyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bm5pbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3J1bm5pbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgc3RhdHMgPSBfZG9uZUpvYnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGF0dGVybiA9IHYxO1xuICAgICAgfVxuXG4gICAgaWYgKHYxIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgcGF0dGVybiA9IHYxO1xuXG4gICAgaWYgKCFwYXR0ZXJuICYmICh0eXBlb2YgdjIgPT09ICdzdHJpbmcnIHx8IHYyIGluc3RhbmNlb2YgUmVnRXhwKSlcbiAgICAgIHBhdHRlcm4gPSB2MjtcblxuICAgIC8vIEZpbHRlciBqb2JzIGlmIGEgcGF0dGVybiBpcyBnaXZlbjpcbiAgICBpZiAocGF0dGVybikge1xuICAgICAgaXNQYXR0ZXJuU3RyaW5nID0gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoc3RhdHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhID0gc3RhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBzdGF0cylcbiAgICAgICAgICBhID0gYS5jb25jYXQoc3RhdHNba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgICBhLnB1c2goX2pvYnNba10pO1xuXG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgICAgYS5wdXNoKF93YWl0aW5nSm9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcblxuICAgICAgICBhID0gYS5jb25jYXQoX2RvbmVKb2JzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGlzUGF0dGVyblN0cmluZyA/IGFbaV0uaWQgPT09IHBhdHRlcm4gOiBhW2ldLmlkLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICAgIHN0YXRzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fY2xvbmUoc3RhdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogVE9PTFMgRlVOQ1RJT05TOlxuICAgKiAqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gdHdvIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gdmFyIG8xID0ge1xuICAgKiAgPiAgICAgICBhOiAxLFxuICAgKiAgPiAgICAgICBiOiAyLFxuICAgKiAgPiAgICAgICBjOiAnMydcbiAgICogID4gICAgIH0sXG4gICAqICA+ICAgICBvMiA9IHtcbiAgICogID4gICAgICAgYzogJzQnLFxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxuICAgKiAgPiAgICAgfTtcbiAgICogID4gX19leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbiBvYmplY3QuIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBvbmx5XG4gICAqIG9iamVjdHMsIGFycmF5cyBhbmQgaW1tdXRhYmxlIHZhbHVlcy4gU2luY2UgaXQgaXMgbm90IHB1YmxpYywgaXQgZG9lcyBub3RcbiAgICogZGVhbCB3aXRoIGN5Y2xpYyByZWZlcmVuY2VzLCBET00gZWxlbWVudHMgYW5kIGluc3RhbnRpYXRlZCBvYmplY3RzIC0gc29cbiAgICogdXNlIGl0IGNhcmVmdWxseS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9fY2xvbmUoaXRlbSkge1xuICAgIHZhciByZXN1bHQsIGksIGssIGw7XG5cbiAgICBpZiAoIWl0ZW0pXG4gICAgICByZXR1cm4gaXRlbTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goX19jbG9uZShpdGVtW2ldKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChpIGluIGl0ZW0pXG4gICAgICAgIHJlc3VsdFtpXSA9IF9fY2xvbmUoaXRlbVtpXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXN1bHQgPSBpdGVtO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7QXJyYXl9ICBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gX19vYmplY3RWYWx1ZXMobykge1xuICAgIHZhciBrLFxuICAgICAgICBhID0gW107XG5cbiAgICBmb3IgKGsgaW4gbylcbiAgICAgIGEucHVzaChvW2tdKTtcblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgZnVuY3Rpb24gX19kYXRlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmlzQXJyYXkgZnVuY3Rpb246XG4gICAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkpXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQgUFVCTElDIEFQSTpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuICB2YXIgY29ucmFkID0ge1xuICAgIGhhc0pvYjogX2hhc0pvYixcbiAgICBhZGRKb2I6IF9hZGRKb2IsXG4gICAga2lsbEpvYjogX2tpbGxKb2IsXG4gICAga2lsbEFsbDogX2tpbGxBbGwsXG4gICAgc2V0dGluZ3M6IF9zZXR0aW5ncyxcbiAgICBnZXRTdGF0czogX2dldFN0YXRzLFxuICAgIGlzUnVubmluZzogX2dldElzUnVubmluZyxcbiAgICBjbGVhckhpc3Rvcnk6IF9jbGVhckhpc3RvcnksXG5cbiAgICAvLyBFdmVudHMgbWFuYWdlbWVudDpcbiAgICBiaW5kOiBfYmluZCxcbiAgICB1bmJpbmQ6IF91bmJpbmQsXG5cbiAgICAvLyBWZXJzaW9uOlxuICAgIHZlcnNpb246ICcwLjEuMCdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29ucmFkO1xuICAgIGV4cG9ydHMuY29ucmFkID0gY29ucmFkO1xuICB9XG4gIGdsb2JhbC5jb25yYWQgPSBjb25yYWQ7XG59KSh0aGlzKTtcblxuLy8gSGFyZGNvZGVkIGV4cG9ydCBmb3IgdGhlIG5vZGUuanMgdmVyc2lvbjpcbnZhciBzaWdtYSA9IHRoaXMuc2lnbWEsXG4gICAgY29ucmFkID0gdGhpcy5jb25yYWQ7XG5cbnNpZ21hLmNvbnJhZCA9IGNvbnJhZDtcblxuLy8gRGlydHkgcG9seWZpbGxzIHRvIHBlcm1pdCBzaWdtYSB1c2FnZSBpbiBub2RlXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJylcbiAgSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gIHdpbmRvdyA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNpZ21hO1xuICBleHBvcnRzLnNpZ21hID0gc2lnbWE7XG59XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICB2YXIgX3Jvb3QgPSB0aGlzO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzID0gc2lnbWEudXRpbHMgfHwge307XG5cbiAgLyoqXG4gICAqIE1JU0MgVVRJTFM6XG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxuICAgKiB3aGVuIHNldmVyYWwgb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBzaWdtYS51dGlscy5leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRhdGVOb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgcGFja2FnZSBuYW1lIGFzIHBhcmFtZXRlciBhbmQgY2hlY2tzIGF0IGVhY2ggbGViZWwgaWYgaXQgZXhpc3RzLFxuICAgKiBhbmQgaWYgaXQgZG9lcyBub3QsIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmMnKTtcbiAgICogID4gYS5iLmM7XG4gICAqICA+IC8vIE9iamVjdCB7fTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuZCcpO1xuICAgKiAgPiBhLmI7XG4gICAqICA+IC8vIE9iamVjdCB7IGM6IHt9LCBkOiB7fSB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnID0gZnVuY3Rpb24ocGtnTmFtZSkge1xuICAgIHJldHVybiAocGtnTmFtZSB8fCAnJykuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oY29udGV4dCwgb2JqTmFtZSkge1xuICAgICAgcmV0dXJuIChvYmpOYW1lIGluIGNvbnRleHQpID9cbiAgICAgICAgY29udGV4dFtvYmpOYW1lXSA6XG4gICAgICAgIChjb250ZXh0W29iak5hbWVdID0ge30pO1xuICAgIH0sIF9yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBudW1iZXIgSUQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDE7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDI7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDM7XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5pZCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsraTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGhleGEgY29sb3IgKGZvciBpbnN0YW5jZSBcIiNmZmNjMDBcIiBvciBcIiNmYzBcIikgb3IgYVxuICAgKiByZ2IgLyByZ2JhIGNvbG9yIChsaWtlIFwicmdiKDI1NSwyNTUsMTIpXCIgb3IgXCJyZ2JhKDI1NSwyNTUsMTIsMSlcIikgYW5kXG4gICAqIHJldHVybnMgYW4gaW50ZWdlciBlcXVhbCB0byBcInIgKiAyNTUgKiAyNTUgKyBnICogMjU1ICsgYlwiLCB0byBnYWluIHNvbWVcbiAgICogbWVtb3J5IGluIHRoZSBkYXRhIGdpdmVuIHRvIFdlYkdMIHNoYWRlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgY2FjaGVzIGl0cyByZXN1bHRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsIFRoZSBoZXhhIG9yIHJnYmEgY29sb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBudW1iZXIgdmFsdWUuXG4gICAqL1xuICB2YXIgZmxvYXRDb2xvckNhY2hlID0ge307XG5cbiAgc2lnbWEudXRpbHMuZmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgLy8gSXMgdGhlIGNvbG9yIGFscmVhZHkgY29tcHV0ZWQ/XG4gICAgaWYgKGZsb2F0Q29sb3JDYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIGZsb2F0Q29sb3JDYWNoZVt2YWxdO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gdmFsLFxuICAgICAgICByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuXG4gICAgaWYgKHZhbFswXSA9PT0gJyMnKSB7XG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XG5cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgciA9ICt2YWxbMV07XG4gICAgICBnID0gK3ZhbFsyXTtcbiAgICAgIGIgPSArdmFsWzNdO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IChcbiAgICAgIHIgKiAyNTYgKiAyNTYgK1xuICAgICAgZyAqIDI1NiArXG4gICAgICBiXG4gICAgKTtcblxuICAgIC8vIENhY2hpbmcgdGhlIGNvbG9yXG4gICAgZmxvYXRDb2xvckNhY2hlW29yaWdpbmFsXSA9IGNvbG9yO1xuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuXG4gICAgLyoqXG4gICAqIFBlcmZvcm0gYSB6b29tIGludG8gYSBjYW1lcmEsIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24sIHRvIHRoZVxuICAgKiBjb29yZGluYXRlcyBpbmRpY2F0ZWQgdXNpbmcgYSBzcGVjaWZpZWQgcmF0aW8uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgYW5pbWF0aW9uXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P251bWJlcn0gZHVyYXRpb24gICAgIEFuIGFtb3VudCBvZiB0aW1lIHRoYXQgbWVhbnMgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLiBJZiB0aGlzIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbSB3aWxsIGJlIHBlcmZvcm1lZCB3aXRob3V0IGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBpdCBhZnRlciB0aGUgYW5pbWF0aW9uLiBJdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwZXJmb3JtZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtjYW1lcmF9ICAgICBUaGUgY2FtZXJhIHdoZXJlIHBlcmZvcm0gdGhlIHpvb20uXG4gICAqIEBwYXJhbSB7eH0gICAgICAgICAgVGhlIFggY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7eX0gICAgICAgICAgVGhlIFkgY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7cmF0aW99ICAgICAgVGhlIHJhdGlvIHRvIGFwcGx5IGl0IHRvIHRoZSBjdXJyZW50IGNhbWVyYSByYXRpby5cbiAgICogQHBhcmFtIHs/YW5pbWF0aW9ufSBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zIGZvciBhIHBvc3NpYmxlIGFuaW1hdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnpvb21UbyA9IGZ1bmN0aW9uKGNhbWVyYSwgeCwgeSwgcmF0aW8sIGFuaW1hdGlvbikge1xuICAgIHZhciBzZXR0aW5ncyA9IGNhbWVyYS5zZXR0aW5ncyxcbiAgICAgICAgY291bnQsXG4gICAgICAgIG5ld1JhdGlvLFxuICAgICAgICBhbmltYXRpb25TZXR0aW5ncyxcbiAgICAgICAgY29vcmRpbmF0ZXM7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG5ld1JhdGlvIGRlYWxpbmcgd2l0aCBtaW4gLyBtYXg6XG4gICAgbmV3UmF0aW8gPSBNYXRoLm1heChcbiAgICAgIHNldHRpbmdzKCd6b29tTWluJyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgc2V0dGluZ3MoJ3pvb21NYXgnKSxcbiAgICAgICAgY2FtZXJhLnJhdGlvICogcmF0aW9cbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbmV3IHJhdGlvIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbml0aWFsIG9uZTpcbiAgICBpZiAobmV3UmF0aW8gIT09IGNhbWVyYS5yYXRpbykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb29yZGluYXRlcyB2YXJpYWJsZTpcbiAgICAgIHJhdGlvID0gbmV3UmF0aW8gLyBjYW1lcmEucmF0aW87XG4gICAgICBjb29yZGluYXRlcyA9IHtcbiAgICAgICAgeDogeCAqICgxIC0gcmF0aW8pICsgY2FtZXJhLngsXG4gICAgICAgIHk6IHkgKiAoMSAtIHJhdGlvKSArIGNhbWVyYS55LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSBhbmltYXRpb24gc2V0aW5nczpcbiAgICAgICAgY291bnQgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKGNhbWVyYSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IHNpZ21hLnV0aWxzLmV4dGVuZChcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nOiBjb3VudCA/ICdxdWFkcmF0aWNPdXQnIDogJ3F1YWRyYXRpY0luT3V0J1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoY2FtZXJhLCBjb29yZGluYXRlcywgYW5pbWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWVyYS5nb1RvKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24ub25Db21wbGV0ZSlcbiAgICAgICAgICBhbmltYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge3gseX0gICAgICAgIFRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHgxICsgeDIpIC8gMiArICh5MiAtIHkxKSAvIDQsXG4gICAgICB5OiAoeTEgKyB5MikgLyAyICsgKHgxIC0geDIpIC8gNFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlpIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgeGksIHlpKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTYzNDUyOFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiAoMSAtIHQpICogdCAqIHhpICsgTWF0aC5wb3codCwgMikgKiB4MixcbiAgICAgIHk6IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqICgxIC0gdCkgKiB0ICogeWkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9IFRoZSBwb2ludCBhdCB0LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCBjeCwgY3ksIGR4LCBkeSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mzk3NTk2XG4gICAgLy8gQmxlbmRpbmcgZnVuY3Rpb25zOlxuICAgIHZhciBCMF90ID0gTWF0aC5wb3coMSAtIHQsIDMpLFxuICAgICAgICBCMV90ID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksXG4gICAgICAgIEIyX3QgPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLFxuICAgICAgICBCM190ID0gTWF0aC5wb3codCwgMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKEIwX3QgKiB4MSkgKyAoQjFfdCAqIGN4KSArIChCMl90ICogZHgpICsgKEIzX3QgKiB4MiksXG4gICAgICB5OiAoQjBfdCAqIHkxKSArIChCMV90ICogY3kpICsgKEIyX3QgKiBkeSkgKyAoQjNfdCAqIHkyKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cyBmb3IgYSBzZWxmIGxvb3AgKGkuZS5cbiAgICogd2hlcmUgdGhlIHN0YXJ0IHBvaW50IGlzIGFsc28gdGhlIGVuZCBwb2ludCkgY29tcHV0ZWQgYXMgYSBjdWJpYyBiZXppZXJcbiAgICogY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBzaXplIFRoZSBub2RlIHNpemUuXG4gICAqIEByZXR1cm4ge3gxLHkxLHgyLHkyfSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKHggLCB5LCBzaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4IC0gc2l6ZSAqIDcsXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiB4LFxuICAgICAgeTI6IHkgKyBzaXplICogN1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiBhIHBsYW5lXG4gICAqIHdpdGggYW4gb3J0aG9ub3JtYWwgYmFzaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBldWNsaWRpYW4gZGlzdGFuY2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0d28gY2lyY2xlcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MCAgVGhlIFggY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MCAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMCAgVGhlIHJhZGl1cyBvZiB0aGUgZmlyc3QgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjEgIFRoZSByYWRpdXMgb2YgdGhlIHNlY29uZCBjaXJjbGUuXG4gICAqIEByZXR1cm4ge3hpLHlpfSAgICAgIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldENpcmNsZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjIxOTgwMlxuICAgIHZhciBhLCBkeCwgZHksIGQsIGgsIHJ4LCByeSwgeDIsIHkyO1xuXG4gICAgLy8gZHggYW5kIGR5IGFyZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGNpcmNsZVxuICAgIC8vIGNlbnRlcnM6XG4gICAgZHggPSB4MSAtIHgwO1xuICAgIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIERldGVybWluZSB0aGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjZW50ZXJzOlxuICAgIGQgPSBNYXRoLnNxcnQoKGR5ICogZHkpICsgKGR4ICogZHgpKTtcblxuICAgIC8vIENoZWNrIGZvciBzb2x2YWJpbGl0eTpcbiAgICBpZiAoZCA+IChyMCArIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gY2lyY2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkIDwgTWF0aC5hYnMocjAgLSByMSkpIHtcbiAgICAgICAgLy8gTm8gc29sdXRpb24uIG9uZSBjaXJjbGUgaXMgY29udGFpbmVkIGluIHRoZSBvdGhlci5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vJ3BvaW50IDInIGlzIHRoZSBwb2ludCB3aGVyZSB0aGUgbGluZSB0aHJvdWdoIHRoZSBjaXJjbGUgaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzIGNyb3NzZXMgdGhlIGxpbmUgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlcnMuXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMCB0byBwb2ludCAyOlxuICAgIGEgPSAoKHIwICogcjApIC0gKHIxICogcjEpICsgKGQgKiBkKSkgLyAoMi4wICogZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzIG9mIHBvaW50IDI6XG4gICAgeDIgPSB4MCArIChkeCAqIGEgLyBkKTtcbiAgICB5MiA9IHkwICsgKGR5ICogYSAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDIgdG8gZWl0aGVyIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHM6XG4gICAgaCA9IE1hdGguc3FydCgocjAgKiByMCkgLSAoYSAqIGEpKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgb2Zmc2V0cyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmcm9tIHBvaW50IDI6XG4gICAgcnggPSAtZHkgKiAoaCAvIGQpO1xuICAgIHJ5ID0gZHggKiAoaCAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzOlxuICAgIHZhciB4aSA9IHgyICsgcng7XG4gICAgdmFyIHhpX3ByaW1lID0geDIgLSByeDtcbiAgICB2YXIgeWkgPSB5MiArIHJ5O1xuICAgIHZhciB5aV9wcmltZSA9IHkyIC0gcnk7XG5cbiAgICByZXR1cm4ge3hpOiB4aSwgeGlfcHJpbWU6IHhpX3ByaW1lLCB5aTogeWksIHlpX3ByaW1lOiB5aV9wcmltZX07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgbGluZSBzZWdtZW50LlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmIHBvaW50IGlzIFwiY2xvc2UgdG9cIiB0aGUgbGluZVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI4MTIyXG4gICAgdmFyIGNyb3NzUHJvZHVjdCA9IE1hdGguYWJzKCh5IC0geTEpICogKHgyIC0geDEpIC0gKHggLSB4MSkgKiAoeTIgLSB5MSkpLFxuICAgICAgICBkID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgICBuQ3Jvc3NQcm9kdWN0ID0gY3Jvc3NQcm9kdWN0IC8gZDsgLy8gbm9ybWFsaXplZCBjcm9zcyBwcm9kdWN0XG5cbiAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXG4gICAgIE1hdGgubWluKHgxLCB4MikgPD0geCAmJiB4IDw9IE1hdGgubWF4KHgxLCB4MikgJiZcbiAgICAgTWF0aC5taW4oeTEsIHkyKSA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweCAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5ICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHksIGVwc2lsb24pIHtcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcbiAgICB2YXIgZFAxUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFQMiB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxUDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSksXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXG4gICAgICAgIG9sZF9kdDtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxuICAgIC8vIGZpbmQgdGhlIG9wdGltYWwgdCB2YWx1ZSB3aGVyZSB0PTAgaXMgdGhlIHN0YXJ0IHBvaW50IGFuZCB0PTEgaXMgdGhlIGVuZFxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cbiAgICB3aGlsZSAoaS0tID4gMCAmJlxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcbiAgICAgIChyID4gclRocmVzaG9sZCB8fCByIDwgLXJUaHJlc2hvbGQpKSB7XG4gICAgICBvbGRfZHQgPSBkdDtcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSk7XG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xuXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgciA9IC1yIC8gMjtcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcbiAgICAgICAgciA9IHIgLyAyO1xuICAgICAgICBkdCA9IG9sZF9kdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9ncmVzczpcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XG4gIH07XG5cblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgxICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkxICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgyICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkyICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFDUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIGNweDEsIGNweTEpO1xuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxQ1AxIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFDUDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogRVZFTlRTIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBIZXJlIGFyZSBzb21lIHVzZWZ1bCBmdW5jdGlvbnMgdG8gdW5pZnkgZXh0cmFjdGlvbiBvZiB0aGUgaW5mb3JtYXRpb24gd2VcbiAgICogbmVlZCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCBmcm9tIGRpZmZlcmVudCBicm93c2VyczpcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFggcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBYIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFggPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLm9mZnNldFggIT09IHVuZGVmaW5lZCAmJiBlLm9mZnNldFgpIHx8XG4gICAgICAoZS5sYXllclggIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWCkgfHxcbiAgICAgIChlLmNsaWVudFggIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFgpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWSBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WSkgfHxcbiAgICAgIChlLmxheWVyWSAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJZKSB8fFxuICAgICAgKGUuY2xpZW50WSAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlbi4gVGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmF0aW8gPSAxO1xuICAgIGlmICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LnNjcmVlbi5zeXN0ZW1YRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gcmF0aW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHdpZHRoIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2lkdGggb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0V2lkdGggPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHcgPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xuICAgICAgICAgICAgICBlLnRhcmdldC53aWR0aCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC53aWR0aDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHcgPT09ICdudW1iZXInICYmIHcpIHx8XG4gICAgICAodyAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBjZW50ZXIgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjZW50ZXIgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByYXRpbyA9IGUudGFyZ2V0Lm5hbWVzcGFjZVVSSS5pbmRleE9mKCdzdmcnKSAhPT0gLTEgPyAxIDpcbiAgICAgICAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzaWdtYS51dGlscy5nZXRXaWR0aChlKSAvICgyICogcmF0aW8pLFxuICAgICAgeTogc2lnbWEudXRpbHMuZ2V0SGVpZ2h0KGUpIC8gKDIgKiByYXRpbylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB4IGNvb3JkIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeSBjb29yZCB0byBjb252ZXJ0XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIHN0YW5kYXJkaXplZCBldmVudFxuICAgKi9cbiAgc2lnbWEudXRpbHMubW91c2VDb29yZHMgPSBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgeCA9IHggfHwgc2lnbWEudXRpbHMuZ2V0WChlKTtcbiAgICB5ID0geSB8fCBzaWdtYS51dGlscy5nZXRZKGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgeTogeSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgaGVpZ2h0IGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgaGVpZ2h0IG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldEhlaWdodCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaCA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LmhlaWdodCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC5oZWlnaHQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiBoID09PSAnbnVtYmVyJyAmJiBoKSB8fFxuICAgICAgKGggIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwudmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICYmIGUud2hlZWxEZWx0YSkgfHxcbiAgICAgIChlLmRldGFpbCAhPT0gdW5kZWZpbmVkICYmIC1lLmRldGFpbClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tIFRoZSBlbGVtZW50IHRvIHJldHJpZXZlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIERPTSBlbGVtZW50ICh0b3AsIGxlZnQpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24oZG9tKSB7XG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwO1xuXG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgdG9wID0gdG9wICsgcGFyc2VJbnQoZG9tLm9mZnNldFRvcCk7XG4gICAgICBsZWZ0ID0gbGVmdCArIHBhcnNlSW50KGRvbS5vZmZzZXRMZWZ0KTtcbiAgICAgIGRvbSA9IGRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIFwiZG91YmxlIGNsaWNrXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBjbGlja3MgPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaGFuZGxlcnM7XG5cbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9O1xuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gfHwgW107XG4gICAgaGFuZGxlcnMgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXTtcblxuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oZSkge1xuICAgICAgY2xpY2tzKys7XG5cbiAgICAgIGlmIChjbGlja3MgPT09IDIpIHtcbiAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja3MgPT09IDEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICB9LCBzaWdtYS5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV0sIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIHNpbXVsYXRlZCBcImRvdWJsZSBjbGlja1wiIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXIsXG4gICAgICAgIGhhbmRsZXJzID0gKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXSB8fCBbXTtcblxuICAgIHdoaWxlICgoaGFuZGxlciA9IGhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZGVsZXRlICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEhlcmUgYXJlIGp1c3Qgc29tZSBvZiB0aGUgbW9zdCBiYXNpYyBlYXNpbmcgZnVuY3Rpb25zLCB1c2VkIGZvciB0aGVcbiAgICogYW5pbWF0ZWQgY2FtZXJhIFwiZ29Ub1wiIGNhbGxzLlxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCBzb21lIG1vcmUgZWFzaW5ncyBmdW5jdGlvbnMsIGRvbid0IGhlc2l0YXRlIHRvIGFkZCB0aGVtIHRvXG4gICAqIHNpZ21hLnV0aWxzLmVhc2luZ3MuIEJ1dCBJIHdpbGwgbm90IGFkZCBzb21lIG1vcmUgaGVyZSBvciBtZXJnZSBQUnNcbiAgICogY29udGFpbmluZywgYmVjYXVzZSBJIGRvIG5vdCB3YW50IHNpZ21hIHNvdXJjZXMgZnVsbCBvZiBvdmVya2lsbCBhbmQgbmV2ZXJcbiAgICogdXNlZCBzdHVmZi4uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZWFzaW5ncyA9IHNpZ21hLnV0aWxzLmVhc2luZ3MgfHwge307XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MubGluZWFyTm9uZSA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqKioqXG4gICAqIFdFQkdMIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBMb2FkcyBhIFdlYkdMIHNoYWRlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7V2ViR0xDb250ZXh0fSAgICAgICAgICAgZ2wgICAgICAgICAgIFRoZSBXZWJHTENvbnRleHQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2UgVGhlIHNoYWRlciBzb3VyY2UuXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgIHNoYWRlclR5cGUgICBUaGUgdHlwZSBvZiBzaGFkZXIuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgc2hhZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMubG9hZFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIGVycm9yKSB7XG4gICAgdmFyIGNvbXBpbGVkLFxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG5cbiAgICAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHNoYWRlclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmc6XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgICdFcnJvciBjb21waWxpbmcgc2hhZGVyIFwiJyArIHNoYWRlciArICdcIjonICtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZ3JhbSwgYXR0YWNoZXMgc2hhZGVycywgYmluZHMgYXR0cmliIGxvY2F0aW9ucywgbGlua3MgdGhlXG4gICAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5LjxXZWJHTFNoYWRlcj59ICAgIHNoYWRlcnMgICBUaGUgc2hhZGVycyB0byBhdHRhY2guXG4gICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSAgICAgICAgIGF0dHJpYnMgICBUaGUgYXR0cmlicyBuYW1lcy5cbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59ICAgICAgICAgbG9jYXRpb25zIFRoZSBsb2NhdGlvbnMgZm9yIHRoZSBhdHRyaWJzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cbiAgICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb2dyYW0uXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJzLCBhdHRyaWJzLCBsb2MsIGVycm9yKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxpbmtlZCxcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgKytpKVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuXG4gICAgaWYgKGF0dHJpYnMpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7ICsraSlcbiAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKFxuICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgbG9jYXRpb25zID8gbG9jYXRpb25zW2ldIDogaSxcbiAgICAgICAgICBvcHRfYXR0cmlic1tpXVxuICAgICAgICApO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcbiAgICBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgaWYgKGVycm9yKVxuICAgICAgICBlcnJvcignRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiAnICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuXG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKlxuICAgKiBNQVRSSUNFUzpcbiAgICogKioqKioqKioqXG4gICAqIFRoZSBmb2xsb3dpbmcgdXRpbHMgYXJlIGp1c3QgaGVyZSB0byBoZWxwIGdlbmVyYXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIG1hdHJpY2VzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXJzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscy5tYXRyaWNlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgdHJhbnNsYXRpb24uXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICBkeCwgZHksIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBhbmdsZSBUaGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUsIG0yKSB7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgY29zLCAtc2luLFxuICAgICAgc2luLCBjb3NcbiAgICBdIDogW1xuICAgICAgY29zLCAtc2luLCAwLFxuICAgICAgc2luLCBjb3MsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByYXRpbyBUaGUgc2NhbGluZyByYXRpby5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUgPSBmdW5jdGlvbihyYXRpbywgbTIpIHtcbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICByYXRpbywgMCxcbiAgICAgIDAsIHJhdGlvXG4gICAgXSA6IFtcbiAgICAgIHJhdGlvLCAwLCAwLFxuICAgICAgMCwgcmF0aW8sIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBhICBUaGUgZmlyc3QgbWF0cml4LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBiICBUaGUgc2Vjb25kIG1hdHJpeC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgYXNzdW1lIGJvdGggbWF0cmljZXMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIDJ4Mi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkgPSBmdW5jdGlvbihhLCBiLCBtMikge1xuICAgIHZhciBsID0gbTIgPyAyIDogMyxcbiAgICAgICAgYTAwID0gYVswICogbCArIDBdLFxuICAgICAgICBhMDEgPSBhWzAgKiBsICsgMV0sXG4gICAgICAgIGEwMiA9IGFbMCAqIGwgKyAyXSxcbiAgICAgICAgYTEwID0gYVsxICogbCArIDBdLFxuICAgICAgICBhMTEgPSBhWzEgKiBsICsgMV0sXG4gICAgICAgIGExMiA9IGFbMSAqIGwgKyAyXSxcbiAgICAgICAgYTIwID0gYVsyICogbCArIDBdLFxuICAgICAgICBhMjEgPSBhWzIgKiBsICsgMV0sXG4gICAgICAgIGEyMiA9IGFbMiAqIGwgKyAyXSxcbiAgICAgICAgYjAwID0gYlswICogbCArIDBdLFxuICAgICAgICBiMDEgPSBiWzAgKiBsICsgMV0sXG4gICAgICAgIGIwMiA9IGJbMCAqIGwgKyAyXSxcbiAgICAgICAgYjEwID0gYlsxICogbCArIDBdLFxuICAgICAgICBiMTEgPSBiWzEgKiBsICsgMV0sXG4gICAgICAgIGIxMiA9IGJbMSAqIGwgKyAyXSxcbiAgICAgICAgYjIwID0gYlsyICogbCArIDBdLFxuICAgICAgICBiMjEgPSBiWzIgKiBsICsgMV0sXG4gICAgICAgIGIyMiA9IGJbMiAqIGwgKyAyXTtcblxuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSxcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMVxuICAgIF0gOiBbXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAgKyBhMDIgKiBiMjAsXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEsXG4gICAgICBhMDAgKiBiMDIgKyBhMDEgKiBiMTIgKyBhMDIgKiBiMjIsXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAgKyBhMTIgKiBiMjAsXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTEgKyBhMTIgKiBiMjEsXG4gICAgICBhMTAgKiBiMDIgKyBhMTEgKiBiMTIgKyBhMTIgKiBiMjIsXG4gICAgICBhMjAgKiBiMDAgKyBhMjEgKiBiMTAgKyBhMjIgKiBiMjAsXG4gICAgICBhMjAgKiBiMDEgKyBhMjEgKiBiMTEgKyBhMjIgKiBiMjEsXG4gICAgICBhMjAgKiBiMDIgKyBhMjEgKiBiMTIgKyBhMjIgKiBiMjJcbiAgICBdO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuXG4gICAqIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIHZhciB4LFxuICAgICAgbGFzdFRpbWUgPSAwLFxuICAgICAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbiAgZm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyB4KyspIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuXG4gIGlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXG4gICAgICAgICAgaWQgPSBnbG9iYWwuc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVUb0NhbGxcbiAgICAgICAgICApO1xuXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gIGlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHBvbHlmaWxsIGZvdW5kIG9uIE1ETi5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNDb21wYXRpYmlsaXR5XG4gICAqIFB1YmxpYyBkb21haW5cbiAgICovXG4gIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAvLyBDbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZVxuICAgICAgICAvLyBmdW5jdGlvbjpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnXG4gICAgICAgICk7XG5cbiAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgZk5PUCxcbiAgICAgICAgICBmQm91bmQ7XG5cbiAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID9cbiAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgb1RoaXMsXG4gICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gUGFja2FnZXMgaW5pdGlhbGl6YXRpb246XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc2V0dGluZ3MnKTtcblxuICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgLyoqXG4gICAgICogR1JBUEggU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzIHRvIGFkZFxuICAgIC8vICAgICAgICAgICBub2RlcyBvciBlZGdlcy5cbiAgICBjbG9uZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIiwgXCJzb3VyY2VcIiBhbmRcbiAgICAvLyAgICAgICAgICAgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXMgaW1tdXRhYmxlLlxuICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHNpZ21hIGNhbiBsb2cgaXRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG4gICAgdmVyYm9zZTogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIFJFTkRFUkVSUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge3N0cmluZ31cbiAgICBjbGFzc1ByZWZpeDogJ3NpZ21hJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZVR5cGU6ICdkZWYnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbFNpemU6IDE0LFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcInNvdXJjZVwiLCBcInRhcmdldFwiLCBcImRlZmF1bHRcIlxuICAgIGVkZ2VDb2xvcjogJ3NvdXJjZScsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyB0aGUgbWluaW1hbCBlZGdlJ3MgYXJyb3cgZGlzcGxheSBzaXplLlxuICAgIG1pbkFycm93U2l6ZTogMCxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGZvbnQ6ICdhcmlhbCcsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgZm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIHNpemUuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJmaXhlZFwiLCBcInByb3BvcnRpb25hbFwiXG4gICAgbGFiZWxTaXplOiAnZml4ZWQnLFxuICAgIC8vIHtzdHJpbmd9IFRoZSByYXRpbyBiZXR3ZWVuIHRoZSBmb250IHNpemUgb2YgdGhlIGxhYmVsIGFuZCB0aGUgbm9kZSBzaXplLlxuICAgIGxhYmVsU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHNpemUgYSBub2RlIG11c3QgaGF2ZSB0byBzZWUgaXRzIGxhYmVsIGRpc3BsYXllZC5cbiAgICBsYWJlbFRocmVzaG9sZDogOCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgb3ZlcnNhbXBsaW5nIGZhY3RvciB1c2VkIGluIFdlYkdMIHJlbmRlcmVyLlxuICAgIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW86IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGJvcmRlciBvZiBob3ZlcmVkIG5vZGVzLlxuICAgIGJvcmRlclNpemU6IDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgaG92ZXJlZCBub2RlIGJvcmRlcidzIGNvbG9yLlxuICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaG92ZXJlZCBub2RlJ3MgbGFiZWwgZm9udC4gSWYgbm90IHNwZWNpZmllZCwgd2lsbCBoZXJpdGF0ZVxuICAgIC8vICAgICAgICAgIHRoZSBcImZvbnRcIiB2YWx1ZS5cbiAgICBob3ZlckZvbnQ6ICcnLFxuICAgIC8vIHtib29sZWFufSBJZiB0cnVlLCB0aGVuIG9ubHkgb25lIG5vZGUgY2FuIGJlIGhvdmVyZWQgYXQgYSB0aW1lLlxuICAgIHNpbmdsZUhvdmVyOiB0cnVlLFxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xuICAgIGhvdmVyRm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBzaGFkb3cgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlclNoYWRvdzogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgbGFiZWxIb3ZlclNoYWRvd0NvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbm9kZUhvdmVyQ29sb3I6ICdub2RlJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlckJHQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcjogJyNmZmYnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIGxhYmVscyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbEhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgZWRnZXMgaG92ZXIgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJlZGdlXCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBtdWx0aXBsaWNhdG9yIG9mIGhvdmVyZWQgZWRnZXMuXG4gICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZSBleHRyZW1pdGllcyBtdXN0IGJlIGhvdmVyZWQgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICAgZWRnZSBpcyBob3ZlcmVkLlxuICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbnN9IFRoZSBkaWZmZXJlbnQgZHJhd2luZyBtb2RlczpcbiAgICAvLyAgICAgICAgICAgZmFsc2U6IExheWVyZWQgbm90IGRpc3BsYXllZC5cbiAgICAvLyAgICAgICAgICAgdHJ1ZTogTGF5ZXJlZCBkaXNwbGF5ZWQuXG4gICAgZHJhd0VkZ2VzOiB0cnVlLFxuICAgIGRyYXdOb2RlczogdHJ1ZSxcbiAgICBkcmF3TGFiZWxzOiB0cnVlLFxuICAgIGRyYXdFZGdlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGRyYXduIGluIHNldmVyYWwgZnJhbWVzIG9yIGluXG4gICAgLy8gICAgICAgICAgIG9uZSBmcmFtZSwgYXMgdGhlIG5vZGVzIGFuZCBsYWJlbHMgYXJlIGRyYXduLlxuICAgIGJhdGNoRWRnZXNEcmF3aW5nOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGhpZGRlbiBkdXJpbmcgZHJhZ2dpbmcgYW5kXG4gICAgLy8gICAgICAgICAgIGFuaW1hdGlvbnMuXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyc30gVGhlIGRpZmZlcmVudCBiYXRjaCBzaXplcywgd2hlbiBlbGVtZW50cyBhcmUgZGlzcGxheWVkIGluXG4gICAgLy8gICAgICAgICAgIHNldmVyYWwgZnJhbWVzLlxuICAgIGNhbnZhc0VkZ2VzQmF0Y2hTaXplOiA1MDAsXG4gICAgd2ViZ2xFZGdlc0JhdGNoU2l6ZTogMTAwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFJFU0NBTEUgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgb2YgdG8gc2NhbGUgdGhlIGdyYXBoIHJlbGF0aXZlbHkgdG8gaXRzIGNvbnRhaW5lci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcImluc2lkZVwiLCBcIm91dHNpZGVcIlxuICAgIHNjYWxpbmdNb2RlOiAnaW5zaWRlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWFyZ2luIHRvIGtlZXAgYXJvdW5kIHRoZSBncmFwaC5cbiAgICBzaWRlTWFyZ2luOiAwLFxuICAgIC8vIHtudW1iZXJ9IERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgc21hbGxlc3QgYW5kIHRoZSBiaWdnZXN0IG5vZGUgLyBlZGdlc1xuICAgIC8vICAgICAgICAgIG9uIHRoZSBzY3JlZW4uIFRoaXMgbWFwcGluZyBtYWtlcyBlYXNpZXIgdG8gZGlzcGxheSB0aGUgZ3JhcGgsXG4gICAgLy8gICAgICAgICAgYXZvaWRpbmcgdG9vIGJpZyBub2RlcyB0aGF0IHRha2UgaGFsZiBvZiB0aGUgc2NyZWVuLCBvciB0b29cbiAgICAvLyAgICAgICAgICBzbWFsbCBvbmVzIHRoYXQgYXJlIG5vdCByZWFkYWJsZS4gSWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vICAgICAgICAgIGVxdWFscywgdGhlbiB0aGUgbWluaW1hbCBkaXNwbGF5IHNpemUgd2lsbCBiZSAwLiBBbmQgaWYgdGhleVxuICAgIC8vICAgICAgICAgIGFyZSBib3RoIGVxdWFsIHRvIDAsIHRoZW4gdGhlcmUgaXMgbm8gbWFwcGluZywgYW5kIHRoZSByYWRpdXNcbiAgICAvLyAgICAgICAgICBvZiB0aGUgbm9kZXMgd2lsbCBiZSB0aGVpciBzaXplLlxuICAgIG1pbkVkZ2VTaXplOiAwLjUsXG4gICAgbWF4RWRnZVNpemU6IDEsXG4gICAgbWluTm9kZVNpemU6IDEsXG4gICAgbWF4Tm9kZVNpemU6IDgsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQVBUT1JTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgdG91Y2hFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBtb3VzZVdoZWVsRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBkb3VibGVDbGlja0VuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgY3VzdG9tIGV2ZW50cyBzdWNoIGFzIFwiY2xpY2tOb2RlXCIgY2FuIGJlXG4gICAgLy8gICAgICAgICAgIHVzZWQuXG4gICAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyB3aXRoIHRoZSBtb3VzZS13aGVlbC5cbiAgICB6b29taW5nUmF0aW86IDEuNyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyBieSBkb3VibGUgY2xpY2tpbmcuXG4gICAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NaW46IDAuMDYyNSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NYXg6IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2Ugc2Nyb2xsaW5nLlxuICAgIG1vdXNlWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZG91YmxlIGNsaWNrLlxuICAgIGRvdWJsZUNsaWNrWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZHJvcHBpbmcuXG4gICAgbW91c2VJbmVydGlhRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAobW91c2UgY2FwdG9yKS5cbiAgICBtb3VzZUluZXJ0aWFSYXRpbzogMyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSB0b3VjaCBkcm9wcGluZy5cbiAgICB0b3VjaEluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyICh0b3VjaCBjYXB0b3IpLlxuICAgIHRvdWNoSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gY2xpY2tzIHRvIG1ha2UgaXQgYSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tUaW1lb3V0OiAzMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byB0YXBzIHRvIG1ha2UgaXQgYSBkb3VibGUgdGFwLlxuICAgIGRvdWJsZVRhcFRpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIG9mIGRyYWdnaW5nIHRvIHRyaWdnZXIgaW50ZXJ0aWEuXG4gICAgZHJhZ1RpbWVvdXQ6IDIwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEdMT0JBTCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaGFzIHRvIHJlZnJlc2ggaXRzZWxmXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgd2hlbiBhIFwicmVzaXplXCIgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoZVxuICAgIC8vICAgICAgICAgICB3aW5kb3cgb2JqZWN0LlxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSBoYXMgdG8gYmUgY2FsbGVkXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgZm9yIGVhY2ggY2FtZXJhIG9uIHJlZnJlc2guXG4gICAgYXV0b1Jlc2NhbGU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIGNhbWVyYSBtZXRob2QgXCJnb1RvXCIgd2lsbCBiYXNpY2FsbHkgZG9cbiAgICAvLyAgICAgICAgICAgbm90aGluZy5cbiAgICBlbmFibGVDYW1lcmE6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIG5vZGVzIGNhbm5vdCBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUhvdmVyaW5nOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkZ2VzIGNhbiBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogZmFsc2UsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFyZWEgYXJvdW5kIHRoZSBlZGdlcyB0byBhY3RpdmF0ZSBob3ZlcmluZy5cbiAgICBlZGdlSG92ZXJQcmVjaXNpb246IDUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgcmVzY2FsZSBtaWRkbGV3YXJlIHdpbGwgaWdub3JlIG5vZGUgc2l6ZXNcbiAgICAvLyAgICAgICAgICAgdG8gZGV0ZXJtaW5lIHRoZSBncmFwaHMgYm91bmRpbmdzLlxuICAgIHJlc2NhbGVJZ25vcmVTaXplOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGUgY29yZSBoYXMgdG8gdHJ5IHRvIGNhdGNoIGVycm9ycyBvblxuICAgIC8vICAgICAgICAgICByZW5kZXJpbmcuXG4gICAgc2tpcEVycm9yczogZmFsc2UsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQU1FUkEgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBwb3dlciBkZWdyZWVzIGFwcGxpZWQgdG8gdGhlIG5vZGVzL2VkZ2VzIHNpemUgcmVsYXRpdmVseSB0b1xuICAgIC8vICAgICAgICAgIHRoZSB6b29taW5nIGxldmVsLiBCYXNpY2FsbHk6XG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5SID0gTWF0aC5wb3coem9vbSwgbm9kZXNQb3dSYXRpbykgKiBSXG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5UID0gTWF0aC5wb3coem9vbSwgZWRnZXNQb3dSYXRpbykgKiBUXG4gICAgbm9kZXNQb3dSYXRpbzogMC41LFxuICAgIGVkZ2VzUG93UmF0aW86IDAuNSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEFOSU1BVElPTlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBhbmltYXRpb24gdGltZS5cbiAgICBhbmltYXRpb25zVGltZTogMjAwXG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBwcmV2aW91c2x5IGRlc2lnbmVkIHNldHRpbmdzOlxuICBzaWdtYS5zZXR0aW5ncyA9IHNpZ21hLnV0aWxzLmV4dGVuZChzaWdtYS5zZXR0aW5ncyB8fCB7fSwgc2V0dGluZ3MpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVyIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSBUaGUgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2hhbmRsZXJzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0J1xuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGw7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IGV2ZW50IGlzIG5vdCAnJzpcbiAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgJ2JpbmQ6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKG9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuX2hhbmRsZXJzKVxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNba107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdKTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgIGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbixcbiAgICAgICAgaixcbiAgICAgICAgbSxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xuXG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHNlbGYuZ2V0RXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0ub25lKVxuICAgICAgICAgICAgYS5wdXNoKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBldmVudCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBkYXRhOiBkYXRhIHx8IHt9LFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQSB1c2VmdWwgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlLiBJdCB3aWxsIG1ha2UgdGhlIHRhcmdldFxuICAgKiBpbmhlcml0IHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzIGRpc3BhdGNoZXIgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldC5cbiAgICovXG4gIGRpc3BhdGNoZXIuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gZGlzcGF0Y2hlci5wcm90b3R5cGUpXG4gICAgICBpZiAoZGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIHRhcmdldFtrXSA9IGRpc3BhdGNoZXIucHJvdG90eXBlW2tdO1xuXG4gICAgZGlzcGF0Y2hlci5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXI7XG4gICAgZXhwb3J0cy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfSBlbHNlXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhpcyB1dGlscyBhaW1zIHRvIGZhY2lsaXRhdGUgdGhlIG1hbmlwdWxhdGlvbiBvZiBlYWNoIGluc3RhbmNlIHNldHRpbmcuXG4gICAqIFVzaW5nIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBvYmplY3QgYnJpbmdzIHR3byBtYWluIGFkdmFudGFnZXM6IEZpcnN0LFxuICAgKiBpdCB3aWxsIGJlIGVhc2llciBpbiB0aGUgZnV0dXJlIHRvIGNhdGNoIHNldHRpbmdzIHVwZGF0ZXMgdGhyb3VnaCBhXG4gICAqIGZ1bmN0aW9uIHRoYW4gYW4gb2JqZWN0LiBTZWNvbmQsIGdpdmluZyBpdCBhIGZ1bGwgb2JqZWN0IHdpbGwgXCJtZXJnZVwiIGl0XG4gICAqIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgcHJvcGVybHksIGtlZXBpbmcgdXMgdG8gaGF2ZSB0byBhbHdheXMgYWRkIGEgbG9vcC5cbiAgICpcbiAgICogQHJldHVybiB7Y29uZmlndXJhYmxlfSBUaGUgXCJzZXR0aW5nc1wiIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIGNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIGRhdGFzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIHNldCBvciBnZXQgYW55IHByb3BlcnR5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICBhMSBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXMgdW5kZWZpbmVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS4gSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0LCB0aGVuIGl0IHdpbGwgc2V0IGEyIGFzIHRoZSBwcm9wZXJ0eVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgdG8gYTEsIGFuZCByZXR1cm4gdGhpcy4gSWZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBpcyBhbiBvYmplY3QsIHRoZW4gZWFjaCBwYWlyIHN0cmluZyArXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0KG9yIGFueSBvdGhlciB0eXBlKSB3aWxsIGJlIHNldCBhcyBhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7Kj99ICAgICAgICAgICAgICAgYTIgVGhlIG5ldyBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIGExIGlmIGExXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7Knxjb25maWd1cmFibGV9ICAgICAgUmV0dXJucyBpdHNlbGYgb3IgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFBvbHltb3JwaGlzbTpcbiAgICAgKiAqKioqKioqKioqKioqXG4gICAgICogSGVyZSBhcmUgc29tZSBiYXNpYyB1c2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgPiBzZXR0aW5ncyA9IG5ldyBjb25maWd1cmFibGUoKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgNDIpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgMTIzKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDEyM1xuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6IDQ1Nn0pO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICpcbiAgICAgKiBBbHNvLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhlIGZ1bmN0aW9uIGFzIGEgZmFsbGJhY2s6XG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7ICAvLyBMb2dzOiAnYWJjJ1xuICAgICAqICA+IHNldHRpbmdzKHtoaXNTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICovXG4gICAgdmFyIHNldHRpbmdzID0gZnVuY3Rpb24oYTEsIGEyKSB7XG4gICAgICB2YXIgbyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgaztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGExID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YVthMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gZGF0YVthMV07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKGRhdGFzW2ldW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFzW2ldW2ExXTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoYTEgfHwge30pW2EyXSAhPT0gdW5kZWZpbmVkID8gYTFbYTJdIDogc2V0dGluZ3MoYTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGEyID09PSB1bmRlZmluZWQpID8gYTEgOiB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGsubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGRhdGFba1tpXV0gPSBvW2tbaV1dO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGNvbmZpZ3VyYWJsZSBmdW5jdGlvbiwgd2l0aCBuZXcgb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0Kn0gIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB0byBzZWFyY2ggaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFJldHVybnMgdGhlIGZ1bmN0aW9uLiBDaGVjayBpdHMgZG9jdW1lbnRhdGlvbiB0byBrbm93XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1vcmUgYWJvdXQgaG93IGl0IHdvcmtzLlxuICAgICAqL1xuICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBkYXRhcy5jb25jYXQoXG4gICAgICAgIGRhdGFcbiAgICAgICkuY29uY2F0KFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYWJsZS5hcHBseSh7fSwgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemVcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHNldHRpbmdzKGFyZ3VtZW50c1tpXSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3VyYWJsZTtcbiAgICBleHBvcnRzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgfSBlbHNlXG4gICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9tZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbmRleGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbml0QmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfZGVmYXVsdFNldHRpbmdzID0ge1xuICAgICAgICBpbW11dGFibGU6IHRydWUsXG4gICAgICAgIGNsb25lOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdFNldHRpbmdzW2tleV07XG4gICAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JhcGggY29uc3RydWN0b3IuIEl0IGluaXRpYWxpemVzIHRoZSBkYXRhIGFuZCB0aGUgaW5kZXhlcywgYW5kIGJpbmRzXG4gICAqIHRoZSBjdXN0b20gaW5kZXhlcyBhbmQgbWV0aG9kcyB0byBpdHMgb3duIHNjb3BlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIHNldHRpbmdzXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7Ym9vbGVhbn0gY2xvbmUgICAgIEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0byBhZGQgbm9kZXMgb3IgZWRnZXMuXG4gICAqICAge2Jvb2xlYW59IGltbXV0YWJsZSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiBhbmQgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgRXZlbnR1YWxseSBhIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtncmFwaH0gICAgICAgICAgICAgICAgICBUaGUgbmV3IGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgdmFyIGdyYXBoID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICB2YXIgayxcbiAgICAgICAgZm4sXG4gICAgICAgIGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBEQVRBOlxuICAgICAqICoqKioqXG4gICAgICogRXZlcnkgZGF0YSB0aGF0IGlzIGNhbGxhYmxlIGZyb20gZ3JhcGggbWV0aG9kcyBhcmUgc3RvcmVkIGluIHRoaXMgXCJkYXRhXCJcbiAgICAgKiBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgc2VydmVkIGFzIGNvbnRleHQgZm9yIGFsbCB0aGVzZSBtZXRob2RzLFxuICAgICAqIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgb3RoZXIgdHlwZSBvZiBkYXRhIGluIGl0LlxuICAgICAqL1xuICAgIGRhdGEgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNFVFRJTkdTIEZVTkNUSU9OOlxuICAgICAgICogKioqKioqKioqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyB8fCBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogTUFJTiBEQVRBOlxuICAgICAgICogKioqKioqKioqKlxuICAgICAgICovXG4gICAgICBub2Rlc0FycmF5OiBbXSxcbiAgICAgIGVkZ2VzQXJyYXk6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEdMT0JBTCBJTkRFWEVTOlxuICAgICAgICogKioqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIGp1c3QgaW5kZXggZGF0YSBieSBpZHMuXG4gICAgICAgKi9cbiAgICAgIG5vZGVzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBlZGdlc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAvKipcbiAgICAgICAqIExPQ0FMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKlxuICAgICAgICogVGhlc2UgaW5kZXhlcyByZWZlciBmcm9tIG5vZGUgdG8gbm9kZXMuIEVhY2gga2V5IGlzIGFuIGlkLCBhbmQgZWFjaFxuICAgICAgICogdmFsdWUgaXMgdGhlIGFycmF5IG9mIHRoZSBpZHMgb2YgcmVsYXRlZCBub2Rlcy5cbiAgICAgICAqL1xuICAgICAgaW5OZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIGluTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBvdXROZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFsbE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGUgYmluZGluZ3M6XG4gICAgZm9yIChrIGluIF9pbml0QmluZGluZ3MpXG4gICAgICBfaW5pdEJpbmRpbmdzW2tdLmNhbGwoZGF0YSk7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBib3RoIHRoZSBzY29wZSBhbmQgdGhlIGRhdGEgb2JqZWN0czpcbiAgICBmb3IgKGsgaW4gX21ldGhvZHMpIHtcbiAgICAgIGZuID0gX19iaW5kR3JhcGhNZXRob2QoaywgZGF0YSwgX21ldGhvZHNba10pO1xuICAgICAgdGhpc1trXSA9IGZuO1xuICAgICAgZGF0YVtrXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogQSBjdXN0b20gdG9vbCB0byBiaW5kIG1ldGhvZHMgc3VjaCB0aGF0IGZ1bmN0aW9uIHRoYXQgYXJlIGJvdW5kIHRvIGl0IHdpbGxcbiAgICogYmUgZXhlY3V0ZWQgYW55dGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiaW5kLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgc2NvcGUgICAgICBUaGUgc2NvcGUgd2hlcmUgdGhlIG1ldGhvZCBtdXN0IGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgVGhlIG5ldyBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2JpbmRHcmFwaE1ldGhvZChtZXRob2ROYW1lLCBzY29wZSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIC8vIEV4ZWN1dGUgXCJiZWZvcmVcIiBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIEFwcGx5IHRoZSBtZXRob2Q6XG4gICAgICByZXMgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gRXhlY3V0ZSBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIFJldHVybiByZXM6XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY3VzdG9tIHRvb2wgZnVuY3Rpb24gcmVtb3ZlcyBldmVyeSBwYWlyIGtleS92YWx1ZSBmcm9tIGFuIGhhc2guIFRoZVxuICAgKiBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aGlsZSBzb21lIG90aGVyIHJlZmVyZW5jZXMgYXJlXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBlbXB0eS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZW1wdHlPYmplY3Qob2JqKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gb2JqKVxuICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBvYmopIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIG9ialtrXTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuXG5cblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIGFkZHMgYSBtZXRob2QgdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoZSBmdXR1cmx5IGNyZWF0ZWRcbiAgICogZ3JhcGggaW5zdGFuY2VzLlxuICAgKlxuICAgKiBTaW5jZSB0aGVzZSBtZXRob2RzIHdpbGwgYmUgYm91bmQgdG8gdGhlaXIgc2NvcGUgd2hlbiB0aGUgaW5zdGFuY2VzIGFyZVxuICAgKiBjcmVhdGVkLCBpdCBkb2VzIG5vdCB1c2UgdGhlIHByb3RvdHlwZS4gQmVjYXVzZSBvZiB0aGF0LCBtZXRob2RzIGhhdmUgdG9cbiAgICogYmUgYWRkZWQgYmVmb3JlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XG4gICAqXG4gICAqICA+IGdyYXBoLmFkZE1ldGhvZCgnZ2V0Tm9kZXNDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoO1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAyXG4gICAgKVxuICAgICAgdGhyb3cgJ2FkZE1ldGhvZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBfbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZuO1xuICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBtZXRob2QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCwgYW5kXG4gICAqIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6XG4gICAqXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnYWRkTm9kZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdoYXNNZXRob2QnKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgndW5leGlzdGluZ01ldGhvZCcpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICBUaGUgcmVzdWx0LlxuICAgKi9cbiAgZ3JhcGguaGFzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHJldHVybiAhIShfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZHMgYXR0YWNoZXMgYSBmdW5jdGlvbiB0byBhIG1ldGhvZC4gQW55dGltZSB0aGUgc3BlY2lmaWVkXG4gICAqIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIsIHdpdGggdGhlXG4gICAqIHNhbWUgYXJndW1lbnRzIGFuZCBpbiB0aGUgc2FtZSBzY29wZS4gVGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgKiByaWdodCBiZWZvcmUgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgdHJ1ZSwgdW5sZXNzIHRoZSBtZXRob2QgaXMgdGhlIGdyYXBoXG4gICAqIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUbyBhdHRhY2ggYSBmdW5jdGlvbiB0byB0aGUgZ3JhcGggY29uc3RydWN0b3IsIHVzZSAnY29uc3RydWN0b3InIGFzIHRoZVxuICAgKiBtZXRob2QgbmFtZSAoZmlyc3QgYXJndW1lbnQpLlxuICAgKlxuICAgKiBUaGUgbWFpbiBpZGVhIGlzIHRvIGhhdmUgYSBjbGVhbiB3YXkgdG8ga2VlcCBjdXN0b20gaW5kZXhlcyB1cCB0byBkYXRlLFxuICAgKiBmb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICA+IHZhciB0aW1lc0FkZE5vZGVDYWxsZWQgPSAwO1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAndGltZXNBZGROb2RlQ2FsbGVkSW5jJywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgdGltZXNBZGROb2RlQ2FsbGVkKys7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAyXG4gICAqXG4gICAqIFRoZSBpZGVhIGZvciBjYWxsaW5nIGEgZnVuY3Rpb24gYmVmb3JlIGlzIHRvIHByb3ZpZGUgcHJlLXByb2Nlc3NvcnMsIGZvclxuICAgKiBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIGNvbG9yUGFsZXR0ZSA9IHsgUGVyc29uOiAnI0MzQ0JFMScsIFBsYWNlOiAnIzlCREVCRCcgfTtcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ2FwcGx5Tm9kZUNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKG4pIHtcbiAgICogID4gICBuLmNvbG9yID0gY29sb3JQYWxldHRlW24uY2F0ZWdvcnldO1xuICAgKiAgPiB9LCB0cnVlKTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICduMCcsIGNhdGVnb3J5OiAnUGVyc29uJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5ub2RlcygnbjAnKS5jb2xvcik7IC8vIG91dHB1dHMgJyNDM0NCRTEnXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSByZWxhdGVkIG1ldGhvZCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgICAgIFRoZSBrZXkgdG8gaWRlbnRpZnkgdGhlIGZ1bmN0aW9uIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICBiZWZvcmUgICAgIElmIHRydWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBiZWZvcmUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hdHRhY2ggPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuLCBiZWZvcmUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNFxuICAgIClcbiAgICAgIHRocm93ICdhdHRhY2g6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIGJpbmRpbmdzO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpXG4gICAgICBiaW5kaW5ncyA9IF9pbml0QmluZGluZ3M7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmICghX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiaW5kaW5nc1trZXldKVxuICAgICAgdGhyb3cgJ0EgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgYXR0YWNoZWQgJyArXG4gICAgICAgICAgICAndG8gdGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiLic7XG5cbiAgICBiaW5kaW5nc1trZXldID0gZm47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWxpYXMgb2YgYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpLlxuICAgKi9cbiAgZ3JhcGguYXR0YWNoQmVmb3JlID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbikge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIGlzIGp1c3QgYW4gaGVscGVyIHRvIGRlYWwgd2l0aCBjdXN0b20gaW5kZXhlcy4gSXQgdGFrZXMgYXNcbiAgICogYXJndW1lbnRzIHRoZSBuYW1lIG9mIHRoZSBpbmRleCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICogZnVuY3Rpb25zIHRvIGJpbmQgdG8gdGhlIG1ldGhvZHMuXG4gICAqXG4gICAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB0aGF0IGNyZWF0ZXMgYW4gaW5kZXggdG8ga2VlcCB0aGUgbnVtYmVyIG9mIG5vZGVzXG4gICAqIGluIHRoZSBjdXJyZW50IGdyYXBoLiBJdCBhbHNvIGFkZHMgYSBtZXRob2QgdG8gcHJvdmlkZSBhIGdldHRlciBvbiB0aGF0XG4gICAqIG5ldyBpbmRleDpcbiAgICpcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRJbmRleCgnbm9kZXNDb3VudCcsIHtcbiAgICogID4gICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQgPSAwO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgYWRkTm9kZTogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQrKztcbiAgICogID4gICB9LFxuICAgKiAgPiAgIGRyb3BOb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudC0tO1xuICAgKiAgPiAgIH1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNDb3VudDtcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IHNpZ21hLmNsYXNzZXMuZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gYmluZGluZ3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbnMgdG8gYmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYWRkSW5kZXggPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5ncykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgT2JqZWN0KGJpbmRpbmdzKSAhPT0gYmluZGluZ3MgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkSW5kZXg6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKF9pbmRleGVzW25hbWVdKVxuICAgICAgdGhyb3cgJ1RoZSBpbmRleCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgaztcblxuICAgIC8vIFN0b3JlIHRoZSBiaW5kaW5nczpcbiAgICBfaW5kZXhlc1tuYW1lXSA9IGJpbmRpbmdzO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gYmluZGluZ3MpXG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzW2tdICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnVGhlIGJpbmRpbmdzIG11c3QgYmUgZnVuY3Rpb25zLic7XG4gICAgICBlbHNlXG4gICAgICAgIGdyYXBoLmF0dGFjaChrLCBuYW1lLCBiaW5kaW5nc1trXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5vZGUgdG8gdGhlIGdyYXBoLiBUaGUgbm9kZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIi4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgYW55XG4gICAqIG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIG5vZGUgd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG5vZGUgVGhlIG5vZGUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGROb2RlJywgZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5vZGUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChub2RlKSAhPT0gbm9kZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygbm9kZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKHRoaXMubm9kZXNJbmRleFtub2RlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBub2RlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaWQgPSBub2RlLmlkLFxuICAgICAgICB2YWxpZE5vZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2Nsb25lJykpIHtcbiAgICAgIGZvciAoayBpbiBub2RlKVxuICAgICAgICBpZiAoayAhPT0gJ2lkJylcbiAgICAgICAgICB2YWxpZE5vZGVba10gPSBub2RlW2tdO1xuICAgIH0gZWxzZVxuICAgICAgdmFsaWROb2RlID0gbm9kZTtcblxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWROb2RlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdmFsaWROb2RlLmlkID0gaWQ7XG5cbiAgICAvLyBBZGQgZW1wdHkgY29udGFpbmVycyBmb3IgZWRnZXMgaW5kZXhlczpcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcblxuICAgIC8vIEFkZCB0aGUgbm9kZSB0byBpbmRleGVzOlxuICAgIHRoaXMubm9kZXNBcnJheS5wdXNoKHZhbGlkTm9kZSk7XG4gICAgdGhpcy5ub2Rlc0luZGV4W3ZhbGlkTm9kZS5pZF0gPSB2YWxpZE5vZGU7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2U6XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIiwgYW5kIHN0cmluZ3MgdW5kZXIgdGhlIGtleXMgXCJzb3VyY2VcIiBhbmRcbiAgICogXCJ0YXJnZXRcIiB0aGF0IGRlc2lnbiBleGlzdGluZyBub2Rlcy4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgKiBhZGQgYW55IG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlXG4gICAqIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIGVkZ2Ugd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCwgc291cmNlIGFuZCB0YXJnZXQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlZGdlIFRoZSBlZGdlIHRvIGFkZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkRWRnZScsIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBlZGdlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxuICAgIGlmIChPYmplY3QoZWRnZSkgIT09IGVkZ2UgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdhZGRFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICh0eXBlb2YgZWRnZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UuaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2Uuc291cmNlXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBzb3VyY2UgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2UudGFyZ2V0XSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSB0YXJnZXQgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICh0aGlzLmVkZ2VzSW5kZXhbZWRnZS5pZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgZWRnZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIHZhbGlkRWRnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIGVkZ2UpXG4gICAgICAgIGlmIChrICE9PSAnaWQnICYmIGsgIT09ICdzb3VyY2UnICYmIGsgIT09ICd0YXJnZXQnKVxuICAgICAgICAgIHZhbGlkRWRnZVtrXSA9IGVkZ2Vba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZEVkZ2UgPSBlZGdlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ2lkJywge1xuICAgICAgICB2YWx1ZTogZWRnZS5pZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdzb3VyY2UnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICd0YXJnZXQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnRhcmdldCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkRWRnZS5pZCA9IGVkZ2UuaWQ7XG4gICAgICB2YWxpZEVkZ2Uuc291cmNlID0gZWRnZS5zb3VyY2U7XG4gICAgICB2YWxpZEVkZ2UudGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBlZGdlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5lZGdlc0FycmF5LnB1c2godmFsaWRFZGdlKTtcbiAgICB0aGlzLmVkZ2VzSW5kZXhbdmFsaWRFZGdlLmlkXSA9IHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdKVxuICAgICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdKVxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICh2YWxpZEVkZ2UudGFyZ2V0ICE9PSB2YWxpZEVkZ2Uuc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgICB2YWxpZEVkZ2U7XG4gICAgfVxuXG4gICAgLy8gS2VlcCBjb3VudHMgdXAgdG8gZGF0ZTpcbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnRhcmdldF0rKztcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS5zb3VyY2VdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYSBub2RlIGZyb20gdGhlIGdyYXBoLiBJdCBhbHNvIHJlbW92ZXMgZWFjaCBlZGdlIHRoYXQgaXNcbiAgICogYm91bmQgdG8gaXQsIHRocm91Z2ggdGhlIGRyb3BFZGdlIG1ldGhvZC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBub2RlXG4gICAqIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBub2RlIGlkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcE5vZGUnLCBmdW5jdGlvbihpZCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnZHJvcE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCF0aGlzLm5vZGVzSW5kZXhbaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICB2YXIgaSwgaywgbDtcblxuICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleFtpZF07XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMubm9kZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5ub2Rlc0FycmF5W2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLm5vZGVzQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2VzOlxuICAgIGZvciAoaSA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uc291cmNlID09PSBpZCB8fCB0aGlzLmVkZ2VzQXJyYXlbaV0udGFyZ2V0ID09PSBpZClcbiAgICAgICAgdGhpcy5kcm9wRWRnZSh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQpO1xuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF07XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF07XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdO1xuXG4gICAgZm9yIChrIGluIHRoaXMubm9kZXNJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhbiBlZGdlIGZyb20gdGhlIGdyYXBoLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGVkZ2VcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIGVkZ2UgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wRWRnZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMuZWRnZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBsLCBlZGdlO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kZXhlczpcbiAgICBlZGdlID0gdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuZWRnZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcblxuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9PSBlZGdlLnNvdXJjZSkge1xuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXVtlZGdlLmlkXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdKS5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV07XG4gICAgfVxuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbZWRnZS5zb3VyY2VdLS07XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS4gSXQgYmFzaWNhbGx5IGVtcHRpZXMgZWFjaCBpbmRleFxuICAgKiBhbmQgbWV0aG9kcyBhdHRhY2hlZCB0byB0aGUgZ3JhcGguXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2tpbGwnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWxldGUgYXJyYXlzOlxuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzQXJyYXk7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNBcnJheTtcblxuICAgIC8vIERlbGV0ZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBub2RlcyBhbmQgZWRnZXMgYXJyYXlzLCBhcyB3ZWxsIGFzIHRoZSBkaWZmZXJlbnRcbiAgICogaW5kZXhlcy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBEdWUgdG8gR0MgaXNzdWVzLCBJIHByZWZlciBub3QgdG8gY3JlYXRlIG5ldyBvYmplY3QuIFRoZXNlIG9iamVjdHMgYXJlXG4gICAgLy8gb25seSBhdmFpbGFibGUgZnJvbSB0aGUgbWV0aG9kcyBhbmQgYXR0YWNoZWQgZnVuY3Rpb25zLCBidXQgc3RpbGwsIGl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIHByZXZlbnQgZ2hvc3QgcmVmZXJlbmNlcyB0byB1bnJlbGV2YW50IGRhdGEuLi5cbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMubm9kZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmVkZ2VzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuaW5OZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm91dE5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuYWxsTmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0NvdW50KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNDb3VudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIGFuIG9iamVjdCBhbmQgYWRkcyB0aGUgbm9kZXMgYW5kIGVkZ2VzLCB0aHJvdWdoIHRoZVxuICAgKiBwcm9wZXIgbWV0aG9kcyBcImFkZE5vZGVcIiBhbmQgXCJhZGRFZGdlXCIuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5yZWFkKHtcbiAgICogID4gICBub2RlczogW1xuICAgKiAgPiAgICAgeyBpZDogJ24wJyB9LFxuICAgKiAgPiAgICAgeyBpZDogJ24xJyB9XG4gICAqICA+ICAgXSxcbiAgICogID4gICBlZGdlczogW1xuICAgKiAgPiAgICAge1xuICAgKiAgPiAgICAgICBpZDogJ2UwJyxcbiAgICogID4gICAgICAgc291cmNlOiAnbjAnLFxuICAgKiAgPiAgICAgICB0YXJnZXQ6ICduMSdcbiAgICogID4gICAgIH1cbiAgICogID4gICBdXG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiBjb25zb2xlLmxvZyhcbiAgICogID4gICBteUdyYXBoLm5vZGVzKCkubGVuZ3RoLFxuICAgKiAgPiAgIG15R3JhcGguZWRnZXMoKS5sZW5ndGhcbiAgICogID4gKTsgLy8gb3V0cHV0cyAyIDFcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBnIFRoZSBncmFwaCBvYmplY3QuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ3JlYWQnLCBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGEsXG4gICAgICAgIGw7XG5cbiAgICBhID0gZy5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZE5vZGUoYVtpXSk7XG5cbiAgICBhID0gZy5lZGdlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZEVkZ2UoYVtpXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBub2RlcywgY2FsbCBcIm5vZGVzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgbm9kZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgbm9kZS4gVGhlIGdldCBtdWx0aXBsZSBub2RlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIG5vZGVzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBub2RlIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdub2RlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMubm9kZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgdGhlIGRlZ3JlZSBvZiBvbmUgb3Igc2V2ZXJhbCBub2RlcywgZGVwZW5kaW5nIG9uIGhvd1xuICAgKiBpdCBpcyBjYWxsZWQuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGluY29taW5nIG9yIG91dGNvbWluZyBkZWdyZWVzXG4gICAqIGluc3RlYWQgYnkgc3BlY2lmeWluZyAnaW4nIG9yICdvdXQnIGFzIGEgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHYgICAgIE9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgIHdoaWNoIFdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZC4gVmFsdWVzIGFyZSAnaW4nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXQnLCBhbmQgYnkgZGVmYXVsdCB0aGUgbm9ybWFsIGRlZ3JlZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGFycmF5fSAgICAgICBUaGUgcmVsYXRlZCBkZWdyZWUgb3IgYXJyYXkgb2YgZGVncmVlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZGVncmVlJywgZnVuY3Rpb24odiwgd2hpY2gpIHtcbiAgICAvLyBDaGVjayB3aGljaCBkZWdyZWUgaXMgcmVxdWlyZWQ6XG4gICAgd2hpY2ggPSB7XG4gICAgICAnaW4nOiB0aGlzLmluTmVpZ2hib3JzQ291bnQsXG4gICAgICAnb3V0JzogdGhpcy5vdXROZWlnaGJvcnNDb3VudFxuICAgIH1bd2hpY2ggfHwgJyddIHx8IHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICAgIHJldHVybiB3aGljaFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh3aGljaFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBvbmUgb3Igc2V2ZXJhbCBlZGdlcywgZGVwZW5kaW5nIG9uIGhvdyBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2YgZWRnZXMsIGNhbGwgXCJlZGdlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXG4gICAqIHNwZWNpZmljIGVkZ2UsIGNhbGwgaXQgd2l0aCB0aGUgaWQgb2YgdGhlIGVkZ2UuIFRoZSBnZXQgbXVsdGlwbGUgZWRnZSxcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBlZGdlcywgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgZWRnZSBvciBhcnJheSBvZiBlZGdlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZWRnZXMnLCBmdW5jdGlvbih2KSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm4gaXQ6XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNBcnJheS5zbGljZSgwKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSW5kZXhbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgZWRnZTpcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh0aGlzLmVkZ2VzSW5kZXhbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNpZ21hLmNsYXNzZXMgPSBzaWdtYS5jbGFzc2VzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2lnbWEuY2xhc3Nlcy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoO1xuICAgIGV4cG9ydHMuZ3JhcGggPSBncmFwaDtcbiAgfSBlbHNlXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2xhc3NlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FtZXJhIGNvbnN0cnVjdG9yLiBJdCBqdXN0IGluaXRpYWxpemVzIGl0cyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGlkICAgICAgIFRoZSBpZC5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gIGdyYXBoICAgIFRoZSBncmFwaC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgb3B0aW9ucyAgRXZlbnR1YWxseSBzb21lIG92ZXJyaWRpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEgPSBmdW5jdGlvbihpZCwgZ3JhcGgsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XG4gICAgICB2YWx1ZTogZ3JhcGhcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkUHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdyZWFkX2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdjYW0nICsgaWQgKyAnOidcbiAgICB9KTtcblxuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnJhdGlvID0gMTtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSA/XG4gICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdChvcHRpb25zKSA6XG4gICAgICBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvb3JkaW5hdGVzIFRoZSBuZXcgY29vcmRpbmF0ZXMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MoJ2VuYWJsZUNhbWVyYScpKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYyA9IGNvb3JkaW5hdGVzIHx8IHt9LFxuICAgICAgICBrZXlzID0gWyd4JywgJ3knLCAncmF0aW8nLCAnYW5nbGUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmIChjW2tleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjW2tleXNbaV1dID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY1trZXlzW2ldXSkpXG4gICAgICAgICAgdGhpc1trZXlzW2ldXSA9IGNba2V5c1tpXV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnVmFsdWUgZm9yIFwiJyArIGtleXNbaV0gKyAnXCIgaXMgbm90IGEgbnVtYmVyLic7XG4gICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGdyYXBoIGFuZCBjb21wdXRlcyBmb3IgZWFjaCBub2RlIGFuZCBlZGdlcyBpdHNcbiAgICogY29vcmRpbmF0ZXMgcmVsYXRpdmVseSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW1lcmEuIEJhc2ljYWxseSwgaXQgd2lsbFxuICAgKiBjb21wdXRlIHRoZSBjb29yZGluYXRlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgZ3JhcGhpYyByZW5kZXJlcnMuXG4gICAqXG4gICAqIFNpbmNlIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgZGlmZmVyZW50IGNhbWVyYXMgYW5kIGRpZmZlcmVudFxuICAgKiByZW5kZXJlcnMsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwcmVmaXggdG8gcHV0IGJlZm9yZSB0aGUgbmV3XG4gICAqIGNvb3JkaW5hdGVzICh0byBnZXQgc29tZXRoaW5nIGxpa2UgXCJub2RlLmNhbWVyYTFfeFwiKVxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSByZWFkICAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHdyaXRlICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy4gVGhvc2UgY2FuIGJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIGVkZ2VzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSB3aWR0aC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuYXBwbHlWaWV3ID0gZnVuY3Rpb24ocmVhZCwgd3JpdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB3cml0ZSA9IHdyaXRlICE9PSB1bmRlZmluZWQgPyB3cml0ZSA6IHRoaXMucHJlZml4O1xuICAgIHJlYWQgPSByZWFkICE9PSB1bmRlZmluZWQgPyByZWFkIDogdGhpcy5yZWFkUHJlZml4O1xuXG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5ub2RlcyB8fCB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGVkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCB0aGlzLmdyYXBoLmVkZ2VzKCk7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVsQ29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxuICAgICAgICByZWxTaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIG5vZGVSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSksXG4gICAgICAgIGVkZ2VSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSksXG4gICAgICAgIHhPZmZzZXQgPSAob3B0aW9ucy53aWR0aCB8fCAwKSAvIDIgLSB0aGlzLnggKiByZWxDb3MgLSB0aGlzLnkgKiByZWxTaW4sXG4gICAgICAgIHlPZmZzZXQgPSAob3B0aW9ucy5oZWlnaHQgfHwgMCkgLyAyIC0gdGhpcy55ICogcmVsQ29zICsgdGhpcy54ICogcmVsU2luO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZVt3cml0ZSArICd4J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbENvcyArXG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeE9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAneSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxDb3MgLVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbFNpbiArXG4gICAgICAgIHlPZmZzZXQ7XG4gICAgICBub2RlW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgbm9kZVJhdGlvO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVkZ2VzW2ldW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChlZGdlc1tpXVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXG4gICAgICAgIGVkZ2VSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogY2FtZXJhIHRvIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5ncmFwaFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XG4gICAgdmFyIFggPSAwLFxuICAgICAgICBZID0gMCxcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcbiAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoeCAqIGNvcyArIHkgKiBzaW4pIC8gdGhpcy5yYXRpbyArIFgsXG4gICAgICB5OiAoeSAqIGNvcyAtIHggKiBzaW4pIC8gdGhpcy5yYXRpbyArIFlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBncmFwaCB0byB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuY2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICgoeCAtIFgpICogY29zIC0gKHkgLSBZKSAqIHNpbikgKiB0aGlzLnJhdGlvLFxuICAgICAgeTogKCh5IC0gWSkgKiBjb3MgKyAoeCAtIFgpICogc2luKSAqIHRoaXMucmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS4gVGhpcyBpc1xuICAgKiBlc3BlY2lhbGx5IHVzZWZ1bCB0byBhcHBseSB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0bHkgaW4gc2hhZGVycywgaW4gY2FzZSBvZlxuICAgKiBXZWJHTCByZW5kZXJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlKDEgLyB0aGlzLnJhdGlvKSxcbiAgICAgICAgcm90YXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbih0aGlzLmFuZ2xlKSxcbiAgICAgICAgdHJhbnNsYXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbigtdGhpcy54LCAtdGhpcy55KSxcbiAgICAgICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgdHJhbnNsYXRpb24sXG4gICAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgIHNjYWxlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfTtcblxuICAvKipcbiAgICogVGFraW5nIGEgd2lkdGggYW5kIGEgaGVpZ2h0IGFzIHBhcmFtZXRlcnMsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXG4gICAqIGNvb3JkaW5hdGVzIG9mIHRoZSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoZSBjYW1lcmEgb24gc2NyZWVuLCBpbiB0aGVcbiAgICogZ3JhcGgncyByZWZlcmVudGllbC5cbiAgICpcbiAgICogVG8ga2VlcCBkaXNwbGF5aW5nIGxhYmVscyBvZiBub2RlcyBnb2luZyBvdXQgb2YgdGhlIHNjcmVlbiwgdGhlIG1ldGhvZFxuICAgKiBrZWVwcyBhIG1hcmdpbiBhcm91bmQgdGhlIHNjcmVlbiBpbiB0aGUgcmV0dXJuZWQgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgcmVjdGFuZ2xlIGFzIHgxLCB5MSwgeDIgYW5kIHkyLCByZXByZXNlbnRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHdvIG9wcG9zaXRlIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRSZWN0YW5nbGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoVmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGgsIDAsIHRydWUpLFxuICAgICAgICBoZWlnaHRWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQsIHRydWUpLFxuICAgICAgICBjZW50ZXJWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHRydWUpLFxuICAgICAgICBtYXJnaW5YID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDQsIDAsIHRydWUpLngsXG4gICAgICAgIG1hcmdpblkgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCAvIDQsIHRydWUpLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXMueCAtIGNlbnRlclZlY3QueCAtIG1hcmdpblgsXG4gICAgICB5MTogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSxcbiAgICAgIHgyOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggKyBtYXJnaW5YICsgd2lkdGhWZWN0LngsXG4gICAgICB5MjogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSArIHdpZHRoVmVjdC55LFxuICAgICAgaGVpZ2h0OiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueCwgMikgK1xuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LnkgKyAyICogbWFyZ2luWSwgMilcbiAgICAgIClcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGVcbiAgICogPT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqL1xuICAgIGlzQXhpc0FsaWduZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIGNhc2VzIHdoZW4gdGhlIHJlY3RhbmdsZSBoYXMgYmVlbiByb3RhdGVkIChsZWZ0LCByaWdodCBvciBib3R0b20gdXApIGFuZFxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xuXG4gICAgICAvLyBCYXNpY1xuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXG4gICAgICAgIHJldHVybiByO1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIGxlZnRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxLCB5MTogci55MixcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEJvdHRvbSdzIHVwXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgd2lkdGggPSAoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhyLngyIC0gci54MSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHIueTIgLSByLnkxLCAyKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByLngxIC0gKHIueTIgLSByLnkxKSAqIHIuaGVpZ2h0IC8gd2lkdGgsXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgcmlnaHQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHNcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbGMueCAtIHIueDEgKyByLngyLFxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0aGUgY29ybmVycyBvZiBhIHJlY3RhbmdsZSBmcm9tIGl0cyB0b3AgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiB0aGUgZm91ciBjb3JuZXJzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGxsYyA9IHRoaXMubG93ZXJMZWZ0Q29vcihyKSxcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxuICAgICAgICB7eDogbGxjLngsIHk6IGxsYy55fSxcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3F1YXJlIGRlZmluZWQgYnkgaXRzIGJvdW5kYXJpZXMgaW50byBmb3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm91ciBuZXcgc3F1YXJlcywgdGhlbXNlbHZlc1xuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqL1xuICAgIHNwbGl0U3F1YXJlOiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm91ciBheGlzIGJldHdlZW4gY29ybmVycyBvZiByZWN0YW5nbGUgQSBhbmQgY29ybmVycyBvZlxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEEncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxuICAgICAqL1xuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVswXS54LCB5OiBjMVsxXS55IC0gYzFbMF0ueX0sXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsxXS54LCB5OiBjMlswXS55IC0gYzJbMV0ueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvamVjdGlvbiBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XG4gICAgICB2YXIgbCA9IChcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xuICAgICAgICAoTWF0aC5wb3coYS54LCAyKSArIE1hdGgucG93KGEueSwgMikpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsICogYS54LFxuICAgICAgICB5OiBsICogYS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXG4gICAgICovXG4gICAgYXhpc0NvbGxpc2lvbjogZnVuY3Rpb24oYSwgYzEsIGMyKSB7XG4gICAgICB2YXIgc2MxID0gW10sXG4gICAgICAgICAgc2MyID0gW107XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxuICAgICAgICAgICAgcDIgPSB0aGlzLnByb2plY3Rpb24oYzJbY2ldLCBhKTtcblxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XG4gICAgICAgIHNjMi5wdXNoKHAyLnggKiBhLnggKyBwMi55ICogYS55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heGMxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1pbmMyID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MyKTtcblxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBlYWNoIG9uZSBvZiB0aGVpciBmb3VyIGF4aXMuIElmXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcbiAgICAgICAgICBjb2wgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgY29sID0gY29sICYmIHRoaXMuYXhpc0NvbGxpc2lvbihheGlzW2ldLCBjMSwgYzIpO1xuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBRdWFkIEZ1bmN0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgKiBGb3IgZWFjaCBvZiB0aG9zZSBmdW5jdGlvbnMsIHdlIGNvbnNpZGVyIHRoYXQgaW4gYSBzcGxpdHRlZCBxdWFkLCB0aGVcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqIDA6IHRvcCBsZWZ0XG4gICAqIDE6IHRvcCByaWdodFxuICAgKiAyOiBib3R0b20gbGVmdFxuICAgKiAzOiBib3R0b20gcmlnaHRcbiAgICpcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcbiAgICogbm9kZXMgaXQgY29sbGlkZXMgd2l0aCB3aGVyZSBvdGhlciB3b3VsZCBsZXQgaXQgbGllIG9uIGEgaGlnaGVyIG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50ICAgICAgQSBwb2ludCBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICB5bXAgPSBxdWFkQm91bmRzLnkgKyBxdWFkQm91bmRzLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcblxuICAgIGlmICh0b3ApIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICByZWN0YW5nbGUgICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4ZXMocmVjdGFuZ2xlLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLngxIDw9IHF1YWRDb3JuZXJzW2ldWzFdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhIG5vbi1heGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcbiAgICogbm90IGdlbmVyYXRlIGFsbCBmb3VyIG5vZGVzIG5vdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgdW51c2VkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHF1YWQgIFRoZSBxdWFkIG9iamVjdCB0byBzdWJkaXZpZGUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRTdWJkaXZpZGUoaW5kZXgsIHF1YWQpIHtcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICBzdWJoID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcbiAgICAgIG5leHQsXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxuICAgICAgcXVhZC5tYXhMZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgc2l6ZWRQb2ludCBBIHNpemVkIHBvaW50IGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG5cbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcXVhZEluZGV4ZXMoc2l6ZWRQb2ludCwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgLy8gSXRlcmF0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvblxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvLyBQdXNoaW5nIHRoZSBlbGVtZW50IGluIGEgbGVhZiBub2RlXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBoZWxkIGJ5IHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCBUaGUgc2VhcmNoZWQgcG9pbnQgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XG5cbiAgICAgIC8vIElmIG5vZGUgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFuIGVtcHR5IGxpc3RcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHF1YWQuZWxlbWVudHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxuICAgKiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGF4aXMtYWxpZ25lZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIGZvdXIgY29ybmVycyAoeCwgeSkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW5kZXhlcy5cbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xuICAgIGVscyA9IGVscyB8fCB7fTtcblxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ZXMgPSBjb2xsaXNpb25GdW5jKHJlY3REYXRhLCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICAgICAgcmVjdERhdGEsXG4gICAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dLFxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgICAgIGVsc1xuICAgICAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICBpZiAoZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcblxuICAgIHJldHVybiBlbHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIGJvdW5kcyAgICAgICBUaGUgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhFbGVtZW50cyAgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiBhIGxlYWYgbm9kZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcbiAgICAgIG1heEVsZW1lbnRzOiBtYXhFbGVtZW50cyB8fCAyMCxcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA0LFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgbm9kZXM6IFtdXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWQgQ29uc3RydWN0b3JcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICovXG4gIHZhciBxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBub2RlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBub2RlcyAgIEFuIGFycmF5IG9mIG5vZGVzIHRvIGluZGV4LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgQW4gb2JqZWN0IG9mIHBhcmFtZXRlcnMgd2l0aCBhdCBsZWFzdCB0aGUgcXVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogLS0tLS0tLS0tLVxuICAgKiBib3VuZHM6ICAgICAge29iamVjdH0gICBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgaXRzIG9yaWdpbiAoeCwgeSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIG5vZGUgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXG4gICAqIG1heEVsZW1lbnRzOiB7aW50ZWdlcj99IHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgbGVhZiBub2RlLlxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24obm9kZXMsIHBhcmFtcykge1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5xdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJztcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBub2RlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgLy8gSW5zZXJ0aW5nIG5vZGVcbiAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICBub2Rlc1tpXSxcbiAgICAgICAgX2dlb20ucG9pbnRUb1NxdWFyZSh7XG4gICAgICAgICAgeDogbm9kZXNbaV1bcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5OiBub2Rlc1tpXVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHNpemU6IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMuX3RyZWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxuICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICByZWN0RGF0YTtcblxuICAgIC8vIFJldHVybmluZyBjYWNoZT9cbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xuXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkSW5kZXhlcztcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZpbmcgbm9kZXNcbiAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgdGhpcy5fdHJlZSxcbiAgICAgICAgY29sbGlzaW9uRnVuY1xuICAgICAgKSA6XG4gICAgICBbXTtcblxuICAgIC8vIE9iamVjdCB0byBhcnJheVxuICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBub2RlcylcbiAgICAgIG5vZGVzQXJyYXkucHVzaChub2Rlc1tpXSk7XG5cbiAgICAvLyBDYWNoaW5nXG4gICAgdGhpcy5fY2FjaGUucXVlcnkgPSBzZXJpYWxpemVkO1xuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IG5vZGVzQXJyYXk7XG5cbiAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHF1YWQ7XG4gICAgZXhwb3J0cy5xdWFkID0gcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5xdWFkID0gcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogU2lnbWEgUXVhZHRyZWUgTW9kdWxlIGZvciBlZGdlc1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogU8OpYmFzdGllbiBIZXltYW5uLFxuICAgKiAgIGZyb20gdGhlIHF1YWQgb2YgR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIHdpdGggeDEsIHkxLCB4MiwgeTIgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgbGluZVRvU3F1YXJlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS55MSA8IGUueTIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHRvcFxuICAgICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXG4gICAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gcmlnaHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gdG9wXG4gICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHJpZ2h0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXG4gICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIG9mIHR5cGUgJ2N1cnZlJyB3aXRoIHgxLCB5MSwgeDIsIHkyLFxuICAgICAqIGNvbnRyb2wgcG9pbnQgYW5kIHNpemUgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlICBBIGdyYXBoIGVkZ2Ugd2l0aCBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNwIEEgY29udHJvbCBwb2ludCAoeCx5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHF1YWRyYXRpY0N1cnZlVG9TcXVhcmU6IGZ1bmN0aW9uKGUsIGNwKSB7XG4gICAgICB2YXIgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgIDAuNSxcbiAgICAgICAgZS54MSxcbiAgICAgICAgZS55MSxcbiAgICAgICAgZS54MixcbiAgICAgICAgZS55MixcbiAgICAgICAgY3AueCxcbiAgICAgICAgY3AueVxuICAgICAgKTtcblxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSB0d28gcG9pbnRzIGFuZCB0aGUgcG9pbnQgYXQgdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAgIC8vIGN1cnZlOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoZS54MSwgZS54MiwgcHQueCksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGUueTEsIGUueTIsIHB0LnkpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChlLnkxLCBlLnkyLCBwdC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBlLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gZS5zaXplLFxuICAgICAgICB4MjogbWF4WCArIGUuc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBlLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggc2VsZiBsb29wIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbiBBIGdyYXBoIG5vZGUgd2l0aCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBzZWxmTG9vcFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBGaXR0aW5nIHRvIHRoZSBjdXJ2ZSBpcyB0b28gY29zdGx5LCB3ZSBjb21wdXRlIGEgbGFyZ2VyIGJvdW5kaW5nIGJveFxuICAgICAgLy8gdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKG4ueCwgbi55LCBuLnNpemUpO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHBvaW50IGFuZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihuLngsIGNwLngxLCBjcC54MiksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obi55LCBjcC55MSwgY3AueTIpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChuLnksIGNwLnkxLCBjcC55Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBtaW5YIC0gbi5zaXplLFxuICAgICAgICB5MTogbWluWSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG1heFggKyBuLnNpemUsXG4gICAgICAgIHkyOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDQwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDgsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBlZGdlcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBlZGdlcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgICAgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gICAgIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZy5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlICAgIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2QuXG4gICAqIHByb3BlcnR5IHtib29sZWFufSBfZW5hYmxlZCBDYW4gaW5kZXggYW5kIHJldHJlaXZlIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIGVkZ2VxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBlZGdlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBncmFwaCAgIEEgZ3JhcGggaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3IgZWRnZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZ3JhcGgsIHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xuXG4gICAgLy8gUHJlZml4XG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJycsXG4gICAgICAgIGNwLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbixcbiAgICAgICAgZTtcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAvLyBJbnNlcnRpbmcgZ3JhcGggZWRnZXMgaW50byB0aGUgdHJlZVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS5zb3VyY2UpO1xuICAgICAgdGFyZ2V0ID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0udGFyZ2V0KTtcbiAgICAgIGUgPSB7XG4gICAgICAgIHgxOiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTE6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB4MjogdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHkyOiB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZTogZWRnZXNbaV1bcHJlZml4ICsgJ3NpemUnXSB8fCAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnNlcnRpbmcgZWRnZVxuICAgICAgaWYgKGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZScgfHwgZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgeDogc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICB5OiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIHNpemU6IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgICBfZ2VvbS5zZWxmTG9vcFRvU3F1YXJlKG4pLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoZS54MSwgZS55MSwgZS54MiwgZS55Mik7XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnF1YWRyYXRpY0N1cnZlVG9TcXVhcmUoZSwgY3ApLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICBfZ2VvbS5saW5lVG9TcXVhcmUoZSksXG4gICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBlZGdlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxuICAgICAgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIGVkZ2VzIHdpdGhpbiBhIHJlY3Rhbmd1bGFyIGFyZWEuIFRoZSBtZXRob2RzIGtlZXAgdGhlXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBlZGdlc1xuICAgIHZhciBlZGdlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIGVkZ2VzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGVkZ2VzKVxuICAgICAgZWRnZXNBcnJheS5wdXNoKGVkZ2VzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gZWRnZXNBcnJheTtcblxuICAgIHJldHVybiBlZGdlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlZGdlcXVhZDtcbiAgICBleHBvcnRzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG4gIH0gZWxzZVxuICAgIHRoaXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLm1vdXNlID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBNT1VTRSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgbW91c2UgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydE1vdXNlWCxcbiAgICAgICAgX3N0YXJ0TW91c2VZLFxuXG4gICAgICAgIF9pc01vdXNlRG93bixcbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfaGFzRHJhZ2dlZCxcbiAgICAgICAgX2Rvd25TdGFydFRpbWUsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJywgX2RvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIsIGZhbHNlKTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gTU9VU0UgRVZFTlRTOlxuICAgIC8vICoqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ21vdmUnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5XG4gICAgICogZHJhZyB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX21vdmVIYW5kbGVyKGUpIHtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcG9zO1xuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudDpcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xuXG4gICAgICAgIGlmIChfaXNNb3VzZURvd24pIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIF9oYXNEcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcblxuICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gX3N0YXJ0TW91c2VYLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIF9zdGFydE1vdXNlWSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IF9zdGFydENhbWVyYVggLSBwb3MueDtcbiAgICAgICAgICB5ID0gX3N0YXJ0Q2FtZXJhWSAtIHBvcy55O1xuXG4gICAgICAgICAgaWYgKHggIT09IF9jYW1lcmEueCB8fCB5ICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd1cCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RvcCBkcmFnZ2luZyB0aGVcbiAgICAgKiBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdXBIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9pc01vdXNlRG93bikge1xuICAgICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgeCA9IHNpZ21hLnV0aWxzLmdldFgoZSksXG4gICAgICAgICAgICB5ID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcblxuICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXG4gICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBfc3RhcnRNb3VzZVggIT09IHggfHxcbiAgICAgICAgICBfc3RhcnRNb3VzZVkgIT09IHlcbiAgICAgICAgKVxuICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICB4OiBfY2FtZXJhLngsXG4gICAgICAgICAgICB5OiBfY2FtZXJhLnlcbiAgICAgICAgICB9KTtcblxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXVwJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIF9pc01vdmluZyBmbGFnOlxuICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdkb3duJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdGFydCBvYnNlcnZpbmdcbiAgICAgKiB0aGUgbW91c2UgcG9zaXRpb24gZm9yIGRyYWdnaW5nIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG93bkhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfc3RhcnRNb3VzZVggPSBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgICAgICBfc3RhcnRNb3VzZVkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIF9oYXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIF9kb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBNaWRkbGUgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAvLyBSaWdodCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRjbGljaycsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdvdXQnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGp1c3QgcmVkaXNwYXRjaFxuICAgICAqIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfb3V0SGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSlcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2VvdXQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdjbGljaycgbW91c2UgZXZlbnQuIEl0IHdpbGwgcmVkaXNwYXRjaCB0aGVcbiAgICAgKiBjbGljayBldmVudCwgYnV0IHdpdGggbm9ybWFsaXplZCBYIGFuZCBZIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSk7XG4gICAgICAgIGV2ZW50LmlzRHJhZ2dpbmcgPVxuICAgICAgICAgICgoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF9kb3duU3RhcnRUaW1lKSA+IDEwMCkgJiYgX2hhc0RyYWdnZWQ7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWxzZVxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgY2xpY2sgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZUNsaWNrSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd3aGVlbCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgYmFzaWNhbGx5IHpvb21cbiAgICAgKiBpbiBvciBub3QgaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3doZWVsSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB3aGVlbERlbHRhID0gc2lnbWEudXRpbHMuZ2V0RGVsdGEoZSk7XG5cbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9zZXR0aW5ncygnbW91c2VXaGVlbEVuYWJsZWQnKSAmJiB3aGVlbERlbHRhICE9PSAwKSB7XG4gICAgICAgIHJhdGlvID0gd2hlZWxEZWx0YSA+IDAgP1xuICAgICAgICAgIDEgLyBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpIDpcbiAgICAgICAgICBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlWm9vbUR1cmF0aW9uJylcbiAgICAgICAgfTtcblxuICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLnRvdWNoID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxuICAgICAgICBfbGFzdENhbWVyYVksXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVE9VQ0ggTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVG91Y2hlcyB0aGF0IGFyZSBkb3duOlxuICAgICAgICBfZG93blRvdWNoZXMgPSBbXSxcblxuICAgICAgICBfc3RhcnRUb3VjaFgwLFxuICAgICAgICBfc3RhcnRUb3VjaFkwLFxuICAgICAgICBfc3RhcnRUb3VjaFgxLFxuICAgICAgICBfc3RhcnRUb3VjaFkxLFxuICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlLFxuICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlLFxuXG4gICAgICAgIF90b3VjaE1vZGUsXG5cbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfZG91YmxlVGFwLFxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0JywgX2RvdWJsZVRhcEhhbmRsZXIpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZSkge1xuICAgICAgdmFyIG9mZnNldCA9IHNpZ21hLnV0aWxzLmdldE9mZnNldChfdGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxuICAgICAqL1xuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUpO1xuICAgIH07XG5cbiAgICAvLyBUT1VDSCBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50LiBJdCB3aWxsIHNldCB0aGUgdG91Y2hcbiAgICAgKiBtb2RlIChcIl90b3VjaE1vZGVcIikgYW5kIHN0YXJ0IG9ic2VydmluZyB0aGUgdXNlciB0b3VjaCBtb3Zlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlU3RhcnQoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczE7XG5cbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuXG4gICAgICAgIHN3aXRjaCAoX2Rvd25Ub3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDE7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHBvczAueDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSBwb3MwLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDI7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuICAgICAgICAgICAgeDEgPSBwb3MxLng7XG4gICAgICAgICAgICB5MSA9IHBvczEueTtcblxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0geDA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0geTA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgxID0geDE7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkxID0geTE7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICtcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKSAqXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIGFuZCAndG91Y2hsZWF2ZSdcbiAgICAgKiBldmVudC4gSXQgd2lsbCB1cGRhdGUgdGhlIHRvdWNoIG1vZGUgaWYgdGhlcmUgYXJlIHN0aWxsIGF0IGxlYXN0IG9uZVxuICAgICAqIGZpbmdlciwgYW5kIHN0b3AgZHJhZ2dpbmcgZWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICB2YXIgaW5lcnRpYVJhdGlvID0gX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFSYXRpbycpO1xuXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgX2hhbmRsZVN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RvcERyYWcnKTtcblxuICAgICAgICAgICAgaWYgKF9pc01vdmluZykge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaG1vdmUnIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5IGRyYWdcbiAgICAgKiB0aGUgZ3JhcGgsIGFuZCBldmVudHVhbGx5IHpvb21zIGFuZCB0dXJuIGl0IGlmIHRoZSB1c2VyIGlzIHVzaW5nIHR3b1xuICAgICAqIGZpbmdlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZU1vdmUoZSkge1xuICAgICAgaWYgKCFfZG91YmxlVGFwICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY29zLFxuICAgICAgICAgICAgc2luLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczEsXG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBkQW5nbGUsXG4gICAgICAgICAgICBkUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZVgsXG4gICAgICAgICAgICBuZXdTdGFnZVksXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvLFxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIF9pc01vdmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcblxuICAgICAgICAgICAgZGlmZiA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIHgwIC0gX3N0YXJ0VG91Y2hYMCxcbiAgICAgICAgICAgICAgeTAgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuZXdTdGFnZVggPSBfc3RhcnRDYW1lcmFYIC0gZGlmZi54O1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0gX3N0YXJ0Q2FtZXJhWSAtIGRpZmYueTtcblxuICAgICAgICAgICAgaWYgKG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8IG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55KSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvczAueCwgcG9zMC55KSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBzdGFydCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgwICsgX3N0YXJ0VG91Y2hYMSkgLyAyIC1cbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTAgKyBfc3RhcnRUb3VjaFkxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZW5kID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKHgwICsgeDEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoeTAgKyB5MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGRBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSBfc3RhcnRUb3VjaEFuZ2xlO1xuICAgICAgICAgICAgZFJhdGlvID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoeTEgLSB5MCkgKiAoeTEgLSB5MCkgKyAoeDEgLSB4MCkgKiAoeDEgLSB4MClcbiAgICAgICAgICAgICkgLyBfc3RhcnRUb3VjaERpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbjpcbiAgICAgICAgICAgIHgwID0gc3RhcnQueDtcbiAgICAgICAgICAgIHkwID0gc3RhcnQueTtcblxuICAgICAgICAgICAgLy8gSG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gPSBfc3RhcnRDYW1lcmFSYXRpbyAvIGRSYXRpbztcbiAgICAgICAgICAgIHgwID0geDAgKiBkUmF0aW87XG4gICAgICAgICAgICB5MCA9IHkwICogZFJhdGlvO1xuXG4gICAgICAgICAgICAvLyBSb3RhdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGUgPSBfc3RhcnRDYW1lcmFBbmdsZSAtIGRBbmdsZTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1kQW5nbGUpO1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oLWRBbmdsZSk7XG4gICAgICAgICAgICB4MSA9IHgwICogY29zICsgeTAgKiBzaW47XG4gICAgICAgICAgICB5MSA9IHkwICogY29zIC0geDAgKiBzaW47XG4gICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgeTAgPSB5MTtcblxuICAgICAgICAgICAgLy8gRmluYWxpemU6XG4gICAgICAgICAgICBuZXdTdGFnZVggPSB4MCAtIGVuZC54ICsgX3N0YXJ0Q2FtZXJhWDtcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IHkwIC0gZW5kLnkgKyBfc3RhcnRDYW1lcmFZO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gIT09IF9jYW1lcmEucmF0aW8gfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSAhPT0gX2NhbWVyYS5hbmdsZSB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVkgIT09IF9jYW1lcmEueVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBuZXdTdGFnZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBuZXdTdGFnZVJhdGlvXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSB0YXAgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZVRhcEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb247XG5cbiAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIF9kb3VibGVUYXAgPSB0cnVlO1xuXG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcblxuICAgICAgICBwb3MgPSBwb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zLngsIHBvcy55KSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgcG9zLnggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgIHBvcy55IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJyksXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLmNhbnZhczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmNvbnRleHRzID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBOb2RlIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgdGhpcy5jb25yYWRJZCArICc6JztcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcbiAgICBpZiAoXG4gICAgICAhdGhpcy5zZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKVxuICAgICkge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcbiAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJyk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgY2FudmFzZXMuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgaWQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgam9iLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIHJlbmRlcmVycyxcbiAgICAgICAgcmVuZGVyZXJUeXBlLFxuICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgIHRlbXBHQ08sXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlTGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXhcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlbjpcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XG5cbiAgICAvLyBEcmF3IGVkZ2VzOlxuICAgIC8vIC0gSWYgc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykgaXMgdHJ1ZSwgdGhlIGVkZ2VzIGFyZSBkaXNwbGF5ZWQgcGVyXG4gICAgLy8gICBiYXRjaGVzLiBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZS5cbiAgICBpZiAoZHJhd0VkZ2VzKSB7XG4gICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgdG8gZHJhdy4gVG8gZG8gdGhpcywgd2UganVzdCBrZWVwXG4gICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgIC8vIGVkZ2VzLlxuICAgICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAgICghby5oaWRkZW4gJiYgIW5vZGVzKG8uc291cmNlKS5oaWRkZW4gJiYgIW5vZGVzKG8udGFyZ2V0KS5oaWRkZW4pXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwiYmF0Y2hFZGdlc0RyYXdpbmdcIiBzZXR0aW5ncyBpcyB0cnVlLCBlZGdlcyBhcmUgYmF0Y2hlZDpcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICBiYXRjaFNpemUgPSBlbWJlZFNldHRpbmdzKCdjYW52YXNFZGdlc0JhdGNoU2l6ZScpO1xuXG4gICAgICAgIGVkZ2VzID0gdGhpcy5lZGdlc09uU2NyZWVuO1xuICAgICAgICBsID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XG5cbiAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGVtcEdDTyA9IHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuXG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyBlZGdlIGxhYmVsczpcbiAgICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFvLmhpZGRlbilcbiAgICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOlxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGVtcEdDTztcblxuICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICBpZiAoZW5kID09PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICBjb25yYWQuYWRkSm9iKGlkLCBqb2IuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBub2RlczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdOb2Rlcykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLm5vZGVzO1xuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5sYWJlbHM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJylcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSArICdweCcpO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgdGhpcy5jb250ZXh0c1trXS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vY2FudmFzXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMud2ViZ2w6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBfc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcbiAgICB0aGlzLmpvYnMgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gdGhpcy5jYW1lcmEucmVhZFByZWZpeDtcblxuICAgIC8vIEluaXRpYWxpemUgcHJvZ3JhbXMgaGFzaFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZVByb2dyYW1zJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVGbG9hdEFycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlSW5kaWNlc0FycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycsIHRydWUpO1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbm9kZXMnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnLCB0cnVlKTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbGFiZWxzJyk7XG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcblxuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZ2VuZXJhdGUgdGhlIG5vZGVzIGFuZCBlZGdlcyBmbG9hdCBhcnJheXMuIFRoaXMgc3RlcCBpc1xuICAgKiBzZXBhcmF0ZWQgZnJvbSB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJlY2F1c2UgdG8ga2VlcCBXZWJHTCBlZmZpY2llbnQsIHNpbmNlXG4gICAqIGFsbCB0aGUgY2FtZXJhIGFuZCBtaWRkbGV3YXJlcyBhcmUgbW9kZWxpc2VkIGFzIG1hdHJpY2VzIGFuZCB0aGV5IGRvIG5vdFxuICAgKiByZXF1aXJlIHRoZSBmbG9hdCBhcnJheXMgdG8gYmUgcmVnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEJhc2ljYWxseSwgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgY2FtZXJhIG9yIGFwcGxpZXMgc29tZSBzcGVjaWZpYyBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb25zLCB0aGlzIHByb2Nlc3Mgc3RlcCB3aWxsIGJlIHNraXBwZWQsIGFuZCB0aGUgXCJyZW5kZXJcIlxuICAgKiBtZXRob2Qgd2lsbCBlZmZpY2llbnRseSByZWZyZXNoIHRoZSByZW5kZXJpbmcuXG4gICAqXG4gICAqIEFuZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBncmFwaCBjb2xvcnMgb3IgcG9zaXRpb25zIChhcHBseWluZyBhIG5ld1xuICAgKiBsYXlvdXQgb3IgZmlsdGVyaW5nIHRoZSBjb2xvcnMsIGZvciBpbnN0YW5jZSksIHRoaXMgXCJwcm9jZXNzXCIgc3RlcCB3aWxsIGJlXG4gICAqIHJlcXVpcmVkIHRvIHJlZ2VuZXJhdGUgdGhlIGZsb2F0IGFycmF5cy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcbiAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJyk7XG5cbiAgICAvLyBFbXB0eSBmbG9hdCBhcnJheXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUluZGljZXNBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXTtcblxuICAgIC8vIFNvcnQgZWRnZXMgYW5kIG5vZGVzIHBlciB0eXBlczpcbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHRFZGdlVHlwZTtcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5lZGdlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XG5cbiAgICAgIGlmICghdGhpcy5lZGdlRmxvYXRBcnJheXNba10pXG4gICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdID0ge1xuICAgICAgICAgIGVkZ2VzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIGZvciAoYSA9IGdyYXBoLm5vZGVzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdE5vZGVUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLm5vZGVzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgbm9kZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBlZGdlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG4gICAgICBhID0gdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlbiAmJlxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSkuaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KS5oaWRkZW5cbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlcmVyLmFkZEVkZ2UoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLFxuICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuY29tcHV0ZUluZGljZXMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMuZWRnZUluZGljZXNBcnJheXNba10gPSByZW5kZXJlci5jb21wdXRlSW5kaWNlcyhcbiAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFB1c2ggbm9kZXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuICAgICAgYSA9IHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5KVxuICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkTm9kZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGguIEl0IGJhc2ljYWxseSBjYWxscyBlYWNoIHByb2dyYW0gKGFuZFxuICAgKiBnZW5lcmF0ZSB0aGVtIGlmIHRoZXkgZG8gbm90IGV4aXN0IHlldCkgdG8gcmVuZGVyIG5vZGVzIGFuZCBlZGdlcywgYmF0Y2hlZFxuICAgKiBwZXIgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3BsYXkgZWRnZXMsIG5vZGVzIGFuZCAvIG9yXG4gICAqIGxhYmVscyBpbiBiYXRjaGVzLCB0byBtYWtlIHRoZSB3aG9sZSB0aGluZyB3YXkgbW9yZSBzY2FsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICBwYXJhbXMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgbyxcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzR2wgPSB0aGlzLmNvbnRleHRzLm5vZGVzLFxuICAgICAgICBlZGdlc0dsID0gdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5jYW1lcmEuZ2V0TWF0cml4KCksXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gVHJhbnNsYXRlIG1hdHJpeCB0byBbd2lkdGgvMiwgaGVpZ2h0LzJdOlxuICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgbWF0cml4LFxuICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24odGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMilcbiAgICApO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBqb2IsXG4gICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgICAgICAgY3VycmVudFByb2dyYW07XG5cbiAgICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcbiAgICAgICAgICBiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbEVkZ2VzQmF0Y2hTaXplJyk7XG4gICAgICAgICAgYSA9IE9iamVjdC5rZXlzKHRoaXMuZWRnZUZsb2F0QXJyYXlzKTtcblxuICAgICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5lZGdlSW5kaWNlc0FycmF5c1thW2ldXTtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pO1xuICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSxcbiAgICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgY291bnQ6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IGluZGljZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTICYmXG4gICAgICAgICAgICAgIGkgPT09IGEubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2tdO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2tdKVxuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IHRoaXMuZWRnZUluZGljZXNBcnJheXNba11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICAvLyBFbmFibGUgYmxlbmRpbmc6XG4gICAgICBub2Rlc0dsLmJsZW5kRnVuYyhub2Rlc0dsLlNSQ19BTFBIQSwgbm9kZXNHbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIG5vZGVzR2wuZW5hYmxlKG5vZGVzR2wuQkxFTkQpO1xuXG4gICAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcblxuICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zW2tdKVxuICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0obm9kZXNHbCk7XG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIGlmICh0aGlzLm5vZGVGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgIG5vZGVzR2wudXNlUHJvZ3JhbSh0aGlzLm5vZGVQcm9ncmFtc1trXSk7XG4gICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgbm9kZXNHbCxcbiAgICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdLFxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIGEgPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSBjYW1lcmEgdmlldyB0byB0aGVzZSBub2RlczpcbiAgICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogYSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBvID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNldHRpbmdzKHtcbiAgICAgICAgICBwcmVmaXg6IHNlbGYuY2FtZXJhLnByZWZpeFxuICAgICAgICB9LCBrZXkpO1xuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5sYWJlbHNbXG4gICAgICAgICAgICAgIGFbaV0udHlwZSB8fFxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCBzaWdtYS5jYW52YXMubGFiZWxzLmRlZlxuICAgICAgICAgICkoYVtpXSwgdGhpcy5jb250ZXh0cy5sYWJlbHMsIG8pO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICB0YWcgICBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkb21FbGVtZW50c1wiKS5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59IHdlYmdsIFdpbGwgaW5pdCB0aGUgV2ViR0wgY29udGV4dCBpZiB0cnVlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCwgd2ViZ2wpIHtcbiAgICB2YXIgZ2wsXG4gICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCh3ZWJnbCA/ICdleHBlcmltZW50YWwtd2ViZ2wnIDogJzJkJywge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGRpbmcgd2ViZ2wgY29udGV4dCBsb3NzIGxpc3RlbmVyc1xuICAgICAgaWYgKHdlYmdsKSB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgLy8gSWYgc2ltcGxlIDJEIGNhbnZhczpcbiAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xuXG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICh3ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgIChoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2NhbGU6XG4gICAgZm9yIChrIGluIHRoaXMuY29udGV4dHMpXG4gICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KVxuICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxuICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dHMubm9kZXMuY2xlYXIodGhpcy5jb250ZXh0cy5ub2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmNsZWFyKHRoaXMuY29udGV4dHMuZWRnZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgY29udGV4dHMgYW5kIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wubm9kZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIG5vZGVcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBub2RlcyBhcyBkaXNjcy4gSGVyZSBhcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICogYW55IG5vZGUgcmVuZGVyZXIgbXVzdCBoYXZlOlxuICAgKlxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYSBub2RlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkTm9kZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYSBub2RlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtudW1iZXJ9ICAgICAgIGluZGV4ICAgVGhlIG5vZGUgaW5kZXggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wubm9kZXMuZGVmIG9yIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLmVkZ2VzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBlZGdlXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgZWRnZXMgYXMgZGlyZWN0IGxpbmVzLiBIZXJlIGFyZSB0aGVcbiAgICogYXR0cmlidXRlcyBhbnkgZWRnZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhbiBlZGdlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkRWRnZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYW4gZWRnZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBlZGdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHRhcmdldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgZWRnZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wuZWRnZXMuZGVmIG9yIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLmNhbnZhcy5sYWJlbHNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50XG4gICAqIGxhYmVsIHJlbmRlcmVycyBmb3IgdGhlIFdlYkdMIHJlbmRlcmVyLiBTaW5jZSBkaXNwbGF5aW5nIHRleHRzIGluIFdlYkdMIGlzXG4gICAqIGRlZmluaXRlbHkgcGFpbmZ1bCBhbmQgc2luY2UgdGhlcmUgYSB3YXkgbGVzcyBsYWJlbHMgdG8gZGlzcGxheSB0aGFuIG5vZGVzXG4gICAqIG9yIGVkZ2VzLCB0aGUgZGVmYXVsdCByZW5kZXJlciBzaW1wbHkgcmVuZGVycyB0aGVtIGluIGEgY2FudmFzLlxuICAgKlxuICAgKiBBIGxhYmVscyByZW5kZXJlciBpcyBhIHNpbXBsZSBmdW5jdGlvbiwgdGFraW5nIGFzIGFyZ3VtZW50cyB0aGUgcmVsYXRlZFxuICAgKiBub2RlLCB0aGUgcmVuZGVyZXIgYW5kIGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdmcgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zdmc6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHtcbiAgICAgIGdyYXBoOiBudWxsLFxuICAgICAgZ3JvdXBzOiB7fSxcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIGVkZ2VzOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBob3ZlcnM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gSXMgdGhlIHJlbmRlcmVyIG1lYW50IHRvIGJlIGZyZWVzdHlsZT9cbiAgICB0aGlzLnNldHRpbmdzKCdmcmVlU3R5bGUnLCAhIXRoaXMub3B0aW9ucy5mcmVlU3R5bGUpO1xuXG4gICAgLy8gU1ZHIHhtbG5zXG4gICAgdGhpcy5zZXR0aW5ncygneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcblxuICAgIC8vIEluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyBzaWdtYS51dGlscy5pZCgpICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5pbml0RE9NKCdzdmcnKTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHJlc2l6ZTpcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICAvLyBUT0RPOiBrZWVwIGFuIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgRE9NIGV2ZW50cz9cbiAgICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMuY2FsbCh0aGlzLCB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoKTtcbiAgICB0aGlzLmJpbmRIb3ZlcnModGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICAvLyBSZXNpemVcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBzdmcgc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgZSxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICBzdWJyZW5kZXJlcnMsXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAgICAgIGZvcmNlTGFiZWxzOiB0aGlzLm9wdGlvbnMuZm9yY2VMYWJlbHNcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIaWRpbmcgZXZlcnl0aGluZ1xuICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIHNlbnNpYmxlIHdheSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5ub2Rlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5lZGdlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5sYWJlbHMpO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuXG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICApO1xuXG4gICAgLy8gTm9kZSBpbmRleFxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIEZpbmQgd2hpY2ggZWRnZXMgYXJlIG9uIHNjcmVlblxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG8gPSBhW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcbiAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgIClcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSBub2Rlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLm5vZGVzO1xuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5sYWJlbHM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgbm9kZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4gJiYgIXRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0pIHtcblxuICAgICAgICAgIC8vIE5vZGVcbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKGUpO1xuXG4gICAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgICBlID0gKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5sYWJlbHMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vLS0gU2Vjb25kIHdlIHVwZGF0ZSB0aGUgbm9kZXNcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFbaV0uaGlkZGVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0sXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIExhYmVsXG4gICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAvLyBEaXNwbGF5IGVkZ2VzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgZWRnZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd0VkZ2VzKVxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmVkZ2VzLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBlZGdlc1xuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0sXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZykge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgdGFnKSxcbiAgICAgICAgYyA9IHRoaXMuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JyksXG4gICAgICAgIGcsXG4gICAgICAgIGwsXG4gICAgICAgIGk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctc3ZnJyk7XG5cbiAgICAvLyBTZXR0aW5nIFNWRyBuYW1lc3BhY2VcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxucycsIHRoaXMuc2V0dGluZ3MoJ3htbG5zJykpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgJzEuMScpO1xuXG4gICAgLy8gQ3JlYXRpbmcgdGhlIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLW1lYXN1cmVtZW50LWNhbnZhcycpO1xuXG4gICAgLy8gQXBwZW5kaW5nIGVsZW1lbnRzXG4gICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCA9IHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICAvLyBDcmVhdGluZyBncm91cHNcbiAgICB2YXIgZ3JvdXBzID0gWydlZGdlcycsICdub2RlcycsICdsYWJlbHMnLCAnaG92ZXJzJ107XG4gICAgZm9yIChpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgJ2cnKTtcblxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCBjICsgJy1ncm91cC0nICsgZ3JvdXBzW2ldKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgYyArICctZ3JvdXAnKTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHNbZ3JvdXBzW2ldXSA9XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguYXBwZW5kQ2hpbGQoZyk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kaW5nIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBoaWRlcyBhIGJhdGNoIG9mIFNWRyBET00gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICBBbiBhcnJheSBvZiBlbGVtZW50cyB0byBoaWRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICByZW5kZXJlciAgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmhpZGVET01FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgaW4gZWxlbWVudHMpIHtcbiAgICAgIG8gPSBlbGVtZW50c1tpXTtcbiAgICAgIHNpZ21hLnN2Zy51dGlscy5oaWRlKG8pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgaG92ZXIgZXZlbnRzIHRvIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggVGhlIHJlbmRlcmVyIHByZWZpeC5cbiAgICovXG4gIC8vIFRPRE86IGFkZCBvcHRpb24gYWJvdXQgd2hldGhlciB0byBkaXNwbGF5IGhvdmVycyBvciBub3RcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuYmluZEhvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciByZW5kZXJlcnMgPSBzaWdtYS5zdmcuaG92ZXJzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaG92ZXJlZE5vZGU7XG5cbiAgICBmdW5jdGlvbiBvdmVyTm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tub2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXSxcbiAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgKTtcblxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgICAgaG92ZXJlZE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dE5vZGUoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLmRhdGEubm9kZSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgaWYgKCFlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnRcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFJlaW5zdGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gT1BUSU1JWkU6IHBlcmZvcm0gYSByZWFsIHVwZGF0ZSByYXRoZXIgdGhhbiBhIGRlbGV0aW9uXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKCFob3ZlcmVkTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnQgYmVmb3JlIHVwZGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbaG92ZXJlZE5vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgIH1cblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgdGhpcy5iaW5kKCdvdmVyTm9kZScsIG92ZXJOb2RlKTtcbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBvdXROb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBvbiByZW5kZXJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIHVwZGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gMTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50cy5ncmFwaC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL3N2Z1wiIGZvbGRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLy8gQ2hlY2sgaWYgV2ViR0wgaXMgZW5hYmxlZDpcbiAgdmFyIGNhbnZhcyxcbiAgICAgIHdlYmdsID0gISFnbG9iYWwuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAod2ViZ2wpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0cnkge1xuICAgICAgd2ViZ2wgPSAhIShcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdlYmdsID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29weSB0aGUgZ29vZCByZW5kZXJlcjpcbiAgc2lnbWEucmVuZGVyZXJzLmRlZiA9IHdlYmdsID9cbiAgICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgOlxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXM7XG59KSh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBhcyBkaXNjcywgc2hhcGVkIGluIHRyaWFuZ2xlcyB3aXRoXG4gICAqIHRoZSBnbC5UUklBTkdMRVMgZGlzcGxheSBtb2RlLiBTbywgdG8gYmUgbW9yZSBwcmVjaXNlLCB0byBkcmF3IG9uZSBub2RlLFxuICAgKiBpdCB3aWxsIHN0b3JlIHRocmVlIHRpbWVzIHRoZSBjZW50ZXIgb2Ygbm9kZSwgd2l0aCB0aGUgY29sb3IgYW5kIHRoZSBzaXplLFxuICAgKiBhbmQgYW4gYW5nbGUgaW5kaWNhdGluZyB3aGljaCBcImNvcm5lclwiIG9mIHRoZSB0cmlhbmdsZSB0byBkcmF3LlxuICAgKlxuICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGRvZXMgbm90IGRlYWwgd2l0aCBhbnRpLWFsaWFzaW5nLCBzbyBtYWtlIHN1cmUgdGhhdFxuICAgKiB5b3UgZGVhbCB3aXRoIGl0IHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIChieSBkZWZhdWx0LCB0aGUgV2ViR0xcbiAgICogcmVuZGVyZXIgd2lsbCBvdmVyc2FtcGxlIHRoZSByZW5kZXJpbmcgdGhyb3VnaCB0aGUgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpb1xuICAgKiB2YWx1ZSkuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgPSB7XG4gICAgUE9JTlRTOiAzLFxuICAgIEFUVFJJQlVURVM6IDUsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDA7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMiAqIE1hdGguUEkgLyAzO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDQgKiBNYXRoLlBJIC8gMztcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIGFuZ2xlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfYW5nbGUnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhbmdsZUxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgYW5nbGVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxuICAgICAgICAgICAgJ3JhZGl1cyA9IGFfc2l6ZSAqIHVfcmF0aW87JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHk7JyxcbiAgICAgICAgICAgIC8vICdjZW50ZXIgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSBwb3NpdGlvbiAqIHVfc2NhbGU7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSB2ZWMyKGNlbnRlci54LCB1X3NjYWxlICogdV9yZXNvbHV0aW9uLnkgLSBjZW50ZXIueSk7JyxcblxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gcG9zaXRpb24gKycsXG4gICAgICAgICAgICAgICcyLjAgKiByYWRpdXMgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTsnLFxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXG5cbiAgICAgICAgICAgICdyYWRpdXMgPSByYWRpdXMgKiB1X3NjYWxlOycsXG5cbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG5cbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXI7JyxcbiAgICAgICAgICAgICdmbG9hdCBkaWZmID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXG5cbiAgICAgICAgICAgIC8vIEhlcmUgaXMgaG93IHdlIGRyYXcgYSBkaXNjIGluc3RlYWQgb2YgYSBzcXVhcmU6XG4gICAgICAgICAgICAnaWYgKGRpZmYgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgaW4gdGhlIGZhc3Rlc3Qgd2F5OiBOb2RlcyBhcmUgYmFzaWNcbiAgICogc3F1YXJlcywgZHJhd24gdGhyb3VnaCB0aGUgZ2wuUE9JTlRTIGRyYXdpbmcgbWV0aG9kLiBUaGUgc2l6ZSBvZiB0aGUgbm9kZXNcbiAgICogYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIFwiZ2xfUG9pbnRTaXplXCIgdmFsdWUgaW4gdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEl0IGlzIHRoZSBmYXN0ZXN0IG5vZGUgcmVuZGVyZXIgaGVyZSBzaW5jZSB0aGUgYnVmZmVyIGp1c3QgdGFrZXMgb25lIGxpbmVcbiAgICogdG8gZHJhdyBlYWNoIG5vZGUgKHdpdGggYXR0cmlidXRlcyBcInhcIiwgXCJ5XCIsIFwic2l6ZVwiIGFuZCBcImNvbG9yXCIpLlxuICAgKlxuICAgKiBOZXZlcnRoZWxlc3MsIHRoaXMgbWV0aG9kIGhhcyBzb21lIHByb2JsZW1zLCBlc3BlY2lhbGx5IGR1ZSB0byBzb21lIGlzc3Vlc1xuICAgKiB3aXRoIHRoZSBnbC5QT0lOVFM6XG4gICAqICAtIEZpcnN0LCBpZiB0aGUgY2VudGVyIG9mIGEgbm9kZSBpcyBvdXRzaWRlIHRoZSBzY2VuZSwgdGhlIHBvaW50IHdpbGwgbm90XG4gICAqICAgIGJlIGRyYXduLCBldmVuIGlmIGl0IHNob3VsZCBiZSBwYXJ0bHkgb24gc2NyZWVuLlxuICAgKiAgLSBJIHRyaWVkIGFwcGx5aW5nIGEgZnJhZ21lbnQgc2hhZGVyIHNpbWlsYXIgdG8gdGhlIG9uZSBpbiB0aGUgZGVmYXVsdFxuICAgKiAgICBub2RlIHJlbmRlcmVyIHRvIGRpc3BsYXkgdGhlbSBhcyBkaXNjcywgYnV0IGl0IGRpZCBub3Qgd29yayBmaW5lIG9uXG4gICAqICAgIHNvbWUgY29tcHV0ZXJzIHNldHRpbmdzLCBmaWxsaW5nIHRoZSBkaXNjcyB3aXRoIHdlaXJkIGdyYWRpZW50cyBub3RcbiAgICogICAgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgY29sb3IuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0ID0ge1xuICAgIFBPSU5UUzogMSxcbiAgICBBVFRSSUJVVEVTOiA0LFxuICAgIGFkZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5QT0lOVFMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcbiAgICAgICAgICAgIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxuICAgICAgICAgICAgJ2dsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIHVfcmF0aW8gKiB1X3NjYWxlICogMi4wOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdmbG9hdCBib3JkZXIgPSAwLjAxOycsXG4gICAgICAgICAgICAnZmxvYXQgcmFkaXVzID0gMC41OycsXG5cbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3QgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IHQgPSAwLjA7JyxcbiAgICAgICAgICAgICdpZiAoZGlzdCA+IGJvcmRlciknLFxuICAgICAgICAgICAgICAndCA9IDEuMDsnLFxuICAgICAgICAgICAgJ2Vsc2UgaWYgKGRpc3QgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ3QgPSBkaXN0IC8gYm9yZGVyOycsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvciwgdCk7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICogdG8gdGhlIHRhcmdldCBub2RlLiBUbyBkZWFsIHdpdGggZWRnZSB0aGlja25lc3NlcywgdGhlIGxpbmVzIGFyZSBtYWRlIG9mXG4gICAqIHR3byB0cmlhbmdsZXMgZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZyBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA2IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgNyBhdHRyaWJ1dGVzIChzb3VyY2UgcG9zaXRpb24sIHRhcmdldCBwb3NpdGlvbiwgdGhpY2tuZXNzLCBjb2xvclxuICAgKiBhbmQgYSBmbGFnIGluZGljYXRpbmcgd2hpY2ggdmVydGljZSBvZiB0aGUgcmVjdGFuZ2xlIGl0IGlzKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDYsXG4gICAgQVRUUklCVVRFUzogNyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24xOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24yOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKicsXG4gICAgICAgICAgICAgICdub3JtYWxpemUoYV9wb3NpdGlvbjIgLSBhX3Bvc2l0aW9uMSk7JyxcblxuICAgICAgICAgICAgJ21hdDIgbWF0cml4ID0gYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBtYXRyaXggKiBwb3NpdGlvbiArIGFfcG9zaXRpb24xOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGxpbmVzIHdpdGggdGhlIGdsLkxJTkVTIGRpc3BsYXlcbiAgICogbW9kZS4gU2luY2UgdGhpcyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgd2VsbCB0aGlja25lc3MsIGVkZ2VzIGFyZSBhbGwgZHJhd25cbiAgICogd2l0aCB0aGUgc2FtZSB0aGlja25lc3MgKDNweCksIGluZGVwZW5kYW50bHkgb2YgdGhlIGVkZ2UgYXR0cmlidXRlcyBvciB0aGVcbiAgICogem9vbWluZyByYXRpby5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAyLFxuICAgIEFUVFJJQlVURVM6IDMsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG5cbiAgICAgIGdsLmxpbmVXaWR0aCgzKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLkxJTkVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdGhyZWUgdHJpYW5nbGVzOiB0d28gZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZ1xuICAgKiBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA5IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgYSBsb3Qgb2YgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmFycm93ID0ge1xuICAgIFBPSU5UUzogOSxcbiAgICBBVFRSSUJVVEVTOiAxMSxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHRhcmdldFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICAvLyBBcnJvdyBoZWFkOlxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IC0xLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MyJyksXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXG4gICAgICAgICAgdGFyZ2V0U2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RTaXplJyksXG4gICAgICAgICAgZGVsYXlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9kZWxheScpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICBoZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZCcpLFxuICAgICAgICAgIGhlYWRQb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWRQb3NpdGlvbicpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfbm9kZVJhdGlvJyksXG4gICAgICAgICAgYXJyb3dIZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2Fycm93SGVhZCcpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICBwYXJhbXMucmF0aW8gLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24sXG4gICAgICAgIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpIC9cbiAgICAgICAgcGFyYW1zLnJhdGlvXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKGFycm93SGVhZExvY2F0aW9uLCA1LjApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGFyZ2V0U2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbGF5TG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZFBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRhcmdldFNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihkZWxheUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG1pbnVzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZExvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRQb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA0MFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MxOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdFNpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfZGVsYXk7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZDsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkUG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfbm9kZVJhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9hcnJvd0hlYWQ7JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3MgPSBub3JtYWxpemUoYV9wb3MyIC0gYV9wb3MxKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSAoMS4wIC0gYV9oZWFkKSAqJyxcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICAgICdhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGknLFxuICAgICAgICAgICAgICAnKSArIGFfaGVhZCAqICgnLFxuICAgICAgICAgICAgICAgICdhX2hlYWRQb3NpdGlvbiAqIHVfbWF0cml4SGFsZlBpTWludXMgKiAwLjYgKycsXG4gICAgICAgICAgICAgICAgJyhhX2hlYWRQb3NpdGlvbiAqIGFfaGVhZFBvc2l0aW9uIC0gMS4wKSAqIG1hdDIoMS4wKScsXG4gICAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgICdwb3MgPSBhX3BvczEgKyAoJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGJvZHk6XG4gICAgICAgICAgICAgICcoMS4wIC0gYV9oZWFkKSAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGhlYWQ6XG4gICAgICAgICAgICAgICdhX2hlYWQgKiB1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlbGF5OlxuICAgICAgICAgICAgICAnYV9kZWxheSAqIHBvcyAqICgnLFxuICAgICAgICAgICAgICAgICdhX3RTaXplIC8gdV9ub2RlUmF0aW8gKycsXG4gICAgICAgICAgICAgICAgJ3VfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvJyxcbiAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvcywgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbGFiZWwgcmVuZGVyZXIgd2lsbCBqdXN0IGRpc3BsYXkgdGhlIGxhYmVsIG9uIHRoZSByaWdodCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgZm9udFNpemUsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgIGlmIChzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoIW5vZGUubGFiZWwgfHwgdHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgIGNvbnRleHQuZm9udCA9IChzZXR0aW5ncygnZm9udFN0eWxlJykgPyBzZXR0aW5ncygnZm9udFN0eWxlJykgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIHNldHRpbmdzKCdmb250Jyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICBub2RlLmxhYmVsLFxuICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMyksXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgYmFzaWNhbGx5IGRpc3BsYXkgdGhlIGxhYmVsIHdpdGggYSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciB4LFxuICAgICAgICB5LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBlLFxuICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgLy8gTGFiZWwgYmFja2dyb3VuZDpcbiAgICBjb250ZXh0LmZvbnQgPSAoZm9udFN0eWxlID8gZm9udFN0eWxlICsgJyAnIDogJycpICtcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgKyAoc2V0dGluZ3MoJ2hvdmVyRm9udCcpIHx8IHNldHRpbmdzKCdmb250JykpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdsYWJlbEhvdmVyQkdDb2xvcicpID09PSAnbm9kZScgP1xuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcicpO1xuXG4gICAgaWYgKG5vZGUubGFiZWwgJiYgc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3cnKSkge1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSA4O1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93Q29sb3InKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArIGZvbnRTaXplIC8gMiArIHNpemUgKyA3XG4gICAgICApO1xuICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgZSk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHksIHggKyBlLCB5LCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgZSwgeSArIGgpO1xuICAgICAgY29udGV4dC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBlLCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm9kZSBib3JkZXI6XG4gICAgaWYgKHNldHRpbmdzKCdib3JkZXJTaXplJykgPiAwKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBub2RlW3ByZWZpeCArICd4J10sXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZSArIHNldHRpbmdzKCdib3JkZXJTaXplJyksXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIC8vIE5vZGU6XG4gICAgdmFyIG5vZGVSZW5kZXJlciA9IHNpZ21hLmNhbnZhcy5ub2Rlc1tub2RlLnR5cGVdIHx8IHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWY7XG4gICAgbm9kZVJlbmRlcmVyKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKTtcblxuICAgIC8vIERpc3BsYXkgdGhlIGxhYmVsOlxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICBub2RlLmxhYmVsLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMubm9kZXMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgIDAsXG4gICAgICBNYXRoLlBJICogMixcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5kZWYgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5hcnJvdyA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpLFxuICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpLFxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuICAgIHNpemUgKj0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZSA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIHRYLCB0WSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmFycm93ID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBzaXplID0gKGVkZ2UuaG92ZXIpID9cbiAgICAgIHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIHNpemUgOiBzaXplO1xuICAgIHZhciBhU2l6ZSA9IHNpemUgKiAyLjUsXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIGFYLFxuICAgICAgYVlcbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmVkQXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBkLFxuICAgICAgICBhU2l6ZSxcbiAgICAgICAgYVgsXG4gICAgICAgIGFZLFxuICAgICAgICB2WCxcbiAgICAgICAgdlk7XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgdFNpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54MSwgMikgKyBNYXRoLnBvdyh0WSAtIGNwLnkxLCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLngxICsgKHRYIC0gY3AueDEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICBhWSA9IGNwLnkxICsgKHRZIC0gY3AueTEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcbiAgICAgIHZZID0gKHRZIC0gY3AueTEpICogYVNpemUgLyBkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54LCAyKSArIE1hdGgucG93KHRZIC0gY3AueSwgMikpO1xuICAgICAgYVNpemUgPSBzaXplICogMi41O1xuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MiwgY3AueTIsIGNwLngxLCBjcC55MSwgYVgsIGFZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIGFYLCBhWSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5leHRyZW1pdGllcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlciBmb3IgaG92ZXJlZCBlZGdlIGV4dHJlbWl0aWVzLiBJdCByZW5kZXJzIHRoZSBlZGdlXG4gICAqIGV4dHJlbWl0aWVzIGFzIGhvdmVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIC8vIFNvdXJjZSBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbc291cmNlLnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgc291cmNlLCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG5cbiAgICAvLyBUYXJnZXQgTm9kZTpcbiAgICAoXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3RhcmdldC50eXBlXSB8fFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcbiAgICApIChcbiAgICAgIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3NcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHNpZ21hJ3MgU1ZHIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLnV0aWxzID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgc2hvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBzaG93LlxuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGhpZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gaGlkZS5cbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxuICAgKi9cbiAgc2lnbWEuc3ZnLm5vZGVzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgdGhlIG5vZGUncyBjaXJjbGVcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBSZXR1cm5pbmcgdGhlIERPTSBFbGVtZW50XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGNpcmNsZSAgIFRoZSBub2RlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgY2lyY2xlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgLy8gQXBwbHlpbmcgY2hhbmdlc1xuICAgICAgLy8gVE9ETzogb3B0aW1pemUgLSBjaGVjayBpZiBuZWNlc3NhcnlcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBub2RlW3ByZWZpeCArICdzaXplJ10pO1xuXG4gICAgICAvLyBVcGRhdGluZyBvbmx5IGlmIG5vdCBmcmVlc3R5bGVcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZyZWVTdHlsZScpKVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBsaW5lLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2xpbmUnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgbGluZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHNvdXJjZVtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kxJywgc291cmNlW3ByZWZpeCArICd5J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDInLCB0YXJnZXRbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHRhcmdldFtwcmVmaXggKyAneSddKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VydmUgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIGJlemllciBjdXJ2ZS5cbiAgICovXG4gIHNpZ21hLnN2Zy5lZGdlcy5jdXJ2ZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3BhdGgnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgcGF0aCwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG5cbiAgICAgIC8vIENvbnRyb2wgcG9pbnRcbiAgICAgIHZhciBjeCA9IChzb3VyY2VbcHJlZml4ICsgJ3gnXSArIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDIgK1xuICAgICAgICAodGFyZ2V0W3ByZWZpeCArICd5J10gLSBzb3VyY2VbcHJlZml4ICsgJ3knXSkgLyA0LFxuICAgICAgICAgIGN5ID0gKHNvdXJjZVtwcmVmaXggKyAneSddICsgdGFyZ2V0W3ByZWZpeCArICd5J10pIC8gMiArXG4gICAgICAgIChzb3VyY2VbcHJlZml4ICsgJ3gnXSAtIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDQ7XG5cbiAgICAgIC8vIFBhdGhcbiAgICAgIHZhciBwID0gJ00nICsgc291cmNlW3ByZWZpeCArICd4J10gKyAnLCcgKyBzb3VyY2VbcHJlZml4ICsgJ3knXSArICcgJyArXG4gICAgICAgICAgICAgICdRJyArIGN4ICsgJywnICsgY3kgKyAnICcgK1xuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSArICcsJyArIHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgICAvLyBVcGRhdGluZyBhdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgcGF0aC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbGFiZWwgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGxhYmVsIGFzIGEgc2ltcGxlIHRleHQuXG4gICAqL1xuICBzaWdtYS5zdmcubGFiZWxzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIHZhciBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XG5cbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbGFiZWwtdGFyZ2V0Jywgbm9kZS5pZCk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1sYWJlbCcpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuXG4gICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgdGV4dCAgICAgVGhlIGxhYmVsIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgdGV4dCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgdmFyIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgICAvLyBDYXNlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSBsYWJlbFxuICAgICAgaWYgKCFzZXR0aW5ncygnZm9yY2VMYWJlbHMnKSAmJiBzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBVcGRhdGluZ1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICB0ZXh0LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBob3ZlciByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLnN2Zy5ob3ZlcnMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBub2RlICAgICAgICAgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0NhbnZhc0VsZW1lbnR9ICAgIG1lYXN1cmVtZW50Q2FudmFzICBBIGZha2UgY2FudmFzIGhhbmRsZWQgYnlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3ZnIHRvIHBlcmZvcm0gc29tZSBtZWFzdXJlbWVudHMgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICBub2RlQ2lyY2xlICAgICAgICAgVGhlIG5vZGUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgc2V0dGluZ3MgICAgICAgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIG5vZGVDaXJjbGUsIG1lYXN1cmVtZW50Q2FudmFzLCBzZXR0aW5ncykge1xuXG4gICAgICAvLyBEZWZpbmluZyB2aXN1YWwgcHJvcGVydGllc1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplLFxuICAgICAgICAgIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcblxuICAgICAgLy8gQ3JlYXRpbmcgZWxlbWVudHNcbiAgICAgIHZhciBncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2cnKSxcbiAgICAgICAgICByZWN0YW5nbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdyZWN0JyksXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyksXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgcHJvcGVydGllc1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1sYWJlbCcpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZXNcbiAgICAgICAgLy8gT1BUSU1JWkU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRoYW4gYSBtZWFzdXJlbWVudCBjYW52YXNcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBtZWFzdXJlbWVudENhbnZhcy5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIgKyBzaXplICsgOVxuICAgICAgICApO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcblxuICAgICAgICAvLyBDaXJjbGVcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIGUpO1xuXG4gICAgICAgIC8vIFJlY3RhbmdsZVxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIG5vZGVbcHJlZml4ICsgJ3gnXSArIGUgLyA0KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5Jywgbm9kZVtwcmVmaXggKyAneSddIC0gZSk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwZW5kaW5nIGNoaWxkc1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlY3RhbmdsZSk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG5vZGVDaXJjbGUpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCByZXNjYWxlIHRoZSBncmFwaCBzdWNoIHRoYXQgaXQgdGFrZXMgYW4gb3B0aW1hbCBzcGFjZVxuICAgKiBvbiB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGVhY2ggbWlkZGxld2FyZSwgdGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHNpZ21hXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHJlYWRQcmVmaXggIFRoZSByZWFkIHByZWZpeC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgIFRoZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4LCBvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBtYXJnaW4sXG4gICAgICAgIG4gPSB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGUgPSB0aGlzLmdyYXBoLmVkZ2VzKCksXG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucyB8fCB7fSksXG4gICAgICAgIGJvdW5kcyA9IHNldHRpbmdzKCdib3VuZHMnKSB8fCBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgcmVhZFByZWZpeCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICBtYXhYID0gYm91bmRzLm1heFgsXG4gICAgICAgIG1heFkgPSBib3VuZHMubWF4WSxcbiAgICAgICAgc2l6ZU1heCA9IGJvdW5kcy5zaXplTWF4LFxuICAgICAgICB3ZWlnaHRNYXggPSBib3VuZHMud2VpZ2h0TWF4LFxuICAgICAgICB3ID0gc2V0dGluZ3MoJ3dpZHRoJykgfHwgMSxcbiAgICAgICAgaCA9IHNldHRpbmdzKCdoZWlnaHQnKSB8fCAxLFxuICAgICAgICByZXNjYWxlU2V0dGluZ3MgPSBzZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSxcbiAgICAgICAgdmFsaWRTZXR0aW5ncyA9IHtcbiAgICAgICAgICBub2RlUG9zaXRpb246IDEsXG4gICAgICAgICAgbm9kZVNpemU6IDEsXG4gICAgICAgICAgZWRnZVNpemU6IDFcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZWxlbWVudHMgc2hvdWxkIHdlIHJlc2NhbGU/XG4gICAgICovXG4gICAgaWYgKCEocmVzY2FsZVNldHRpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgcmVzY2FsZVNldHRpbmdzID0gWydub2RlUG9zaXRpb24nLCAnbm9kZVNpemUnLCAnZWRnZVNpemUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSByZXNjYWxlU2V0dGluZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKCF2YWxpZFNldHRpbmdzW3Jlc2NhbGVTZXR0aW5nc1tpXV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHJlc2NhbGUgc2V0dGluZyBcIicgKyByZXNjYWxlU2V0dGluZ3NbaV0gKyAnXCIgaXMgbm90IHJlY29nbml6ZWQuJ1xuICAgICAgICApO1xuXG4gICAgdmFyIG5wID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlUG9zaXRpb24nKSxcbiAgICAgICAgbnMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVTaXplJyksXG4gICAgICAgIGVzID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdlZGdlU2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHNjYWxpbmcgcmF0aW8sIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIHNpemVzXG4gICAgICogb2YgdGhlIG5vZGVzIDogRWFjaCBub2RlIHdpbGwgaGF2ZSBpdHMgY2VudGVyIGluIHRoZSBjYW52YXMsIGJ1dCBtaWdodFxuICAgICAqIGJlIHBhcnRpYWxseSBvdXQgb2YgaXQuXG4gICAgICovXG4gICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cbiAgICAgIE1hdGgubWF4KFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApIDpcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApO1xuXG4gICAgLyoqXG4gICAgICogVGhlbiwgd2UgY29ycmVjdCB0aGF0IHNjYWxpbmcgcmF0aW8gY29uc2lkZXJpbmcgYSBtYXJnaW4sIHdoaWNoIGlzXG4gICAgICogYmFzaWNhbGx5IHRoZSBzaXplIG9mIHRoZSBiaWdnZXN0IG5vZGUuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgZG9uZSBhcyBhIGNvcnJlY3Rpb24gc2luY2UgdG8gY29tcGFyZSB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgKiBiaWdnZXN0IG5vZGUgdG8gdGhlIFggYW5kIFkgdmFsdWVzLCB3ZSBoYXZlIHRvIGZpcnN0IGdldCBhblxuICAgICAqIGFwcHJveGltYXRpb24gb2YgdGhlIHNjYWxpbmcgcmF0aW8uXG4gICAgICoqL1xuICAgIG1hcmdpbiA9XG4gICAgICAoXG4gICAgICAgIHNldHRpbmdzKCdyZXNjYWxlSWdub3JlU2l6ZScpID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgfHwgc2l6ZU1heCkgLyBzY2FsZVxuICAgICAgKSArXG4gICAgICAoc2V0dGluZ3MoJ3NpZGVNYXJnaW4nKSB8fCAwKTtcbiAgICBtYXhYICs9IG1hcmdpbjtcbiAgICBtaW5YIC09IG1hcmdpbjtcbiAgICBtYXhZICs9IG1hcmdpbjtcbiAgICBtaW5ZIC09IG1hcmdpbjtcblxuICAgIC8vIEZpeCB0aGUgc2NhbGluZyB3aXRoIHRoZSBuZXcgZXh0cmVtYTpcbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvLyBTaXplIGhvbW90aGV0aWMgcGFyYW1ldGVyczpcbiAgICBpZiAoIXNldHRpbmdzKCdtYXhOb2RlU2l6ZScpICYmICFzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDE7XG4gICAgICBiID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpID09PSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDA7XG4gICAgICBiID0gK3NldHRpbmdzKCdtYXhOb2RlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIC8gc2l6ZU1heDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21pbk5vZGVTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAxO1xuICAgICAgZCA9IDA7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAwO1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAtIHNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSAvIHdlaWdodE1heDtcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzY2FsZSB0aGUgbm9kZXMgYW5kIGVkZ2VzOlxuICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGVbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cbiAgICAgICAgZVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChlcyA/IGMgOiAxKSArIChlcyA/IGQgOiAwKTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBuW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKG5zID8gYSA6IDEpICsgKG5zID8gYiA6IDApO1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPVxuICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3gnXSAtIChtYXhYICsgbWluWCkgLyAyKSAqIChucCA/IHNjYWxlIDogMSk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneSddIC0gKG1heFkgKyBtaW5ZKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICB9XG4gIH07XG5cbiAgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uKGdyYXBoLCBwcmVmaXgsIGRvRWRnZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZSA9IGdyYXBoLmVkZ2VzKCksXG4gICAgICAgIG4gPSBncmFwaC5ub2RlcygpLFxuICAgICAgICB3ZWlnaHRNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHNpemVNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgaWYgKGRvRWRnZXMpXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHdlaWdodE1heCA9IE1hdGgubWF4KGVbaV1bcHJlZml4ICsgJ3NpemUnXSwgd2VpZ2h0TWF4KTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2l6ZU1heCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3NpemUnXSwgc2l6ZU1heCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneCddLCBtYXhYKTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd4J10sIG1pblgpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3knXSwgbWF4WSk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneSddLCBtaW5ZKTtcbiAgICB9XG5cbiAgICB3ZWlnaHRNYXggPSB3ZWlnaHRNYXggfHwgMTtcbiAgICBzaXplTWF4ID0gc2l6ZU1heCB8fCAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodE1heDogd2VpZ2h0TWF4LFxuICAgICAgc2l6ZU1heDogc2l6ZU1heCxcbiAgICAgIG1pblg6IG1pblgsXG4gICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgbWF4WDogbWF4WCxcbiAgICAgIG1heFk6IG1heFlcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwganVzdCBjb3B5IHRoZSBncmFwaGljIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5ID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYTtcblxuICAgIGlmICh3cml0ZVByZWZpeCArICcnID09PSByZWFkUHJlZml4ICsgJycpXG4gICAgICByZXR1cm47XG5cbiAgICBhID0gdGhpcy5ncmFwaC5ub2RlcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd4J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneCddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd5J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneSddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICAgIH1cblxuICAgIGEgPSB0aGlzLmdyYXBoLmVkZ2VzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZycpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmV3IElELlxuICAgKi9cbiAgdmFyIF9nZXRJRCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJyArICgrK2lkKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFuaW1hdGVzIGEgY2FtZXJhLiBJdCBoYXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNhbWVyYSB0b1xuICAgKiBhbmltYXRlLCB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFjaCBhbmQgZXZlbnR1YWxseSBzb21lXG4gICAqIG9wdGlvbnMuIEl0IHJldHVybnMgYSBudW1iZXIgaWQsIHRoYXQgeW91IGNhbiB1c2UgdG8ga2lsbCB0aGUgYW5pbWF0aW9uLFxuICAgKiB3aXRoIHRoZSBtZXRob2Qgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbChpZCkuXG4gICAqXG4gICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbk5ld0ZyYW1lIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyIGEgbmV3IGZyYW1lLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgY29tcGxldGVkIG9yIGtpbGxlZC5cbiAgICogICB7PyhzdHJpbmd8ZnVuY3Rpb24pfSBlYXNpbmcgICAgIFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gZnJvbSB0aGUgcGFja2FnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncywgb3IgYSBjdXN0b20gZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgY2FtZXJhICBUaGUgY2FtZXJhIHRvIGFuaW1hdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldCAgVGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IHRvIHNwZWNpZnkgc29tZSBvcHRpb25zIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZ1bmN0aW9uLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgVGhlIGFuaW1hdGlvbiBpZCwgdG8gbWFrZSBpdCBlYXN5IHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIHRoZSBtZXRob2QgXCJzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsXCIuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEgPSBmdW5jdGlvbihjYW1lcmEsIHZhbCwgb3B0aW9ucykge1xuICAgIGlmIChcbiAgICAgICEoY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEpIHx8XG4gICAgICB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgIXZhbFxuICAgIClcbiAgICAgIHRocm93ICdhbmltYXRpb24uY2FtZXJhOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWwueCAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwueSAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwucmF0aW8gIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLmFuZ2xlICE9PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHRocm93ICdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSB2YWxpZCBjb29yZGluYXRlIGluIHRoZSBnaXZlbiB2YWwuJztcblxuICAgIHZhciBmbixcbiAgICAgICAgaWQsXG4gICAgICAgIGFuaW0sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGluaXRpYWxWYWwsXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzOlxuICAgIGluaXRpYWxWYWwgPSB7XG4gICAgICB4OiBjYW1lcmEueCxcbiAgICAgIHk6IGNhbWVyYS55LFxuICAgICAgcmF0aW86IGNhbWVyYS5yYXRpbyxcbiAgICAgIGFuZ2xlOiBjYW1lcmEuYW5nbGVcbiAgICB9O1xuXG4gICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uO1xuICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nIHx8ICdxdWFkcmF0aWNJbk91dCddIDpcbiAgICAgIG8uZWFzaW5nO1xuXG4gICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2VmLFxuICAgICAgICAgIHQgPSBvLmR1cmF0aW9uID8gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIG8uZHVyYXRpb24gOiAxO1xuXG4gICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGlzIG92ZXI6XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID8gdmFsLnggOiBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/IHZhbC55IDogaW5pdGlhbFZhbC55LFxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/IHZhbC5yYXRpbyA6IGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID8gdmFsLmFuZ2xlIDogaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuXG4gICAgICAvLyBFbHNlLCBsZXQncyBrZWVwIGdvaW5nOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29lZiA9IGVhc2luZyh0KTtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICBjYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnggKyAodmFsLnggLSBpbml0aWFsVmFsLngpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnkgKyAodmFsLnkgLSBpbml0aWFsVmFsLnkpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8gKyAodmFsLnJhdGlvIC0gaW5pdGlhbFZhbC5yYXRpbykgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGUgKyAodmFsLmFuZ2xlIC0gaW5pdGlhbFZhbC5hbmdsZSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIG8ub25OZXdGcmFtZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9uTmV3RnJhbWUoKTtcblxuICAgICAgICBhbmltLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZCA9IF9nZXRJRCgpO1xuICAgIGFuaW0gPSB7XG4gICAgICBmcmFtZUlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pLFxuICAgICAgdGFyZ2V0OiBjYW1lcmEsXG4gICAgICB0eXBlOiAnY2FtZXJhJyxcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBmbjogZm5cbiAgICB9O1xuICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdID0gYW5pbTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogS2lsbHMgYSBydW5uaW5nIGFuaW1hdGlvbi4gSXQgdHJpZ2dlcnMgdGhlIGV2ZW50dWFsIG9uQ29tcGxldGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gaWQgIFRoZSBpZCBvZiB0aGUgYW5pbWF0aW9uIHRvIGtpbGwuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFJldHVybnMgdGhlIHNpZ21hLm1pc2MuYW5pbWF0aW9uIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5raWxsOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHZhciBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICBpZiAobykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbby5mcmFtZUlkXTtcblxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBvLm9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nIGFuaW1hdGlvbnMsIG9yIG9ubHkgdGhlIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSxcbiAgICogaWYgYSBzdHJpbmcgcGFyYW1ldGVyIGlzIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xvYmplY3QpfSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGZpbHRlciBvbiB0aGVpciB0YXJnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYW5pbWF0aW9ucyBraWxsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2F5LlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBvLFxuICAgICAgICBpZCxcbiAgICAgICAgY291bnQgPSAwLFxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xuXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxuICAgICAgaWYgKFxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvLmZyYW1lSWQpO1xuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyOlxuICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IGFuaW1hdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBzdGlsbCBydW5uaW5nIG1hdGNoZXNcbiAgICogdGhlIGZpbHRlciBnaXZlbiB0byB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5oYXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgbm8tRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2UgY2FudmFzIG9yIFdlYkdMKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBtWCxcbiAgICAgICAgbVksXG4gICAgICAgIGNhcHRvcixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXROb2RlcyhlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcyxcbiAgICAgICAgICBpbnNlcnRlZCxcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIG1YLFxuICAgICAgICAgICAgbVlcbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGVzID0gc2VsZi5jYW1lcmEucXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnQueVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgeCA9IG5bcHJlZml4ICsgJ3gnXTtcbiAgICAgICAgICB5ID0gbltwcmVmaXggKyAneSddO1xuICAgICAgICAgIHMgPSBuW3ByZWZpeCArICdzaXplJ107XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbi5oaWRkZW4gJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA+IHggLSBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFggPCB4ICsgcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZID4geSAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWSA8IHkgKyBzICYmXG4gICAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIE1hdGgucG93KG1vZGlmaWVkWCAtIHgsIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRZIC0geSwgMilcbiAgICAgICAgICAgICkgPCBzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGU6XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIGlmIChuLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIG4pO1xuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRFZGdlcyhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XG4gICAgICAgIC8vIE5vIGV2ZW50IGlmIHRoZSBzZXR0aW5nIGlzIG9mZjpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDYW52YXMgPSAoXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgJiYgc2VsZiBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5jYW52YXMpO1xuXG4gICAgICBpZiAoIWlzQ2FudmFzKSB7XG4gICAgICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIG5vdCBnb29kIGVub3VnaCBhdCB0aGUgbW9tZW50KTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZWRnZSBldmVudHMgZmVhdHVyZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgZWRnZSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIG1heEVwc2lsb24gPSBzZWxmLnNldHRpbmdzKCdlZGdlSG92ZXJQcmVjaXNpb24nKSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGNwLFxuICAgICAgICAgIG5vZGVJbmRleCA9IHt9LFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgaWYgKGlzQ2FudmFzKSB7XG4gICAgICAgIHZhciBub2Rlc09uU2NyZWVuID0gc2VsZi5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgICAgICBzZWxmLmNhbWVyYS5nZXRSZWN0YW5nbGUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoYSA9IG5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgbm9kZUluZGV4W2FbaV0uaWRdID0gYVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2VzID0gc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlLnBvaW50KFxuICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgcG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKSB7XG4gICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxuICAgICAgICAgIGlmIChlZGdlLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgZWRnZSk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpO1xuICAgICAgICAgIC8vIChIQUNLKSB3ZSBjYW4ndCBnZXQgZWRnZVtwcmVmaXggKyAnc2l6ZSddIG9uIFdlYkdMIHJlbmRlcmVyOlxuICAgICAgICAgIHMgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHxcbiAgICAgICAgICAgICAgZWRnZVsncmVhZF8nICsgcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyBhcmUgZHJhd24uIFRvIGRvIHRoaXMsIHdlIGtlZXBcbiAgICAgICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXG4gICAgICAgICAgLy8gZWRnZXMuXG4gICAgICAgICAgLy8gVGhlbiwgbGV0J3MgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBlZGdlICh3ZSBzdXBwb3NlIHRoYXQgaXRcbiAgICAgICAgICAvLyBpcyBhIGxpbmUgc2VnbWVudCkuXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZWRnZS5oaWRkZW4gJiZcbiAgICAgICAgICAgICFzb3VyY2UuaGlkZGVuICYmICF0YXJnZXQuaGlkZGVuICYmXG4gICAgICAgICAgICAoIWlzQ2FudmFzIHx8XG4gICAgICAgICAgICAgIChub2RlSW5kZXhbZWRnZS5zb3VyY2VdIHx8IG5vZGVJbmRleFtlZGdlLnRhcmdldF0pKSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gc291cmNlW3ByZWZpeCArICdzaXplJ10gJiZcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS50eXBlID09ICdjdXJ2ZScgfHwgZWRnZS50eXBlID09ICdjdXJ2ZWRBcnJvdycpIHtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54MSxcbiAgICAgICAgICAgICAgICAgIGNwLnkxLFxuICAgICAgICAgICAgICAgICAgY3AueDIsXG4gICAgICAgICAgICAgICAgICBjcC55MixcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54LFxuICAgICAgICAgICAgICAgICAgY3AueSxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBiaW5kQ2FwdG9yKGNhcHRvcikge1xuICAgICAgdmFyIG5vZGVzLFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIG92ZXJOb2RlcyA9IHt9LFxuICAgICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsZSxcbiAgICAgICAgICAgIG91dE5vZGVzID0gW10sXG4gICAgICAgICAgICBvdXRFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXG4gICAgICAgICAgb3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuXG4gICAgICAgIG92ZXJOb2RlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG91dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG91dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICBvdmVyRWRnZXMgPSB7fTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBvdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG91dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG91dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Nb3ZlKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgICBuZXdPdXROb2RlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgICBsID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmV3T3V0RWRnZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcyA9IFtdLFxuICAgICAgICAgICAgY3VycmVudE92ZXJFZGdlcyA9IHt9LFxuICAgICAgICAgICAgbGUgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICBpZiAoIW92ZXJOb2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3Zlck5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyTm9kZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyTm9kZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdmVyTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBuZXdPdmVyTm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmV3T3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld091dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJOb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3Zlck5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG5ld091dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGU7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICBpZiAoIW92ZXJFZGdlc1tlZGdlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBlZGdlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJFZGdlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyRWRnZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dEVkZ2VzLnB1c2gob3ZlckVkZ2VzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyRWRnZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3ZlckVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld092ZXJFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3V0RWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBuZXdPdXRFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdmVyRWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld092ZXJFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdXRFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdPdXRFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpbmQgZXZlbnRzOlxuICAgICAgY2FwdG9yLmJpbmQoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vkb3duJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZXVwJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlb3V0Jywgb25PdXQpO1xuICAgICAgY2FwdG9yLmJpbmQoJ2RvdWJsZWNsaWNrJywgb25Eb3VibGVDbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgncmlnaHRjbGljaycsIG9uUmlnaHRDbGljayk7XG4gICAgICBzZWxmLmJpbmQoJ3JlbmRlcicsIG9uTW92ZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2FwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBiaW5kQ2FwdG9yKHRoaXMuY2FwdG9yc1tpXSk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2Ugc3ZnKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgLy8gRE9NRWxlbWVudCBhYnN0cmFjdGlvblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQoZG9tRWxlbWVudCkge1xuXG4gICAgICAvLyBIZWxwZXJzXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBhdHRyTmFtZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnRhZyA9IGRvbUVsZW1lbnQudGFnTmFtZTtcbiAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICB0aGlzLmlkID0gdGhpcy5hdHRyKCdpZCcpO1xuXG4gICAgICAvLyBNZXRob2RzXG4gICAgICB0aGlzLmlzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0hvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2xpY2tcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBEb3VibGUgY2xpY2tcbiAgICBmdW5jdGlvbiBkb3VibGVDbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBPbiBvdmVyXG4gICAgZnVuY3Rpb24gb25PdmVyKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykgfHwgIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoZWwuaXNOb2RlKCkpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIG91dFxuICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLmZyb21FbGVtZW50IHx8IGUub3JpZ2luYWxUYXJnZXQ7XG5cbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWwuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlcyhlbC5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyaW5nIEV2ZW50czpcblxuICAgIC8vIENsaWNrXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICdjbGljaycsIGRvdWJsZUNsaWNrKTtcblxuICAgIC8vIFRvdWNoIGNvdW50ZXJwYXJ0c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICd0b3VjaHN0YXJ0JywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gTW91c2VvdmVyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uT3ZlciwgdHJ1ZSk7XG5cbiAgICAvLyBNb3VzZW91dFxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uT3V0LCB0cnVlKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBcIm92ZXJOb2RlXCIsIFwib3V0Tm9kZVwiLCBcIm92ZXJFZGdlXCIgYW5kIFwib3V0RWRnZVwiXG4gICAqIGV2ZW50cyBmcm9tIGEgcmVuZGVyZXIgYW5kIHJlbmRlcnMgdGhlIG5vZGVzIGRpZmZlcmVudGx5IG9uIHRoZSB0b3AgbGF5ZXIuXG4gICAqIFRoZSBnb2FsIGlzIHRvIG1ha2UgYW55IG5vZGUgbGFiZWwgcmVhZGFibGUgd2l0aCB0aGUgbW91c2UsIGFuZCB0b1xuICAgKiBoaWdobGlnaHQgaG92ZXJlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5kcmF3SG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZXMgPSB7fSxcbiAgICAgICAgaG92ZXJlZEVkZ2VzID0ge307XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQuZGF0YS5ub2RlO1xuICAgICAgaWYgKCFub2RlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWROb2Rlc1tldmVudC5kYXRhLm5vZGUuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdmVyRWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZWRnZSA9IGV2ZW50LmRhdGEuZWRnZTtcbiAgICAgIGlmICghZWRnZS5oaWRkZW4pIHtcbiAgICAgICAgaG92ZXJlZEVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdXRFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBob3ZlcmVkRWRnZXNbZXZlbnQuZGF0YS5lZGdlLmlkXTtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG5cbiAgICAgIHZhciBrLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgYyA9IHNlbGYuY29udGV4dHMuaG92ZXIuY2FudmFzLFxuICAgICAgICAgIGRlZmF1bHROb2RlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHROb2RlVHlwZScpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuaG92ZXJzLFxuICAgICAgICAgIGVkZ2VSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZWhvdmVycyxcbiAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcyxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ2xlYXIgc2VsZi5jb250ZXh0cy5ob3ZlcjpcbiAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIuY2xlYXJSZWN0KDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcblxuICAgICAgLy8gTm9kZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZE5vZGVzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkTm9kZSA9IGhvdmVyZWROb2Rlc1tPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpWzBdXTtcbiAgICAgICAgKFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzLmRlZlxuICAgICAgICApKFxuICAgICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogbXVsdGlwbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKVxuICAgICAgICBmb3IgKGsgaW4gaG92ZXJlZE5vZGVzKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGVzW2tdLnR5cGVdIHx8XG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgKShcbiAgICAgICAgICAgIGhvdmVyZWROb2Rlc1trXSxcbiAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgLy8gRWRnZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyZWRFZGdlcykubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNbT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKVswXV07XG4gICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgIGlmICghIGhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgIChcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApIChcbiAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICApKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXZvaWQgZWRnZXMgcmVuZGVyZWQgb3ZlciBub2RlczpcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2UgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkRWRnZXMpIHtcbiAgICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1trXTtcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKCFob3ZlcmVkRWRnZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gfHxcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgICApKFxuICAgICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3RhcmdldC50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2FkYXB0b3JcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZDNhZGFwdG9yXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2Rlc2NlbnRcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZ2VvbVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9ncmlkcm91dGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2hhbmRsZWRpc2Nvbm5lY3RlZFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9sYXlvdXRcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvbGF5b3V0M2RcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvbGlua2xlbmd0aHNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvcG93ZXJncmFwaFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9wcXVldWVcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvcmJ0cmVlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3JlY3RhbmdsZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9zaG9ydGVzdHBhdGhzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3Zwc2NcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvYmF0Y2hcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGxheW91dF8xID0gcmVxdWlyZShcIi4vbGF5b3V0XCIpO1xyXG52YXIgTGF5b3V0QWRhcHRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGF5b3V0QWRhcHRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExheW91dEFkYXB0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcclxuICAgICAgICB2YXIgbyA9IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKG8udHJpZ2dlcikge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyID0gby50cmlnZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoby5raWNrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmtpY2sgPSBvLmtpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvLmRyYWcpIHtcclxuICAgICAgICAgICAgX3RoaXMuZHJhZyA9IG8uZHJhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG8ub24pIHtcclxuICAgICAgICAgICAgX3RoaXMub24gPSBvLm9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5kcmFnc3RhcnQgPSBfdGhpcy5kcmFnU3RhcnQgPSBsYXlvdXRfMS5MYXlvdXQuZHJhZ1N0YXJ0O1xyXG4gICAgICAgIF90aGlzLmRyYWdlbmQgPSBfdGhpcy5kcmFnRW5kID0gbGF5b3V0XzEuTGF5b3V0LmRyYWdFbmQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTGF5b3V0QWRhcHRvci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChlKSB7IH07XHJcbiAgICA7XHJcbiAgICBMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5raWNrID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgO1xyXG4gICAgTGF5b3V0QWRhcHRvci5wcm90b3R5cGUuZHJhZyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIDtcclxuICAgIExheW91dEFkYXB0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHsgcmV0dXJuIHRoaXM7IH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gTGF5b3V0QWRhcHRvcjtcclxufShsYXlvdXRfMS5MYXlvdXQpKTtcclxuZXhwb3J0cy5MYXlvdXRBZGFwdG9yID0gTGF5b3V0QWRhcHRvcjtcclxuZnVuY3Rpb24gYWRhcHRvcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IExheW91dEFkYXB0b3Iob3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5hZGFwdG9yID0gYWRhcHRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXRcIik7XHJcbnZhciBncmlkcm91dGVyXzEgPSByZXF1aXJlKFwiLi9ncmlkcm91dGVyXCIpO1xyXG5mdW5jdGlvbiBncmlkaWZ5KHBnTGF5b3V0LCBudWRnZUdhcCwgbWFyZ2luLCBncm91cE1hcmdpbikge1xyXG4gICAgcGdMYXlvdXQuY29sYS5zdGFydCgwLCAwLCAwLCAxMCwgZmFsc2UpO1xyXG4gICAgdmFyIGdyaWRyb3V0ZXIgPSByb3V0ZShwZ0xheW91dC5jb2xhLm5vZGVzKCksIHBnTGF5b3V0LmNvbGEuZ3JvdXBzKCksIG1hcmdpbiwgZ3JvdXBNYXJnaW4pO1xyXG4gICAgcmV0dXJuIGdyaWRyb3V0ZXIucm91dGVFZGdlcyhwZ0xheW91dC5wb3dlckdyYXBoLnBvd2VyRWRnZXMsIG51ZGdlR2FwLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zb3VyY2Uucm91dGVyTm9kZS5pZDsgfSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudGFyZ2V0LnJvdXRlck5vZGUuaWQ7IH0pO1xyXG59XHJcbmV4cG9ydHMuZ3JpZGlmeSA9IGdyaWRpZnk7XHJcbmZ1bmN0aW9uIHJvdXRlKG5vZGVzLCBncm91cHMsIG1hcmdpbiwgZ3JvdXBNYXJnaW4pIHtcclxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkLnJvdXRlck5vZGUgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGQubmFtZSxcclxuICAgICAgICAgICAgYm91bmRzOiBkLmJvdW5kcy5pbmZsYXRlKC1tYXJnaW4pXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkLnJvdXRlck5vZGUgPSB7XHJcbiAgICAgICAgICAgIGJvdW5kczogZC5ib3VuZHMuaW5mbGF0ZSgtZ3JvdXBNYXJnaW4pLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogKHR5cGVvZiBkLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcgPyBkLmdyb3Vwcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5vZGVzLmxlbmd0aCArIGMuaWQ7IH0pIDogW10pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHR5cGVvZiBkLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcgPyBkLmxlYXZlcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuaW5kZXg7IH0pIDogW10pXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGdyaWRSb3V0ZXJOb2RlcyA9IG5vZGVzLmNvbmNhdChncm91cHMpLm1hcChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIGQucm91dGVyTm9kZS5pZCA9IGk7XHJcbiAgICAgICAgcmV0dXJuIGQucm91dGVyTm9kZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBncmlkcm91dGVyXzEuR3JpZFJvdXRlcihncmlkUm91dGVyTm9kZXMsIHtcclxuICAgICAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuY2hpbGRyZW47IH0sXHJcbiAgICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5ib3VuZHM7IH1cclxuICAgIH0sIG1hcmdpbiAtIGdyb3VwTWFyZ2luKTtcclxufVxyXG5mdW5jdGlvbiBwb3dlckdyYXBoR3JpZExheW91dChncmFwaCwgc2l6ZSwgZ3JvdXBwYWRkaW5nKSB7XHJcbiAgICB2YXIgcG93ZXJHcmFwaDtcclxuICAgIGdyYXBoLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYuaW5kZXggPSBpOyB9KTtcclxuICAgIG5ldyBsYXlvdXRfMS5MYXlvdXQoKVxyXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKGZhbHNlKVxyXG4gICAgICAgIC5ub2RlcyhncmFwaC5ub2RlcylcclxuICAgICAgICAubGlua3MoZ3JhcGgubGlua3MpXHJcbiAgICAgICAgLnBvd2VyR3JhcGhHcm91cHMoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBwb3dlckdyYXBoID0gZDtcclxuICAgICAgICBwb3dlckdyYXBoLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnBhZGRpbmcgPSBncm91cHBhZGRpbmc7IH0pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgbiA9IGdyYXBoLm5vZGVzLmxlbmd0aDtcclxuICAgIHZhciBlZGdlcyA9IFtdO1xyXG4gICAgdmFyIHZzID0gZ3JhcGgubm9kZXMuc2xpY2UoMCk7XHJcbiAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiB2LmluZGV4ID0gaTsgfSk7XHJcbiAgICBwb3dlckdyYXBoLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZUluZCA9IGcuaW5kZXggPSBnLmlkICsgbjtcclxuICAgICAgICB2cy5wdXNoKGcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZy5sZWF2ZXMgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBnLmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBlZGdlcy5wdXNoKHsgc291cmNlOiBzb3VyY2VJbmQsIHRhcmdldDogdi5pbmRleCB9KTsgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGcuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdnKSB7IHJldHVybiBlZGdlcy5wdXNoKHsgc291cmNlOiBzb3VyY2VJbmQsIHRhcmdldDogZ2cuaWQgKyBuIH0pOyB9KTtcclxuICAgIH0pO1xyXG4gICAgcG93ZXJHcmFwaC5wb3dlckVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBlLnNvdXJjZS5pbmRleCwgdGFyZ2V0OiBlLnRhcmdldC5pbmRleCB9KTtcclxuICAgIH0pO1xyXG4gICAgbmV3IGxheW91dF8xLkxheW91dCgpXHJcbiAgICAgICAgLnNpemUoc2l6ZSlcclxuICAgICAgICAubm9kZXModnMpXHJcbiAgICAgICAgLmxpbmtzKGVkZ2VzKVxyXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKGZhbHNlKVxyXG4gICAgICAgIC5saW5rRGlzdGFuY2UoMzApXHJcbiAgICAgICAgLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3Rocyg1KVxyXG4gICAgICAgIC5jb252ZXJnZW5jZVRocmVzaG9sZCgxZS00KVxyXG4gICAgICAgIC5zdGFydCgxMDAsIDAsIDAsIDAsIGZhbHNlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29sYTogbmV3IGxheW91dF8xLkxheW91dCgpXHJcbiAgICAgICAgICAgIC5jb252ZXJnZW5jZVRocmVzaG9sZCgxZS0zKVxyXG4gICAgICAgICAgICAuc2l6ZShzaXplKVxyXG4gICAgICAgICAgICAuYXZvaWRPdmVybGFwcyh0cnVlKVxyXG4gICAgICAgICAgICAubm9kZXMoZ3JhcGgubm9kZXMpXHJcbiAgICAgICAgICAgIC5saW5rcyhncmFwaC5saW5rcylcclxuICAgICAgICAgICAgLmdyb3VwQ29tcGFjdG5lc3MoMWUtNClcclxuICAgICAgICAgICAgLmxpbmtEaXN0YW5jZSgzMClcclxuICAgICAgICAgICAgLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3Rocyg1KVxyXG4gICAgICAgICAgICAucG93ZXJHcmFwaEdyb3VwcyhmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBwb3dlckdyYXBoID0gZDtcclxuICAgICAgICAgICAgcG93ZXJHcmFwaC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdi5wYWRkaW5nID0gZ3JvdXBwYWRkaW5nO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KS5zdGFydCg1MCwgMCwgMTAwLCAwLCBmYWxzZSksXHJcbiAgICAgICAgcG93ZXJHcmFwaDogcG93ZXJHcmFwaFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBvd2VyR3JhcGhHcmlkTGF5b3V0ID0gcG93ZXJHcmFwaEdyaWRMYXlvdXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkM3YzID0gcmVxdWlyZShcIi4vZDN2M2FkYXB0b3JcIik7XHJcbnZhciBkM3Y0ID0gcmVxdWlyZShcIi4vZDN2NGFkYXB0b3JcIik7XHJcbjtcclxuZnVuY3Rpb24gZDNhZGFwdG9yKGQzQ29udGV4dCkge1xyXG4gICAgaWYgKCFkM0NvbnRleHQgfHwgaXNEM1YzKGQzQ29udGV4dCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGQzdjMuRDNTdHlsZUxheW91dEFkYXB0b3IoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgZDN2NC5EM1N0eWxlTGF5b3V0QWRhcHRvcihkM0NvbnRleHQpO1xyXG59XHJcbmV4cG9ydHMuZDNhZGFwdG9yID0gZDNhZGFwdG9yO1xyXG5mdW5jdGlvbiBpc0QzVjMoZDNDb250ZXh0KSB7XHJcbiAgICB2YXIgdjNleHAgPSAvXjNcXC4vO1xyXG4gICAgcmV0dXJuIGQzQ29udGV4dC52ZXJzaW9uICYmIGQzQ29udGV4dC52ZXJzaW9uLm1hdGNoKHYzZXhwKSAhPT0gbnVsbDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kM2FkYXB0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2xheW91dFwiKTtcclxudmFyIEQzU3R5bGVMYXlvdXRBZGFwdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEM1N0eWxlTGF5b3V0QWRhcHRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEQzU3R5bGVMYXlvdXRBZGFwdG9yKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXZlbnQgPSBkMy5kaXNwYXRjaChsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLnN0YXJ0XSwgbGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS50aWNrXSwgbGF5b3V0XzEuRXZlbnRUeXBlW2xheW91dF8xLkV2ZW50VHlwZS5lbmRdKTtcclxuICAgICAgICB2YXIgZDNsYXlvdXQgPSBfdGhpcztcclxuICAgICAgICB2YXIgZHJhZztcclxuICAgICAgICBfdGhpcy5kcmFnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIWRyYWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9yaWdpbihsYXlvdXRfMS5MYXlvdXQuZHJhZ09yaWdpbilcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJkcmFnc3RhcnQuZDNhZGFwdG9yXCIsIGxheW91dF8xLkxheW91dC5kcmFnU3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiZHJhZy5kM2FkYXB0b3JcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRfMS5MYXlvdXQuZHJhZyhkLCBkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZDNsYXlvdXQucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImRyYWdlbmQuZDNhZGFwdG9yXCIsIGxheW91dF8xLkxheW91dC5kcmFnRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZztcclxuICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAgICAgLmNhbGwoZHJhZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGQzZXZlbnQgPSB7IHR5cGU6IGxheW91dF8xLkV2ZW50VHlwZVtlLnR5cGVdLCBhbHBoYTogZS5hbHBoYSwgc3RyZXNzOiBlLnN0cmVzcyB9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRbZDNldmVudC50eXBlXShkM2V2ZW50KTtcclxuICAgIH07XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUua2ljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGQzLnRpbWVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudGljay5jYWxsKF90aGlzKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRDNTdHlsZUxheW91dEFkYXB0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudC5vbihldmVudFR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQub24obGF5b3V0XzEuRXZlbnRUeXBlW2V2ZW50VHlwZV0sIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEQzU3R5bGVMYXlvdXRBZGFwdG9yO1xyXG59KGxheW91dF8xLkxheW91dCkpO1xyXG5leHBvcnRzLkQzU3R5bGVMYXlvdXRBZGFwdG9yID0gRDNTdHlsZUxheW91dEFkYXB0b3I7XHJcbmZ1bmN0aW9uIGQzYWRhcHRvcigpIHtcclxuICAgIHJldHVybiBuZXcgRDNTdHlsZUxheW91dEFkYXB0b3IoKTtcclxufVxyXG5leHBvcnRzLmQzYWRhcHRvciA9IGQzYWRhcHRvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZDN2M2FkYXB0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2xheW91dFwiKTtcclxudmFyIEQzU3R5bGVMYXlvdXRBZGFwdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEM1N0eWxlTGF5b3V0QWRhcHRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEQzU3R5bGVMYXlvdXRBZGFwdG9yKGQzQ29udGV4dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZDNDb250ZXh0ID0gZDNDb250ZXh0O1xyXG4gICAgICAgIF90aGlzLmV2ZW50ID0gZDNDb250ZXh0LmRpc3BhdGNoKGxheW91dF8xLkV2ZW50VHlwZVtsYXlvdXRfMS5FdmVudFR5cGUuc3RhcnRdLCBsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLnRpY2tdLCBsYXlvdXRfMS5FdmVudFR5cGVbbGF5b3V0XzEuRXZlbnRUeXBlLmVuZF0pO1xyXG4gICAgICAgIHZhciBkM2xheW91dCA9IF90aGlzO1xyXG4gICAgICAgIHZhciBkcmFnO1xyXG4gICAgICAgIF90aGlzLmRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghZHJhZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWcgPSBkM0NvbnRleHQuZHJhZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN1YmplY3QobGF5b3V0XzEuTGF5b3V0LmRyYWdPcmlnaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwic3RhcnQuZDNhZGFwdG9yXCIsIGxheW91dF8xLkxheW91dC5kcmFnU3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKFwiZHJhZy5kM2FkYXB0b3JcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXlvdXRfMS5MYXlvdXQuZHJhZyhkLCBkM0NvbnRleHQuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQzbGF5b3V0LnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAub24oXCJlbmQuZDNhZGFwdG9yXCIsIGxheW91dF8xLkxheW91dC5kcmFnRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhZztcclxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmNhbGwoZHJhZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEM1N0eWxlTGF5b3V0QWRhcHRvci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGQzZXZlbnQgPSB7IHR5cGU6IGxheW91dF8xLkV2ZW50VHlwZVtlLnR5cGVdLCBhbHBoYTogZS5hbHBoYSwgc3RyZXNzOiBlLnN0cmVzcyB9O1xyXG4gICAgICAgIHRoaXMuZXZlbnQuY2FsbChkM2V2ZW50LnR5cGUsIGQzZXZlbnQpO1xyXG4gICAgfTtcclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5raWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmQzQ29udGV4dC50aW1lcihmdW5jdGlvbiAoKSB7IHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRpY2suY2FsbChfdGhpcykgJiYgdC5zdG9wKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIEQzU3R5bGVMYXlvdXRBZGFwdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudFR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnQub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50Lm9uKGxheW91dF8xLkV2ZW50VHlwZVtldmVudFR5cGVdLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEM1N0eWxlTGF5b3V0QWRhcHRvcjtcclxufShsYXlvdXRfMS5MYXlvdXQpKTtcclxuZXhwb3J0cy5EM1N0eWxlTGF5b3V0QWRhcHRvciA9IEQzU3R5bGVMYXlvdXRBZGFwdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kM3Y0YWRhcHRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTG9ja3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9ja3MoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgTG9ja3MucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpZCwgeCkge1xyXG4gICAgICAgIHRoaXMubG9ja3NbaWRdID0geDtcclxuICAgIH07XHJcbiAgICBMb2Nrcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrcyA9IHt9O1xyXG4gICAgfTtcclxuICAgIExvY2tzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGwgaW4gdGhpcy5sb2NrcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIExvY2tzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbCBpbiB0aGlzLmxvY2tzKSB7XHJcbiAgICAgICAgICAgIGYoTnVtYmVyKGwpLCB0aGlzLmxvY2tzW2xdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvY2tzO1xyXG59KCkpO1xyXG5leHBvcnRzLkxvY2tzID0gTG9ja3M7XHJcbnZhciBEZXNjZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlc2NlbnQoeCwgRCwgRykge1xyXG4gICAgICAgIGlmIChHID09PSB2b2lkIDApIHsgRyA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLkQgPSBEO1xyXG4gICAgICAgIHRoaXMuRyA9IEc7XHJcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSAwLjAwMDE7XHJcbiAgICAgICAgdGhpcy5udW1HcmlkU25hcE5vZGVzID0gMDtcclxuICAgICAgICB0aGlzLnNuYXBHcmlkU2l6ZSA9IDEwMDtcclxuICAgICAgICB0aGlzLnNuYXBTdHJlbmd0aCA9IDEwMDA7XHJcbiAgICAgICAgdGhpcy5zY2FsZVNuYXBCeU1heEggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJhbmRvbSA9IG5ldyBQc2V1ZG9SYW5kb20oKTtcclxuICAgICAgICB0aGlzLnByb2plY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy5rID0geC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLm4gPSB4WzBdLmxlbmd0aDtcclxuICAgICAgICB0aGlzLkggPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmcgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLkhkID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5hID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5iID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5jID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5kID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5lID0gbmV3IEFycmF5KHRoaXMuayk7XHJcbiAgICAgICAgdGhpcy5pYSA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHRoaXMuaWIgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLnh0bXAgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB0aGlzLmxvY2tzID0gbmV3IExvY2tzKCk7XHJcbiAgICAgICAgdGhpcy5taW5EID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgaSA9IG4sIGo7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBqID0gbjtcclxuICAgICAgICAgICAgd2hpbGUgKC0taiA+IGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gRFtpXVtqXTtcclxuICAgICAgICAgICAgICAgIGlmIChkID4gMCAmJiBkIDwgdGhpcy5taW5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5EID0gZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5taW5EID09PSBOdW1iZXIuTUFYX1ZBTFVFKVxyXG4gICAgICAgICAgICB0aGlzLm1pbkQgPSAxO1xyXG4gICAgICAgIGkgPSB0aGlzLms7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmdbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuSFtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgaiA9IG47XHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuSFtpXVtqXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLkhkW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmFbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuYltpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5jW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICB0aGlzLmRbaV0gPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgICAgIHRoaXMuZVtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5pYVtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy5pYltpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgdGhpcy54dG1wW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIERlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4ID0gZnVuY3Rpb24gKG4sIGYpIHtcclxuICAgICAgICB2YXIgTSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICBNW2ldID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xyXG4gICAgICAgICAgICAgICAgTVtpXVtqXSA9IGYoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE07XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUub2Zmc2V0RGlyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHUgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHVbaV0gPSB0aGlzLnJhbmRvbS5nZXROZXh0QmV0d2VlbigwLjAxLCAxKSAtIDAuNTtcclxuICAgICAgICAgICAgbCArPSB4ICogeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCA9IE1hdGguc3FydChsKTtcclxuICAgICAgICByZXR1cm4gdS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKj0gX3RoaXMubWluRCAvIGw7IH0pO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLmNvbXB1dGVEZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbiA9IHRoaXMubjtcclxuICAgICAgICBpZiAobiA8IDEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZCA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHZhciBkMiA9IG5ldyBBcnJheSh0aGlzLmspO1xyXG4gICAgICAgIHZhciBIdXUgPSBuZXcgQXJyYXkodGhpcy5rKTtcclxuICAgICAgICB2YXIgbWF4SCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBuOyArK3UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKVxyXG4gICAgICAgICAgICAgICAgSHV1W2ldID0gdGhpcy5nW2ldW3VdID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBuOyArK3YpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1ID09PSB2KVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heERpc3BsYWNlcyA9IG47XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobWF4RGlzcGxhY2VzLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2QyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gZFtpXSA9IHhbaV1bdV0gLSB4W2ldW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZDIgKz0gZDJbaV0gPSBkeCAqIGR4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2QyID4gMWUtOSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJkID0gdGhpcy5vZmZzZXREaXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhbaV1bdl0gKz0gcmRbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydChzZDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIEQgPSB0aGlzLkRbdV1bdl07XHJcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy5HICE9IG51bGwgPyB0aGlzLkdbdV1bdl0gOiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDEgJiYgbCA+IEQgfHwgIWlzRmluaXRlKEQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkhbaV1bdV1bdl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIEQyID0gRCAqIEQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3MgPSAyICogd2VpZ2h0ICogKGwgLSBEKSAvIChEMiAqIGwpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGwzID0gbCAqIGwgKiBsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhzID0gMiAqIC13ZWlnaHQgLyAoRDIgKiBsMyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGdzKSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5rOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdbaV1bdV0gKz0gZFtpXSAqIGdzO1xyXG4gICAgICAgICAgICAgICAgICAgIEh1dVtpXSAtPSB0aGlzLkhbaV1bdV1bdl0gPSBocyAqIChsMyArIEQgKiAoZDJbaV0gLSBzZDIpICsgbCAqIHNkMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKVxyXG4gICAgICAgICAgICAgICAgbWF4SCA9IE1hdGgubWF4KG1heEgsIHRoaXMuSFtpXVt1XVt1XSA9IEh1dVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByID0gdGhpcy5zbmFwR3JpZFNpemUgLyAyO1xyXG4gICAgICAgIHZhciBnID0gdGhpcy5zbmFwR3JpZFNpemU7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLnNuYXBTdHJlbmd0aDtcclxuICAgICAgICB2YXIgayA9IHcgLyAociAqIHIpO1xyXG4gICAgICAgIHZhciBudW1Ob2RlcyA9IHRoaXMubnVtR3JpZFNuYXBOb2RlcztcclxuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IG51bU5vZGVzOyArK3UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGl1ID0gdGhpcy54W2ldW3VdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSB4aXUgLyBnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBtICUgMTtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gbSAtIGY7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IE1hdGguYWJzKGYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gKGEgPD0gMC41KSA/IHhpdSAtIHEgKiBnIDpcclxuICAgICAgICAgICAgICAgICAgICAoeGl1ID4gMCkgPyB4aXUgLSAocSArIDEpICogZyA6IHhpdSAtIChxIC0gMSkgKiBnO1xyXG4gICAgICAgICAgICAgICAgaWYgKC1yIDwgZHggJiYgZHggPD0gcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlU25hcEJ5TWF4SCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdbaV1bdV0gKz0gbWF4SCAqIGsgKiBkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5IW2ldW3VdW3VdICs9IG1heEggKiBrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nW2ldW3VdICs9IGsgKiBkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5IW2ldW3VdW3VdICs9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5sb2Nrcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2Nrcy5hcHBseShmdW5jdGlvbiAodSwgcCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF90aGlzLms7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLkhbaV1bdV1bdV0gKz0gbWF4SDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nW2ldW3VdIC09IG1heEggKiAocFtpXSAtIHhbaV1bdV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5kb3RQcm9kID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgeCA9IDAsIGkgPSBhLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICB4ICs9IGFbaV0gKiBiW2ldO1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucmlnaHRNdWx0aXBseSA9IGZ1bmN0aW9uIChtLCB2LCByKSB7XHJcbiAgICAgICAgdmFyIGkgPSBtLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICByW2ldID0gRGVzY2VudC5kb3RQcm9kKG1baV0sIHYpO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLmNvbXB1dGVTdGVwU2l6ZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIG51bWVyYXRvciA9IDAsIGRlbm9taW5hdG9yID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgIG51bWVyYXRvciArPSBEZXNjZW50LmRvdFByb2QodGhpcy5nW2ldLCBkW2ldKTtcclxuICAgICAgICAgICAgRGVzY2VudC5yaWdodE11bHRpcGx5KHRoaXMuSFtpXSwgZFtpXSwgdGhpcy5IZFtpXSk7XHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IERlc2NlbnQuZG90UHJvZChkW2ldLCB0aGlzLkhkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwIHx8ICFpc0Zpbml0ZShkZW5vbWluYXRvcikpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiAxICogbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUucmVkdWNlU3RyZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZURlcml2YXRpdmVzKHRoaXMueCk7XHJcbiAgICAgICAgdmFyIGFscGhhID0gdGhpcy5jb21wdXRlU3RlcFNpemUodGhpcy5nKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFrZURlc2NlbnRTdGVwKHRoaXMueFtpXSwgdGhpcy5nW2ldLCBhbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVTdHJlc3MoKTtcclxuICAgIH07XHJcbiAgICBEZXNjZW50LmNvcHkgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBtID0gYS5sZW5ndGgsIG4gPSBiWzBdLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xyXG4gICAgICAgICAgICAgICAgYltpXVtqXSA9IGFbaV1bal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUuc3RlcEFuZFByb2plY3QgPSBmdW5jdGlvbiAoeDAsIHIsIGQsIHN0ZXBTaXplKSB7XHJcbiAgICAgICAgRGVzY2VudC5jb3B5KHgwLCByKTtcclxuICAgICAgICB0aGlzLnRha2VEZXNjZW50U3RlcChyWzBdLCBkWzBdLCBzdGVwU2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdClcclxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0WzBdKHgwWzBdLCB4MFsxXSwgclswXSk7XHJcbiAgICAgICAgdGhpcy50YWtlRGVzY2VudFN0ZXAoclsxXSwgZFsxXSwgc3RlcFNpemUpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpXHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdFsxXShyWzBdLCB4MFsxXSwgclsxXSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0aGlzLms7IGkrKylcclxuICAgICAgICAgICAgdGhpcy50YWtlRGVzY2VudFN0ZXAocltpXSwgZFtpXSwgc3RlcFNpemUpO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQubUFwcGx5ID0gZnVuY3Rpb24gKG0sIG4sIGYpIHtcclxuICAgICAgICB2YXIgaSA9IG07XHJcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGogPSBuO1xyXG4gICAgICAgICAgICB3aGlsZSAoai0tID4gMClcclxuICAgICAgICAgICAgICAgIGYoaSwgaik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLm1hdHJpeEFwcGx5ID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBEZXNjZW50Lm1BcHBseSh0aGlzLmssIHRoaXMubiwgZik7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUuY29tcHV0ZU5leHRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4MCwgcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlRGVyaXZhdGl2ZXMoeDApO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IHRoaXMuY29tcHV0ZVN0ZXBTaXplKHRoaXMuZyk7XHJcbiAgICAgICAgdGhpcy5zdGVwQW5kUHJvamVjdCh4MCwgciwgdGhpcy5nLCBhbHBoYSk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeEFwcGx5KGZ1bmN0aW9uIChpLCBqKSB7IHJldHVybiBfdGhpcy5lW2ldW2pdID0geDBbaV1bal0gLSByW2ldW2pdOyB9KTtcclxuICAgICAgICAgICAgdmFyIGJldGEgPSB0aGlzLmNvbXB1dGVTdGVwU2l6ZSh0aGlzLmUpO1xyXG4gICAgICAgICAgICBiZXRhID0gTWF0aC5tYXgoMC4yLCBNYXRoLm1pbihiZXRhLCAxKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcEFuZFByb2plY3QoeDAsIHIsIHRoaXMuZSwgYmV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlc2NlbnQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN0cmVzcyA9IE51bWJlci5NQVhfVkFMVUUsIGNvbnZlcmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlICghY29udmVyZ2VkICYmIGl0ZXJhdGlvbnMtLSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnJ1bmdlS3V0dGEoKTtcclxuICAgICAgICAgICAgY29udmVyZ2VkID0gTWF0aC5hYnMoc3RyZXNzIC8gcyAtIDEpIDwgdGhpcy50aHJlc2hvbGQ7XHJcbiAgICAgICAgICAgIHN0cmVzcyA9IHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJlc3M7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUucnVuZ2VLdXR0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZU5leHRQb3NpdGlvbih0aGlzLngsIHRoaXMuYSk7XHJcbiAgICAgICAgRGVzY2VudC5taWQodGhpcy54LCB0aGlzLmEsIHRoaXMuaWEpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZU5leHRQb3NpdGlvbih0aGlzLmlhLCB0aGlzLmIpO1xyXG4gICAgICAgIERlc2NlbnQubWlkKHRoaXMueCwgdGhpcy5iLCB0aGlzLmliKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVOZXh0UG9zaXRpb24odGhpcy5pYiwgdGhpcy5jKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVOZXh0UG9zaXRpb24odGhpcy5jLCB0aGlzLmQpO1xyXG4gICAgICAgIHZhciBkaXNwID0gMDtcclxuICAgICAgICB0aGlzLm1hdHJpeEFwcGx5KGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKF90aGlzLmFbaV1bal0gKyAyLjAgKiBfdGhpcy5iW2ldW2pdICsgMi4wICogX3RoaXMuY1tpXVtqXSArIF90aGlzLmRbaV1bal0pIC8gNi4wLCBkID0gX3RoaXMueFtpXVtqXSAtIHg7XHJcbiAgICAgICAgICAgIGRpc3AgKz0gZCAqIGQ7XHJcbiAgICAgICAgICAgIF90aGlzLnhbaV1bal0gPSB4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkaXNwO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQubWlkID0gZnVuY3Rpb24gKGEsIGIsIG0pIHtcclxuICAgICAgICBEZXNjZW50Lm1BcHBseShhLmxlbmd0aCwgYVswXS5sZW5ndGgsIGZ1bmN0aW9uIChpLCBqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtW2ldW2pdID0gYVtpXVtqXSArIChiW2ldW2pdIC0gYVtpXVtqXSkgLyAyLjA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUudGFrZURlc2NlbnRTdGVwID0gZnVuY3Rpb24gKHgsIGQsIHN0ZXBTaXplKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm47ICsraSkge1xyXG4gICAgICAgICAgICB4W2ldID0geFtpXSAtIHN0ZXBTaXplICogZFtpXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVzY2VudC5wcm90b3R5cGUuY29tcHV0ZVN0cmVzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RyZXNzID0gMDtcclxuICAgICAgICBmb3IgKHZhciB1ID0gMCwgbk1pbnVzMSA9IHRoaXMubiAtIDE7IHUgPCBuTWludXMxOyArK3UpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdiA9IHUgKyAxLCBuID0gdGhpcy5uOyB2IDwgbjsgKyt2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuazsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gdGhpcy54W2ldW3VdIC0gdGhpcy54W2ldW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgKz0gZHggKiBkeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGwgPSBNYXRoLnNxcnQobCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuRFt1XVt2XTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmwgPSBkIC0gbDtcclxuICAgICAgICAgICAgICAgIHZhciBkMiA9IGQgKiBkO1xyXG4gICAgICAgICAgICAgICAgc3RyZXNzICs9IHJsICogcmwgLyBkMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyZXNzO1xyXG4gICAgfTtcclxuICAgIERlc2NlbnQuemVyb0Rpc3RhbmNlID0gMWUtMTA7XHJcbiAgICByZXR1cm4gRGVzY2VudDtcclxufSgpKTtcclxuZXhwb3J0cy5EZXNjZW50ID0gRGVzY2VudDtcclxudmFyIFBzZXVkb1JhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQc2V1ZG9SYW5kb20oc2VlZCkge1xyXG4gICAgICAgIGlmIChzZWVkID09PSB2b2lkIDApIHsgc2VlZCA9IDE7IH1cclxuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xyXG4gICAgICAgIHRoaXMuYSA9IDIxNDAxMztcclxuICAgICAgICB0aGlzLmMgPSAyNTMxMDExO1xyXG4gICAgICAgIHRoaXMubSA9IDIxNDc0ODM2NDg7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IDMyNzY3O1xyXG4gICAgfVxyXG4gICAgUHNldWRvUmFuZG9tLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VlZCA9ICh0aGlzLnNlZWQgKiB0aGlzLmEgKyB0aGlzLmMpICUgdGhpcy5tO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zZWVkID4+IDE2KSAvIHRoaXMucmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgUHNldWRvUmFuZG9tLnByb3RvdHlwZS5nZXROZXh0QmV0d2VlbiA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBtaW4gKyB0aGlzLmdldE5leHQoKSAqIChtYXggLSBtaW4pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQc2V1ZG9SYW5kb207XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHNldWRvUmFuZG9tID0gUHNldWRvUmFuZG9tO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXNjZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGVcIik7XHJcbnZhciBQb2ludCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb2ludCgpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBQb2ludDtcclxufSgpKTtcclxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xyXG52YXIgTGluZVNlZ21lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGluZVNlZ21lbnQoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICB0aGlzLngxID0geDE7XHJcbiAgICAgICAgdGhpcy55MSA9IHkxO1xyXG4gICAgICAgIHRoaXMueDIgPSB4MjtcclxuICAgICAgICB0aGlzLnkyID0geTI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTGluZVNlZ21lbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTGluZVNlZ21lbnQgPSBMaW5lU2VnbWVudDtcclxudmFyIFBvbHlQb2ludCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUG9seVBvaW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUG9seVBvaW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBQb2x5UG9pbnQ7XHJcbn0oUG9pbnQpKTtcclxuZXhwb3J0cy5Qb2x5UG9pbnQgPSBQb2x5UG9pbnQ7XHJcbmZ1bmN0aW9uIGlzTGVmdChQMCwgUDEsIFAyKSB7XHJcbiAgICByZXR1cm4gKFAxLnggLSBQMC54KSAqIChQMi55IC0gUDAueSkgLSAoUDIueCAtIFAwLngpICogKFAxLnkgLSBQMC55KTtcclxufVxyXG5leHBvcnRzLmlzTGVmdCA9IGlzTGVmdDtcclxuZnVuY3Rpb24gYWJvdmUocCwgdmksIHZqKSB7XHJcbiAgICByZXR1cm4gaXNMZWZ0KHAsIHZpLCB2aikgPiAwO1xyXG59XHJcbmZ1bmN0aW9uIGJlbG93KHAsIHZpLCB2aikge1xyXG4gICAgcmV0dXJuIGlzTGVmdChwLCB2aSwgdmopIDwgMDtcclxufVxyXG5mdW5jdGlvbiBDb252ZXhIdWxsKFMpIHtcclxuICAgIHZhciBQID0gUy5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnggIT09IGIueCA/IGIueCAtIGEueCA6IGIueSAtIGEueTsgfSk7XHJcbiAgICB2YXIgbiA9IFMubGVuZ3RoLCBpO1xyXG4gICAgdmFyIG1pbm1pbiA9IDA7XHJcbiAgICB2YXIgeG1pbiA9IFBbMF0ueDtcclxuICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICBpZiAoUFtpXS54ICE9PSB4bWluKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHZhciBtaW5tYXggPSBpIC0gMTtcclxuICAgIHZhciBIID0gW107XHJcbiAgICBILnB1c2goUFttaW5taW5dKTtcclxuICAgIGlmIChtaW5tYXggPT09IG4gLSAxKSB7XHJcbiAgICAgICAgaWYgKFBbbWlubWF4XS55ICE9PSBQW21pbm1pbl0ueSlcclxuICAgICAgICAgICAgSC5wdXNoKFBbbWlubWF4XSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbWF4bWluLCBtYXhtYXggPSBuIC0gMTtcclxuICAgICAgICB2YXIgeG1heCA9IFBbbiAtIDFdLng7XHJcbiAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICBpZiAoUFtpXS54ICE9PSB4bWF4KVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgbWF4bWluID0gaSArIDE7XHJcbiAgICAgICAgaSA9IG1pbm1heDtcclxuICAgICAgICB3aGlsZSAoKytpIDw9IG1heG1pbikge1xyXG4gICAgICAgICAgICBpZiAoaXNMZWZ0KFBbbWlubWluXSwgUFttYXhtaW5dLCBQW2ldKSA+PSAwICYmIGkgPCBtYXhtaW4pXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgd2hpbGUgKEgubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChIW0gubGVuZ3RoIC0gMl0sIEhbSC5sZW5ndGggLSAxXSwgUFtpXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIEgubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgIT0gbWlubWluKVxyXG4gICAgICAgICAgICAgICAgSC5wdXNoKFBbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4bWF4ICE9IG1heG1pbilcclxuICAgICAgICAgICAgSC5wdXNoKFBbbWF4bWF4XSk7XHJcbiAgICAgICAgdmFyIGJvdCA9IEgubGVuZ3RoO1xyXG4gICAgICAgIGkgPSBtYXhtaW47XHJcbiAgICAgICAgd2hpbGUgKC0taSA+PSBtaW5tYXgpIHtcclxuICAgICAgICAgICAgaWYgKGlzTGVmdChQW21heG1heF0sIFBbbWlubWF4XSwgUFtpXSkgPj0gMCAmJiBpID4gbWlubWF4KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHdoaWxlIChILmxlbmd0aCA+IGJvdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdChIW0gubGVuZ3RoIC0gMl0sIEhbSC5sZW5ndGggLSAxXSwgUFtpXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIEgubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgIT0gbWlubWluKVxyXG4gICAgICAgICAgICAgICAgSC5wdXNoKFBbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBIO1xyXG59XHJcbmV4cG9ydHMuQ29udmV4SHVsbCA9IENvbnZleEh1bGw7XHJcbmZ1bmN0aW9uIGNsb2Nrd2lzZVJhZGlhbFN3ZWVwKHAsIFAsIGYpIHtcclxuICAgIFAuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gTWF0aC5hdGFuMihhLnkgLSBwLnksIGEueCAtIHAueCkgLSBNYXRoLmF0YW4yKGIueSAtIHAueSwgYi54IC0gcC54KTsgfSkuZm9yRWFjaChmKTtcclxufVxyXG5leHBvcnRzLmNsb2Nrd2lzZVJhZGlhbFN3ZWVwID0gY2xvY2t3aXNlUmFkaWFsU3dlZXA7XHJcbmZ1bmN0aW9uIG5leHRQb2x5UG9pbnQocCwgcHMpIHtcclxuICAgIGlmIChwLnBvbHlJbmRleCA9PT0gcHMubGVuZ3RoIC0gMSlcclxuICAgICAgICByZXR1cm4gcHNbMF07XHJcbiAgICByZXR1cm4gcHNbcC5wb2x5SW5kZXggKyAxXTtcclxufVxyXG5mdW5jdGlvbiBwcmV2UG9seVBvaW50KHAsIHBzKSB7XHJcbiAgICBpZiAocC5wb2x5SW5kZXggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHBzW3BzLmxlbmd0aCAtIDFdO1xyXG4gICAgcmV0dXJuIHBzW3AucG9seUluZGV4IC0gMV07XHJcbn1cclxuZnVuY3Rpb24gdGFuZ2VudF9Qb2ludFBvbHlDKFAsIFYpIHtcclxuICAgIHZhciBWY2xvc2VkID0gVi5zbGljZSgwKTtcclxuICAgIFZjbG9zZWQucHVzaChWWzBdKTtcclxuICAgIHJldHVybiB7IHJ0YW46IFJ0YW5nZW50X1BvaW50UG9seUMoUCwgVmNsb3NlZCksIGx0YW46IEx0YW5nZW50X1BvaW50UG9seUMoUCwgVmNsb3NlZCkgfTtcclxufVxyXG5mdW5jdGlvbiBSdGFuZ2VudF9Qb2ludFBvbHlDKFAsIFYpIHtcclxuICAgIHZhciBuID0gVi5sZW5ndGggLSAxO1xyXG4gICAgdmFyIGEsIGIsIGM7XHJcbiAgICB2YXIgdXBBLCBkbkM7XHJcbiAgICBpZiAoYmVsb3coUCwgVlsxXSwgVlswXSkgJiYgIWFib3ZlKFAsIFZbbiAtIDFdLCBWWzBdKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIGZvciAoYSA9IDAsIGIgPSBuOzspIHtcclxuICAgICAgICBpZiAoYiAtIGEgPT09IDEpXHJcbiAgICAgICAgICAgIGlmIChhYm92ZShQLCBWW2FdLCBWW2JdKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICBjID0gTWF0aC5mbG9vcigoYSArIGIpIC8gMik7XHJcbiAgICAgICAgZG5DID0gYmVsb3coUCwgVltjICsgMV0sIFZbY10pO1xyXG4gICAgICAgIGlmIChkbkMgJiYgIWFib3ZlKFAsIFZbYyAtIDFdLCBWW2NdKSlcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgdXBBID0gYWJvdmUoUCwgVlthICsgMV0sIFZbYV0pO1xyXG4gICAgICAgIGlmICh1cEEpIHtcclxuICAgICAgICAgICAgaWYgKGRuQylcclxuICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm92ZShQLCBWW2FdLCBWW2NdKSlcclxuICAgICAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFkbkMpXHJcbiAgICAgICAgICAgICAgICBhID0gYztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmVsb3coUCwgVlthXSwgVltjXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTHRhbmdlbnRfUG9pbnRQb2x5QyhQLCBWKSB7XHJcbiAgICB2YXIgbiA9IFYubGVuZ3RoIC0gMTtcclxuICAgIHZhciBhLCBiLCBjO1xyXG4gICAgdmFyIGRuQSwgZG5DO1xyXG4gICAgaWYgKGFib3ZlKFAsIFZbbiAtIDFdLCBWWzBdKSAmJiAhYmVsb3coUCwgVlsxXSwgVlswXSkpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICBmb3IgKGEgPSAwLCBiID0gbjs7KSB7XHJcbiAgICAgICAgaWYgKGIgLSBhID09PSAxKVxyXG4gICAgICAgICAgICBpZiAoYmVsb3coUCwgVlthXSwgVltiXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgYyA9IE1hdGguZmxvb3IoKGEgKyBiKSAvIDIpO1xyXG4gICAgICAgIGRuQyA9IGJlbG93KFAsIFZbYyArIDFdLCBWW2NdKTtcclxuICAgICAgICBpZiAoYWJvdmUoUCwgVltjIC0gMV0sIFZbY10pICYmICFkbkMpXHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIGRuQSA9IGJlbG93KFAsIFZbYSArIDFdLCBWW2FdKTtcclxuICAgICAgICBpZiAoZG5BKSB7XHJcbiAgICAgICAgICAgIGlmICghZG5DKVxyXG4gICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlbG93KFAsIFZbYV0sIFZbY10pKVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZG5DKVxyXG4gICAgICAgICAgICAgICAgYSA9IGM7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFib3ZlKFAsIFZbYV0sIFZbY10pKVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRhbmdlbnRfUG9seVBvbHlDKFYsIFcsIHQxLCB0MiwgY21wMSwgY21wMikge1xyXG4gICAgdmFyIGl4MSwgaXgyO1xyXG4gICAgaXgxID0gdDEoV1swXSwgVik7XHJcbiAgICBpeDIgPSB0MihWW2l4MV0sIFcpO1xyXG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgIHdoaWxlICghZG9uZSkge1xyXG4gICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpeDEgPT09IFYubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgIGl4MSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChjbXAxKFdbaXgyXSwgVltpeDFdLCBWW2l4MSArIDFdKSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICArK2l4MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGl4MiA9PT0gMClcclxuICAgICAgICAgICAgICAgIGl4MiA9IFcubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgaWYgKGNtcDIoVltpeDFdLCBXW2l4Ml0sIFdbaXgyIC0gMV0pKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC0taXgyO1xyXG4gICAgICAgICAgICBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdDE6IGl4MSwgdDI6IGl4MiB9O1xyXG59XHJcbmV4cG9ydHMudGFuZ2VudF9Qb2x5UG9seUMgPSB0YW5nZW50X1BvbHlQb2x5QztcclxuZnVuY3Rpb24gTFJ0YW5nZW50X1BvbHlQb2x5QyhWLCBXKSB7XHJcbiAgICB2YXIgcmwgPSBSTHRhbmdlbnRfUG9seVBvbHlDKFcsIFYpO1xyXG4gICAgcmV0dXJuIHsgdDE6IHJsLnQyLCB0MjogcmwudDEgfTtcclxufVxyXG5leHBvcnRzLkxSdGFuZ2VudF9Qb2x5UG9seUMgPSBMUnRhbmdlbnRfUG9seVBvbHlDO1xyXG5mdW5jdGlvbiBSTHRhbmdlbnRfUG9seVBvbHlDKFYsIFcpIHtcclxuICAgIHJldHVybiB0YW5nZW50X1BvbHlQb2x5QyhWLCBXLCBSdGFuZ2VudF9Qb2ludFBvbHlDLCBMdGFuZ2VudF9Qb2ludFBvbHlDLCBhYm92ZSwgYmVsb3cpO1xyXG59XHJcbmV4cG9ydHMuUkx0YW5nZW50X1BvbHlQb2x5QyA9IFJMdGFuZ2VudF9Qb2x5UG9seUM7XHJcbmZ1bmN0aW9uIExMdGFuZ2VudF9Qb2x5UG9seUMoViwgVykge1xyXG4gICAgcmV0dXJuIHRhbmdlbnRfUG9seVBvbHlDKFYsIFcsIEx0YW5nZW50X1BvaW50UG9seUMsIEx0YW5nZW50X1BvaW50UG9seUMsIGJlbG93LCBiZWxvdyk7XHJcbn1cclxuZXhwb3J0cy5MTHRhbmdlbnRfUG9seVBvbHlDID0gTEx0YW5nZW50X1BvbHlQb2x5QztcclxuZnVuY3Rpb24gUlJ0YW5nZW50X1BvbHlQb2x5QyhWLCBXKSB7XHJcbiAgICByZXR1cm4gdGFuZ2VudF9Qb2x5UG9seUMoViwgVywgUnRhbmdlbnRfUG9pbnRQb2x5QywgUnRhbmdlbnRfUG9pbnRQb2x5QywgYWJvdmUsIGFib3ZlKTtcclxufVxyXG5leHBvcnRzLlJSdGFuZ2VudF9Qb2x5UG9seUMgPSBSUnRhbmdlbnRfUG9seVBvbHlDO1xyXG52YXIgQmlUYW5nZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJpVGFuZ2VudCh0MSwgdDIpIHtcclxuICAgICAgICB0aGlzLnQxID0gdDE7XHJcbiAgICAgICAgdGhpcy50MiA9IHQyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJpVGFuZ2VudDtcclxufSgpKTtcclxuZXhwb3J0cy5CaVRhbmdlbnQgPSBCaVRhbmdlbnQ7XHJcbnZhciBCaVRhbmdlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJpVGFuZ2VudHMoKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmlUYW5nZW50cztcclxufSgpKTtcclxuZXhwb3J0cy5CaVRhbmdlbnRzID0gQmlUYW5nZW50cztcclxudmFyIFRWR1BvaW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUVkdQb2ludCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRWR1BvaW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBUVkdQb2ludDtcclxufShQb2ludCkpO1xyXG5leHBvcnRzLlRWR1BvaW50ID0gVFZHUG9pbnQ7XHJcbnZhciBWaXNpYmlsaXR5VmVydGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpc2liaWxpdHlWZXJ0ZXgoaWQsIHBvbHlpZCwgcG9seXZlcnRpZCwgcCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnBvbHlpZCA9IHBvbHlpZDtcclxuICAgICAgICB0aGlzLnBvbHl2ZXJ0aWQgPSBwb2x5dmVydGlkO1xyXG4gICAgICAgIHRoaXMucCA9IHA7XHJcbiAgICAgICAgcC52diA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVmlzaWJpbGl0eVZlcnRleDtcclxufSgpKTtcclxuZXhwb3J0cy5WaXNpYmlsaXR5VmVydGV4ID0gVmlzaWJpbGl0eVZlcnRleDtcclxudmFyIFZpc2liaWxpdHlFZGdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpc2liaWxpdHlFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBWaXNpYmlsaXR5RWRnZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkeCA9IHRoaXMuc291cmNlLnAueCAtIHRoaXMudGFyZ2V0LnAueDtcclxuICAgICAgICB2YXIgZHkgPSB0aGlzLnNvdXJjZS5wLnkgLSB0aGlzLnRhcmdldC5wLnk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZpc2liaWxpdHlFZGdlO1xyXG59KCkpO1xyXG5leHBvcnRzLlZpc2liaWxpdHlFZGdlID0gVmlzaWJpbGl0eUVkZ2U7XHJcbnZhciBUYW5nZW50VmlzaWJpbGl0eUdyYXBoID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGgoUCwgZzApIHtcclxuICAgICAgICB0aGlzLlAgPSBQO1xyXG4gICAgICAgIHRoaXMuViA9IFtdO1xyXG4gICAgICAgIHRoaXMuRSA9IFtdO1xyXG4gICAgICAgIGlmICghZzApIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBQLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gUFtpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcC5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaiA9IHBbal0sIHZ2ID0gbmV3IFZpc2liaWxpdHlWZXJ0ZXgodGhpcy5WLmxlbmd0aCwgaSwgaiwgcGopO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVi5wdXNoKHZ2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRS5wdXNoKG5ldyBWaXNpYmlsaXR5RWRnZShwW2ogLSAxXS52diwgdnYpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FLnB1c2gobmV3IFZpc2liaWxpdHlFZGdlKHBbMF0udnYsIHBbcC5sZW5ndGggLSAxXS52dikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIFBpID0gUFtpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBQaiA9IFBbal0sIHQgPSB0YW5nZW50cyhQaSwgUGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHEgaW4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHRbcV0sIHNvdXJjZSA9IFBpW2MudDFdLCB0YXJnZXQgPSBQaltjLnQyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFZGdlSWZWaXNpYmxlKHNvdXJjZSwgdGFyZ2V0LCBpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuViA9IGcwLlYuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuRSA9IGcwLkUuc2xpY2UoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVGFuZ2VudFZpc2liaWxpdHlHcmFwaC5wcm90b3R5cGUuYWRkRWRnZUlmVmlzaWJsZSA9IGZ1bmN0aW9uICh1LCB2LCBpMSwgaTIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW50ZXJzZWN0c1BvbHlzKG5ldyBMaW5lU2VnbWVudCh1LngsIHUueSwgdi54LCB2LnkpLCBpMSwgaTIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuRS5wdXNoKG5ldyBWaXNpYmlsaXR5RWRnZSh1LnZ2LCB2LnZ2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRhbmdlbnRWaXNpYmlsaXR5R3JhcGgucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24gKHAsIGkxKSB7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLlAubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuVi5wdXNoKG5ldyBWaXNpYmlsaXR5VmVydGV4KHRoaXMuVi5sZW5ndGgsIG4sIDAsIHApKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gaTEpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHBvbHkgPSB0aGlzLlBbaV0sIHQgPSB0YW5nZW50X1BvaW50UG9seUMocCwgcG9seSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZUlmVmlzaWJsZShwLCBwb2x5W3QubHRhbl0sIGkxLCBpKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFZGdlSWZWaXNpYmxlKHAsIHBvbHlbdC5ydGFuXSwgaTEsIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcC52djtcclxuICAgIH07XHJcbiAgICBUYW5nZW50VmlzaWJpbGl0eUdyYXBoLnByb3RvdHlwZS5pbnRlcnNlY3RzUG9seXMgPSBmdW5jdGlvbiAobCwgaTEsIGkyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0aGlzLlAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpICE9IGkxICYmIGkgIT0gaTIgJiYgaW50ZXJzZWN0cyhsLCB0aGlzLlBbaV0pLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGFuZ2VudFZpc2liaWxpdHlHcmFwaDtcclxufSgpKTtcclxuZXhwb3J0cy5UYW5nZW50VmlzaWJpbGl0eUdyYXBoID0gVGFuZ2VudFZpc2liaWxpdHlHcmFwaDtcclxuZnVuY3Rpb24gaW50ZXJzZWN0cyhsLCBQKSB7XHJcbiAgICB2YXIgaW50cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDEsIG4gPSBQLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgIHZhciBpbnQgPSByZWN0YW5nbGVfMS5SZWN0YW5nbGUubGluZUludGVyc2VjdGlvbihsLngxLCBsLnkxLCBsLngyLCBsLnkyLCBQW2kgLSAxXS54LCBQW2kgLSAxXS55LCBQW2ldLngsIFBbaV0ueSk7XHJcbiAgICAgICAgaWYgKGludClcclxuICAgICAgICAgICAgaW50cy5wdXNoKGludCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW50cztcclxufVxyXG5mdW5jdGlvbiB0YW5nZW50cyhWLCBXKSB7XHJcbiAgICB2YXIgbSA9IFYubGVuZ3RoIC0gMSwgbiA9IFcubGVuZ3RoIC0gMTtcclxuICAgIHZhciBidCA9IG5ldyBCaVRhbmdlbnRzKCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07ICsraSkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgICAgIHZhciB2MSA9IFZbaSA9PSAwID8gbSAtIDEgOiBpIC0gMV07XHJcbiAgICAgICAgICAgIHZhciB2MiA9IFZbaV07XHJcbiAgICAgICAgICAgIHZhciB2MyA9IFZbaSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgdzEgPSBXW2ogPT0gMCA/IG4gLSAxIDogaiAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgdzIgPSBXW2pdO1xyXG4gICAgICAgICAgICB2YXIgdzMgPSBXW2ogKyAxXTtcclxuICAgICAgICAgICAgdmFyIHYxdjJ3MiA9IGlzTGVmdCh2MSwgdjIsIHcyKTtcclxuICAgICAgICAgICAgdmFyIHYydzF3MiA9IGlzTGVmdCh2MiwgdzEsIHcyKTtcclxuICAgICAgICAgICAgdmFyIHYydzJ3MyA9IGlzTGVmdCh2MiwgdzIsIHczKTtcclxuICAgICAgICAgICAgdmFyIHcxdzJ2MiA9IGlzTGVmdCh3MSwgdzIsIHYyKTtcclxuICAgICAgICAgICAgdmFyIHcydjF2MiA9IGlzTGVmdCh3MiwgdjEsIHYyKTtcclxuICAgICAgICAgICAgdmFyIHcydjJ2MyA9IGlzTGVmdCh3MiwgdjIsIHYzKTtcclxuICAgICAgICAgICAgaWYgKHYxdjJ3MiA+PSAwICYmIHYydzF3MiA+PSAwICYmIHYydzJ3MyA8IDBcclxuICAgICAgICAgICAgICAgICYmIHcxdzJ2MiA+PSAwICYmIHcydjF2MiA+PSAwICYmIHcydjJ2MyA8IDApIHtcclxuICAgICAgICAgICAgICAgIGJ0LmxsID0gbmV3IEJpVGFuZ2VudChpLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2MXYydzIgPD0gMCAmJiB2MncxdzIgPD0gMCAmJiB2MncydzMgPiAwXHJcbiAgICAgICAgICAgICAgICAmJiB3MXcydjIgPD0gMCAmJiB3MnYxdjIgPD0gMCAmJiB3MnYydjMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBidC5yciA9IG5ldyBCaVRhbmdlbnQoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodjF2MncyIDw9IDAgJiYgdjJ3MXcyID4gMCAmJiB2MncydzMgPD0gMFxyXG4gICAgICAgICAgICAgICAgJiYgdzF3MnYyID49IDAgJiYgdzJ2MXYyIDwgMCAmJiB3MnYydjMgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnQucmwgPSBuZXcgQmlUYW5nZW50KGksIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHYxdjJ3MiA+PSAwICYmIHYydzF3MiA8IDAgJiYgdjJ3MnczID49IDBcclxuICAgICAgICAgICAgICAgICYmIHcxdzJ2MiA8PSAwICYmIHcydjF2MiA+IDAgJiYgdzJ2MnYzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGJ0LmxyID0gbmV3IEJpVGFuZ2VudChpLCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBidDtcclxufVxyXG5leHBvcnRzLnRhbmdlbnRzID0gdGFuZ2VudHM7XHJcbmZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5KHAsIHBvbHkpIHtcclxuICAgIGZvciAodmFyIGkgPSAxLCBuID0gcG9seS5sZW5ndGg7IGkgPCBuOyArK2kpXHJcbiAgICAgICAgaWYgKGJlbG93KHBvbHlbaSAtIDFdLCBwb2x5W2ldLCBwKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNBbnlQSW5RKHAsIHEpIHtcclxuICAgIHJldHVybiAhcC5ldmVyeShmdW5jdGlvbiAodikgeyByZXR1cm4gIWlzUG9pbnRJbnNpZGVQb2x5KHYsIHEpOyB9KTtcclxufVxyXG5mdW5jdGlvbiBwb2x5c092ZXJsYXAocCwgcSkge1xyXG4gICAgaWYgKGlzQW55UEluUShwLCBxKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChpc0FueVBJblEocSwgcCkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbiA9IHAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgdmFyIHYgPSBwW2ldLCB1ID0gcFtpIC0gMV07XHJcbiAgICAgICAgaWYgKGludGVyc2VjdHMobmV3IExpbmVTZWdtZW50KHUueCwgdS55LCB2LngsIHYueSksIHEpLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMucG9seXNPdmVybGFwID0gcG9seXNPdmVybGFwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciByZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZVwiKTtcclxudmFyIHZwc2NfMSA9IHJlcXVpcmUoXCIuL3Zwc2NcIik7XHJcbnZhciBzaG9ydGVzdHBhdGhzXzEgPSByZXF1aXJlKFwiLi9zaG9ydGVzdHBhdGhzXCIpO1xyXG52YXIgTm9kZVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZVdyYXBwZXIoaWQsIHJlY3QsIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMucmVjdCA9IHJlY3Q7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMubGVhZiA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3VuZGVmaW5lZCcgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vZGVXcmFwcGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGVXcmFwcGVyID0gTm9kZVdyYXBwZXI7XHJcbnZhciBWZXJ0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZlcnQoaWQsIHgsIHksIG5vZGUsIGxpbmUpIHtcclxuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7IG5vZGUgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGxpbmUgPT09IHZvaWQgMCkgeyBsaW5lID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZlcnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmVydCA9IFZlcnQ7XHJcbnZhciBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlKHMsIHQpIHtcclxuICAgICAgICB0aGlzLnMgPSBzO1xyXG4gICAgICAgIHRoaXMudCA9IHQ7XHJcbiAgICAgICAgdmFyIG1mID0gTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlLmZpbmRNYXRjaChzLCB0KTtcclxuICAgICAgICB2YXIgdHIgPSB0LnNsaWNlKDApLnJldmVyc2UoKTtcclxuICAgICAgICB2YXIgbXIgPSBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UuZmluZE1hdGNoKHMsIHRyKTtcclxuICAgICAgICBpZiAobWYubGVuZ3RoID49IG1yLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG1mLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5zaSA9IG1mLnNpO1xyXG4gICAgICAgICAgICB0aGlzLnRpID0gbWYudGk7XHJcbiAgICAgICAgICAgIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnNpID0gbXIuc2k7XHJcbiAgICAgICAgICAgIHRoaXMudGkgPSB0Lmxlbmd0aCAtIG1yLnRpIC0gbXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnJldmVyc2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UuZmluZE1hdGNoID0gZnVuY3Rpb24gKHMsIHQpIHtcclxuICAgICAgICB2YXIgbSA9IHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBuID0gdC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG1hdGNoID0geyBsZW5ndGg6IDAsIHNpOiAtMSwgdGk6IC0xIH07XHJcbiAgICAgICAgdmFyIGwgPSBuZXcgQXJyYXkobSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyBpKyspIHtcclxuICAgICAgICAgICAgbFtpXSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspXHJcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSA9PT0gdFtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gbFtpXVtqXSA9IChpID09PSAwIHx8IGogPT09IDApID8gMSA6IGxbaSAtIDFdW2ogLSAxXSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPiBtYXRjaC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gubGVuZ3RoID0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2kgPSBpIC0gdiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLnRpID0gaiAtIHYgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbFtpXVtqXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH07XHJcbiAgICBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UucHJvdG90eXBlLmdldFNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+PSAwID8gdGhpcy5zLnNsaWNlKHRoaXMuc2ksIHRoaXMuc2kgKyB0aGlzLmxlbmd0aCkgOiBbXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlO1xyXG59KCkpO1xyXG5leHBvcnRzLkxvbmdlc3RDb21tb25TdWJzZXF1ZW5jZSA9IExvbmdlc3RDb21tb25TdWJzZXF1ZW5jZTtcclxudmFyIEdyaWRSb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR3JpZFJvdXRlcihvcmlnaW5hbG5vZGVzLCBhY2Nlc3NvciwgZ3JvdXBQYWRkaW5nKSB7XHJcbiAgICAgICAgaWYgKGdyb3VwUGFkZGluZyA9PT0gdm9pZCAwKSB7IGdyb3VwUGFkZGluZyA9IDEyOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9yaWdpbmFsbm9kZXMgPSBvcmlnaW5hbG5vZGVzO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBQYWRkaW5nID0gZ3JvdXBQYWRkaW5nO1xyXG4gICAgICAgIHRoaXMubGVhdmVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5vZGVzID0gb3JpZ2luYWxub2Rlcy5tYXAoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIG5ldyBOb2RlV3JhcHBlcihpLCBhY2Nlc3Nvci5nZXRCb3VuZHModiksIGFjY2Vzc29yLmdldENoaWxkcmVuKHYpKTsgfSk7XHJcbiAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLm5vZGVzLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5sZWFmOyB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwcyA9IHRoaXMubm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChnKSB7IHJldHVybiAhZy5sZWFmOyB9KTtcclxuICAgICAgICB0aGlzLmNvbHMgPSB0aGlzLmdldEdyaWRMaW5lcygneCcpO1xyXG4gICAgICAgIHRoaXMucm93cyA9IHRoaXMuZ2V0R3JpZExpbmVzKCd5Jyk7XHJcbiAgICAgICAgdGhpcy5ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICByZXR1cm4gdi5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5ub2Rlc1tjXS5wYXJlbnQgPSB2OyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJvb3QgPSB7IGNoaWxkcmVuOiBbXSB9O1xyXG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYucGFyZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdi5wYXJlbnQgPSBfdGhpcy5yb290O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucm9vdC5jaGlsZHJlbi5wdXNoKHYuaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHYucG9ydHMgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmJhY2tUb0Zyb250ID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcclxuICAgICAgICB0aGlzLmJhY2tUb0Zyb250LnNvcnQoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIF90aGlzLmdldERlcHRoKHgpIC0gX3RoaXMuZ2V0RGVwdGgoeSk7IH0pO1xyXG4gICAgICAgIHZhciBmcm9udFRvQmFja0dyb3VwcyA9IHRoaXMuYmFja1RvRnJvbnQuc2xpY2UoMCkucmV2ZXJzZSgpLmZpbHRlcihmdW5jdGlvbiAoZykgeyByZXR1cm4gIWcubGVhZjsgfSk7XHJcbiAgICAgICAgZnJvbnRUb0JhY2tHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgciA9IHJlY3RhbmdsZV8xLlJlY3RhbmdsZS5lbXB0eSgpO1xyXG4gICAgICAgICAgICB2LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHIgPSByLnVuaW9uKF90aGlzLm5vZGVzW2NdLnJlY3QpOyB9KTtcclxuICAgICAgICAgICAgdi5yZWN0ID0gci5pbmZsYXRlKF90aGlzLmdyb3VwUGFkZGluZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGNvbE1pZHMgPSB0aGlzLm1pZFBvaW50cyh0aGlzLmNvbHMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnBvczsgfSkpO1xyXG4gICAgICAgIHZhciByb3dNaWRzID0gdGhpcy5taWRQb2ludHModGhpcy5yb3dzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5wb3M7IH0pKTtcclxuICAgICAgICB2YXIgcm93eCA9IGNvbE1pZHNbMF0sIHJvd1ggPSBjb2xNaWRzW2NvbE1pZHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGNvbHkgPSByb3dNaWRzWzBdLCBjb2xZID0gcm93TWlkc1tyb3dNaWRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBobGluZXMgPSB0aGlzLnJvd3MubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiAoeyB4MTogcm93eCwgeDI6IHJvd1gsIHkxOiByLnBvcywgeTI6IHIucG9zIH0pOyB9KVxyXG4gICAgICAgICAgICAuY29uY2F0KHJvd01pZHMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyB4MTogcm93eCwgeDI6IHJvd1gsIHkxOiBtLCB5MjogbSB9KTsgfSkpO1xyXG4gICAgICAgIHZhciB2bGluZXMgPSB0aGlzLmNvbHMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoeyB4MTogYy5wb3MsIHgyOiBjLnBvcywgeTE6IGNvbHksIHkyOiBjb2xZIH0pOyB9KVxyXG4gICAgICAgICAgICAuY29uY2F0KGNvbE1pZHMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyB4MTogbSwgeDI6IG0sIHkxOiBjb2x5LCB5MjogY29sWSB9KTsgfSkpO1xyXG4gICAgICAgIHZhciBsaW5lcyA9IGhsaW5lcy5jb25jYXQodmxpbmVzKTtcclxuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnZlcnRzID0gW107IH0pO1xyXG4gICAgICAgIHRoaXMudmVydHMgPSBbXTtcclxuICAgICAgICB0aGlzLmVkZ2VzID0gW107XHJcbiAgICAgICAgaGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBWZXJ0KF90aGlzLnZlcnRzLmxlbmd0aCwgdi54MSwgaC55MSk7XHJcbiAgICAgICAgICAgICAgICBoLnZlcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB2LnZlcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52ZXJ0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBfdGhpcy5iYWNrVG9Gcm9udC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMuYmFja1RvRnJvbnRbaV0sIHIgPSBub2RlLnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMocC54IC0gci5jeCgpKSwgZHkgPSBNYXRoLmFicyhwLnkgLSByLmN5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCA8IHIud2lkdGgoKSAvIDIgJiYgZHkgPCByLmhlaWdodCgpIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGwsIGxpKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIHYucmVjdC5saW5lSW50ZXJzZWN0aW9ucyhsLngxLCBsLnkxLCBsLngyLCBsLnkyKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnNlY3QsIGopIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBWZXJ0KF90aGlzLnZlcnRzLmxlbmd0aCwgaW50ZXJzZWN0LngsIGludGVyc2VjdC55LCB2LCBsKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52ZXJ0cy5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGwudmVydHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICB2LnBvcnRzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBpc0hvcml6ID0gTWF0aC5hYnMobC55MSAtIGwueTIpIDwgMC4xO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaXNIb3JpeiA/IGIueCAtIGEueCA6IGIueSAtIGEueTsgfTtcclxuICAgICAgICAgICAgbC52ZXJ0cy5zb3J0KGRlbHRhKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsLnZlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSA9IGwudmVydHNbaSAtIDFdLCB2ID0gbC52ZXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICh1Lm5vZGUgJiYgdS5ub2RlID09PSB2Lm5vZGUgJiYgdS5ub2RlLmxlYWYpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lZGdlcy5wdXNoKHsgc291cmNlOiB1LmlkLCB0YXJnZXQ6IHYuaWQsIGxlbmd0aDogTWF0aC5hYnMoZGVsdGEodSwgdikpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBHcmlkUm91dGVyLnByb3RvdHlwZS5hdmcgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggKyB5OyB9KSAvIGEubGVuZ3RoOyB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuZ2V0R3JpZExpbmVzID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAgICAgICB2YXIgY29sdW1ucyA9IFtdO1xyXG4gICAgICAgIHZhciBscyA9IHRoaXMubGVhdmVzLnNsaWNlKDAsIHRoaXMubGVhdmVzLmxlbmd0aCk7XHJcbiAgICAgICAgd2hpbGUgKGxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gbHMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnJlY3RbJ292ZXJsYXAnICsgYXhpcy50b1VwcGVyQ2FzZSgpXShsc1swXS5yZWN0KTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBjb2wgPSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlczogb3ZlcmxhcHBpbmcsXHJcbiAgICAgICAgICAgICAgICBwb3M6IHRoaXMuYXZnKG92ZXJsYXBwaW5nLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5yZWN0WydjJyArIGF4aXNdKCk7IH0pKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sKTtcclxuICAgICAgICAgICAgY29sLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGxzLnNwbGljZShscy5pbmRleE9mKHYpLCAxKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbHVtbnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5wb3MgLSBiLnBvczsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbnM7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHYucGFyZW50ICE9PSB0aGlzLnJvb3QpIHtcclxuICAgICAgICAgICAgZGVwdGgrKztcclxuICAgICAgICAgICAgdiA9IHYucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVwdGg7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5wcm90b3R5cGUubWlkUG9pbnRzID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgZ2FwID0gYVsxXSAtIGFbMF07XHJcbiAgICAgICAgdmFyIG1pZHMgPSBbYVswXSAtIGdhcCAvIDJdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBtaWRzLnB1c2goKGFbaV0gKyBhW2kgLSAxXSkgLyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWlkcy5wdXNoKGFbYS5sZW5ndGggLSAxXSArIGdhcCAvIDIpO1xyXG4gICAgICAgIHJldHVybiBtaWRzO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLmZpbmRMaW5lYWdlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbGluZWFnZSA9IFt2XTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHYgPSB2LnBhcmVudDtcclxuICAgICAgICAgICAgbGluZWFnZS5wdXNoKHYpO1xyXG4gICAgICAgIH0gd2hpbGUgKHYgIT09IHRoaXMucm9vdCk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVhZ2UucmV2ZXJzZSgpO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLmZpbmRBbmNlc3RvclBhdGhCZXR3ZWVuID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgYWEgPSB0aGlzLmZpbmRMaW5lYWdlKGEpLCBiYSA9IHRoaXMuZmluZExpbmVhZ2UoYiksIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChhYVtpXSA9PT0gYmFbaV0pXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICByZXR1cm4geyBjb21tb25BbmNlc3RvcjogYWFbaSAtIDFdLCBsaW5lYWdlczogYWEuc2xpY2UoaSkuY29uY2F0KGJhLnNsaWNlKGkpKSB9O1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLnNpYmxpbmdPYnN0YWNsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmZpbmRBbmNlc3RvclBhdGhCZXR3ZWVuKGEsIGIpO1xyXG4gICAgICAgIHZhciBsaW5lYWdlTG9va3VwID0ge307XHJcbiAgICAgICAgcGF0aC5saW5lYWdlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBsaW5lYWdlTG9va3VwW3YuaWRdID0ge307IH0pO1xyXG4gICAgICAgIHZhciBvYnN0YWNsZXMgPSBwYXRoLmNvbW1vbkFuY2VzdG9yLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gISh2IGluIGxpbmVhZ2VMb29rdXApOyB9KTtcclxuICAgICAgICBwYXRoLmxpbmVhZ2VzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucGFyZW50ICE9PSBwYXRoLmNvbW1vbkFuY2VzdG9yOyB9KVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gb2JzdGFjbGVzID0gb2JzdGFjbGVzLmNvbmNhdCh2LnBhcmVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT09IHYuaWQ7IH0pKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIG9ic3RhY2xlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLm5vZGVzW3ZdOyB9KTtcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLmdldFNlZ21lbnRTZXRzID0gZnVuY3Rpb24gKHJvdXRlcywgeCwgeSkge1xyXG4gICAgICAgIHZhciB2c2VnbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgcm91dGVzLmxlbmd0aDsgZWkrKykge1xyXG4gICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbZWldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgcm91dGUubGVuZ3RoOyBzaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHJvdXRlW3NpXTtcclxuICAgICAgICAgICAgICAgIHMuZWRnZWlkID0gZWk7XHJcbiAgICAgICAgICAgICAgICBzLmkgPSBzaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZHggPSBzWzFdW3hdIC0gc1swXVt4XTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZHgpIDwgMC4xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdnNlZ21lbnRzLnB1c2gocyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdnNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF1beF0gLSBiWzBdW3hdOyB9KTtcclxuICAgICAgICB2YXIgdnNlZ21lbnRzZXRzID0gW107XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzZXQgPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzID0gdnNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXNlZ21lbnRzZXQgfHwgTWF0aC5hYnMoc1swXVt4XSAtIHNlZ21lbnRzZXQucG9zKSA+IDAuMSkge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudHNldCA9IHsgcG9zOiBzWzBdW3hdLCBzZWdtZW50czogW10gfTtcclxuICAgICAgICAgICAgICAgIHZzZWdtZW50c2V0cy5wdXNoKHNlZ21lbnRzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZ21lbnRzZXQuc2VnbWVudHMucHVzaChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZzZWdtZW50c2V0cztcclxuICAgIH07XHJcbiAgICBHcmlkUm91dGVyLm51ZGdlU2VncyA9IGZ1bmN0aW9uICh4LCB5LCByb3V0ZXMsIHNlZ21lbnRzLCBsZWZ0T2YsIGdhcCkge1xyXG4gICAgICAgIHZhciBuID0gc2VnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChuIDw9IDEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdnMgPSBzZWdtZW50cy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIG5ldyB2cHNjXzEuVmFyaWFibGUoc1swXVt4XSk7IH0pO1xyXG4gICAgICAgIHZhciBjcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gailcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IHNlZ21lbnRzW2ldLCBzMiA9IHNlZ21lbnRzW2pdLCBlMSA9IHMxLmVkZ2VpZCwgZTIgPSBzMi5lZGdlaWQsIGxpbmQgPSAtMSwgcmluZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPT0gJ3gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRPZihlMSwgZTIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMVswXVt5XSA8IHMxWzFdW3ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5kID0gaiwgcmluZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5kID0gaSwgcmluZCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdE9mKGUxLCBlMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxWzBdW3ldIDwgczFbMV1beV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmQgPSBpLCByaW5kID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmQgPSBqLCByaW5kID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaW5kID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjcy5wdXNoKG5ldyB2cHNjXzEuQ29uc3RyYWludCh2c1tsaW5kXSwgdnNbcmluZF0sIGdhcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb2x2ZXIgPSBuZXcgdnBzY18xLlNvbHZlcih2cywgY3MpO1xyXG4gICAgICAgIHNvbHZlci5zb2x2ZSgpO1xyXG4gICAgICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBzZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IHYucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgc1swXVt4XSA9IHNbMV1beF0gPSBwb3M7XHJcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tzLmVkZ2VpZF07XHJcbiAgICAgICAgICAgIGlmIChzLmkgPiAwKVxyXG4gICAgICAgICAgICAgICAgcm91dGVbcy5pIC0gMV1bMV1beF0gPSBwb3M7XHJcbiAgICAgICAgICAgIGlmIChzLmkgPCByb3V0ZS5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgcm91dGVbcy5pICsgMV1bMF1beF0gPSBwb3M7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5udWRnZVNlZ21lbnRzID0gZnVuY3Rpb24gKHJvdXRlcywgeCwgeSwgbGVmdE9mLCBnYXApIHtcclxuICAgICAgICB2YXIgdnNlZ21lbnRzZXRzID0gR3JpZFJvdXRlci5nZXRTZWdtZW50U2V0cyhyb3V0ZXMsIHgsIHkpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdnNlZ21lbnRzZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzcyA9IHZzZWdtZW50c2V0c1tpXTtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNzLnNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNzLnNlZ21lbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyB0eXBlOiAwLCBzOiBzLCBwb3M6IE1hdGgubWluKHNbMF1beV0sIHNbMV1beV0pIH0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyB0eXBlOiAxLCBzOiBzLCBwb3M6IE1hdGgubWF4KHNbMF1beV0sIHNbMV1beV0pIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnBvcyAtIGIucG9zICsgYS50eXBlIC0gYi50eXBlOyB9KTtcclxuICAgICAgICAgICAgdmFyIG9wZW4gPSBbXTtcclxuICAgICAgICAgICAgdmFyIG9wZW5Db3VudCA9IDA7XHJcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbi5wdXNoKGUucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuQ291bnQtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcGVuQ291bnQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEdyaWRSb3V0ZXIubnVkZ2VTZWdzKHgsIHksIHJvdXRlcywgb3BlbiwgbGVmdE9mLCBnYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLnJvdXRlRWRnZXMgPSBmdW5jdGlvbiAoZWRnZXMsIG51ZGdlR2FwLCBzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJvdXRlUGF0aHMgPSBlZGdlcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLnJvdXRlKHNvdXJjZShlKSwgdGFyZ2V0KGUpKTsgfSk7XHJcbiAgICAgICAgdmFyIG9yZGVyID0gR3JpZFJvdXRlci5vcmRlckVkZ2VzKHJvdXRlUGF0aHMpO1xyXG4gICAgICAgIHZhciByb3V0ZXMgPSByb3V0ZVBhdGhzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gR3JpZFJvdXRlci5tYWtlU2VnbWVudHMoZSk7IH0pO1xyXG4gICAgICAgIEdyaWRSb3V0ZXIubnVkZ2VTZWdtZW50cyhyb3V0ZXMsICd4JywgJ3knLCBvcmRlciwgbnVkZ2VHYXApO1xyXG4gICAgICAgIEdyaWRSb3V0ZXIubnVkZ2VTZWdtZW50cyhyb3V0ZXMsICd5JywgJ3gnLCBvcmRlciwgbnVkZ2VHYXApO1xyXG4gICAgICAgIEdyaWRSb3V0ZXIudW5yZXZlcnNlRWRnZXMocm91dGVzLCByb3V0ZVBhdGhzKTtcclxuICAgICAgICByZXR1cm4gcm91dGVzO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIudW5yZXZlcnNlRWRnZXMgPSBmdW5jdGlvbiAocm91dGVzLCByb3V0ZVBhdGhzKSB7XHJcbiAgICAgICAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnRzLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gcm91dGVQYXRoc1tpXTtcclxuICAgICAgICAgICAgaWYgKHBhdGgucmV2ZXJzZWQpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5hbmdsZUJldHdlZW4yTGluZXMgPSBmdW5jdGlvbiAobGluZTEsIGxpbmUyKSB7XHJcbiAgICAgICAgdmFyIGFuZ2xlMSA9IE1hdGguYXRhbjIobGluZTFbMF0ueSAtIGxpbmUxWzFdLnksIGxpbmUxWzBdLnggLSBsaW5lMVsxXS54KTtcclxuICAgICAgICB2YXIgYW5nbGUyID0gTWF0aC5hdGFuMihsaW5lMlswXS55IC0gbGluZTJbMV0ueSwgbGluZTJbMF0ueCAtIGxpbmUyWzFdLngpO1xyXG4gICAgICAgIHZhciBkaWZmID0gYW5nbGUxIC0gYW5nbGUyO1xyXG4gICAgICAgIGlmIChkaWZmID4gTWF0aC5QSSB8fCBkaWZmIDwgLU1hdGguUEkpIHtcclxuICAgICAgICAgICAgZGlmZiA9IGFuZ2xlMiAtIGFuZ2xlMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5pc0xlZnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgIHJldHVybiAoKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKGMueCAtIGEueCkpIDw9IDA7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5nZXRPcmRlciA9IGZ1bmN0aW9uIChwYWlycykge1xyXG4gICAgICAgIHZhciBvdXRnb2luZyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAgPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvdXRnb2luZ1twLmxdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIG91dGdvaW5nW3AubF0gPSB7fTtcclxuICAgICAgICAgICAgb3V0Z29pbmdbcC5sXVtwLnJdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsLCByKSB7IHJldHVybiB0eXBlb2Ygb3V0Z29pbmdbbF0gIT09ICd1bmRlZmluZWQnICYmIG91dGdvaW5nW2xdW3JdOyB9O1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIub3JkZXJFZGdlcyA9IGZ1bmN0aW9uIChlZGdlcykge1xyXG4gICAgICAgIHZhciBlZGdlT3JkZXIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlZGdlc1tpXSwgZiA9IGVkZ2VzW2pdLCBsY3MgPSBuZXcgTG9uZ2VzdENvbW1vblN1YnNlcXVlbmNlKGUsIGYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHUsIHZpLCB2ajtcclxuICAgICAgICAgICAgICAgIGlmIChsY3MubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxjcy5yZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGYucmV2ZXJzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxjcyA9IG5ldyBMb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UoZSwgZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKGxjcy5zaSA8PSAwIHx8IGxjcy50aSA8PSAwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChsY3Muc2kgKyBsY3MubGVuZ3RoID49IGUubGVuZ3RoIHx8IGxjcy50aSArIGxjcy5sZW5ndGggPj0gZi5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZU9yZGVyLnB1c2goeyBsOiBpLCByOiBqIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxjcy5zaSArIGxjcy5sZW5ndGggPj0gZS5sZW5ndGggfHwgbGNzLnRpICsgbGNzLmxlbmd0aCA+PSBmLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBlW2xjcy5zaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZqID0gZVtsY3Muc2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2aSA9IGZbbGNzLnRpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1ID0gZVtsY3Muc2kgKyBsY3MubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmkgPSBlW2xjcy5zaSArIGxjcy5sZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZqID0gZltsY3MudGkgKyBsY3MubGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChHcmlkUm91dGVyLmlzTGVmdCh1LCB2aSwgdmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZU9yZGVyLnB1c2goeyBsOiBqLCByOiBpIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZU9yZGVyLnB1c2goeyBsOiBpLCByOiBqIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHcmlkUm91dGVyLmdldE9yZGVyKGVkZ2VPcmRlcik7XHJcbiAgICB9O1xyXG4gICAgR3JpZFJvdXRlci5tYWtlU2VnbWVudHMgPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvcHlQb2ludChwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHAueCwgeTogcC55IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc1N0cmFpZ2h0ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIE1hdGguYWJzKChiLnggLSBhLngpICogKGMueSAtIGEueSkgLSAoYi55IC0gYS55KSAqIChjLnggLSBhLngpKSA8IDAuMDAxOyB9O1xyXG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBhID0gY29weVBvaW50KHBhdGhbMF0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYiA9IGNvcHlQb2ludChwYXRoW2ldKSwgYyA9IGkgPCBwYXRoLmxlbmd0aCAtIDEgPyBwYXRoW2kgKyAxXSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghYyB8fCAhaXNTdHJhaWdodChhLCBiLCBjKSkge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbYSwgYl0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKHMsIHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLm5vZGVzW3NdLCB0YXJnZXQgPSB0aGlzLm5vZGVzW3RdO1xyXG4gICAgICAgIHRoaXMub2JzdGFjbGVzID0gdGhpcy5zaWJsaW5nT2JzdGFjbGVzKHNvdXJjZSwgdGFyZ2V0KTtcclxuICAgICAgICB2YXIgb2JzdGFjbGVMb29rdXAgPSB7fTtcclxuICAgICAgICB0aGlzLm9ic3RhY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvYnN0YWNsZUxvb2t1cFtvLmlkXSA9IG87IH0pO1xyXG4gICAgICAgIHRoaXMucGFzc2FibGVFZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciB1ID0gX3RoaXMudmVydHNbZS5zb3VyY2VdLCB2ID0gX3RoaXMudmVydHNbZS50YXJnZXRdO1xyXG4gICAgICAgICAgICByZXR1cm4gISh1Lm5vZGUgJiYgdS5ub2RlLmlkIGluIG9ic3RhY2xlTG9va3VwXHJcbiAgICAgICAgICAgICAgICB8fCB2Lm5vZGUgJiYgdi5ub2RlLmlkIGluIG9ic3RhY2xlTG9va3VwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNvdXJjZS5wb3J0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdSA9IHNvdXJjZS5wb3J0c1swXS5pZDtcclxuICAgICAgICAgICAgdmFyIHYgPSBzb3VyY2UucG9ydHNbaV0uaWQ7XHJcbiAgICAgICAgICAgIHRoaXMucGFzc2FibGVFZGdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogdSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdixcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0YXJnZXQucG9ydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHUgPSB0YXJnZXQucG9ydHNbMF0uaWQ7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGFyZ2V0LnBvcnRzW2ldLmlkO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NhYmxlRWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHYsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnZXRTb3VyY2UgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zb3VyY2U7IH0sIGdldFRhcmdldCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldDsgfSwgZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubGVuZ3RoOyB9O1xyXG4gICAgICAgIHZhciBzaG9ydGVzdFBhdGhDYWxjdWxhdG9yID0gbmV3IHNob3J0ZXN0cGF0aHNfMS5DYWxjdWxhdG9yKHRoaXMudmVydHMubGVuZ3RoLCB0aGlzLnBhc3NhYmxlRWRnZXMsIGdldFNvdXJjZSwgZ2V0VGFyZ2V0LCBnZXRMZW5ndGgpO1xyXG4gICAgICAgIHZhciBiZW5kUGVuYWx0eSA9IGZ1bmN0aW9uICh1LCB2LCB3KSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gX3RoaXMudmVydHNbdV0sIGIgPSBfdGhpcy52ZXJ0c1t2XSwgYyA9IF90aGlzLnZlcnRzW3ddO1xyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyhjLnggLSBhLngpLCBkeSA9IE1hdGguYWJzKGMueSAtIGEueSk7XHJcbiAgICAgICAgICAgIGlmIChhLm5vZGUgPT09IHNvdXJjZSAmJiBhLm5vZGUgPT09IGIubm9kZSB8fCBiLm5vZGUgPT09IHRhcmdldCAmJiBiLm5vZGUgPT09IGMubm9kZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gZHggPiAxICYmIGR5ID4gMSA/IDEwMDAgOiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNob3J0ZXN0UGF0aCA9IHNob3J0ZXN0UGF0aENhbGN1bGF0b3IuUGF0aEZyb21Ob2RlVG9Ob2RlV2l0aFByZXZDb3N0KHNvdXJjZS5wb3J0c1swXS5pZCwgdGFyZ2V0LnBvcnRzWzBdLmlkLCBiZW5kUGVuYWx0eSk7XHJcbiAgICAgICAgdmFyIHBhdGhQb2ludHMgPSBzaG9ydGVzdFBhdGgucmV2ZXJzZSgpLm1hcChmdW5jdGlvbiAodmkpIHsgcmV0dXJuIF90aGlzLnZlcnRzW3ZpXTsgfSk7XHJcbiAgICAgICAgcGF0aFBvaW50cy5wdXNoKHRoaXMubm9kZXNbdGFyZ2V0LmlkXS5wb3J0c1swXSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhQb2ludHMuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKGkgPCBwYXRoUG9pbnRzLmxlbmd0aCAtIDEgJiYgcGF0aFBvaW50c1tpICsgMV0ubm9kZSA9PT0gc291cmNlICYmIHYubm9kZSA9PT0gc291cmNlXHJcbiAgICAgICAgICAgICAgICB8fCBpID4gMCAmJiB2Lm5vZGUgPT09IHRhcmdldCAmJiBwYXRoUG9pbnRzW2kgLSAxXS5ub2RlID09PSB0YXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEdyaWRSb3V0ZXIuZ2V0Um91dGVQYXRoID0gZnVuY3Rpb24gKHJvdXRlLCBjb3JuZXJyYWRpdXMsIGFycm93d2lkdGgsIGFycm93aGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgcm91dGVwYXRoOiAnTSAnICsgcm91dGVbMF1bMF0ueCArICcgJyArIHJvdXRlWzBdWzBdLnkgKyAnICcsXHJcbiAgICAgICAgICAgIGFycm93cGF0aDogJydcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChyb3V0ZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaSA9IHJvdXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBsaVsxXS54LCB5ID0gbGlbMV0ueTtcclxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSBsaVswXS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtIGxpWzBdLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHJvdXRlLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4IC09IGR4IC8gTWF0aC5hYnMoZHgpICogY29ybmVycmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSBkeSAvIE1hdGguYWJzKGR5KSAqIGNvcm5lcnJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJvdXRlcGF0aCArPSAnTCAnICsgeCArICcgJyArIHkgKyAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSByb3V0ZVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgwID0gbFswXS54LCB5MCA9IGxbMF0ueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBsWzFdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gbFsxXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGR4ID0geDEgLSB4MDtcclxuICAgICAgICAgICAgICAgICAgICBkeSA9IHkxIC0geTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gR3JpZFJvdXRlci5hbmdsZUJldHdlZW4yTGluZXMobGksIGwpIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiwgeTI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4MCArIGR4IC8gTWF0aC5hYnMoZHgpICogY29ybmVycmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHkwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5MCArIGR5IC8gTWF0aC5hYnMoZHkpICogY29ybmVycmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBNYXRoLmFicyh4MiAtIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IE1hdGguYWJzKHkyIC0geSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJvdXRlcGF0aCArPSAnQSAnICsgY3ggKyAnICcgKyBjeSArICcgMCAwICcgKyBhbmdsZSArICcgJyArIHgyICsgJyAnICsgeTIgKyAnICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyb3d0aXAgPSBbeCwgeV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycm93Y29ybmVyMSwgYXJyb3djb3JuZXIyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkeCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gZHggLyBNYXRoLmFicyhkeCkgKiBhcnJvd2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3djb3JuZXIxID0gW3gsIHkgKyBhcnJvd3dpZHRoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3djb3JuZXIyID0gW3gsIHkgLSBhcnJvd3dpZHRoXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gZHkgLyBNYXRoLmFicyhkeSkgKiBhcnJvd2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3djb3JuZXIxID0gW3ggKyBhcnJvd3dpZHRoLCB5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3djb3JuZXIyID0gW3ggLSBhcnJvd3dpZHRoLCB5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJvdXRlcGF0aCArPSAnTCAnICsgeCArICcgJyArIHkgKyAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycm93aGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXJyb3dwYXRoID0gJ00gJyArIGFycm93dGlwWzBdICsgJyAnICsgYXJyb3d0aXBbMV0gKyAnIEwgJyArIGFycm93Y29ybmVyMVswXSArICcgJyArIGFycm93Y29ybmVyMVsxXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIEwgJyArIGFycm93Y29ybmVyMlswXSArICcgJyArIGFycm93Y29ybmVyMlsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaSA9IHJvdXRlWzBdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IGxpWzFdLngsIHkgPSBsaVsxXS55O1xyXG4gICAgICAgICAgICB2YXIgZHggPSB4IC0gbGlbMF0ueDtcclxuICAgICAgICAgICAgdmFyIGR5ID0geSAtIGxpWzBdLnk7XHJcbiAgICAgICAgICAgIHZhciBhcnJvd3RpcCA9IFt4LCB5XTtcclxuICAgICAgICAgICAgdmFyIGFycm93Y29ybmVyMSwgYXJyb3djb3JuZXIyO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZHgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgeCAtPSBkeCAvIE1hdGguYWJzKGR4KSAqIGFycm93aGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgYXJyb3djb3JuZXIxID0gW3gsIHkgKyBhcnJvd3dpZHRoXTtcclxuICAgICAgICAgICAgICAgIGFycm93Y29ybmVyMiA9IFt4LCB5IC0gYXJyb3d3aWR0aF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5IC09IGR5IC8gTWF0aC5hYnMoZHkpICogYXJyb3doZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBhcnJvd2Nvcm5lcjEgPSBbeCArIGFycm93d2lkdGgsIHldO1xyXG4gICAgICAgICAgICAgICAgYXJyb3djb3JuZXIyID0gW3ggLSBhcnJvd3dpZHRoLCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucm91dGVwYXRoICs9ICdMICcgKyB4ICsgJyAnICsgeSArICcgJztcclxuICAgICAgICAgICAgaWYgKGFycm93aGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmFycm93cGF0aCA9ICdNICcgKyBhcnJvd3RpcFswXSArICcgJyArIGFycm93dGlwWzFdICsgJyBMICcgKyBhcnJvd2Nvcm5lcjFbMF0gKyAnICcgKyBhcnJvd2Nvcm5lcjFbMV1cclxuICAgICAgICAgICAgICAgICAgICArICcgTCAnICsgYXJyb3djb3JuZXIyWzBdICsgJyAnICsgYXJyb3djb3JuZXIyWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdyaWRSb3V0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuR3JpZFJvdXRlciA9IEdyaWRSb3V0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyaWRyb3V0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHBhY2tpbmdPcHRpb25zID0ge1xyXG4gICAgUEFERElORzogMTAsXHJcbiAgICBHT0xERU5fU0VDVElPTjogKDEgKyBNYXRoLnNxcnQoNSkpIC8gMixcclxuICAgIEZMT0FUX0VQU0lMT046IDAuMDAwMSxcclxuICAgIE1BWF9JTkVSQVRJT05TOiAxMDBcclxufTtcclxuZnVuY3Rpb24gYXBwbHlQYWNraW5nKGdyYXBocywgdywgaCwgbm9kZV9zaXplLCBkZXNpcmVkX3JhdGlvKSB7XHJcbiAgICBpZiAoZGVzaXJlZF9yYXRpbyA9PT0gdm9pZCAwKSB7IGRlc2lyZWRfcmF0aW8gPSAxOyB9XHJcbiAgICB2YXIgaW5pdF94ID0gMCwgaW5pdF95ID0gMCwgc3ZnX3dpZHRoID0gdywgc3ZnX2hlaWdodCA9IGgsIGRlc2lyZWRfcmF0aW8gPSB0eXBlb2YgZGVzaXJlZF9yYXRpbyAhPT0gJ3VuZGVmaW5lZCcgPyBkZXNpcmVkX3JhdGlvIDogMSwgbm9kZV9zaXplID0gdHlwZW9mIG5vZGVfc2l6ZSAhPT0gJ3VuZGVmaW5lZCcgPyBub2RlX3NpemUgOiAwLCByZWFsX3dpZHRoID0gMCwgcmVhbF9oZWlnaHQgPSAwLCBtaW5fd2lkdGggPSAwLCBnbG9iYWxfYm90dG9tID0gMCwgbGluZSA9IFtdO1xyXG4gICAgaWYgKGdyYXBocy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjYWxjdWxhdGVfYmIoZ3JhcGhzKTtcclxuICAgIGFwcGx5KGdyYXBocywgZGVzaXJlZF9yYXRpbyk7XHJcbiAgICBwdXRfbm9kZXNfdG9fcmlnaHRfcG9zaXRpb25zKGdyYXBocyk7XHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVfYmIoZ3JhcGhzKSB7XHJcbiAgICAgICAgZ3JhcGhzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRlX3NpbmdsZV9iYihnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiBjYWxjdWxhdGVfc2luZ2xlX2JiKGdyYXBoKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5feCA9IE51bWJlci5NQVhfVkFMVUUsIG1pbl95ID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4X3ggPSAwLCBtYXhfeSA9IDA7XHJcbiAgICAgICAgICAgIGdyYXBoLmFycmF5LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3ID0gdHlwZW9mIHYud2lkdGggIT09ICd1bmRlZmluZWQnID8gdi53aWR0aCA6IG5vZGVfc2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBoID0gdHlwZW9mIHYuaGVpZ2h0ICE9PSAndW5kZWZpbmVkJyA/IHYuaGVpZ2h0IDogbm9kZV9zaXplO1xyXG4gICAgICAgICAgICAgICAgdyAvPSAyO1xyXG4gICAgICAgICAgICAgICAgaCAvPSAyO1xyXG4gICAgICAgICAgICAgICAgbWF4X3ggPSBNYXRoLm1heCh2LnggKyB3LCBtYXhfeCk7XHJcbiAgICAgICAgICAgICAgICBtaW5feCA9IE1hdGgubWluKHYueCAtIHcsIG1pbl94KTtcclxuICAgICAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgodi55ICsgaCwgbWF4X3kpO1xyXG4gICAgICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbih2LnkgLSBoLCBtaW5feSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBncmFwaC53aWR0aCA9IG1heF94IC0gbWluX3g7XHJcbiAgICAgICAgICAgIGdyYXBoLmhlaWdodCA9IG1heF95IC0gbWluX3k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHV0X25vZGVzX3RvX3JpZ2h0X3Bvc2l0aW9ucyhncmFwaHMpIHtcclxuICAgICAgICBncmFwaHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGcuYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyLnggKz0gbm9kZS54O1xyXG4gICAgICAgICAgICAgICAgY2VudGVyLnkgKz0gbm9kZS55O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2VudGVyLnggLz0gZy5hcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNlbnRlci55IC89IGcuYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgY29ybmVyID0geyB4OiBjZW50ZXIueCAtIGcud2lkdGggLyAyLCB5OiBjZW50ZXIueSAtIGcuaGVpZ2h0IC8gMiB9O1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0geyB4OiBnLnggLSBjb3JuZXIueCArIHN2Z193aWR0aCAvIDIgLSByZWFsX3dpZHRoIC8gMiwgeTogZy55IC0gY29ybmVyLnkgKyBzdmdfaGVpZ2h0IC8gMiAtIHJlYWxfaGVpZ2h0IC8gMiB9O1xyXG4gICAgICAgICAgICBnLmFycmF5LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUueCArPSBvZmZzZXQueDtcclxuICAgICAgICAgICAgICAgIG5vZGUueSArPSBvZmZzZXQueTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseShkYXRhLCBkZXNpcmVkX3JhdGlvKSB7XHJcbiAgICAgICAgdmFyIGN1cnJfYmVzdF9mID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIHZhciBjdXJyX2Jlc3QgPSAwO1xyXG4gICAgICAgIGRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5oZWlnaHQgLSBhLmhlaWdodDsgfSk7XHJcbiAgICAgICAgbWluX3dpZHRoID0gZGF0YS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEud2lkdGggPCBiLndpZHRoID8gYS53aWR0aCA6IGIud2lkdGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB4MSA9IG1pbl93aWR0aDtcclxuICAgICAgICB2YXIgcmlnaHQgPSB4MiA9IGdldF9lbnRpcmVfd2lkdGgoZGF0YSk7XHJcbiAgICAgICAgdmFyIGl0ZXJhdGlvbkNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHZhciBmX3gxID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgZl94MiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIGZsYWcgPSAtMTtcclxuICAgICAgICB2YXIgZHggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIHZhciBkZiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgd2hpbGUgKChkeCA+IG1pbl93aWR0aCkgfHwgZGYgPiBwYWNraW5nT3B0aW9ucy5GTE9BVF9FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgIGlmIChmbGFnICE9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IHJpZ2h0IC0gKHJpZ2h0IC0gbGVmdCkgLyBwYWNraW5nT3B0aW9ucy5HT0xERU5fU0VDVElPTjtcclxuICAgICAgICAgICAgICAgIHZhciBmX3gxID0gc3RlcChkYXRhLCB4MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZsYWcgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgyID0gbGVmdCArIChyaWdodCAtIGxlZnQpIC8gcGFja2luZ09wdGlvbnMuR09MREVOX1NFQ1RJT047XHJcbiAgICAgICAgICAgICAgICB2YXIgZl94MiA9IHN0ZXAoZGF0YSwgeDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeDEgLSB4Mik7XHJcbiAgICAgICAgICAgIGRmID0gTWF0aC5hYnMoZl94MSAtIGZfeDIpO1xyXG4gICAgICAgICAgICBpZiAoZl94MSA8IGN1cnJfYmVzdF9mKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyX2Jlc3RfZiA9IGZfeDE7XHJcbiAgICAgICAgICAgICAgICBjdXJyX2Jlc3QgPSB4MTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZl94MiA8IGN1cnJfYmVzdF9mKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyX2Jlc3RfZiA9IGZfeDI7XHJcbiAgICAgICAgICAgICAgICBjdXJyX2Jlc3QgPSB4MjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZl94MSA+IGZfeDIpIHtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSB4MTtcclxuICAgICAgICAgICAgICAgIHgxID0geDI7XHJcbiAgICAgICAgICAgICAgICBmX3gxID0gZl94MjtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB4MjtcclxuICAgICAgICAgICAgICAgIHgyID0geDE7XHJcbiAgICAgICAgICAgICAgICBmX3gyID0gZl94MTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25Db3VudGVyKysgPiAxMDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0ZXAoZGF0YSwgY3Vycl9iZXN0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAoZGF0YSwgbWF4X3dpZHRoKSB7XHJcbiAgICAgICAgbGluZSA9IFtdO1xyXG4gICAgICAgIHJlYWxfd2lkdGggPSAwO1xyXG4gICAgICAgIHJlYWxfaGVpZ2h0ID0gMDtcclxuICAgICAgICBnbG9iYWxfYm90dG9tID0gaW5pdF95O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbyA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIHB1dF9yZWN0KG8sIG1heF93aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhnZXRfcmVhbF9yYXRpbygpIC0gZGVzaXJlZF9yYXRpbyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXRfcmVjdChyZWN0LCBtYXhfd2lkdGgpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKGxpbmVbaV0uc3BhY2VfbGVmdCA+PSByZWN0LmhlaWdodCkgJiYgKGxpbmVbaV0ueCArIGxpbmVbaV0ud2lkdGggKyByZWN0LndpZHRoICsgcGFja2luZ09wdGlvbnMuUEFERElORyAtIG1heF93aWR0aCkgPD0gcGFja2luZ09wdGlvbnMuRkxPQVRfRVBTSUxPTikge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbGluZVtpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmUucHVzaChyZWN0KTtcclxuICAgICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVjdC54ID0gcGFyZW50LnggKyBwYXJlbnQud2lkdGggKyBwYWNraW5nT3B0aW9ucy5QQURESU5HO1xyXG4gICAgICAgICAgICByZWN0LnkgPSBwYXJlbnQuYm90dG9tO1xyXG4gICAgICAgICAgICByZWN0LnNwYWNlX2xlZnQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgcmVjdC5ib3R0b20gPSByZWN0Lnk7XHJcbiAgICAgICAgICAgIHBhcmVudC5zcGFjZV9sZWZ0IC09IHJlY3QuaGVpZ2h0ICsgcGFja2luZ09wdGlvbnMuUEFERElORztcclxuICAgICAgICAgICAgcGFyZW50LmJvdHRvbSArPSByZWN0LmhlaWdodCArIHBhY2tpbmdPcHRpb25zLlBBRERJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWN0LnkgPSBnbG9iYWxfYm90dG9tO1xyXG4gICAgICAgICAgICBnbG9iYWxfYm90dG9tICs9IHJlY3QuaGVpZ2h0ICsgcGFja2luZ09wdGlvbnMuUEFERElORztcclxuICAgICAgICAgICAgcmVjdC54ID0gaW5pdF94O1xyXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA9IHJlY3QueTtcclxuICAgICAgICAgICAgcmVjdC5zcGFjZV9sZWZ0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWN0LnkgKyByZWN0LmhlaWdodCAtIHJlYWxfaGVpZ2h0ID4gLXBhY2tpbmdPcHRpb25zLkZMT0FUX0VQU0lMT04pXHJcbiAgICAgICAgICAgIHJlYWxfaGVpZ2h0ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLSBpbml0X3k7XHJcbiAgICAgICAgaWYgKHJlY3QueCArIHJlY3Qud2lkdGggLSByZWFsX3dpZHRoID4gLXBhY2tpbmdPcHRpb25zLkZMT0FUX0VQU0lMT04pXHJcbiAgICAgICAgICAgIHJlYWxfd2lkdGggPSByZWN0LnggKyByZWN0LndpZHRoIC0gaW5pdF94O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZnVuY3Rpb24gZ2V0X2VudGlyZV93aWR0aChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcclxuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHdpZHRoICs9IGQud2lkdGggKyBwYWNraW5nT3B0aW9ucy5QQURESU5HOyB9KTtcclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRfcmVhbF9yYXRpbygpIHtcclxuICAgICAgICByZXR1cm4gKHJlYWxfd2lkdGggLyByZWFsX2hlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseVBhY2tpbmcgPSBhcHBseVBhY2tpbmc7XHJcbmZ1bmN0aW9uIHNlcGFyYXRlR3JhcGhzKG5vZGVzLCBsaW5rcykge1xyXG4gICAgdmFyIG1hcmtzID0ge307XHJcbiAgICB2YXIgd2F5cyA9IHt9O1xyXG4gICAgdmFyIGdyYXBocyA9IFtdO1xyXG4gICAgdmFyIGNsdXN0ZXJzID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgICAgIHZhciBuMSA9IGxpbmsuc291cmNlO1xyXG4gICAgICAgIHZhciBuMiA9IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIGlmICh3YXlzW24xLmluZGV4XSlcclxuICAgICAgICAgICAgd2F5c1tuMS5pbmRleF0ucHVzaChuMik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB3YXlzW24xLmluZGV4XSA9IFtuMl07XHJcbiAgICAgICAgaWYgKHdheXNbbjIuaW5kZXhdKVxyXG4gICAgICAgICAgICB3YXlzW24yLmluZGV4XS5wdXNoKG4xKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHdheXNbbjIuaW5kZXhdID0gW24xXTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGlmIChtYXJrc1tub2RlLmluZGV4XSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgZXhwbG9yZV9ub2RlKG5vZGUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXhwbG9yZV9ub2RlKG4sIGlzX25ldykge1xyXG4gICAgICAgIGlmIChtYXJrc1tuLmluZGV4XSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGlzX25ldykge1xyXG4gICAgICAgICAgICBjbHVzdGVycysrO1xyXG4gICAgICAgICAgICBncmFwaHMucHVzaCh7IGFycmF5OiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya3Nbbi5pbmRleF0gPSBjbHVzdGVycztcclxuICAgICAgICBncmFwaHNbY2x1c3RlcnMgLSAxXS5hcnJheS5wdXNoKG4pO1xyXG4gICAgICAgIHZhciBhZGphY2VudCA9IHdheXNbbi5pbmRleF07XHJcbiAgICAgICAgaWYgKCFhZGphY2VudClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWRqYWNlbnQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgZXhwbG9yZV9ub2RlKGFkamFjZW50W2pdLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdyYXBocztcclxufVxyXG5leHBvcnRzLnNlcGFyYXRlR3JhcGhzID0gc2VwYXJhdGVHcmFwaHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbmRsZWRpc2Nvbm5lY3RlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcG93ZXJncmFwaCA9IHJlcXVpcmUoXCIuL3Bvd2VyZ3JhcGhcIik7XHJcbnZhciBsaW5rbGVuZ3Roc18xID0gcmVxdWlyZShcIi4vbGlua2xlbmd0aHNcIik7XHJcbnZhciBkZXNjZW50XzEgPSByZXF1aXJlKFwiLi9kZXNjZW50XCIpO1xyXG52YXIgcmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9yZWN0YW5nbGVcIik7XHJcbnZhciBzaG9ydGVzdHBhdGhzXzEgPSByZXF1aXJlKFwiLi9zaG9ydGVzdHBhdGhzXCIpO1xyXG52YXIgZ2VvbV8xID0gcmVxdWlyZShcIi4vZ2VvbVwiKTtcclxudmFyIGhhbmRsZWRpc2Nvbm5lY3RlZF8xID0gcmVxdWlyZShcIi4vaGFuZGxlZGlzY29ubmVjdGVkXCIpO1xyXG52YXIgRXZlbnRUeXBlO1xyXG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcInN0YXJ0XCJdID0gMF0gPSBcInN0YXJ0XCI7XHJcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1widGlja1wiXSA9IDFdID0gXCJ0aWNrXCI7XHJcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiZW5kXCJdID0gMl0gPSBcImVuZFwiO1xyXG59KShFdmVudFR5cGUgPSBleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xyXG47XHJcbmZ1bmN0aW9uIGlzR3JvdXAoZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBnLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGcuZ3JvdXBzICE9PSAndW5kZWZpbmVkJztcclxufVxyXG52YXIgTGF5b3V0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExheW91dCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc1NpemUgPSBbMSwgMV07XHJcbiAgICAgICAgdGhpcy5fbGlua0Rpc3RhbmNlID0gMjA7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdE5vZGVTaXplID0gMTA7XHJcbiAgICAgICAgdGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xpbmtUeXBlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hdm9pZE92ZXJsYXBzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9ncm91cHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yb290R3JvdXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xpbmtzID0gW107XHJcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZU1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0ZWRMaW5rQ29uc3RyYWludHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RocmVzaG9sZCA9IDAuMDE7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eUdyYXBoID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ncm91cENvbXBhY3RuZXNzID0gMWUtNjtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmtBY2Nlc3NvciA9IHtcclxuICAgICAgICAgICAgZ2V0U291cmNlSW5kZXg6IExheW91dC5nZXRTb3VyY2VJbmRleCxcclxuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5kZXg6IExheW91dC5nZXRUYXJnZXRJbmRleCxcclxuICAgICAgICAgICAgc2V0TGVuZ3RoOiBMYXlvdXQuc2V0TGlua0xlbmd0aCxcclxuICAgICAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24gKGwpIHsgcmV0dXJuIHR5cGVvZiBfdGhpcy5fbGlua1R5cGUgPT09IFwiZnVuY3Rpb25cIiA/IF90aGlzLl9saW5rVHlwZShsKSA6IDA7IH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICghdGhpcy5ldmVudClcclxuICAgICAgICAgICAgdGhpcy5ldmVudCA9IHt9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFtFdmVudFR5cGVbZV1dID0gbGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50W2VdID0gbGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnQgJiYgdHlwZW9mIHRoaXMuZXZlbnRbZS50eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFtlLnR5cGVdKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmtpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2hpbGUgKCF0aGlzLnRpY2soKSlcclxuICAgICAgICAgICAgO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWxwaGEgPCB0aGlzLl90aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiBFdmVudFR5cGUuZW5kLCBhbHBoYTogdGhpcy5fYWxwaGEgPSAwLCBzdHJlc3M6IHRoaXMuX2xhc3RTdHJlc3MgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbiA9IHRoaXMuX25vZGVzLmxlbmd0aCwgbSA9IHRoaXMuX2xpbmtzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbywgaTtcclxuICAgICAgICB0aGlzLl9kZXNjZW50LmxvY2tzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICBvID0gdGhpcy5fbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChvLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG8ucHggPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvLnB5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8ucHggPSBvLng7XHJcbiAgICAgICAgICAgICAgICAgICAgby5weSA9IG8ueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwID0gW28ucHgsIG8ucHldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5sb2Nrcy5hZGQoaSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHMxID0gdGhpcy5fZGVzY2VudC5ydW5nZUt1dHRhKCk7XHJcbiAgICAgICAgaWYgKHMxID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX2xhc3RTdHJlc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhID0gczE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhc3RTdHJlc3MgPSBzMTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiBFdmVudFR5cGUudGljaywgYWxwaGE6IHRoaXMuX2FscGhhLCBzdHJlc3M6IHRoaXMuX2xhc3RTdHJlc3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUudXBkYXRlTm9kZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuX2Rlc2NlbnQueFswXSwgeSA9IHRoaXMuX2Rlc2NlbnQueFsxXTtcclxuICAgICAgICB2YXIgbywgaSA9IHRoaXMuX25vZGVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIG8gPSB0aGlzLl9ub2Rlc1tpXTtcclxuICAgICAgICAgICAgby54ID0geFtpXTtcclxuICAgICAgICAgICAgby55ID0geVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ub2Rlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fbGlua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBNYXRoLm1heChuLCBsLnNvdXJjZSwgbC50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlcyA9IG5ldyBBcnJheSgrK24pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tpXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbm9kZXMgPSB2O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZ3JvdXBzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICgheClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwcztcclxuICAgICAgICB0aGlzLl9ncm91cHMgPSB4O1xyXG4gICAgICAgIHRoaXMuX3Jvb3RHcm91cCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZy5wYWRkaW5nID09PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgZy5wYWRkaW5nID0gMTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnLmxlYXZlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgZy5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChnLmxlYXZlc1tpXSA9IF90aGlzLl9ub2Rlc1t2XSkucGFyZW50ID0gZztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZy5ncm91cHMgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGcuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdpLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnaSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChnLmdyb3Vwc1tpXSA9IF90aGlzLl9ncm91cHNbZ2ldKS5wYXJlbnQgPSBnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yb290R3JvdXAubGVhdmVzID0gdGhpcy5fbm9kZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2Ygdi5wYXJlbnQgPT09ICd1bmRlZmluZWQnOyB9KTtcclxuICAgICAgICB0aGlzLl9yb290R3JvdXAuZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLmZpbHRlcihmdW5jdGlvbiAoZykgeyByZXR1cm4gdHlwZW9mIGcucGFyZW50ID09PSAndW5kZWZpbmVkJzsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5wb3dlckdyYXBoR3JvdXBzID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICB2YXIgZyA9IHBvd2VyZ3JhcGguZ2V0R3JvdXBzKHRoaXMuX25vZGVzLCB0aGlzLl9saW5rcywgdGhpcy5saW5rQWNjZXNzb3IsIHRoaXMuX3Jvb3RHcm91cCk7XHJcbiAgICAgICAgdGhpcy5ncm91cHMoZy5ncm91cHMpO1xyXG4gICAgICAgIGYoZyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5hdm9pZE92ZXJsYXBzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdm9pZE92ZXJsYXBzO1xyXG4gICAgICAgIHRoaXMuX2F2b2lkT3ZlcmxhcHMgPSB2O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuaGFuZGxlRGlzY29ubmVjdGVkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdGVkID0gdjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmZsb3dMYXlvdXQgPSBmdW5jdGlvbiAoYXhpcywgbWluU2VwYXJhdGlvbikge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgYXhpcyA9ICd5JztcclxuICAgICAgICB0aGlzLl9kaXJlY3RlZExpbmtDb25zdHJhaW50cyA9IHtcclxuICAgICAgICAgICAgYXhpczogYXhpcyxcclxuICAgICAgICAgICAgZ2V0TWluU2VwYXJhdGlvbjogdHlwZW9mIG1pblNlcGFyYXRpb24gPT09ICdudW1iZXInID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluU2VwYXJhdGlvbjsgfSA6IG1pblNlcGFyYXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUubGlua3MgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmtzO1xyXG4gICAgICAgIHRoaXMuX2xpbmtzID0geDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW50cztcclxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5kaXN0YW5jZU1hdHJpeCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VNYXRyaXg7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VNYXRyaXggPSBkO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCF4KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzU2l6ZTtcclxuICAgICAgICB0aGlzLl9jYW52YXNTaXplID0geDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmRlZmF1bHROb2RlU2l6ZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCF4KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE5vZGVTaXplO1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHROb2RlU2l6ZSA9IHg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5ncm91cENvbXBhY3RuZXNzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIXgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ncm91cENvbXBhY3RuZXNzO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwQ29tcGFjdG5lc3MgPSB4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUubGlua0Rpc3RhbmNlID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmtEaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGlua0Rpc3RhbmNlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcclxuICAgICAgICB0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvciA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5saW5rVHlwZSA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgdGhpcy5fbGlua1R5cGUgPSBmO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuY29udmVyZ2VuY2VUaHJlc2hvbGQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICgheClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVzaG9sZDtcclxuICAgICAgICB0aGlzLl90aHJlc2hvbGQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4ID0gK3g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FscGhhID0geDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbHBoYSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6IEV2ZW50VHlwZS5zdGFydCwgYWxwaGE6IHRoaXMuX2FscGhhID0geCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5nZXRMaW5rTGVuZ3RoID0gZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2xpbmtEaXN0YW5jZSA9PT0gXCJmdW5jdGlvblwiID8gKyh0aGlzLl9saW5rRGlzdGFuY2UobGluaykpIDogdGhpcy5fbGlua0Rpc3RhbmNlO1xyXG4gICAgfTtcclxuICAgIExheW91dC5zZXRMaW5rTGVuZ3RoID0gZnVuY3Rpb24gKGxpbmssIGxlbmd0aCkge1xyXG4gICAgICAgIGxpbmsubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuZ2V0TGlua1R5cGUgPSBmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fbGlua1R5cGUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2xpbmtUeXBlKGxpbmspIDogMDtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnN5bW1ldHJpY0RpZmZMaW5rTGVuZ3RocyA9IGZ1bmN0aW9uIChpZGVhbExlbmd0aCwgdykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMTsgfVxyXG4gICAgICAgIHRoaXMubGlua0Rpc3RhbmNlKGZ1bmN0aW9uIChsKSB7IHJldHVybiBpZGVhbExlbmd0aCAqIGwubGVuZ3RoOyB9KTtcclxuICAgICAgICB0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtsZW5ndGhzXzEuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzKF90aGlzLl9saW5rcywgX3RoaXMubGlua0FjY2Vzc29yLCB3KTsgfTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLmphY2NhcmRMaW5rTGVuZ3RocyA9IGZ1bmN0aW9uIChpZGVhbExlbmd0aCwgdykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gMTsgfVxyXG4gICAgICAgIHRoaXMubGlua0Rpc3RhbmNlKGZ1bmN0aW9uIChsKSB7IHJldHVybiBpZGVhbExlbmd0aCAqIGwubGVuZ3RoOyB9KTtcclxuICAgICAgICB0aGlzLl9saW5rTGVuZ3RoQ2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtsZW5ndGhzXzEuamFjY2FyZExpbmtMZW5ndGhzKF90aGlzLl9saW5rcywgX3RoaXMubGlua0FjY2Vzc29yLCB3KTsgfTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGluaXRpYWxVbmNvbnN0cmFpbmVkSXRlcmF0aW9ucywgaW5pdGlhbFVzZXJDb25zdHJhaW50SXRlcmF0aW9ucywgaW5pdGlhbEFsbENvbnN0cmFpbnRzSXRlcmF0aW9ucywgZ3JpZFNuYXBJdGVyYXRpb25zLCBrZWVwUnVubmluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGluaXRpYWxVbmNvbnN0cmFpbmVkSXRlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IGluaXRpYWxVbmNvbnN0cmFpbmVkSXRlcmF0aW9ucyA9IDA7IH1cclxuICAgICAgICBpZiAoaW5pdGlhbFVzZXJDb25zdHJhaW50SXRlcmF0aW9ucyA9PT0gdm9pZCAwKSB7IGluaXRpYWxVc2VyQ29uc3RyYWludEl0ZXJhdGlvbnMgPSAwOyB9XHJcbiAgICAgICAgaWYgKGluaXRpYWxBbGxDb25zdHJhaW50c0l0ZXJhdGlvbnMgPT09IHZvaWQgMCkgeyBpbml0aWFsQWxsQ29uc3RyYWludHNJdGVyYXRpb25zID0gMDsgfVxyXG4gICAgICAgIGlmIChncmlkU25hcEl0ZXJhdGlvbnMgPT09IHZvaWQgMCkgeyBncmlkU25hcEl0ZXJhdGlvbnMgPSAwOyB9XHJcbiAgICAgICAgaWYgKGtlZXBSdW5uaW5nID09PSB2b2lkIDApIHsga2VlcFJ1bm5pbmcgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIGksIGosIG4gPSB0aGlzLm5vZGVzKCkubGVuZ3RoLCBOID0gbiArIDIgKiB0aGlzLl9ncm91cHMubGVuZ3RoLCBtID0gdGhpcy5fbGlua3MubGVuZ3RoLCB3ID0gdGhpcy5fY2FudmFzU2l6ZVswXSwgaCA9IHRoaXMuX2NhbnZhc1NpemVbMV07XHJcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkoTiksIHkgPSBuZXcgQXJyYXkoTik7XHJcbiAgICAgICAgdmFyIEcgPSBudWxsO1xyXG4gICAgICAgIHZhciBhbyA9IHRoaXMuX2F2b2lkT3ZlcmxhcHM7XHJcbiAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICB2LmluZGV4ID0gaTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2LnggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2LnggPSB3IC8gMiwgdi55ID0gaCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeFtpXSA9IHYueCwgeVtpXSA9IHYueTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5fbGlua0xlbmd0aENhbGN1bGF0b3IpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmtMZW5ndGhDYWxjdWxhdG9yKCk7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlcztcclxuICAgICAgICBpZiAodGhpcy5fZGlzdGFuY2VNYXRyaXgpIHtcclxuICAgICAgICAgICAgZGlzdGFuY2VzID0gdGhpcy5fZGlzdGFuY2VNYXRyaXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaXN0YW5jZXMgPSAobmV3IHNob3J0ZXN0cGF0aHNfMS5DYWxjdWxhdG9yKE4sIHRoaXMuX2xpbmtzLCBMYXlvdXQuZ2V0U291cmNlSW5kZXgsIExheW91dC5nZXRUYXJnZXRJbmRleCwgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLmdldExpbmtMZW5ndGgobCk7IH0pKS5EaXN0YW5jZU1hdHJpeCgpO1xyXG4gICAgICAgICAgICBHID0gZGVzY2VudF8xLkRlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4KE4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDI7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGwuc291cmNlID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbC5zb3VyY2UgPSBfdGhpcy5fbm9kZXNbbC5zb3VyY2VdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsLnRhcmdldCA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIGwudGFyZ2V0ID0gX3RoaXMuX25vZGVzW2wudGFyZ2V0XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmtzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1ID0gTGF5b3V0LmdldFNvdXJjZUluZGV4KGUpLCB2ID0gTGF5b3V0LmdldFRhcmdldEluZGV4KGUpO1xyXG4gICAgICAgICAgICAgICAgR1t1XVt2XSA9IEdbdl1bdV0gPSBlLndlaWdodCB8fCAxO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIEQgPSBkZXNjZW50XzEuRGVzY2VudC5jcmVhdGVTcXVhcmVNYXRyaXgoTiwgZnVuY3Rpb24gKGksIGopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlc1tpXVtqXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEdyb3VwICYmIHR5cGVvZiB0aGlzLl9yb290R3JvdXAuZ3JvdXBzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IG47XHJcbiAgICAgICAgICAgIHZhciBhZGRBdHRyYWN0aW9uID0gZnVuY3Rpb24gKGksIGosIHN0cmVuZ3RoLCBpZGVhbERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBHW2ldW2pdID0gR1tqXVtpXSA9IHN0cmVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgRFtpXVtqXSA9IERbal1baV0gPSBpZGVhbERpc3RhbmNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICAgICAgYWRkQXR0cmFjdGlvbihpLCBpICsgMSwgX3RoaXMuX2dyb3VwQ29tcGFjdG5lc3MsIDAuMSk7XHJcbiAgICAgICAgICAgICAgICB4W2ldID0gMCwgeVtpKytdID0gMDtcclxuICAgICAgICAgICAgICAgIHhbaV0gPSAwLCB5W2krK10gPSAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLl9yb290R3JvdXAgPSB7IGxlYXZlczogdGhpcy5fbm9kZXMsIGdyb3VwczogW10gfTtcclxuICAgICAgICB2YXIgY3VyQ29uc3RyYWludHMgPSB0aGlzLl9jb25zdHJhaW50cyB8fCBbXTtcclxuICAgICAgICBpZiAodGhpcy5fZGlyZWN0ZWRMaW5rQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rQWNjZXNzb3IuZ2V0TWluU2VwYXJhdGlvbiA9IHRoaXMuX2RpcmVjdGVkTGlua0NvbnN0cmFpbnRzLmdldE1pblNlcGFyYXRpb247XHJcbiAgICAgICAgICAgIGN1ckNvbnN0cmFpbnRzID0gY3VyQ29uc3RyYWludHMuY29uY2F0KGxpbmtsZW5ndGhzXzEuZ2VuZXJhdGVEaXJlY3RlZEVkZ2VDb25zdHJhaW50cyhuLCB0aGlzLl9saW5rcywgdGhpcy5fZGlyZWN0ZWRMaW5rQ29uc3RyYWludHMuYXhpcywgKHRoaXMubGlua0FjY2Vzc29yKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF2b2lkT3ZlcmxhcHMoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NlbnQgPSBuZXcgZGVzY2VudF8xLkRlc2NlbnQoW3gsIHldLCBEKTtcclxuICAgICAgICB0aGlzLl9kZXNjZW50LmxvY2tzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl9ub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKG8uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgIG8ucHggPSBvLng7XHJcbiAgICAgICAgICAgICAgICBvLnB5ID0gby55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBbby54LCBvLnldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5sb2Nrcy5hZGQoaSwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC50aHJlc2hvbGQgPSB0aGlzLl90aHJlc2hvbGQ7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsTGF5b3V0KGluaXRpYWxVbmNvbnN0cmFpbmVkSXRlcmF0aW9ucywgeCwgeSk7XHJcbiAgICAgICAgaWYgKGN1ckNvbnN0cmFpbnRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQucHJvamVjdCA9IG5ldyByZWN0YW5nbGVfMS5Qcm9qZWN0aW9uKHRoaXMuX25vZGVzLCB0aGlzLl9ncm91cHMsIHRoaXMuX3Jvb3RHcm91cCwgY3VyQ29uc3RyYWludHMpLnByb2plY3RGdW5jdGlvbnMoKTtcclxuICAgICAgICB0aGlzLl9kZXNjZW50LnJ1bihpbml0aWFsVXNlckNvbnN0cmFpbnRJdGVyYXRpb25zKTtcclxuICAgICAgICB0aGlzLnNlcGFyYXRlT3ZlcmxhcHBpbmdDb21wb25lbnRzKHcsIGgpO1xyXG4gICAgICAgIHRoaXMuYXZvaWRPdmVybGFwcyhhbyk7XHJcbiAgICAgICAgaWYgKGFvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgdi54ID0geFtpXSwgdi55ID0geVtpXTsgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQucHJvamVjdCA9IG5ldyByZWN0YW5nbGVfMS5Qcm9qZWN0aW9uKHRoaXMuX25vZGVzLCB0aGlzLl9ncm91cHMsIHRoaXMuX3Jvb3RHcm91cCwgY3VyQ29uc3RyYWludHMsIHRydWUpLnByb2plY3RGdW5jdGlvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyB4W2ldID0gdi54LCB5W2ldID0gdi55OyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVzY2VudC5HID0gRztcclxuICAgICAgICB0aGlzLl9kZXNjZW50LnJ1bihpbml0aWFsQWxsQ29uc3RyYWludHNJdGVyYXRpb25zKTtcclxuICAgICAgICBpZiAoZ3JpZFNuYXBJdGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQuc25hcFN0cmVuZ3RoID0gMTAwMDtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5zbmFwR3JpZFNpemUgPSB0aGlzLl9ub2Rlc1swXS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5udW1HcmlkU25hcE5vZGVzID0gbjtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5zY2FsZVNuYXBCeU1heEggPSBuICE9IE47XHJcbiAgICAgICAgICAgIHZhciBHMCA9IGRlc2NlbnRfMS5EZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeChOLCBmdW5jdGlvbiAoaSwgaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbiB8fCBqID49IG4pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdbaV1bal07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc2NlbnQuRyA9IEcwO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXNjZW50LnJ1bihncmlkU25hcEl0ZXJhdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnNlcGFyYXRlT3ZlcmxhcHBpbmdDb21wb25lbnRzKHcsIGgpO1xyXG4gICAgICAgIHJldHVybiBrZWVwUnVubmluZyA/IHRoaXMucmVzdW1lKCkgOiB0aGlzO1xyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuaW5pdGlhbExheW91dCA9IGZ1bmN0aW9uIChpdGVyYXRpb25zLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyb3Vwcy5sZW5ndGggPiAwICYmIGl0ZXJhdGlvbnMgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLl9saW5rcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuICh7IHNvdXJjZTogZS5zb3VyY2UuaW5kZXgsIHRhcmdldDogZS50YXJnZXQuaW5kZXggfSk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgdnMgPSB0aGlzLl9ub2Rlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh7IGluZGV4OiB2LmluZGV4IH0pOyB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZzLnB1c2goeyBpbmRleDogZy5pbmRleCA9IG4gKyBpIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZy5sZWF2ZXMgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGcubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGcuaW5kZXgsIHRhcmdldDogdi5pbmRleCB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGcuZ3JvdXBzICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICBnLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnZykgeyByZXR1cm4gZWRnZXMucHVzaCh7IHNvdXJjZTogZy5pbmRleCwgdGFyZ2V0OiBnZy5pbmRleCB9KTsgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuZXcgTGF5b3V0KClcclxuICAgICAgICAgICAgICAgIC5zaXplKHRoaXMuc2l6ZSgpKVxyXG4gICAgICAgICAgICAgICAgLm5vZGVzKHZzKVxyXG4gICAgICAgICAgICAgICAgLmxpbmtzKGVkZ2VzKVxyXG4gICAgICAgICAgICAgICAgLmF2b2lkT3ZlcmxhcHMoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAubGlua0Rpc3RhbmNlKHRoaXMubGlua0Rpc3RhbmNlKCkpXHJcbiAgICAgICAgICAgICAgICAuc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzKDUpXHJcbiAgICAgICAgICAgICAgICAuY29udmVyZ2VuY2VUaHJlc2hvbGQoMWUtNClcclxuICAgICAgICAgICAgICAgIC5zdGFydChpdGVyYXRpb25zLCAwLCAwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHhbdi5pbmRleF0gPSB2c1t2LmluZGV4XS54O1xyXG4gICAgICAgICAgICAgICAgeVt2LmluZGV4XSA9IHZzW3YuaW5kZXhdLnk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzY2VudC5ydW4oaXRlcmF0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5wcm90b3R5cGUuc2VwYXJhdGVPdmVybGFwcGluZ0NvbXBvbmVudHMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXN0YW5jZU1hdHJpeCAmJiB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHhfMSA9IHRoaXMuX2Rlc2NlbnQueFswXSwgeV8xID0gdGhpcy5fZGVzY2VudC54WzFdO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHYueCA9IHhfMVtpXSwgdi55ID0geV8xW2ldOyB9KTtcclxuICAgICAgICAgICAgdmFyIGdyYXBocyA9IGhhbmRsZWRpc2Nvbm5lY3RlZF8xLnNlcGFyYXRlR3JhcGhzKHRoaXMuX25vZGVzLCB0aGlzLl9saW5rcyk7XHJcbiAgICAgICAgICAgIGhhbmRsZWRpc2Nvbm5lY3RlZF8xLmFwcGx5UGFja2luZyhncmFwaHMsIHdpZHRoLCBoZWlnaHQsIHRoaXMuX2RlZmF1bHROb2RlU2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9kZXNjZW50LnhbMF1baV0gPSB2LngsIF90aGlzLl9kZXNjZW50LnhbMV1baV0gPSB2Lnk7XHJcbiAgICAgICAgICAgICAgICBpZiAodi5ib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmJvdW5kcy5zZXRYQ2VudHJlKHYueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5ib3VuZHMuc2V0WUNlbnRyZSh2LnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGEoMC4xKTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGEoMCk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnByb3RvdHlwZS5wcmVwYXJlRWRnZVJvdXRpbmcgPSBmdW5jdGlvbiAobm9kZU1hcmdpbikge1xyXG4gICAgICAgIGlmIChub2RlTWFyZ2luID09PSB2b2lkIDApIHsgbm9kZU1hcmdpbiA9IDA7IH1cclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5R3JhcGggPSBuZXcgZ2VvbV8xLlRhbmdlbnRWaXNpYmlsaXR5R3JhcGgodGhpcy5fbm9kZXMubWFwKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2LmJvdW5kcy5pbmZsYXRlKC1ub2RlTWFyZ2luKS52ZXJ0aWNlcygpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQucHJvdG90eXBlLnJvdXRlRWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBhaCwgZHJhdykge1xyXG4gICAgICAgIGlmIChhaCA9PT0gdm9pZCAwKSB7IGFoID0gNTsgfVxyXG4gICAgICAgIHZhciBsaW5lRGF0YSA9IFtdO1xyXG4gICAgICAgIHZhciB2ZzIgPSBuZXcgZ2VvbV8xLlRhbmdlbnRWaXNpYmlsaXR5R3JhcGgodGhpcy5fdmlzaWJpbGl0eUdyYXBoLlAsIHsgVjogdGhpcy5fdmlzaWJpbGl0eUdyYXBoLlYsIEU6IHRoaXMuX3Zpc2liaWxpdHlHcmFwaC5FIH0pLCBwb3J0MSA9IHsgeDogZWRnZS5zb3VyY2UueCwgeTogZWRnZS5zb3VyY2UueSB9LCBwb3J0MiA9IHsgeDogZWRnZS50YXJnZXQueCwgeTogZWRnZS50YXJnZXQueSB9LCBzdGFydCA9IHZnMi5hZGRQb2ludChwb3J0MSwgZWRnZS5zb3VyY2UuaW5kZXgpLCBlbmQgPSB2ZzIuYWRkUG9pbnQocG9ydDIsIGVkZ2UudGFyZ2V0LmluZGV4KTtcclxuICAgICAgICB2ZzIuYWRkRWRnZUlmVmlzaWJsZShwb3J0MSwgcG9ydDIsIGVkZ2Uuc291cmNlLmluZGV4LCBlZGdlLnRhcmdldC5pbmRleCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkcmF3ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBkcmF3KHZnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb3VyY2VJbmQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zb3VyY2UuaWQ7IH0sIHRhcmdldEluZCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldC5pZDsgfSwgbGVuZ3RoID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubGVuZ3RoKCk7IH0sIHNwQ2FsYyA9IG5ldyBzaG9ydGVzdHBhdGhzXzEuQ2FsY3VsYXRvcih2ZzIuVi5sZW5ndGgsIHZnMi5FLCBzb3VyY2VJbmQsIHRhcmdldEluZCwgbGVuZ3RoKSwgc2hvcnRlc3RQYXRoID0gc3BDYWxjLlBhdGhGcm9tTm9kZVRvTm9kZShzdGFydC5pZCwgZW5kLmlkKTtcclxuICAgICAgICBpZiAoc2hvcnRlc3RQYXRoLmxlbmd0aCA9PT0gMSB8fCBzaG9ydGVzdFBhdGgubGVuZ3RoID09PSB2ZzIuVi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHJvdXRlID0gcmVjdGFuZ2xlXzEubWFrZUVkZ2VCZXR3ZWVuKGVkZ2Uuc291cmNlLmlubmVyQm91bmRzLCBlZGdlLnRhcmdldC5pbm5lckJvdW5kcywgYWgpO1xyXG4gICAgICAgICAgICBsaW5lRGF0YSA9IFtyb3V0ZS5zb3VyY2VJbnRlcnNlY3Rpb24sIHJvdXRlLmFycm93U3RhcnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBzaG9ydGVzdFBhdGgubGVuZ3RoIC0gMiwgcCA9IHZnMi5WW3Nob3J0ZXN0UGF0aFtuXV0ucCwgcSA9IHZnMi5WW3Nob3J0ZXN0UGF0aFswXV0ucCwgbGluZURhdGEgPSBbZWRnZS5zb3VyY2UuaW5uZXJCb3VuZHMucmF5SW50ZXJzZWN0aW9uKHAueCwgcC55KV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBuOyBpID49IDA7IC0taSlcclxuICAgICAgICAgICAgICAgIGxpbmVEYXRhLnB1c2godmcyLlZbc2hvcnRlc3RQYXRoW2ldXS5wKTtcclxuICAgICAgICAgICAgbGluZURhdGEucHVzaChyZWN0YW5nbGVfMS5tYWtlRWRnZVRvKHEsIGVkZ2UudGFyZ2V0LmlubmVyQm91bmRzLCBhaCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZURhdGE7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmdldFNvdXJjZUluZGV4ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGUuc291cmNlID09PSAnbnVtYmVyJyA/IGUuc291cmNlIDogZS5zb3VyY2UuaW5kZXg7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmdldFRhcmdldEluZGV4ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGUudGFyZ2V0ID09PSAnbnVtYmVyJyA/IGUudGFyZ2V0IDogZS50YXJnZXQuaW5kZXg7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmxpbmtJZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIExheW91dC5nZXRTb3VyY2VJbmRleChlKSArIFwiLVwiICsgTGF5b3V0LmdldFRhcmdldEluZGV4KGUpO1xyXG4gICAgfTtcclxuICAgIExheW91dC5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChpc0dyb3VwKGQpKSB7XHJcbiAgICAgICAgICAgIExheW91dC5zdG9yZU9mZnNldChkLCBMYXlvdXQuZHJhZ09yaWdpbihkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBMYXlvdXQuc3RvcE5vZGUoZCk7XHJcbiAgICAgICAgICAgIGQuZml4ZWQgfD0gMjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnN0b3BOb2RlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2LnB4ID0gdi54O1xyXG4gICAgICAgIHYucHkgPSB2Lnk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LnN0b3JlT2Zmc2V0ID0gZnVuY3Rpb24gKGQsIG9yaWdpbikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZC5sZWF2ZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGQubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHYuZml4ZWQgfD0gMjtcclxuICAgICAgICAgICAgICAgIExheW91dC5zdG9wTm9kZSh2KTtcclxuICAgICAgICAgICAgICAgIHYuX2RyYWdHcm91cE9mZnNldFggPSB2LnggLSBvcmlnaW4ueDtcclxuICAgICAgICAgICAgICAgIHYuX2RyYWdHcm91cE9mZnNldFkgPSB2LnkgLSBvcmlnaW4ueTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZC5ncm91cHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGQuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHsgcmV0dXJuIExheW91dC5zdG9yZU9mZnNldChnLCBvcmlnaW4pOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0LmRyYWdPcmlnaW4gPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChpc0dyb3VwKGQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBkLmJvdW5kcy5jeCgpLFxyXG4gICAgICAgICAgICAgICAgeTogZC5ib3VuZHMuY3koKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5kcmFnID0gZnVuY3Rpb24gKGQsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzR3JvdXAoZCkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGQubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBkLmJvdW5kcy5zZXRYQ2VudHJlKHBvc2l0aW9uLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuYm91bmRzLnNldFlDZW50cmUocG9zaXRpb24ueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5weCA9IHYuX2RyYWdHcm91cE9mZnNldFggKyBwb3NpdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgICAgIHYucHkgPSB2Ll9kcmFnR3JvdXBPZmZzZXRZICsgcG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC5ncm91cHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBkLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7IHJldHVybiBMYXlvdXQuZHJhZyhnLCBwb3NpdGlvbik7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkLnB4ID0gcG9zaXRpb24ueDtcclxuICAgICAgICAgICAgZC5weSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheW91dC5kcmFnRW5kID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoaXNHcm91cChkKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGQubGVhdmVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZC5sZWF2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIExheW91dC5kcmFnRW5kKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2Ll9kcmFnR3JvdXBPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2Ll9kcmFnR3JvdXBPZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGQuZ3JvdXBzLmZvckVhY2goTGF5b3V0LmRyYWdFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkLmZpeGVkICY9IH42O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXlvdXQubW91c2VPdmVyID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkLmZpeGVkIHw9IDQ7XHJcbiAgICAgICAgZC5weCA9IGQueCwgZC5weSA9IGQueTtcclxuICAgIH07XHJcbiAgICBMYXlvdXQubW91c2VPdXQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQuZml4ZWQgJj0gfjQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExheW91dDtcclxufSgpKTtcclxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgc2hvcnRlc3RwYXRoc18xID0gcmVxdWlyZShcIi4vc2hvcnRlc3RwYXRoc1wiKTtcclxudmFyIGRlc2NlbnRfMSA9IHJlcXVpcmUoXCIuL2Rlc2NlbnRcIik7XHJcbnZhciByZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL3JlY3RhbmdsZVwiKTtcclxudmFyIGxpbmtsZW5ndGhzXzEgPSByZXF1aXJlKFwiLi9saW5rbGVuZ3Roc1wiKTtcclxudmFyIExpbmszRCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaW5rM0Qoc291cmNlLCB0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIExpbmszRC5wcm90b3R5cGUuYWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeC5yZWR1Y2UoZnVuY3Rpb24gKGMsIHYpIHtcclxuICAgICAgICAgICAgdmFyIGR4ID0gdltfdGhpcy50YXJnZXRdIC0gdltfdGhpcy5zb3VyY2VdO1xyXG4gICAgICAgICAgICByZXR1cm4gYyArIGR4ICogZHg7XHJcbiAgICAgICAgfSwgMCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaW5rM0Q7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTGluazNEID0gTGluazNEO1xyXG52YXIgTm9kZTNEID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUzRCh4LCB5LCB6KSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkgeyB4ID0gMDsgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHsgeSA9IDA7IH1cclxuICAgICAgICBpZiAoeiA9PT0gdm9pZCAwKSB7IHogPSAwOyB9XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZTNEO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGUzRCA9IE5vZGUzRDtcclxudmFyIExheW91dDNEID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExheW91dDNEKG5vZGVzLCBsaW5rcywgaWRlYWxMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGlkZWFsTGlua0xlbmd0aCA9PT0gdm9pZCAwKSB7IGlkZWFsTGlua0xlbmd0aCA9IDE7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcclxuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XHJcbiAgICAgICAgdGhpcy5pZGVhbExpbmtMZW5ndGggPSBpZGVhbExpbmtMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51c2VKYWNjYXJkTGlua0xlbmd0aHMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IEFycmF5KExheW91dDNELmspO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTGF5b3V0M0QuazsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0W2ldID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IExheW91dDNELmRpbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGltID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2W2RpbV0gPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgdltkaW1dID0gTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5yZXN1bHRbMF1baV0gPSB2Lng7XHJcbiAgICAgICAgICAgIF90aGlzLnJlc3VsdFsxXVtpXSA9IHYueTtcclxuICAgICAgICAgICAgX3RoaXMucmVzdWx0WzJdW2ldID0gdi56O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgTGF5b3V0M0QucHJvdG90eXBlLmxpbmtMZW5ndGggPSBmdW5jdGlvbiAobCkge1xyXG4gICAgICAgIHJldHVybiBsLmFjdHVhbExlbmd0aCh0aGlzLnJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgTGF5b3V0M0QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpdGVyYXRpb25zID09PSB2b2lkIDApIHsgaXRlcmF0aW9ucyA9IDEwMDsgfVxyXG4gICAgICAgIHZhciBuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGxpbmtBY2Nlc3NvciA9IG5ldyBMaW5rQWNjZXNzb3IoKTtcclxuICAgICAgICBpZiAodGhpcy51c2VKYWNjYXJkTGlua0xlbmd0aHMpXHJcbiAgICAgICAgICAgIGxpbmtsZW5ndGhzXzEuamFjY2FyZExpbmtMZW5ndGhzKHRoaXMubGlua3MsIGxpbmtBY2Nlc3NvciwgMS41KTtcclxuICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubGVuZ3RoICo9IF90aGlzLmlkZWFsTGlua0xlbmd0aDsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0cml4ID0gKG5ldyBzaG9ydGVzdHBhdGhzXzEuQ2FsY3VsYXRvcihuLCB0aGlzLmxpbmtzLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5zb3VyY2U7IH0sIGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldDsgfSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubGVuZ3RoOyB9KSkuRGlzdGFuY2VNYXRyaXgoKTtcclxuICAgICAgICB2YXIgRCA9IGRlc2NlbnRfMS5EZXNjZW50LmNyZWF0ZVNxdWFyZU1hdHJpeChuLCBmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gZGlzdGFuY2VNYXRyaXhbaV1bal07IH0pO1xyXG4gICAgICAgIHZhciBHID0gZGVzY2VudF8xLkRlc2NlbnQuY3JlYXRlU3F1YXJlTWF0cml4KG4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIDI7IH0pO1xyXG4gICAgICAgIHRoaXMubGlua3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9hLnNvdXJjZSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gR1tzb3VyY2VdW3RhcmdldF0gPSBHW3RhcmdldF1bc291cmNlXSA9IDE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZXNjZW50ID0gbmV3IGRlc2NlbnRfMS5EZXNjZW50KHRoaXMucmVzdWx0LCBEKTtcclxuICAgICAgICB0aGlzLmRlc2NlbnQudGhyZXNob2xkID0gMWUtMztcclxuICAgICAgICB0aGlzLmRlc2NlbnQuRyA9IEc7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMpXHJcbiAgICAgICAgICAgIHRoaXMuZGVzY2VudC5wcm9qZWN0ID0gbmV3IHJlY3RhbmdsZV8xLlByb2plY3Rpb24odGhpcy5ub2RlcywgbnVsbCwgbnVsbCwgdGhpcy5jb25zdHJhaW50cykucHJvamVjdEZ1bmN0aW9ucygpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMubm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2LmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2NlbnQubG9ja3MuYWRkKGksIFt2LngsIHYueSwgdi56XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZXNjZW50LnJ1bihpdGVyYXRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBMYXlvdXQzRC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlc2NlbnQubG9ja3MuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLm5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAodi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXNjZW50LmxvY2tzLmFkZChpLCBbdi54LCB2LnksIHYuel0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NlbnQucnVuZ2VLdXR0YSgpO1xyXG4gICAgfTtcclxuICAgIExheW91dDNELmRpbXMgPSBbJ3gnLCAneScsICd6J107XHJcbiAgICBMYXlvdXQzRC5rID0gTGF5b3V0M0QuZGltcy5sZW5ndGg7XHJcbiAgICByZXR1cm4gTGF5b3V0M0Q7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTGF5b3V0M0QgPSBMYXlvdXQzRDtcclxudmFyIExpbmtBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaW5rQWNjZXNzb3IoKSB7XHJcbiAgICB9XHJcbiAgICBMaW5rQWNjZXNzb3IucHJvdG90eXBlLmdldFNvdXJjZUluZGV4ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUuc291cmNlOyB9O1xyXG4gICAgTGlua0FjY2Vzc29yLnByb3RvdHlwZS5nZXRUYXJnZXRJbmRleCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRhcmdldDsgfTtcclxuICAgIExpbmtBY2Nlc3Nvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubGVuZ3RoOyB9O1xyXG4gICAgTGlua0FjY2Vzc29yLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoZSwgbCkgeyBlLmxlbmd0aCA9IGw7IH07XHJcbiAgICByZXR1cm4gTGlua0FjY2Vzc29yO1xyXG59KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQzZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiB1bmlvbkNvdW50KGEsIGIpIHtcclxuICAgIHZhciB1ID0ge307XHJcbiAgICBmb3IgKHZhciBpIGluIGEpXHJcbiAgICAgICAgdVtpXSA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSBpbiBiKVxyXG4gICAgICAgIHVbaV0gPSB7fTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh1KS5sZW5ndGg7XHJcbn1cclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQ291bnQoYSwgYikge1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgZm9yICh2YXIgaSBpbiBhKVxyXG4gICAgICAgIGlmICh0eXBlb2YgYltpXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICsrbjtcclxuICAgIHJldHVybiBuO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5laWdoYm91cnMobGlua3MsIGxhKSB7XHJcbiAgICB2YXIgbmVpZ2hib3VycyA9IHt9O1xyXG4gICAgdmFyIGFkZE5laWdoYm91cnMgPSBmdW5jdGlvbiAodSwgdikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmVpZ2hib3Vyc1t1XSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIG5laWdoYm91cnNbdV0gPSB7fTtcclxuICAgICAgICBuZWlnaGJvdXJzW3VdW3ZdID0ge307XHJcbiAgICB9O1xyXG4gICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciB1ID0gbGEuZ2V0U291cmNlSW5kZXgoZSksIHYgPSBsYS5nZXRUYXJnZXRJbmRleChlKTtcclxuICAgICAgICBhZGROZWlnaGJvdXJzKHUsIHYpO1xyXG4gICAgICAgIGFkZE5laWdoYm91cnModiwgdSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZWlnaGJvdXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVMaW5rTGVuZ3RocyhsaW5rcywgdywgZiwgbGEpIHtcclxuICAgIHZhciBuZWlnaGJvdXJzID0gZ2V0TmVpZ2hib3VycyhsaW5rcywgbGEpO1xyXG4gICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobCkge1xyXG4gICAgICAgIHZhciBhID0gbmVpZ2hib3Vyc1tsYS5nZXRTb3VyY2VJbmRleChsKV07XHJcbiAgICAgICAgdmFyIGIgPSBuZWlnaGJvdXJzW2xhLmdldFRhcmdldEluZGV4KGwpXTtcclxuICAgICAgICBsYS5zZXRMZW5ndGgobCwgMSArIHcgKiBmKGEsIGIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZMaW5rTGVuZ3RocyhsaW5rcywgbGEsIHcpIHtcclxuICAgIGlmICh3ID09PSB2b2lkIDApIHsgdyA9IDE7IH1cclxuICAgIGNvbXB1dGVMaW5rTGVuZ3RocyhsaW5rcywgdywgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGguc3FydCh1bmlvbkNvdW50KGEsIGIpIC0gaW50ZXJzZWN0aW9uQ291bnQoYSwgYikpOyB9LCBsYSk7XHJcbn1cclxuZXhwb3J0cy5zeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMgPSBzeW1tZXRyaWNEaWZmTGlua0xlbmd0aHM7XHJcbmZ1bmN0aW9uIGphY2NhcmRMaW5rTGVuZ3RocyhsaW5rcywgbGEsIHcpIHtcclxuICAgIGlmICh3ID09PSB2b2lkIDApIHsgdyA9IDE7IH1cclxuICAgIGNvbXB1dGVMaW5rTGVuZ3RocyhsaW5rcywgdywgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oT2JqZWN0LmtleXMoYSkubGVuZ3RoLCBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIDwgMS4xID8gMCA6IGludGVyc2VjdGlvbkNvdW50KGEsIGIpIC8gdW5pb25Db3VudChhLCBiKTtcclxuICAgIH0sIGxhKTtcclxufVxyXG5leHBvcnRzLmphY2NhcmRMaW5rTGVuZ3RocyA9IGphY2NhcmRMaW5rTGVuZ3RocztcclxuZnVuY3Rpb24gZ2VuZXJhdGVEaXJlY3RlZEVkZ2VDb25zdHJhaW50cyhuLCBsaW5rcywgYXhpcywgbGEpIHtcclxuICAgIHZhciBjb21wb25lbnRzID0gc3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzKG4sIGxpbmtzLCBsYSk7XHJcbiAgICB2YXIgbm9kZXMgPSB7fTtcclxuICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgIHJldHVybiBjLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5vZGVzW3ZdID0gaTsgfSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBjb25zdHJhaW50cyA9IFtdO1xyXG4gICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobCkge1xyXG4gICAgICAgIHZhciB1aSA9IGxhLmdldFNvdXJjZUluZGV4KGwpLCB2aSA9IGxhLmdldFRhcmdldEluZGV4KGwpLCB1ID0gbm9kZXNbdWldLCB2ID0gbm9kZXNbdmldO1xyXG4gICAgICAgIGlmICh1ICE9PSB2KSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYXhpczogYXhpcyxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHVpLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZpLFxyXG4gICAgICAgICAgICAgICAgZ2FwOiBsYS5nZXRNaW5TZXBhcmF0aW9uKGwpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVEaXJlY3RlZEVkZ2VDb25zdHJhaW50cyA9IGdlbmVyYXRlRGlyZWN0ZWRFZGdlQ29uc3RyYWludHM7XHJcbmZ1bmN0aW9uIHN0cm9uZ2x5Q29ubmVjdGVkQ29tcG9uZW50cyhudW1WZXJ0aWNlcywgZWRnZXMsIGxhKSB7XHJcbiAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgIHZhciBjb21wb25lbnRzID0gW107XHJcbiAgICBmdW5jdGlvbiBzdHJvbmdDb25uZWN0KHYpIHtcclxuICAgICAgICB2LmluZGV4ID0gdi5sb3dsaW5rID0gaW5kZXgrKztcclxuICAgICAgICBzdGFjay5wdXNoKHYpO1xyXG4gICAgICAgIHYub25TdGFjayA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHYub3V0OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdyA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmluZGV4ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgc3Ryb25nQ29ubmVjdCh3KTtcclxuICAgICAgICAgICAgICAgIHYubG93bGluayA9IE1hdGgubWluKHYubG93bGluaywgdy5sb3dsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3Lm9uU3RhY2spIHtcclxuICAgICAgICAgICAgICAgIHYubG93bGluayA9IE1hdGgubWluKHYubG93bGluaywgdy5pbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYubG93bGluayA9PT0gdi5pbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHcgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHcub25TdGFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnB1c2godyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodyA9PT0gdilcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50Lm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5pZDsgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmVydGljZXM7IGkrKykge1xyXG4gICAgICAgIG5vZGVzLnB1c2goeyBpZDogaSwgb3V0OiBbXSB9KTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIF9pID0gMCwgZWRnZXNfMSA9IGVkZ2VzOyBfaSA8IGVkZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGUgPSBlZGdlc18xW19pXTtcclxuICAgICAgICB2YXIgdl8xID0gbm9kZXNbbGEuZ2V0U291cmNlSW5kZXgoZSldLCB3ID0gbm9kZXNbbGEuZ2V0VGFyZ2V0SW5kZXgoZSldO1xyXG4gICAgICAgIHZfMS5vdXQucHVzaCh3KTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIF9hID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfYSA8IG5vZGVzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgdmFyIHYgPSBub2Rlc18xW19hXTtcclxuICAgICAgICBpZiAodHlwZW9mIHYuaW5kZXggPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBzdHJvbmdDb25uZWN0KHYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbn1cclxuZXhwb3J0cy5zdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMgPSBzdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtsZW5ndGhzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBQb3dlckVkZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG93ZXJFZGdlKHNvdXJjZSwgdGFyZ2V0LCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiBQb3dlckVkZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUG93ZXJFZGdlID0gUG93ZXJFZGdlO1xyXG52YXIgQ29uZmlndXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb25maWd1cmF0aW9uKG4sIGVkZ2VzLCBsaW5rQWNjZXNzb3IsIHJvb3RHcm91cCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5saW5rQWNjZXNzb3IgPSBsaW5rQWNjZXNzb3I7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gbmV3IEFycmF5KG4pO1xyXG4gICAgICAgIHRoaXMucm9vdHMgPSBbXTtcclxuICAgICAgICBpZiAocm9vdEdyb3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdE1vZHVsZXNGcm9tR3JvdXAocm9vdEdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdHMucHVzaChuZXcgTW9kdWxlU2V0KCkpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdHNbMF0uYWRkKHRoaXMubW9kdWxlc1tpXSA9IG5ldyBNb2R1bGUoaSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLlIgPSBlZGdlcy5sZW5ndGg7XHJcbiAgICAgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IF90aGlzLm1vZHVsZXNbbGlua0FjY2Vzc29yLmdldFNvdXJjZUluZGV4KGUpXSwgdCA9IF90aGlzLm1vZHVsZXNbbGlua0FjY2Vzc29yLmdldFRhcmdldEluZGV4KGUpXSwgdHlwZSA9IGxpbmtBY2Nlc3Nvci5nZXRUeXBlKGUpO1xyXG4gICAgICAgICAgICBzLm91dGdvaW5nLmFkZCh0eXBlLCB0KTtcclxuICAgICAgICAgICAgdC5pbmNvbWluZy5hZGQodHlwZSwgcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5pbml0TW9kdWxlc0Zyb21Hcm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIHZhciBtb2R1bGVTZXQgPSBuZXcgTW9kdWxlU2V0KCk7XHJcbiAgICAgICAgdGhpcy5yb290cy5wdXNoKG1vZHVsZVNldCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZWF2ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBncm91cC5sZWF2ZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBuZXcgTW9kdWxlKG5vZGUuaWQpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNbbm9kZS5pZF0gPSBtb2R1bGU7XHJcbiAgICAgICAgICAgIG1vZHVsZVNldC5hZGQobW9kdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyb3VwLmdyb3Vwcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLmdyb3Vwcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZ3JvdXAuZ3JvdXBzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgIT09IFwibGVhdmVzXCIgJiYgcHJvcCAhPT0gXCJncm91cHNcIiAmJiBjaGlsZC5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbltwcm9wXSA9IGNoaWxkW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlU2V0LmFkZChuZXcgTW9kdWxlKC0xIC0gaiwgbmV3IExpbmtTZXRzKCksIG5ldyBMaW5rU2V0cygpLCB0aGlzLmluaXRNb2R1bGVzRnJvbUdyb3VwKGNoaWxkKSwgZGVmaW5pdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb2R1bGVTZXQ7XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAoYSwgYiwgaykge1xyXG4gICAgICAgIGlmIChrID09PSB2b2lkIDApIHsgayA9IDA7IH1cclxuICAgICAgICB2YXIgaW5JbnQgPSBhLmluY29taW5nLmludGVyc2VjdGlvbihiLmluY29taW5nKSwgb3V0SW50ID0gYS5vdXRnb2luZy5pbnRlcnNlY3Rpb24oYi5vdXRnb2luZyk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IE1vZHVsZVNldCgpO1xyXG4gICAgICAgIGNoaWxkcmVuLmFkZChhKTtcclxuICAgICAgICBjaGlsZHJlbi5hZGQoYik7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgTW9kdWxlKHRoaXMubW9kdWxlcy5sZW5ndGgsIG91dEludCwgaW5JbnQsIGNoaWxkcmVuKTtcclxuICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChtKTtcclxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHMsIGksIG8pIHtcclxuICAgICAgICAgICAgcy5mb3JBbGwoZnVuY3Rpb24gKG1zLCBsaW5rdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgbXMuZm9yQWxsKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5scyA9IG5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgbmxzLmFkZChsaW5rdHlwZSwgbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmxzLnJlbW92ZShsaW5rdHlwZSwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmxzLnJlbW92ZShsaW5rdHlwZSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgYVtvXS5yZW1vdmUobGlua3R5cGUsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJbb10ucmVtb3ZlKGxpbmt0eXBlLCBuKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHVwZGF0ZShvdXRJbnQsIFwiaW5jb21pbmdcIiwgXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICB1cGRhdGUoaW5JbnQsIFwib3V0Z29pbmdcIiwgXCJpbmNvbWluZ1wiKTtcclxuICAgICAgICB0aGlzLlIgLT0gaW5JbnQuY291bnQoKSArIG91dEludC5jb3VudCgpO1xyXG4gICAgICAgIHRoaXMucm9vdHNba10ucmVtb3ZlKGEpO1xyXG4gICAgICAgIHRoaXMucm9vdHNba10ucmVtb3ZlKGIpO1xyXG4gICAgICAgIHRoaXMucm9vdHNba10uYWRkKG0pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLnJvb3RNZXJnZXMgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgIGlmIChrID09PSB2b2lkIDApIHsgayA9IDA7IH1cclxuICAgICAgICB2YXIgcnMgPSB0aGlzLnJvb3RzW2tdLm1vZHVsZXMoKTtcclxuICAgICAgICB2YXIgbiA9IHJzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbWVyZ2VzID0gbmV3IEFycmF5KG4gKiAobiAtIDEpKTtcclxuICAgICAgICB2YXIgY3RyID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaV8gPSBuIC0gMTsgaSA8IGlfOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbjsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHJzW2ldLCBiID0gcnNbal07XHJcbiAgICAgICAgICAgICAgICBtZXJnZXNbY3RyXSA9IHsgaWQ6IGN0ciwgbkVkZ2VzOiB0aGlzLm5FZGdlcyhhLCBiKSwgYTogYSwgYjogYiB9O1xyXG4gICAgICAgICAgICAgICAgY3RyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlcztcclxuICAgIH07XHJcbiAgICBDb25maWd1cmF0aW9uLnByb3RvdHlwZS5ncmVlZHlNZXJnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm9vdHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdHNbaV0ubW9kdWxlcygpLmxlbmd0aCA8IDIpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIG1zID0gdGhpcy5yb290TWVyZ2VzKGkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubkVkZ2VzID09IGIubkVkZ2VzID8gYS5pZCAtIGIuaWQgOiBhLm5FZGdlcyAtIGIubkVkZ2VzOyB9KTtcclxuICAgICAgICAgICAgdmFyIG0gPSBtc1swXTtcclxuICAgICAgICAgICAgaWYgKG0ubkVkZ2VzID49IHRoaXMuUilcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlKG0uYSwgbS5iLCBpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24ucHJvdG90eXBlLm5FZGdlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGluSW50ID0gYS5pbmNvbWluZy5pbnRlcnNlY3Rpb24oYi5pbmNvbWluZyksIG91dEludCA9IGEub3V0Z29pbmcuaW50ZXJzZWN0aW9uKGIub3V0Z29pbmcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLlIgLSBpbkludC5jb3VudCgpIC0gb3V0SW50LmNvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuZ2V0R3JvdXBIaWVyYXJjaHkgPSBmdW5jdGlvbiAocmV0YXJnZXRlZEVkZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW107XHJcbiAgICAgICAgdmFyIHJvb3QgPSB7fTtcclxuICAgICAgICB0b0dyb3Vwcyh0aGlzLnJvb3RzWzBdLCByb290LCBncm91cHMpO1xyXG4gICAgICAgIHZhciBlcyA9IHRoaXMuYWxsRWRnZXMoKTtcclxuICAgICAgICBlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gX3RoaXMubW9kdWxlc1tlLnNvdXJjZV07XHJcbiAgICAgICAgICAgIHZhciBiID0gX3RoaXMubW9kdWxlc1tlLnRhcmdldF07XHJcbiAgICAgICAgICAgIHJldGFyZ2V0ZWRFZGdlcy5wdXNoKG5ldyBQb3dlckVkZ2UodHlwZW9mIGEuZ2lkID09PSBcInVuZGVmaW5lZFwiID8gZS5zb3VyY2UgOiBncm91cHNbYS5naWRdLCB0eXBlb2YgYi5naWQgPT09IFwidW5kZWZpbmVkXCIgPyBlLnRhcmdldCA6IGdyb3Vwc1tiLmdpZF0sIGUudHlwZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBncm91cHM7XHJcbiAgICB9O1xyXG4gICAgQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVzID0gW107XHJcbiAgICAgICAgQ29uZmlndXJhdGlvbi5nZXRFZGdlcyh0aGlzLnJvb3RzWzBdLCBlcyk7XHJcbiAgICAgICAgcmV0dXJuIGVzO1xyXG4gICAgfTtcclxuICAgIENvbmZpZ3VyYXRpb24uZ2V0RWRnZXMgPSBmdW5jdGlvbiAobW9kdWxlcywgZXMpIHtcclxuICAgICAgICBtb2R1bGVzLmZvckFsbChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBtLmdldEVkZ2VzKGVzKTtcclxuICAgICAgICAgICAgQ29uZmlndXJhdGlvbi5nZXRFZGdlcyhtLmNoaWxkcmVuLCBlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbmZpZ3VyYXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb247XHJcbmZ1bmN0aW9uIHRvR3JvdXBzKG1vZHVsZXMsIGdyb3VwLCBncm91cHMpIHtcclxuICAgIG1vZHVsZXMuZm9yQWxsKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgaWYgKG0uaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFncm91cC5sZWF2ZXMpXHJcbiAgICAgICAgICAgICAgICBncm91cC5sZWF2ZXMgPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXAubGVhdmVzLnB1c2gobS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZyA9IGdyb3VwO1xyXG4gICAgICAgICAgICBtLmdpZCA9IGdyb3Vwcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICghbS5pc0lzbGFuZCgpIHx8IG0uaXNQcmVkZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGcgPSB7IGlkOiBtLmdpZCB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG0uaXNQcmVkZWZpbmVkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtLmRlZmluaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdbcHJvcF0gPSBtLmRlZmluaXRpb25bcHJvcF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLmdyb3VwcylcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5ncm91cHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmdyb3Vwcy5wdXNoKG0uZ2lkKTtcclxuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvR3JvdXBzKG0uY2hpbGRyZW4sIGcsIGdyb3Vwcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxudmFyIE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2R1bGUoaWQsIG91dGdvaW5nLCBpbmNvbWluZywgY2hpbGRyZW4sIGRlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAob3V0Z29pbmcgPT09IHZvaWQgMCkgeyBvdXRnb2luZyA9IG5ldyBMaW5rU2V0cygpOyB9XHJcbiAgICAgICAgaWYgKGluY29taW5nID09PSB2b2lkIDApIHsgaW5jb21pbmcgPSBuZXcgTGlua1NldHMoKTsgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gbmV3IE1vZHVsZVNldCgpOyB9XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMub3V0Z29pbmcgPSBvdXRnb2luZztcclxuICAgICAgICB0aGlzLmluY29taW5nID0gaW5jb21pbmc7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XHJcbiAgICB9XHJcbiAgICBNb2R1bGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKGVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm91dGdvaW5nLmZvckFsbChmdW5jdGlvbiAobXMsIGVkZ2V0eXBlKSB7XHJcbiAgICAgICAgICAgIG1zLmZvckFsbChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBlcy5wdXNoKG5ldyBQb3dlckVkZ2UoX3RoaXMuaWQsIHRhcmdldC5pZCwgZWRnZXR5cGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uY291bnQoKSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBNb2R1bGUucHJvdG90eXBlLmlzSXNsYW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm91dGdvaW5nLmNvdW50KCkgPT09IDAgJiYgdGhpcy5pbmNvbWluZy5jb3VudCgpID09PSAwO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZS5wcm90b3R5cGUuaXNQcmVkZWZpbmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5kZWZpbml0aW9uICE9PSBcInVuZGVmaW5lZFwiO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2R1bGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xyXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24obSwgbikge1xyXG4gICAgdmFyIGkgPSB7fTtcclxuICAgIGZvciAodmFyIHYgaW4gbSlcclxuICAgICAgICBpZiAodiBpbiBuKVxyXG4gICAgICAgICAgICBpW3ZdID0gbVt2XTtcclxuICAgIHJldHVybiBpO1xyXG59XHJcbnZhciBNb2R1bGVTZXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW9kdWxlU2V0KCkge1xyXG4gICAgICAgIHRoaXMudGFibGUgPSB7fTtcclxuICAgIH1cclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGFibGUpLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTW9kdWxlU2V0KCk7XHJcbiAgICAgICAgcmVzdWx0LnRhYmxlID0gaW50ZXJzZWN0aW9uKHRoaXMudGFibGUsIG90aGVyLnRhYmxlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uQ291bnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24ob3RoZXIpLmNvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiBpZCBpbiB0aGlzLnRhYmxlO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICB0aGlzLnRhYmxlW20uaWRdID0gbTtcclxuICAgIH07XHJcbiAgICBNb2R1bGVTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMudGFibGVbbS5pZF07XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5mb3JBbGwgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGZvciAodmFyIG1pZCBpbiB0aGlzLnRhYmxlKSB7XHJcbiAgICAgICAgICAgIGYodGhpcy50YWJsZVttaWRdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlU2V0LnByb3RvdHlwZS5tb2R1bGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yQWxsKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIGlmICghbS5pc1ByZWRlZmluZWQoKSlcclxuICAgICAgICAgICAgICAgIHZzLnB1c2gobSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2R1bGVTZXQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTW9kdWxlU2V0ID0gTW9kdWxlU2V0O1xyXG52YXIgTGlua1NldHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGlua1NldHMoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRzID0ge307XHJcbiAgICAgICAgdGhpcy5uID0gMDtcclxuICAgIH1cclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uO1xyXG4gICAgfTtcclxuICAgIExpbmtTZXRzLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvckFsbE1vZHVsZXMoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgbS5pZCA9PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChsaW5rdHlwZSwgbSkge1xyXG4gICAgICAgIHZhciBzID0gbGlua3R5cGUgaW4gdGhpcy5zZXRzID8gdGhpcy5zZXRzW2xpbmt0eXBlXSA6IHRoaXMuc2V0c1tsaW5rdHlwZV0gPSBuZXcgTW9kdWxlU2V0KCk7XHJcbiAgICAgICAgcy5hZGQobSk7XHJcbiAgICAgICAgKyt0aGlzLm47XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsaW5rdHlwZSwgbSkge1xyXG4gICAgICAgIHZhciBtcyA9IHRoaXMuc2V0c1tsaW5rdHlwZV07XHJcbiAgICAgICAgbXMucmVtb3ZlKG0pO1xyXG4gICAgICAgIGlmIChtcy5jb3VudCgpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldHNbbGlua3R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAtLXRoaXMubjtcclxuICAgIH07XHJcbiAgICBMaW5rU2V0cy5wcm90b3R5cGUuZm9yQWxsID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICBmb3IgKHZhciBsaW5rdHlwZSBpbiB0aGlzLnNldHMpIHtcclxuICAgICAgICAgICAgZih0aGlzLnNldHNbbGlua3R5cGVdLCBOdW1iZXIobGlua3R5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmZvckFsbE1vZHVsZXMgPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHRoaXMuZm9yQWxsKGZ1bmN0aW9uIChtcywgbHQpIHsgcmV0dXJuIG1zLmZvckFsbChmKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTGlua1NldHMucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGlua1NldHMoKTtcclxuICAgICAgICB0aGlzLmZvckFsbChmdW5jdGlvbiAobXMsIGx0KSB7XHJcbiAgICAgICAgICAgIGlmIChsdCBpbiBvdGhlci5zZXRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG1zLmludGVyc2VjdGlvbihvdGhlci5zZXRzW2x0XSksIG4gPSBpLmNvdW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0c1tsdF0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uICs9IG47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaW5rU2V0cztcclxufSgpKTtcclxuZXhwb3J0cy5MaW5rU2V0cyA9IExpbmtTZXRzO1xyXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25Db3VudChtLCBuKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaW50ZXJzZWN0aW9uKG0sIG4pKS5sZW5ndGg7XHJcbn1cclxuZnVuY3Rpb24gZ2V0R3JvdXBzKG5vZGVzLCBsaW5rcywgbGEsIHJvb3RHcm91cCkge1xyXG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsIGMgPSBuZXcgQ29uZmlndXJhdGlvbihuLCBsaW5rcywgbGEsIHJvb3RHcm91cCk7XHJcbiAgICB3aGlsZSAoYy5ncmVlZHlNZXJnZSgpKVxyXG4gICAgICAgIDtcclxuICAgIHZhciBwb3dlckVkZ2VzID0gW107XHJcbiAgICB2YXIgZyA9IGMuZ2V0R3JvdXBIaWVyYXJjaHkocG93ZXJFZGdlcyk7XHJcbiAgICBwb3dlckVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChlbmQpIHtcclxuICAgICAgICAgICAgdmFyIGcgPSBlW2VuZF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZyA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgZVtlbmRdID0gbm9kZXNbZ107XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmKFwic291cmNlXCIpO1xyXG4gICAgICAgIGYoXCJ0YXJnZXRcIik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IGdyb3VwczogZywgcG93ZXJFZGdlczogcG93ZXJFZGdlcyB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0R3JvdXBzID0gZ2V0R3JvdXBzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3dlcmdyYXBoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBQYWlyaW5nSGVhcCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYWlyaW5nSGVhcChlbGVtKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICB0aGlzLnN1YmhlYXBzID0gW107XHJcbiAgICB9XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc3RyID0gXCJcIiwgbmVlZENvbW1hID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YmhlYXBzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJoZWFwID0gdGhpcy5zdWJoZWFwc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFzdWJoZWFwLmVsZW0pIHtcclxuICAgICAgICAgICAgICAgIG5lZWRDb21tYSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5lZWRDb21tYSkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyICsgXCIsXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyID0gc3RyICsgc3ViaGVhcC50b1N0cmluZyhzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIG5lZWRDb21tYSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHIgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgc3RyID0gXCIoXCIgKyBzdHIgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmVsZW0gPyBzZWxlY3Rvcih0aGlzLmVsZW0pIDogXCJcIikgKyBzdHI7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGlmICghdGhpcy5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGYodGhpcy5lbGVtLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJoZWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmZvckVhY2goZik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHkoKSA/IDAgOiAxICsgdGhpcy5zdWJoZWFwcy5yZWR1Y2UoZnVuY3Rpb24gKG4sIGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG4gKyBoLmNvdW50KCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtID09IG51bGw7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gaClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YmhlYXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YmhlYXBzW2ldLmNvbnRhaW5zKGgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuaXNIZWFwID0gZnVuY3Rpb24gKGxlc3NUaGFuKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJoZWFwcy5ldmVyeShmdW5jdGlvbiAoaCkgeyByZXR1cm4gbGVzc1RoYW4oX3RoaXMuZWxlbSwgaC5lbGVtKSAmJiBoLmlzSGVhcChsZXNzVGhhbik7IH0pO1xyXG4gICAgfTtcclxuICAgIFBhaXJpbmdIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAob2JqLCBsZXNzVGhhbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKG5ldyBQYWlyaW5nSGVhcChvYmopLCBsZXNzVGhhbik7XHJcbiAgICB9O1xyXG4gICAgUGFpcmluZ0hlYXAucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGhlYXAyLCBsZXNzVGhhbikge1xyXG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpXHJcbiAgICAgICAgICAgIHJldHVybiBoZWFwMjtcclxuICAgICAgICBlbHNlIGlmIChoZWFwMi5lbXB0eSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIGlmIChsZXNzVGhhbih0aGlzLmVsZW0sIGhlYXAyLmVsZW0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViaGVhcHMucHVzaChoZWFwMik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcDIuc3ViaGVhcHMucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhlYXAyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24gKGxlc3NUaGFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXJnZVBhaXJzKGxlc3NUaGFuKTtcclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUubWVyZ2VQYWlycyA9IGZ1bmN0aW9uIChsZXNzVGhhbikge1xyXG4gICAgICAgIGlmICh0aGlzLnN1YmhlYXBzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhaXJpbmdIZWFwKG51bGwpO1xyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3ViaGVhcHMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViaGVhcHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RQYWlyID0gdGhpcy5zdWJoZWFwcy5wb3AoKS5tZXJnZSh0aGlzLnN1YmhlYXBzLnBvcCgpLCBsZXNzVGhhbik7XHJcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB0aGlzLm1lcmdlUGFpcnMobGVzc1RoYW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RQYWlyLm1lcmdlKHJlbWFpbmluZywgbGVzc1RoYW4pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQYWlyaW5nSGVhcC5wcm90b3R5cGUuZGVjcmVhc2VLZXkgPSBmdW5jdGlvbiAoc3ViaGVhcCwgbmV3VmFsdWUsIHNldEhlYXBOb2RlLCBsZXNzVGhhbikge1xyXG4gICAgICAgIHZhciBuZXdIZWFwID0gc3ViaGVhcC5yZW1vdmVNaW4obGVzc1RoYW4pO1xyXG4gICAgICAgIHN1YmhlYXAuZWxlbSA9IG5ld0hlYXAuZWxlbTtcclxuICAgICAgICBzdWJoZWFwLnN1YmhlYXBzID0gbmV3SGVhcC5zdWJoZWFwcztcclxuICAgICAgICBpZiAoc2V0SGVhcE5vZGUgIT09IG51bGwgJiYgbmV3SGVhcC5lbGVtICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEhlYXBOb2RlKHN1YmhlYXAuZWxlbSwgc3ViaGVhcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYWlyaW5nTm9kZSA9IG5ldyBQYWlyaW5nSGVhcChuZXdWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHNldEhlYXBOb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEhlYXBOb2RlKG5ld1ZhbHVlLCBwYWlyaW5nTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKHBhaXJpbmdOb2RlLCBsZXNzVGhhbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhaXJpbmdIZWFwO1xyXG59KCkpO1xyXG5leHBvcnRzLlBhaXJpbmdIZWFwID0gUGFpcmluZ0hlYXA7XHJcbnZhciBQcmlvcml0eVF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByaW9yaXR5UXVldWUobGVzc1RoYW4pIHtcclxuICAgICAgICB0aGlzLmxlc3NUaGFuID0gbGVzc1RoYW47XHJcbiAgICB9XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS50b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5lbGVtO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYWlyaW5nTm9kZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJnOyBhcmcgPSBhcmdzW2ldOyArK2kpIHtcclxuICAgICAgICAgICAgcGFpcmluZ05vZGUgPSBuZXcgUGFpcmluZ0hlYXAoYXJnKTtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5lbXB0eSgpID9cclxuICAgICAgICAgICAgICAgIHBhaXJpbmdOb2RlIDogdGhpcy5yb290Lm1lcmdlKHBhaXJpbmdOb2RlLCB0aGlzLmxlc3NUaGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhaXJpbmdOb2RlO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5yb290IHx8ICF0aGlzLnJvb3QuZWxlbTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0hlYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0hlYXAodGhpcy5sZXNzVGhhbik7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgdGhpcy5yb290LmZvckVhY2goZik7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLnJvb3QubWluKCk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5yb290LnJlbW92ZU1pbih0aGlzLmxlc3NUaGFuKTtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlZHVjZUtleSA9IGZ1bmN0aW9uIChoZWFwTm9kZSwgbmV3S2V5LCBzZXRIZWFwTm9kZSkge1xyXG4gICAgICAgIGlmIChzZXRIZWFwTm9kZSA9PT0gdm9pZCAwKSB7IHNldEhlYXBOb2RlID0gbnVsbDsgfVxyXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5kZWNyZWFzZUtleShoZWFwTm9kZSwgbmV3S2V5LCBzZXRIZWFwTm9kZSwgdGhpcy5sZXNzVGhhbik7XHJcbiAgICB9O1xyXG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LnRvU3RyaW5nKHNlbGVjdG9yKTtcclxuICAgIH07XHJcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmNvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJpb3JpdHlRdWV1ZSA9IFByaW9yaXR5UXVldWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBxdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFRyZWVCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyZWVCYXNlKCkge1xyXG4gICAgICAgIHRoaXMuZmluZEl0ZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLml0ZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCByZXMuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXIuX2N1cnNvciA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5wdXNoKHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmdldF9jaGlsZChjID4gMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB3aGlsZSAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5fY29tcGFyYXRvcihkYXRhLCByZXMuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuZ2V0X2NoaWxkKGMgPiAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUubG93ZXJCb3VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kKGRhdGEsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS51cHBlckJvdW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgY21wID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICBmdW5jdGlvbiByZXZlcnNlX2NtcChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXAoYiwgYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZChkYXRhLCByZXZlcnNlX2NtcCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5fcm9vdDtcclxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAocmVzLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzID0gcmVzLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBUcmVlQmFzZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChyZXMucmlnaHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzID0gcmVzLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzLmRhdGE7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCksIGRhdGE7XHJcbiAgICAgICAgd2hpbGUgKChkYXRhID0gaXQubmV4dCgpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgVHJlZUJhc2UucHJvdG90eXBlLnJlYWNoID0gZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpLCBkYXRhO1xyXG4gICAgICAgIHdoaWxlICgoZGF0YSA9IGl0LnByZXYoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2IoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFRyZWVCYXNlLnByb3RvdHlwZS5fYm91bmQgPSBmdW5jdGlvbiAoZGF0YSwgY21wKSB7XHJcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIGl0ZXIgPSB0aGlzLml0ZXJhdG9yKCk7XHJcbiAgICAgICAgd2hpbGUgKGN1ciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuX2NvbXBhcmF0b3IoZGF0YSwgY3VyLmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlci5fY3Vyc29yID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlci5fYW5jZXN0b3JzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gY3VyLmdldF9jaGlsZChjID4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBpdGVyLl9hbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgY3VyID0gaXRlci5fYW5jZXN0b3JzW2ldO1xyXG4gICAgICAgICAgICBpZiAoY21wKGRhdGEsIGN1ci5kYXRhKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGl0ZXIuX2N1cnNvciA9IGN1cjtcclxuICAgICAgICAgICAgICAgIGl0ZXIuX2FuY2VzdG9ycy5sZW5ndGggPSBpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlci5fYW5jZXN0b3JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXI7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIFRyZWVCYXNlO1xyXG59KCkpO1xyXG5leHBvcnRzLlRyZWVCYXNlID0gVHJlZUJhc2U7XHJcbnZhciBJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvcih0cmVlKSB7XHJcbiAgICAgICAgdGhpcy5fdHJlZSA9IHRyZWU7XHJcbiAgICAgICAgdGhpcy5fYW5jZXN0b3JzID0gW107XHJcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcclxuICAgIH1cclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3RyZWUuX3Jvb3Q7XHJcbiAgICAgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5Ob2RlKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZTtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlID0gdGhpcy5fY3Vyc29yO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmNlc3RvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRoaXMuX2FuY2VzdG9ycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuX2N1cnNvci5yaWdodCA9PT0gc2F2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaCh0aGlzLl9jdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluTm9kZSh0aGlzLl9jdXJzb3IucmlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3RyZWUuX3Jvb3Q7XHJcbiAgICAgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhOb2RlKHJvb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzYXZlO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmUgPSB0aGlzLl9jdXJzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuY2VzdG9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gdGhpcy5fYW5jZXN0b3JzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5fY3Vyc29yLmxlZnQgPT09IHNhdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2godGhpcy5fY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heE5vZGUodGhpcy5fY3Vyc29yLmxlZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3IgIT09IG51bGwgPyB0aGlzLl9jdXJzb3IuZGF0YSA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLl9taW5Ob2RlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0LmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5jZXN0b3JzLnB1c2goc3RhcnQpO1xyXG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5fbWF4Tm9kZSA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG4gICAgICAgIHdoaWxlIChzdGFydC5yaWdodCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbmNlc3RvcnMucHVzaChzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBJdGVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5JdGVyYXRvciA9IEl0ZXJhdG9yO1xyXG52YXIgTm9kZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0X2NoaWxkID0gZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHJldHVybiBkaXIgPyB0aGlzLnJpZ2h0IDogdGhpcy5sZWZ0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIE5vZGUucHJvdG90eXBlLnNldF9jaGlsZCA9IGZ1bmN0aW9uIChkaXIsIHZhbCkge1xyXG4gICAgICAgIGlmIChkaXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XHJcbnZhciBSQlRyZWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJCVHJlZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJCVHJlZShjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fcm9vdCA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIF90aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJCVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmV0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5ldyBOb2RlKGRhdGEpO1xyXG4gICAgICAgICAgICByZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoZWFkID0gbmV3IE5vZGUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgdmFyIGRpciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgZ3AgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZ2dwID0gaGVhZDtcclxuICAgICAgICAgICAgdmFyIHAgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIGdncC5yaWdodCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnNldF9jaGlsZChkaXIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChSQlRyZWUuaXNfcmVkKG5vZGUubGVmdCkgJiYgUkJUcmVlLmlzX3JlZChub2RlLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQucmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodC5yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChSQlRyZWUuaXNfcmVkKG5vZGUpICYmIFJCVHJlZS5pc19yZWQocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyMiA9IGdncC5yaWdodCA9PT0gZ3A7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHAuZ2V0X2NoaWxkKGxhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdncC5zZXRfY2hpbGQoZGlyMiwgUkJUcmVlLnNpbmdsZV9yb3RhdGUoZ3AsICFsYXN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZ3Auc2V0X2NoaWxkKGRpcjIsIFJCVHJlZS5kb3VibGVfcm90YXRlKGdwLCAhbGFzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yKG5vZGUuZGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gZGlyO1xyXG4gICAgICAgICAgICAgICAgZGlyID0gY21wIDwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChncCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdncCA9IGdwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ3AgPSBwO1xyXG4gICAgICAgICAgICAgICAgcCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5nZXRfY2hpbGQoZGlyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gaGVhZC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcm9vdC5yZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFJCVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWFkID0gbmV3IE5vZGUodW5kZWZpbmVkKTtcclxuICAgICAgICB2YXIgbm9kZSA9IGhlYWQ7XHJcbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIHAgPSBudWxsO1xyXG4gICAgICAgIHZhciBncCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gbnVsbDtcclxuICAgICAgICB2YXIgZGlyID0gdHJ1ZTtcclxuICAgICAgICB3aGlsZSAobm9kZS5nZXRfY2hpbGQoZGlyKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IGRpcjtcclxuICAgICAgICAgICAgZ3AgPSBwO1xyXG4gICAgICAgICAgICBwID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0X2NoaWxkKGRpcik7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSB0aGlzLl9jb21wYXJhdG9yKGRhdGEsIG5vZGUuZGF0YSk7XHJcbiAgICAgICAgICAgIGRpciA9IGNtcCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIVJCVHJlZS5pc19yZWQobm9kZSkgJiYgIVJCVHJlZS5pc19yZWQobm9kZS5nZXRfY2hpbGQoZGlyKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChSQlRyZWUuaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKCFkaXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzciA9IFJCVHJlZS5zaW5nbGVfcm90YXRlKG5vZGUsIGRpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5zZXRfY2hpbGQobGFzdCwgc3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBzcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFSQlRyZWUuaXNfcmVkKG5vZGUuZ2V0X2NoaWxkKCFkaXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gcC5nZXRfY2hpbGQoIWxhc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghUkJUcmVlLmlzX3JlZChzaWJsaW5nLmdldF9jaGlsZCghbGFzdCkpICYmICFSQlRyZWUuaXNfcmVkKHNpYmxpbmcuZ2V0X2NoaWxkKGxhc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcucmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIyID0gZ3AucmlnaHQgPT09IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkJUcmVlLmlzX3JlZChzaWJsaW5nLmdldF9jaGlsZChsYXN0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncC5zZXRfY2hpbGQoZGlyMiwgUkJUcmVlLmRvdWJsZV9yb3RhdGUocCwgbGFzdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoUkJUcmVlLmlzX3JlZChzaWJsaW5nLmdldF9jaGlsZCghbGFzdCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Auc2V0X2NoaWxkKGRpcjIsIFJCVHJlZS5zaW5nbGVfcm90YXRlKHAsIGxhc3QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncGMgPSBncC5nZXRfY2hpbGQoZGlyMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncGMucmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwYy5sZWZ0LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3BjLnJpZ2h0LnJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3VuZC5kYXRhID0gbm9kZS5kYXRhO1xyXG4gICAgICAgICAgICBwLnNldF9jaGlsZChwLnJpZ2h0ID09PSBub2RlLCBub2RlLmdldF9jaGlsZChub2RlLmxlZnQgPT09IG51bGwpKTtcclxuICAgICAgICAgICAgdGhpcy5zaXplLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBoZWFkLnJpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QucmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZCAhPT0gbnVsbDtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBSQlRyZWUuaXNfcmVkID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZSAhPT0gbnVsbCAmJiBub2RlLnJlZDtcclxuICAgIH07XHJcbiAgICBSQlRyZWUuc2luZ2xlX3JvdGF0ZSA9IGZ1bmN0aW9uIChyb290LCBkaXIpIHtcclxuICAgICAgICB2YXIgc2F2ZSA9IHJvb3QuZ2V0X2NoaWxkKCFkaXIpO1xyXG4gICAgICAgIHJvb3Quc2V0X2NoaWxkKCFkaXIsIHNhdmUuZ2V0X2NoaWxkKGRpcikpO1xyXG4gICAgICAgIHNhdmUuc2V0X2NoaWxkKGRpciwgcm9vdCk7XHJcbiAgICAgICAgcm9vdC5yZWQgPSB0cnVlO1xyXG4gICAgICAgIHNhdmUucmVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHNhdmU7XHJcbiAgICB9O1xyXG4gICAgUkJUcmVlLmRvdWJsZV9yb3RhdGUgPSBmdW5jdGlvbiAocm9vdCwgZGlyKSB7XHJcbiAgICAgICAgcm9vdC5zZXRfY2hpbGQoIWRpciwgUkJUcmVlLnNpbmdsZV9yb3RhdGUocm9vdC5nZXRfY2hpbGQoIWRpciksICFkaXIpKTtcclxuICAgICAgICByZXR1cm4gUkJUcmVlLnNpbmdsZV9yb3RhdGUocm9vdCwgZGlyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUkJUcmVlO1xyXG59KFRyZWVCYXNlKSk7XHJcbmV4cG9ydHMuUkJUcmVlID0gUkJUcmVlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYnRyZWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB2cHNjXzEgPSByZXF1aXJlKFwiLi92cHNjXCIpO1xyXG52YXIgcmJ0cmVlXzEgPSByZXF1aXJlKFwiLi9yYnRyZWVcIik7XHJcbmZ1bmN0aW9uIGNvbXB1dGVHcm91cEJvdW5kcyhnKSB7XHJcbiAgICBnLmJvdW5kcyA9IHR5cGVvZiBnLmxlYXZlcyAhPT0gXCJ1bmRlZmluZWRcIiA/XHJcbiAgICAgICAgZy5sZWF2ZXMucmVkdWNlKGZ1bmN0aW9uIChyLCBjKSB7IHJldHVybiBjLmJvdW5kcy51bmlvbihyKTsgfSwgUmVjdGFuZ2xlLmVtcHR5KCkpIDpcclxuICAgICAgICBSZWN0YW5nbGUuZW1wdHkoKTtcclxuICAgIGlmICh0eXBlb2YgZy5ncm91cHMgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgZy5ib3VuZHMgPSBnLmdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24gKHIsIGMpIHsgcmV0dXJuIGNvbXB1dGVHcm91cEJvdW5kcyhjKS51bmlvbihyKTsgfSwgZy5ib3VuZHMpO1xyXG4gICAgZy5ib3VuZHMgPSBnLmJvdW5kcy5pbmZsYXRlKGcucGFkZGluZyk7XHJcbiAgICByZXR1cm4gZy5ib3VuZHM7XHJcbn1cclxuZXhwb3J0cy5jb21wdXRlR3JvdXBCb3VuZHMgPSBjb21wdXRlR3JvdXBCb3VuZHM7XHJcbnZhciBSZWN0YW5nbGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIFgsIHksIFkpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMuWCA9IFg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLlkgPSBZO1xyXG4gICAgfVxyXG4gICAgUmVjdGFuZ2xlLmVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFJlY3RhbmdsZShOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpOyB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5jeCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnggKyB0aGlzLlgpIC8gMjsgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuY3kgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy55ICsgdGhpcy5ZKSAvIDI7IH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLm92ZXJsYXBYID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgdXggPSB0aGlzLmN4KCksIHZ4ID0gci5jeCgpO1xyXG4gICAgICAgIGlmICh1eCA8PSB2eCAmJiByLnggPCB0aGlzLlgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlggLSByLng7XHJcbiAgICAgICAgaWYgKHZ4IDw9IHV4ICYmIHRoaXMueCA8IHIuWClcclxuICAgICAgICAgICAgcmV0dXJuIHIuWCAtIHRoaXMueDtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLm92ZXJsYXBZID0gZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICB2YXIgdXkgPSB0aGlzLmN5KCksIHZ5ID0gci5jeSgpO1xyXG4gICAgICAgIGlmICh1eSA8PSB2eSAmJiByLnkgPCB0aGlzLlkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlkgLSByLnk7XHJcbiAgICAgICAgaWYgKHZ5IDw9IHV5ICYmIHRoaXMueSA8IHIuWSlcclxuICAgICAgICAgICAgcmV0dXJuIHIuWSAtIHRoaXMueTtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLnNldFhDZW50cmUgPSBmdW5jdGlvbiAoY3gpIHtcclxuICAgICAgICB2YXIgZHggPSBjeCAtIHRoaXMuY3goKTtcclxuICAgICAgICB0aGlzLnggKz0gZHg7XHJcbiAgICAgICAgdGhpcy5YICs9IGR4O1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuc2V0WUNlbnRyZSA9IGZ1bmN0aW9uIChjeSkge1xyXG4gICAgICAgIHZhciBkeSA9IGN5IC0gdGhpcy5jeSgpO1xyXG4gICAgICAgIHRoaXMueSArPSBkeTtcclxuICAgICAgICB0aGlzLlkgKz0gZHk7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5YIC0gdGhpcy54O1xyXG4gICAgfTtcclxuICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLlkgLSB0aGlzLnk7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoTWF0aC5taW4odGhpcy54LCByLngpLCBNYXRoLm1heCh0aGlzLlgsIHIuWCksIE1hdGgubWluKHRoaXMueSwgci55KSwgTWF0aC5tYXgodGhpcy5ZLCByLlkpKTtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmxpbmVJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAgICAgdmFyIHNpZGVzID0gW1t0aGlzLngsIHRoaXMueSwgdGhpcy5YLCB0aGlzLnldLFxyXG4gICAgICAgICAgICBbdGhpcy5YLCB0aGlzLnksIHRoaXMuWCwgdGhpcy5ZXSxcclxuICAgICAgICAgICAgW3RoaXMuWCwgdGhpcy5ZLCB0aGlzLngsIHRoaXMuWV0sXHJcbiAgICAgICAgICAgIFt0aGlzLngsIHRoaXMuWSwgdGhpcy54LCB0aGlzLnldXTtcclxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gUmVjdGFuZ2xlLmxpbmVJbnRlcnNlY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHNpZGVzW2ldWzBdLCBzaWRlc1tpXVsxXSwgc2lkZXNbaV1bMl0sIHNpZGVzW2ldWzNdKTtcclxuICAgICAgICAgICAgaWYgKHIgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeyB4OiByLngsIHk6IHIueSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5yYXlJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoeDIsIHkyKSB7XHJcbiAgICAgICAgdmFyIGludHMgPSB0aGlzLmxpbmVJbnRlcnNlY3Rpb25zKHRoaXMuY3goKSwgdGhpcy5jeSgpLCB4MiwgeTIpO1xyXG4gICAgICAgIHJldHVybiBpbnRzLmxlbmd0aCA+IDAgPyBpbnRzWzBdIDogbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLnZlcnRpY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfSxcclxuICAgICAgICAgICAgeyB4OiB0aGlzLlgsIHk6IHRoaXMueSB9LFxyXG4gICAgICAgICAgICB7IHg6IHRoaXMuWCwgeTogdGhpcy5ZIH0sXHJcbiAgICAgICAgICAgIHsgeDogdGhpcy54LCB5OiB0aGlzLlkgfVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgUmVjdGFuZ2xlLmxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XHJcbiAgICAgICAgdmFyIGR4MTIgPSB4MiAtIHgxLCBkeDM0ID0geDQgLSB4MywgZHkxMiA9IHkyIC0geTEsIGR5MzQgPSB5NCAtIHkzLCBkZW5vbWluYXRvciA9IGR5MzQgKiBkeDEyIC0gZHgzNCAqIGR5MTI7XHJcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciBkeDMxID0geDEgLSB4MywgZHkzMSA9IHkxIC0geTMsIG51bWEgPSBkeDM0ICogZHkzMSAtIGR5MzQgKiBkeDMxLCBhID0gbnVtYSAvIGRlbm9taW5hdG9yLCBudW1iID0gZHgxMiAqIGR5MzEgLSBkeTEyICogZHgzMSwgYiA9IG51bWIgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICBpZiAoYSA+PSAwICYmIGEgPD0gMSAmJiBiID49IDAgJiYgYiA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4MSArIGEgKiBkeDEyLFxyXG4gICAgICAgICAgICAgICAgeTogeTEgKyBhICogZHkxMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbiAocGFkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gcGFkLCB0aGlzLlggKyBwYWQsIHRoaXMueSAtIHBhZCwgdGhpcy5ZICsgcGFkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVjdGFuZ2xlO1xyXG59KCkpO1xyXG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcclxuZnVuY3Rpb24gbWFrZUVkZ2VCZXR3ZWVuKHNvdXJjZSwgdGFyZ2V0LCBhaCkge1xyXG4gICAgdmFyIHNpID0gc291cmNlLnJheUludGVyc2VjdGlvbih0YXJnZXQuY3goKSwgdGFyZ2V0LmN5KCkpIHx8IHsgeDogc291cmNlLmN4KCksIHk6IHNvdXJjZS5jeSgpIH0sIHRpID0gdGFyZ2V0LnJheUludGVyc2VjdGlvbihzb3VyY2UuY3goKSwgc291cmNlLmN5KCkpIHx8IHsgeDogdGFyZ2V0LmN4KCksIHk6IHRhcmdldC5jeSgpIH0sIGR4ID0gdGkueCAtIHNpLngsIGR5ID0gdGkueSAtIHNpLnksIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLCBhbCA9IGwgLSBhaDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc291cmNlSW50ZXJzZWN0aW9uOiBzaSxcclxuICAgICAgICB0YXJnZXRJbnRlcnNlY3Rpb246IHRpLFxyXG4gICAgICAgIGFycm93U3RhcnQ6IHsgeDogc2kueCArIGFsICogZHggLyBsLCB5OiBzaS55ICsgYWwgKiBkeSAvIGwgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1ha2VFZGdlQmV0d2VlbiA9IG1ha2VFZGdlQmV0d2VlbjtcclxuZnVuY3Rpb24gbWFrZUVkZ2VUbyhzLCB0YXJnZXQsIGFoKSB7XHJcbiAgICB2YXIgdGkgPSB0YXJnZXQucmF5SW50ZXJzZWN0aW9uKHMueCwgcy55KTtcclxuICAgIGlmICghdGkpXHJcbiAgICAgICAgdGkgPSB7IHg6IHRhcmdldC5jeCgpLCB5OiB0YXJnZXQuY3koKSB9O1xyXG4gICAgdmFyIGR4ID0gdGkueCAtIHMueCwgZHkgPSB0aS55IC0gcy55LCBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIHJldHVybiB7IHg6IHRpLnggLSBhaCAqIGR4IC8gbCwgeTogdGkueSAtIGFoICogZHkgLyBsIH07XHJcbn1cclxuZXhwb3J0cy5tYWtlRWRnZVRvID0gbWFrZUVkZ2VUbztcclxudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZSh2LCByLCBwb3MpIHtcclxuICAgICAgICB0aGlzLnYgPSB2O1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICAgICAgdGhpcy5wcmV2ID0gbWFrZVJCVHJlZSgpO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG1ha2VSQlRyZWUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG52YXIgRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnQoaXNPcGVuLCB2LCBwb3MpIHtcclxuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcclxuICAgICAgICB0aGlzLnYgPSB2O1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50O1xyXG59KCkpO1xyXG5mdW5jdGlvbiBjb21wYXJlRXZlbnRzKGEsIGIpIHtcclxuICAgIGlmIChhLnBvcyA+IGIucG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5wb3MgPCBiLnBvcykge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChhLmlzT3Blbikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChiLmlzT3Blbikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gbWFrZVJCVHJlZSgpIHtcclxuICAgIHJldHVybiBuZXcgcmJ0cmVlXzEuUkJUcmVlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnBvcyAtIGIucG9zOyB9KTtcclxufVxyXG52YXIgeFJlY3QgPSB7XHJcbiAgICBnZXRDZW50cmU6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmN4KCk7IH0sXHJcbiAgICBnZXRPcGVuOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci55OyB9LFxyXG4gICAgZ2V0Q2xvc2U6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLlk7IH0sXHJcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci53aWR0aCgpOyB9LFxyXG4gICAgbWFrZVJlY3Q6IGZ1bmN0aW9uIChvcGVuLCBjbG9zZSwgY2VudGVyLCBzaXplKSB7IHJldHVybiBuZXcgUmVjdGFuZ2xlKGNlbnRlciAtIHNpemUgLyAyLCBjZW50ZXIgKyBzaXplIC8gMiwgb3BlbiwgY2xvc2UpOyB9LFxyXG4gICAgZmluZE5laWdoYm91cnM6IGZpbmRYTmVpZ2hib3Vyc1xyXG59O1xyXG52YXIgeVJlY3QgPSB7XHJcbiAgICBnZXRDZW50cmU6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmN5KCk7IH0sXHJcbiAgICBnZXRPcGVuOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci54OyB9LFxyXG4gICAgZ2V0Q2xvc2U6IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLlg7IH0sXHJcbiAgICBnZXRTaXplOiBmdW5jdGlvbiAocikgeyByZXR1cm4gci5oZWlnaHQoKTsgfSxcclxuICAgIG1ha2VSZWN0OiBmdW5jdGlvbiAob3BlbiwgY2xvc2UsIGNlbnRlciwgc2l6ZSkgeyByZXR1cm4gbmV3IFJlY3RhbmdsZShvcGVuLCBjbG9zZSwgY2VudGVyIC0gc2l6ZSAvIDIsIGNlbnRlciArIHNpemUgLyAyKTsgfSxcclxuICAgIGZpbmROZWlnaGJvdXJzOiBmaW5kWU5laWdoYm91cnNcclxufTtcclxuZnVuY3Rpb24gZ2VuZXJhdGVHcm91cENvbnN0cmFpbnRzKHJvb3QsIGYsIG1pblNlcCwgaXNDb250YWluZWQpIHtcclxuICAgIGlmIChpc0NvbnRhaW5lZCA9PT0gdm9pZCAwKSB7IGlzQ29udGFpbmVkID0gZmFsc2U7IH1cclxuICAgIHZhciBwYWRkaW5nID0gcm9vdC5wYWRkaW5nLCBnbiA9IHR5cGVvZiByb290Lmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcgPyByb290Lmdyb3Vwcy5sZW5ndGggOiAwLCBsbiA9IHR5cGVvZiByb290LmxlYXZlcyAhPT0gJ3VuZGVmaW5lZCcgPyByb290LmxlYXZlcy5sZW5ndGggOiAwLCBjaGlsZENvbnN0cmFpbnRzID0gIWduID8gW11cclxuICAgICAgICA6IHJvb3QuZ3JvdXBzLnJlZHVjZShmdW5jdGlvbiAoY2NzLCBnKSB7IHJldHVybiBjY3MuY29uY2F0KGdlbmVyYXRlR3JvdXBDb25zdHJhaW50cyhnLCBmLCBtaW5TZXAsIHRydWUpKTsgfSwgW10pLCBuID0gKGlzQ29udGFpbmVkID8gMiA6IDApICsgbG4gKyBnbiwgdnMgPSBuZXcgQXJyYXkobiksIHJzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgYWRkID0gZnVuY3Rpb24gKHIsIHYpIHsgcnNbaV0gPSByOyB2c1tpKytdID0gdjsgfTtcclxuICAgIGlmIChpc0NvbnRhaW5lZCkge1xyXG4gICAgICAgIHZhciBiID0gcm9vdC5ib3VuZHMsIGMgPSBmLmdldENlbnRyZShiKSwgcyA9IGYuZ2V0U2l6ZShiKSAvIDIsIG9wZW4gPSBmLmdldE9wZW4oYiksIGNsb3NlID0gZi5nZXRDbG9zZShiKSwgbWluID0gYyAtIHMgKyBwYWRkaW5nIC8gMiwgbWF4ID0gYyArIHMgLSBwYWRkaW5nIC8gMjtcclxuICAgICAgICByb290Lm1pblZhci5kZXNpcmVkUG9zaXRpb24gPSBtaW47XHJcbiAgICAgICAgYWRkKGYubWFrZVJlY3Qob3BlbiwgY2xvc2UsIG1pbiwgcGFkZGluZyksIHJvb3QubWluVmFyKTtcclxuICAgICAgICByb290Lm1heFZhci5kZXNpcmVkUG9zaXRpb24gPSBtYXg7XHJcbiAgICAgICAgYWRkKGYubWFrZVJlY3Qob3BlbiwgY2xvc2UsIG1heCwgcGFkZGluZyksIHJvb3QubWF4VmFyKTtcclxuICAgIH1cclxuICAgIGlmIChsbilcclxuICAgICAgICByb290LmxlYXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBhZGQobC5ib3VuZHMsIGwudmFyaWFibGUpOyB9KTtcclxuICAgIGlmIChnbilcclxuICAgICAgICByb290Lmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gZy5ib3VuZHM7XHJcbiAgICAgICAgICAgIGFkZChmLm1ha2VSZWN0KGYuZ2V0T3BlbihiKSwgZi5nZXRDbG9zZShiKSwgZi5nZXRDZW50cmUoYiksIGYuZ2V0U2l6ZShiKSksIGcubWluVmFyKTtcclxuICAgICAgICB9KTtcclxuICAgIHZhciBjcyA9IGdlbmVyYXRlQ29uc3RyYWludHMocnMsIHZzLCBmLCBtaW5TZXApO1xyXG4gICAgaWYgKGduKSB7XHJcbiAgICAgICAgdnMuZm9yRWFjaChmdW5jdGlvbiAodikgeyB2LmNPdXQgPSBbXSwgdi5jSW4gPSBbXTsgfSk7XHJcbiAgICAgICAgY3MuZm9yRWFjaChmdW5jdGlvbiAoYykgeyBjLmxlZnQuY091dC5wdXNoKGMpLCBjLnJpZ2h0LmNJbi5wdXNoKGMpOyB9KTtcclxuICAgICAgICByb290Lmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIHZhciBnYXBBZGp1c3RtZW50ID0gKGcucGFkZGluZyAtIGYuZ2V0U2l6ZShnLmJvdW5kcykpIC8gMjtcclxuICAgICAgICAgICAgZy5taW5WYXIuY0luLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZ2FwICs9IGdhcEFkanVzdG1lbnQ7IH0pO1xyXG4gICAgICAgICAgICBnLm1pblZhci5jT3V0LmZvckVhY2goZnVuY3Rpb24gKGMpIHsgYy5sZWZ0ID0gZy5tYXhWYXI7IGMuZ2FwICs9IGdhcEFkanVzdG1lbnQ7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkQ29uc3RyYWludHMuY29uY2F0KGNzKTtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnN0cmFpbnRzKHJzLCB2YXJzLCByZWN0LCBtaW5TZXApIHtcclxuICAgIHZhciBpLCBuID0gcnMubGVuZ3RoO1xyXG4gICAgdmFyIE4gPSAyICogbjtcclxuICAgIGNvbnNvbGUuYXNzZXJ0KHZhcnMubGVuZ3RoID49IG4pO1xyXG4gICAgdmFyIGV2ZW50cyA9IG5ldyBBcnJheShOKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICB2YXIgciA9IHJzW2ldO1xyXG4gICAgICAgIHZhciB2ID0gbmV3IE5vZGUodmFyc1tpXSwgciwgcmVjdC5nZXRDZW50cmUocikpO1xyXG4gICAgICAgIGV2ZW50c1tpXSA9IG5ldyBFdmVudCh0cnVlLCB2LCByZWN0LmdldE9wZW4ocikpO1xyXG4gICAgICAgIGV2ZW50c1tpICsgbl0gPSBuZXcgRXZlbnQoZmFsc2UsIHYsIHJlY3QuZ2V0Q2xvc2UocikpO1xyXG4gICAgfVxyXG4gICAgZXZlbnRzLnNvcnQoY29tcGFyZUV2ZW50cyk7XHJcbiAgICB2YXIgY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgIHZhciBzY2FubGluZSA9IG1ha2VSQlRyZWUoKTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBOOyArK2kpIHtcclxuICAgICAgICB2YXIgZSA9IGV2ZW50c1tpXTtcclxuICAgICAgICB2YXIgdiA9IGUudjtcclxuICAgICAgICBpZiAoZS5pc09wZW4pIHtcclxuICAgICAgICAgICAgc2NhbmxpbmUuaW5zZXJ0KHYpO1xyXG4gICAgICAgICAgICByZWN0LmZpbmROZWlnaGJvdXJzKHYsIHNjYW5saW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjYW5saW5lLnJlbW92ZSh2KTtcclxuICAgICAgICAgICAgdmFyIG1ha2VDb25zdHJhaW50ID0gZnVuY3Rpb24gKGwsIHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXAgPSAocmVjdC5nZXRTaXplKGwucikgKyByZWN0LmdldFNpemUoci5yKSkgLyAyICsgbWluU2VwO1xyXG4gICAgICAgICAgICAgICAgY3MucHVzaChuZXcgdnBzY18xLkNvbnN0cmFpbnQobC52LCByLnYsIHNlcCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdmlzaXROZWlnaGJvdXJzID0gZnVuY3Rpb24gKGZvcndhcmQsIHJldmVyc2UsIG1rY29uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSwgaXQgPSB2W2ZvcndhcmRdLml0ZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHUgPSBpdFtmb3J3YXJkXSgpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1rY29uKHUsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVbcmV2ZXJzZV0ucmVtb3ZlKHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2aXNpdE5laWdoYm91cnMoXCJwcmV2XCIsIFwibmV4dFwiLCBmdW5jdGlvbiAodSwgdikgeyByZXR1cm4gbWFrZUNvbnN0cmFpbnQodSwgdik7IH0pO1xyXG4gICAgICAgICAgICB2aXNpdE5laWdoYm91cnMoXCJuZXh0XCIsIFwicHJldlwiLCBmdW5jdGlvbiAodSwgdikgeyByZXR1cm4gbWFrZUNvbnN0cmFpbnQodiwgdSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUuYXNzZXJ0KHNjYW5saW5lLnNpemUgPT09IDApO1xyXG4gICAgcmV0dXJuIGNzO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRYTmVpZ2hib3Vycyh2LCBzY2FubGluZSkge1xyXG4gICAgdmFyIGYgPSBmdW5jdGlvbiAoZm9yd2FyZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHZhciBpdCA9IHNjYW5saW5lLmZpbmRJdGVyKHYpO1xyXG4gICAgICAgIHZhciB1O1xyXG4gICAgICAgIHdoaWxlICgodSA9IGl0W2ZvcndhcmRdKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciB1b3ZlcnZYID0gdS5yLm92ZXJsYXBYKHYucik7XHJcbiAgICAgICAgICAgIGlmICh1b3ZlcnZYIDw9IDAgfHwgdW92ZXJ2WCA8PSB1LnIub3ZlcmxhcFkodi5yKSkge1xyXG4gICAgICAgICAgICAgICAgdltmb3J3YXJkXS5pbnNlcnQodSk7XHJcbiAgICAgICAgICAgICAgICB1W3JldmVyc2VdLmluc2VydCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW92ZXJ2WCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmKFwibmV4dFwiLCBcInByZXZcIik7XHJcbiAgICBmKFwicHJldlwiLCBcIm5leHRcIik7XHJcbn1cclxuZnVuY3Rpb24gZmluZFlOZWlnaGJvdXJzKHYsIHNjYW5saW5lKSB7XHJcbiAgICB2YXIgZiA9IGZ1bmN0aW9uIChmb3J3YXJkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgdmFyIHUgPSBzY2FubGluZS5maW5kSXRlcih2KVtmb3J3YXJkXSgpO1xyXG4gICAgICAgIGlmICh1ICE9PSBudWxsICYmIHUuci5vdmVybGFwWCh2LnIpID4gMCkge1xyXG4gICAgICAgICAgICB2W2ZvcndhcmRdLmluc2VydCh1KTtcclxuICAgICAgICAgICAgdVtyZXZlcnNlXS5pbnNlcnQodik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGYoXCJuZXh0XCIsIFwicHJldlwiKTtcclxuICAgIGYoXCJwcmV2XCIsIFwibmV4dFwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZVhDb25zdHJhaW50cyhycywgdmFycykge1xyXG4gICAgcmV0dXJuIGdlbmVyYXRlQ29uc3RyYWludHMocnMsIHZhcnMsIHhSZWN0LCAxZS02KTtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlWENvbnN0cmFpbnRzID0gZ2VuZXJhdGVYQ29uc3RyYWludHM7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlWUNvbnN0cmFpbnRzKHJzLCB2YXJzKSB7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGVDb25zdHJhaW50cyhycywgdmFycywgeVJlY3QsIDFlLTYpO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVZQ29uc3RyYWludHMgPSBnZW5lcmF0ZVlDb25zdHJhaW50cztcclxuZnVuY3Rpb24gZ2VuZXJhdGVYR3JvdXBDb25zdHJhaW50cyhyb290KSB7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGVHcm91cENvbnN0cmFpbnRzKHJvb3QsIHhSZWN0LCAxZS02KTtcclxufVxyXG5leHBvcnRzLmdlbmVyYXRlWEdyb3VwQ29uc3RyYWludHMgPSBnZW5lcmF0ZVhHcm91cENvbnN0cmFpbnRzO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVlHcm91cENvbnN0cmFpbnRzKHJvb3QpIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZUdyb3VwQ29uc3RyYWludHMocm9vdCwgeVJlY3QsIDFlLTYpO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVZR3JvdXBDb25zdHJhaW50cyA9IGdlbmVyYXRlWUdyb3VwQ29uc3RyYWludHM7XHJcbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXBzKHJzKSB7XHJcbiAgICB2YXIgdnMgPSBycy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIG5ldyB2cHNjXzEuVmFyaWFibGUoci5jeCgpKTsgfSk7XHJcbiAgICB2YXIgY3MgPSBnZW5lcmF0ZVhDb25zdHJhaW50cyhycywgdnMpO1xyXG4gICAgdmFyIHNvbHZlciA9IG5ldyB2cHNjXzEuU29sdmVyKHZzLCBjcyk7XHJcbiAgICBzb2x2ZXIuc29sdmUoKTtcclxuICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHJzW2ldLnNldFhDZW50cmUodi5wb3NpdGlvbigpKTsgfSk7XHJcbiAgICB2cyA9IHJzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gbmV3IHZwc2NfMS5WYXJpYWJsZShyLmN5KCkpOyB9KTtcclxuICAgIGNzID0gZ2VuZXJhdGVZQ29uc3RyYWludHMocnMsIHZzKTtcclxuICAgIHNvbHZlciA9IG5ldyB2cHNjXzEuU29sdmVyKHZzLCBjcyk7XHJcbiAgICBzb2x2ZXIuc29sdmUoKTtcclxuICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHJzW2ldLnNldFlDZW50cmUodi5wb3NpdGlvbigpKTsgfSk7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVPdmVybGFwcyA9IHJlbW92ZU92ZXJsYXBzO1xyXG52YXIgSW5kZXhlZFZhcmlhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbmRleGVkVmFyaWFibGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbmRleGVkVmFyaWFibGUoaW5kZXgsIHcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAwLCB3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEluZGV4ZWRWYXJpYWJsZTtcclxufSh2cHNjXzEuVmFyaWFibGUpKTtcclxuZXhwb3J0cy5JbmRleGVkVmFyaWFibGUgPSBJbmRleGVkVmFyaWFibGU7XHJcbnZhciBQcm9qZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb2plY3Rpb24obm9kZXMsIGdyb3Vwcywgcm9vdEdyb3VwLCBjb25zdHJhaW50cywgYXZvaWRPdmVybGFwcykge1xyXG4gICAgICAgIGlmIChyb290R3JvdXAgPT09IHZvaWQgMCkgeyByb290R3JvdXAgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzID09PSB2b2lkIDApIHsgY29uc3RyYWludHMgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGF2b2lkT3ZlcmxhcHMgPT09IHZvaWQgMCkgeyBhdm9pZE92ZXJsYXBzID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcclxuICAgICAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcclxuICAgICAgICB0aGlzLnJvb3RHcm91cCA9IHJvb3RHcm91cDtcclxuICAgICAgICB0aGlzLmF2b2lkT3ZlcmxhcHMgPSBhdm9pZE92ZXJsYXBzO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gbm9kZXMubWFwKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnZhcmlhYmxlID0gbmV3IEluZGV4ZWRWYXJpYWJsZShpLCAxKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY29uc3RyYWludHMpXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ29uc3RyYWludHMoY29uc3RyYWludHMpO1xyXG4gICAgICAgIGlmIChhdm9pZE92ZXJsYXBzICYmIHJvb3RHcm91cCAmJiB0eXBlb2Ygcm9vdEdyb3VwLmdyb3VwcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2LndpZHRoIHx8ICF2LmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYm91bmRzID0gbmV3IFJlY3RhbmdsZSh2LngsIHYueCwgdi55LCB2LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3MiA9IHYud2lkdGggLyAyLCBoMiA9IHYuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHYuYm91bmRzID0gbmV3IFJlY3RhbmdsZSh2LnggLSB3Miwgdi54ICsgdzIsIHYueSAtIGgyLCB2LnkgKyBoMik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb21wdXRlR3JvdXBCb3VuZHMocm9vdEdyb3VwKTtcclxuICAgICAgICAgICAgdmFyIGkgPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXNbaV0gPSBnLm1pblZhciA9IG5ldyBJbmRleGVkVmFyaWFibGUoaSsrLCB0eXBlb2YgZy5zdGlmZm5lc3MgIT09IFwidW5kZWZpbmVkXCIgPyBnLnN0aWZmbmVzcyA6IDAuMDEpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzW2ldID0gZy5tYXhWYXIgPSBuZXcgSW5kZXhlZFZhcmlhYmxlKGkrKywgdHlwZW9mIGcuc3RpZmZuZXNzICE9PSBcInVuZGVmaW5lZFwiID8gZy5zdGlmZm5lc3MgOiAwLjAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUuY3JlYXRlU2VwYXJhdGlvbiA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2cHNjXzEuQ29uc3RyYWludCh0aGlzLm5vZGVzW2MubGVmdF0udmFyaWFibGUsIHRoaXMubm9kZXNbYy5yaWdodF0udmFyaWFibGUsIGMuZ2FwLCB0eXBlb2YgYy5lcXVhbGl0eSAhPT0gXCJ1bmRlZmluZWRcIiA/IGMuZXF1YWxpdHkgOiBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUubWFrZUZlYXNpYmxlID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5hdm9pZE92ZXJsYXBzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGF4aXMgPSAneCcsIGRpbSA9ICd3aWR0aCc7XHJcbiAgICAgICAgaWYgKGMuYXhpcyA9PT0gJ3gnKVxyXG4gICAgICAgICAgICBheGlzID0gJ3knLCBkaW0gPSAnaGVpZ2h0JztcclxuICAgICAgICB2YXIgdnMgPSBjLm9mZnNldHMubWFwKGZ1bmN0aW9uIChvKSB7IHJldHVybiBfdGhpcy5ub2Rlc1tvLm5vZGVdOyB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhW2F4aXNdIC0gYltheGlzXTsgfSk7XHJcbiAgICAgICAgdmFyIHAgPSBudWxsO1xyXG4gICAgICAgIHZzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9zID0gcFtheGlzXSArIHBbZGltXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UG9zID4gdltheGlzXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbYXhpc10gPSBuZXh0UG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSB2O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFsaWdubWVudCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdSA9IHRoaXMubm9kZXNbYy5vZmZzZXRzWzBdLm5vZGVdLnZhcmlhYmxlO1xyXG4gICAgICAgIHRoaXMubWFrZUZlYXNpYmxlKGMpO1xyXG4gICAgICAgIHZhciBjcyA9IGMuYXhpcyA9PT0gJ3gnID8gdGhpcy54Q29uc3RyYWludHMgOiB0aGlzLnlDb25zdHJhaW50cztcclxuICAgICAgICBjLm9mZnNldHMuc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IF90aGlzLm5vZGVzW28ubm9kZV0udmFyaWFibGU7XHJcbiAgICAgICAgICAgIGNzLnB1c2gobmV3IHZwc2NfMS5Db25zdHJhaW50KHUsIHYsIG8ub2Zmc2V0LCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpc1NlcCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYy50eXBlID09PSAndW5kZWZpbmVkJyB8fCBjLnR5cGUgPT09ICdzZXBhcmF0aW9uJzsgfTtcclxuICAgICAgICB0aGlzLnhDb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuYXhpcyA9PT0gXCJ4XCIgJiYgaXNTZXAoYyk7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZVNlcGFyYXRpb24oYyk7IH0pO1xyXG4gICAgICAgIHRoaXMueUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5heGlzID09PSBcInlcIiAmJiBpc1NlcChjKTsgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuY3JlYXRlU2VwYXJhdGlvbihjKTsgfSk7XHJcbiAgICAgICAgY29uc3RyYWludHNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50eXBlID09PSAnYWxpZ25tZW50JzsgfSlcclxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUFsaWdubWVudChjKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0dXBWYXJpYWJsZXNBbmRCb3VuZHMgPSBmdW5jdGlvbiAoeDAsIHkwLCBkZXNpcmVkLCBnZXREZXNpcmVkKSB7XHJcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIGlmICh2LmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2LnZhcmlhYmxlLndlaWdodCA9IHYuZml4ZWRXZWlnaHQgPyB2LmZpeGVkV2VpZ2h0IDogMTAwMDtcclxuICAgICAgICAgICAgICAgIGRlc2lyZWRbaV0gPSBnZXREZXNpcmVkKHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdi52YXJpYWJsZS53ZWlnaHQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB3ID0gKHYud2lkdGggfHwgMCkgLyAyLCBoID0gKHYuaGVpZ2h0IHx8IDApIC8gMjtcclxuICAgICAgICAgICAgdmFyIGl4ID0geDBbaV0sIGl5ID0geTBbaV07XHJcbiAgICAgICAgICAgIHYuYm91bmRzID0gbmV3IFJlY3RhbmdsZShpeCAtIHcsIGl4ICsgdywgaXkgLSBoLCBpeSArIGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnhQcm9qZWN0ID0gZnVuY3Rpb24gKHgwLCB5MCwgeCkge1xyXG4gICAgICAgIGlmICghdGhpcy5yb290R3JvdXAgJiYgISh0aGlzLmF2b2lkT3ZlcmxhcHMgfHwgdGhpcy54Q29uc3RyYWludHMpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0KHgwLCB5MCwgeDAsIHgsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnB4OyB9LCB0aGlzLnhDb25zdHJhaW50cywgZ2VuZXJhdGVYR3JvdXBDb25zdHJhaW50cywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuYm91bmRzLnNldFhDZW50cmUoeFt2LnZhcmlhYmxlLmluZGV4XSA9IHYudmFyaWFibGUucG9zaXRpb24oKSk7IH0sIGZ1bmN0aW9uIChnKSB7XHJcbiAgICAgICAgICAgIHZhciB4bWluID0geFtnLm1pblZhci5pbmRleF0gPSBnLm1pblZhci5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgeG1heCA9IHhbZy5tYXhWYXIuaW5kZXhdID0gZy5tYXhWYXIucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHAyID0gZy5wYWRkaW5nIC8gMjtcclxuICAgICAgICAgICAgZy5ib3VuZHMueCA9IHhtaW4gLSBwMjtcclxuICAgICAgICAgICAgZy5ib3VuZHMuWCA9IHhtYXggKyBwMjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS55UHJvamVjdCA9IGZ1bmN0aW9uICh4MCwgeTAsIHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMucm9vdEdyb3VwICYmICF0aGlzLnlDb25zdHJhaW50cylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJvamVjdCh4MCwgeTAsIHkwLCB5LCBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5weTsgfSwgdGhpcy55Q29uc3RyYWludHMsIGdlbmVyYXRlWUdyb3VwQ29uc3RyYWludHMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LmJvdW5kcy5zZXRZQ2VudHJlKHlbdi52YXJpYWJsZS5pbmRleF0gPSB2LnZhcmlhYmxlLnBvc2l0aW9uKCkpOyB9LCBmdW5jdGlvbiAoZykge1xyXG4gICAgICAgICAgICB2YXIgeW1pbiA9IHlbZy5taW5WYXIuaW5kZXhdID0gZy5taW5WYXIucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHltYXggPSB5W2cubWF4VmFyLmluZGV4XSA9IGcubWF4VmFyLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciBwMiA9IGcucGFkZGluZyAvIDI7XHJcbiAgICAgICAgICAgIGcuYm91bmRzLnkgPSB5bWluIC0gcDI7XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgZy5ib3VuZHMuWSA9IHltYXggKyBwMjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5wcm9qZWN0RnVuY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHgwLCB5MCwgeCkgeyByZXR1cm4gX3RoaXMueFByb2plY3QoeDAsIHkwLCB4KTsgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKHgwLCB5MCwgeSkgeyByZXR1cm4gX3RoaXMueVByb2plY3QoeDAsIHkwLCB5KTsgfVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgUHJvamVjdGlvbi5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uICh4MCwgeTAsIHN0YXJ0LCBkZXNpcmVkLCBnZXREZXNpcmVkLCBjcywgZ2VuZXJhdGVDb25zdHJhaW50cywgdXBkYXRlTm9kZUJvdW5kcywgdXBkYXRlR3JvdXBCb3VuZHMpIHtcclxuICAgICAgICB0aGlzLnNldHVwVmFyaWFibGVzQW5kQm91bmRzKHgwLCB5MCwgZGVzaXJlZCwgZ2V0RGVzaXJlZCk7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdEdyb3VwICYmIHRoaXMuYXZvaWRPdmVybGFwcykge1xyXG4gICAgICAgICAgICBjb21wdXRlR3JvdXBCb3VuZHModGhpcy5yb290R3JvdXApO1xyXG4gICAgICAgICAgICBjcyA9IGNzLmNvbmNhdChnZW5lcmF0ZUNvbnN0cmFpbnRzKHRoaXMucm9vdEdyb3VwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc29sdmUodGhpcy52YXJpYWJsZXMsIGNzLCBzdGFydCwgZGVzaXJlZCk7XHJcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHVwZGF0ZU5vZGVCb3VuZHMpO1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3RHcm91cCAmJiB0aGlzLmF2b2lkT3ZlcmxhcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHMuZm9yRWFjaCh1cGRhdGVHcm91cEJvdW5kcyk7XHJcbiAgICAgICAgICAgIGNvbXB1dGVHcm91cEJvdW5kcyh0aGlzLnJvb3RHcm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFByb2plY3Rpb24ucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKHZzLCBjcywgc3RhcnRpbmcsIGRlc2lyZWQpIHtcclxuICAgICAgICB2YXIgc29sdmVyID0gbmV3IHZwc2NfMS5Tb2x2ZXIodnMsIGNzKTtcclxuICAgICAgICBzb2x2ZXIuc2V0U3RhcnRpbmdQb3NpdGlvbnMoc3RhcnRpbmcpO1xyXG4gICAgICAgIHNvbHZlci5zZXREZXNpcmVkUG9zaXRpb25zKGRlc2lyZWQpO1xyXG4gICAgICAgIHNvbHZlci5zb2x2ZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm9qZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlByb2plY3Rpb24gPSBQcm9qZWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWN0YW5nbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHBxdWV1ZV8xID0gcmVxdWlyZShcIi4vcHF1ZXVlXCIpO1xyXG52YXIgTmVpZ2hib3VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5laWdoYm91cihpZCwgZGlzdGFuY2UpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5laWdoYm91cjtcclxufSgpKTtcclxudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZShpZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLm5laWdoYm91cnMgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG52YXIgUXVldWVFbnRyeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRdWV1ZUVudHJ5KG5vZGUsIHByZXYsIGQpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XHJcbiAgICAgICAgdGhpcy5kID0gZDtcclxuICAgIH1cclxuICAgIHJldHVybiBRdWV1ZUVudHJ5O1xyXG59KCkpO1xyXG52YXIgQ2FsY3VsYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYWxjdWxhdG9yKG4sIGVzLCBnZXRTb3VyY2VJbmRleCwgZ2V0VGFyZ2V0SW5kZXgsIGdldExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMubiA9IG47XHJcbiAgICAgICAgdGhpcy5lcyA9IGVzO1xyXG4gICAgICAgIHRoaXMubmVpZ2hib3VycyA9IG5ldyBBcnJheSh0aGlzLm4pO1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5uO1xyXG4gICAgICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3Vyc1tpXSA9IG5ldyBOb2RlKGkpO1xyXG4gICAgICAgIGkgPSB0aGlzLmVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5lc1tpXTtcclxuICAgICAgICAgICAgdmFyIHUgPSBnZXRTb3VyY2VJbmRleChlKSwgdiA9IGdldFRhcmdldEluZGV4KGUpO1xyXG4gICAgICAgICAgICB2YXIgZCA9IGdldExlbmd0aChlKTtcclxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvdXJzW3VdLm5laWdoYm91cnMucHVzaChuZXcgTmVpZ2hib3VyKHYsIGQpKTtcclxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvdXJzW3ZdLm5laWdoYm91cnMucHVzaChuZXcgTmVpZ2hib3VyKHUsIGQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDYWxjdWxhdG9yLnByb3RvdHlwZS5EaXN0YW5jZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgRCA9IG5ldyBBcnJheSh0aGlzLm4pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uOyArK2kpIHtcclxuICAgICAgICAgICAgRFtpXSA9IHRoaXMuZGlqa3N0cmFOZWlnaGJvdXJzKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRDtcclxuICAgIH07XHJcbiAgICBDYWxjdWxhdG9yLnByb3RvdHlwZS5EaXN0YW5jZXNGcm9tTm9kZSA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpamtzdHJhTmVpZ2hib3VycyhzdGFydCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsY3VsYXRvci5wcm90b3R5cGUuUGF0aEZyb21Ob2RlVG9Ob2RlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaWprc3RyYU5laWdoYm91cnMoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsY3VsYXRvci5wcm90b3R5cGUuUGF0aEZyb21Ob2RlVG9Ob2RlV2l0aFByZXZDb3N0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHByZXZDb3N0KSB7XHJcbiAgICAgICAgdmFyIHEgPSBuZXcgcHF1ZXVlXzEuUHJpb3JpdHlRdWV1ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5kIDw9IGIuZDsgfSksIHUgPSB0aGlzLm5laWdoYm91cnNbc3RhcnRdLCBxdSA9IG5ldyBRdWV1ZUVudHJ5KHUsIG51bGwsIDApLCB2aXNpdGVkRnJvbSA9IHt9O1xyXG4gICAgICAgIHEucHVzaChxdSk7XHJcbiAgICAgICAgd2hpbGUgKCFxLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgcXUgPSBxLnBvcCgpO1xyXG4gICAgICAgICAgICB1ID0gcXUubm9kZTtcclxuICAgICAgICAgICAgaWYgKHUuaWQgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGkgPSB1Lm5laWdoYm91cnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3VyID0gdS5uZWlnaGJvdXJzW2ldLCB2ID0gdGhpcy5uZWlnaGJvdXJzW25laWdoYm91ci5pZF07XHJcbiAgICAgICAgICAgICAgICBpZiAocXUucHJldiAmJiB2LmlkID09PSBxdS5wcmV2Lm5vZGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlkdWlkID0gdi5pZCArICcsJyArIHUuaWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlkdWlkIGluIHZpc2l0ZWRGcm9tICYmIHZpc2l0ZWRGcm9tW3ZpZHVpZF0gPD0gcXUuZClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBjYyA9IHF1LnByZXYgPyBwcmV2Q29zdChxdS5wcmV2Lm5vZGUuaWQsIHUuaWQsIHYuaWQpIDogMCwgdCA9IHF1LmQgKyBuZWlnaGJvdXIuZGlzdGFuY2UgKyBjYztcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRGcm9tW3ZpZHVpZF0gPSB0O1xyXG4gICAgICAgICAgICAgICAgcS5wdXNoKG5ldyBRdWV1ZUVudHJ5KHYsIHF1LCB0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcclxuICAgICAgICB3aGlsZSAocXUucHJldikge1xyXG4gICAgICAgICAgICBxdSA9IHF1LnByZXY7XHJcbiAgICAgICAgICAgIHBhdGgucHVzaChxdS5ub2RlLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG4gICAgQ2FsY3VsYXRvci5wcm90b3R5cGUuZGlqa3N0cmFOZWlnaGJvdXJzID0gZnVuY3Rpb24gKHN0YXJ0LCBkZXN0KSB7XHJcbiAgICAgICAgaWYgKGRlc3QgPT09IHZvaWQgMCkgeyBkZXN0ID0gLTE7IH1cclxuICAgICAgICB2YXIgcSA9IG5ldyBwcXVldWVfMS5Qcmlvcml0eVF1ZXVlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmQgPD0gYi5kOyB9KSwgaSA9IHRoaXMubmVpZ2hib3Vycy5sZW5ndGgsIGQgPSBuZXcgQXJyYXkoaSk7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubmVpZ2hib3Vyc1tpXTtcclxuICAgICAgICAgICAgbm9kZS5kID0gaSA9PT0gc3RhcnQgPyAwIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICBub2RlLnEgPSBxLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICghcS5lbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHZhciB1ID0gcS5wb3AoKTtcclxuICAgICAgICAgICAgZFt1LmlkXSA9IHUuZDtcclxuICAgICAgICAgICAgaWYgKHUuaWQgPT09IGRlc3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHU7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIHYucHJldiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2godi5wcmV2LmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gdi5wcmV2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IHUubmVpZ2hib3Vycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvdXIgPSB1Lm5laWdoYm91cnNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMubmVpZ2hib3Vyc1tuZWlnaGJvdXIuaWRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB1LmQgKyBuZWlnaGJvdXIuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodS5kICE9PSBOdW1iZXIuTUFYX1ZBTFVFICYmIHYuZCA+IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmQgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHYucHJldiA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5yZWR1Y2VLZXkodi5xLCB2LCBmdW5jdGlvbiAoZSwgcSkgeyByZXR1cm4gZS5xID0gcTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhbGN1bGF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ2FsY3VsYXRvciA9IENhbGN1bGF0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNob3J0ZXN0cGF0aHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFBvc2l0aW9uU3RhdHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9zaXRpb25TdGF0cyhzY2FsZSkge1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICB0aGlzLkFCID0gMDtcclxuICAgICAgICB0aGlzLkFEID0gMDtcclxuICAgICAgICB0aGlzLkEyID0gMDtcclxuICAgIH1cclxuICAgIFBvc2l0aW9uU3RhdHMucHJvdG90eXBlLmFkZFZhcmlhYmxlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgYWkgPSB0aGlzLnNjYWxlIC8gdi5zY2FsZTtcclxuICAgICAgICB2YXIgYmkgPSB2Lm9mZnNldCAvIHYuc2NhbGU7XHJcbiAgICAgICAgdmFyIHdpID0gdi53ZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5BQiArPSB3aSAqIGFpICogYmk7XHJcbiAgICAgICAgdGhpcy5BRCArPSB3aSAqIGFpICogdi5kZXNpcmVkUG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5BMiArPSB3aSAqIGFpICogYWk7XHJcbiAgICB9O1xyXG4gICAgUG9zaXRpb25TdGF0cy5wcm90b3R5cGUuZ2V0UG9zbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuQUQgLSB0aGlzLkFCKSAvIHRoaXMuQTI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvc2l0aW9uU3RhdHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUG9zaXRpb25TdGF0cyA9IFBvc2l0aW9uU3RhdHM7XHJcbnZhciBDb25zdHJhaW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnQobGVmdCwgcmlnaHQsIGdhcCwgZXF1YWxpdHkpIHtcclxuICAgICAgICBpZiAoZXF1YWxpdHkgPT09IHZvaWQgMCkgeyBlcXVhbGl0eSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgdGhpcy5nYXAgPSBnYXA7XHJcbiAgICAgICAgdGhpcy5lcXVhbGl0eSA9IGVxdWFsaXR5O1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy51bnNhdGlzZmlhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgdGhpcy5nYXAgPSBnYXA7XHJcbiAgICAgICAgdGhpcy5lcXVhbGl0eSA9IGVxdWFsaXR5O1xyXG4gICAgfVxyXG4gICAgQ29uc3RyYWludC5wcm90b3R5cGUuc2xhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zYXRpc2ZpYWJsZSA/IE51bWJlci5NQVhfVkFMVUVcclxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LnNjYWxlICogdGhpcy5yaWdodC5wb3NpdGlvbigpIC0gdGhpcy5nYXBcclxuICAgICAgICAgICAgICAgIC0gdGhpcy5sZWZ0LnNjYWxlICogdGhpcy5sZWZ0LnBvc2l0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnN0cmFpbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ29uc3RyYWludCA9IENvbnN0cmFpbnQ7XHJcbnZhciBWYXJpYWJsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYXJpYWJsZShkZXNpcmVkUG9zaXRpb24sIHdlaWdodCwgc2NhbGUpIHtcclxuICAgICAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHsgd2VpZ2h0ID0gMTsgfVxyXG4gICAgICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMTsgfVxyXG4gICAgICAgIHRoaXMuZGVzaXJlZFBvc2l0aW9uID0gZGVzaXJlZFBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICB9XHJcbiAgICBWYXJpYWJsZS5wcm90b3R5cGUuZGZkdiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMi4wICogdGhpcy53ZWlnaHQgKiAodGhpcy5wb3NpdGlvbigpIC0gdGhpcy5kZXNpcmVkUG9zaXRpb24pO1xyXG4gICAgfTtcclxuICAgIFZhcmlhYmxlLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2sucHMuc2NhbGUgKiB0aGlzLmJsb2NrLnBvc24gKyB0aGlzLm9mZnNldCkgLyB0aGlzLnNjYWxlO1xyXG4gICAgfTtcclxuICAgIFZhcmlhYmxlLnByb3RvdHlwZS52aXNpdE5laWdoYm91cnMgPSBmdW5jdGlvbiAocHJldiwgZikge1xyXG4gICAgICAgIHZhciBmZiA9IGZ1bmN0aW9uIChjLCBuZXh0KSB7IHJldHVybiBjLmFjdGl2ZSAmJiBwcmV2ICE9PSBuZXh0ICYmIGYoYywgbmV4dCk7IH07XHJcbiAgICAgICAgdGhpcy5jT3V0LmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGZmKGMsIGMucmlnaHQpOyB9KTtcclxuICAgICAgICB0aGlzLmNJbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBmZihjLCBjLmxlZnQpOyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmFyaWFibGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZTtcclxudmFyIEJsb2NrID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJsb2NrKHYpIHtcclxuICAgICAgICB0aGlzLnZhcnMgPSBbXTtcclxuICAgICAgICB2Lm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5wcyA9IG5ldyBQb3NpdGlvblN0YXRzKHYuc2NhbGUpO1xyXG4gICAgICAgIHRoaXMuYWRkVmFyaWFibGUodik7XHJcbiAgICB9XHJcbiAgICBCbG9jay5wcm90b3R5cGUuYWRkVmFyaWFibGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHYuYmxvY2sgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudmFycy5wdXNoKHYpO1xyXG4gICAgICAgIHRoaXMucHMuYWRkVmFyaWFibGUodik7XHJcbiAgICAgICAgdGhpcy5wb3NuID0gdGhpcy5wcy5nZXRQb3NuKCk7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLnVwZGF0ZVdlaWdodGVkUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcy5BQiA9IHRoaXMucHMuQUQgPSB0aGlzLnBzLkEyID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRoaXMudmFycy5sZW5ndGg7IGkgPCBuOyArK2kpXHJcbiAgICAgICAgICAgIHRoaXMucHMuYWRkVmFyaWFibGUodGhpcy52YXJzW2ldKTtcclxuICAgICAgICB0aGlzLnBvc24gPSB0aGlzLnBzLmdldFBvc24oKTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuY29tcHV0ZV9sbSA9IGZ1bmN0aW9uICh2LCB1LCBwb3N0QWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZGZkdiA9IHYuZGZkdigpO1xyXG4gICAgICAgIHYudmlzaXROZWlnaGJvdXJzKHUsIGZ1bmN0aW9uIChjLCBuZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBfZGZkdiA9IF90aGlzLmNvbXB1dGVfbG0obmV4dCwgdiwgcG9zdEFjdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBjLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBkZmR2ICs9IF9kZmR2ICogYy5sZWZ0LnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgYy5sbSA9IF9kZmR2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGZkdiArPSBfZGZkdiAqIGMucmlnaHQuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBjLmxtID0gLV9kZmR2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvc3RBY3Rpb24oYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRmZHYgLyB2LnNjYWxlO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5wb3B1bGF0ZVNwbGl0QmxvY2sgPSBmdW5jdGlvbiAodiwgcHJldikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdi52aXNpdE5laWdoYm91cnMocHJldiwgZnVuY3Rpb24gKGMsIG5leHQpIHtcclxuICAgICAgICAgICAgbmV4dC5vZmZzZXQgPSB2Lm9mZnNldCArIChuZXh0ID09PSBjLnJpZ2h0ID8gYy5nYXAgOiAtYy5nYXApO1xyXG4gICAgICAgICAgICBfdGhpcy5hZGRWYXJpYWJsZShuZXh0KTtcclxuICAgICAgICAgICAgX3RoaXMucG9wdWxhdGVTcGxpdEJsb2NrKG5leHQsIHYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uICh2aXNpdCwgYWNjLCB2LCBwcmV2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodiA9PT0gdm9pZCAwKSB7IHYgPSB0aGlzLnZhcnNbMF07IH1cclxuICAgICAgICBpZiAocHJldiA9PT0gdm9pZCAwKSB7IHByZXYgPSBudWxsOyB9XHJcbiAgICAgICAgdi52aXNpdE5laWdoYm91cnMocHJldiwgZnVuY3Rpb24gKGMsIG5leHQpIHtcclxuICAgICAgICAgICAgYWNjLnB1c2godmlzaXQoYykpO1xyXG4gICAgICAgICAgICBfdGhpcy50cmF2ZXJzZSh2aXNpdCwgYWNjLCBuZXh0LCB2KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUuZmluZE1pbkxNID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbXB1dGVfbG0odGhpcy52YXJzWzBdLCBudWxsLCBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICBpZiAoIWMuZXF1YWxpdHkgJiYgKG0gPT09IG51bGwgfHwgYy5sbSA8IG0ubG0pKVxyXG4gICAgICAgICAgICAgICAgbSA9IGM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmZpbmRNaW5MTUJldHdlZW4gPSBmdW5jdGlvbiAobHYsIHJ2KSB7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlX2xtKGx2LCBudWxsLCBmdW5jdGlvbiAoKSB7IH0pO1xyXG4gICAgICAgIHZhciBtID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbmRQYXRoKGx2LCBudWxsLCBydiwgZnVuY3Rpb24gKGMsIG5leHQpIHtcclxuICAgICAgICAgICAgaWYgKCFjLmVxdWFsaXR5ICYmIGMucmlnaHQgPT09IG5leHQgJiYgKG0gPT09IG51bGwgfHwgYy5sbSA8IG0ubG0pKVxyXG4gICAgICAgICAgICAgICAgbSA9IGM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24gKHYsIHByZXYsIHRvLCB2aXNpdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVuZEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdi52aXNpdE5laWdoYm91cnMocHJldiwgZnVuY3Rpb24gKGMsIG5leHQpIHtcclxuICAgICAgICAgICAgaWYgKCFlbmRGb3VuZCAmJiAobmV4dCA9PT0gdG8gfHwgX3RoaXMuZmluZFBhdGgobmV4dCwgdiwgdG8sIHZpc2l0KSkpIHtcclxuICAgICAgICAgICAgICAgIGVuZEZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZpc2l0KGMsIG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZEZvdW5kO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5pc0FjdGl2ZURpcmVjdGVkUGF0aEJldHdlZW4gPSBmdW5jdGlvbiAodSwgdikge1xyXG4gICAgICAgIGlmICh1ID09PSB2KVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgaSA9IHUuY091dC5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHUuY091dFtpXTtcclxuICAgICAgICAgICAgaWYgKGMuYWN0aXZlICYmIHRoaXMuaXNBY3RpdmVEaXJlY3RlZFBhdGhCZXR3ZWVuKGMucmlnaHQsIHYpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBCbG9jay5zcGxpdCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgYy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gW0Jsb2NrLmNyZWF0ZVNwbGl0QmxvY2soYy5sZWZ0KSwgQmxvY2suY3JlYXRlU3BsaXRCbG9jayhjLnJpZ2h0KV07XHJcbiAgICB9O1xyXG4gICAgQmxvY2suY3JlYXRlU3BsaXRCbG9jayA9IGZ1bmN0aW9uIChzdGFydFZhcikge1xyXG4gICAgICAgIHZhciBiID0gbmV3IEJsb2NrKHN0YXJ0VmFyKTtcclxuICAgICAgICBiLnBvcHVsYXRlU3BsaXRCbG9jayhzdGFydFZhciwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICB9O1xyXG4gICAgQmxvY2sucHJvdG90eXBlLnNwbGl0QmV0d2VlbiA9IGZ1bmN0aW9uICh2bCwgdnIpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuZmluZE1pbkxNQmV0d2Vlbih2bCwgdnIpO1xyXG4gICAgICAgIGlmIChjICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBicyA9IEJsb2NrLnNwbGl0KGMpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBjb25zdHJhaW50OiBjLCBsYjogYnNbMF0sIHJiOiBic1sxXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBCbG9jay5wcm90b3R5cGUubWVyZ2VBY3Jvc3MgPSBmdW5jdGlvbiAoYiwgYywgZGlzdCkge1xyXG4gICAgICAgIGMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGIudmFycy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBiLnZhcnNbaV07XHJcbiAgICAgICAgICAgIHYub2Zmc2V0ICs9IGRpc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkVmFyaWFibGUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9zbiA9IHRoaXMucHMuZ2V0UG9zbigpO1xyXG4gICAgfTtcclxuICAgIEJsb2NrLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdW0gPSAwLCBpID0gdGhpcy52YXJzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy52YXJzW2ldLCBkID0gdi5wb3NpdGlvbigpIC0gdi5kZXNpcmVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIHN1bSArPSBkICogZCAqIHYud2VpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCbG9jaztcclxufSgpKTtcclxuZXhwb3J0cy5CbG9jayA9IEJsb2NrO1xyXG52YXIgQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJsb2Nrcyh2cykge1xyXG4gICAgICAgIHRoaXMudnMgPSB2cztcclxuICAgICAgICB2YXIgbiA9IHZzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgQXJyYXkobik7XHJcbiAgICAgICAgd2hpbGUgKG4tLSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCbG9jayh2c1tuXSk7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtuXSA9IGI7XHJcbiAgICAgICAgICAgIGIuYmxvY2tJbmQgPSBuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEJsb2Nrcy5wcm90b3R5cGUuY29zdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VtID0gMCwgaSA9IHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgc3VtICs9IHRoaXMubGlzdFtpXS5jb3N0KCk7XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgYi5ibG9ja0luZCA9IHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2goYik7XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5saXN0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHN3YXBCbG9jayA9IHRoaXMubGlzdFtsYXN0XTtcclxuICAgICAgICB0aGlzLmxpc3QubGVuZ3RoID0gbGFzdDtcclxuICAgICAgICBpZiAoYiAhPT0gc3dhcEJsb2NrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtiLmJsb2NrSW5kXSA9IHN3YXBCbG9jaztcclxuICAgICAgICAgICAgc3dhcEJsb2NrLmJsb2NrSW5kID0gYi5ibG9ja0luZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmxvY2tzLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgdmFyIGwgPSBjLmxlZnQuYmxvY2ssIHIgPSBjLnJpZ2h0LmJsb2NrO1xyXG4gICAgICAgIHZhciBkaXN0ID0gYy5yaWdodC5vZmZzZXQgLSBjLmxlZnQub2Zmc2V0IC0gYy5nYXA7XHJcbiAgICAgICAgaWYgKGwudmFycy5sZW5ndGggPCByLnZhcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHIubWVyZ2VBY3Jvc3MobCwgYywgZGlzdCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbC5tZXJnZUFjcm9zcyhyLCBjLCAtZGlzdCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKGYpO1xyXG4gICAgfTtcclxuICAgIEJsb2Nrcy5wcm90b3R5cGUudXBkYXRlQmxvY2tQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIudXBkYXRlV2VpZ2h0ZWRQb3NpdGlvbigpOyB9KTtcclxuICAgIH07XHJcbiAgICBCbG9ja3MucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGluYWN0aXZlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBiLmZpbmRNaW5MTSgpO1xyXG4gICAgICAgICAgICBpZiAodiAhPT0gbnVsbCAmJiB2LmxtIDwgU29sdmVyLkxBR1JBTkdJQU5fVE9MRVJBTkNFKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gdi5sZWZ0LmJsb2NrO1xyXG4gICAgICAgICAgICAgICAgQmxvY2suc3BsaXQodikuZm9yRWFjaChmdW5jdGlvbiAobmIpIHsgcmV0dXJuIF90aGlzLmluc2VydChuYik7IH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlKGIpO1xyXG4gICAgICAgICAgICAgICAgaW5hY3RpdmUucHVzaCh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCbG9ja3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmxvY2tzID0gQmxvY2tzO1xyXG52YXIgU29sdmVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvbHZlcih2cywgY3MpIHtcclxuICAgICAgICB0aGlzLnZzID0gdnM7XHJcbiAgICAgICAgdGhpcy5jcyA9IGNzO1xyXG4gICAgICAgIHRoaXMudnMgPSB2cztcclxuICAgICAgICB2cy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHYuY0luID0gW10sIHYuY091dCA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY3MgPSBjcztcclxuICAgICAgICBjcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgIGMubGVmdC5jT3V0LnB1c2goYyk7XHJcbiAgICAgICAgICAgIGMucmlnaHQuY0luLnB1c2goYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbmFjdGl2ZSA9IGNzLm1hcChmdW5jdGlvbiAoYykgeyBjLmFjdGl2ZSA9IGZhbHNlOyByZXR1cm4gYzsgfSk7XHJcbiAgICAgICAgdGhpcy5icyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBTb2x2ZXIucHJvdG90eXBlLmNvc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnMuY29zdCgpO1xyXG4gICAgfTtcclxuICAgIFNvbHZlci5wcm90b3R5cGUuc2V0U3RhcnRpbmdQb3NpdGlvbnMgPSBmdW5jdGlvbiAocHMpIHtcclxuICAgICAgICB0aGlzLmluYWN0aXZlID0gdGhpcy5jcy5tYXAoZnVuY3Rpb24gKGMpIHsgYy5hY3RpdmUgPSBmYWxzZTsgcmV0dXJuIGM7IH0pO1xyXG4gICAgICAgIHRoaXMuYnMgPSBuZXcgQmxvY2tzKHRoaXMudnMpO1xyXG4gICAgICAgIHRoaXMuYnMuZm9yRWFjaChmdW5jdGlvbiAoYiwgaSkgeyByZXR1cm4gYi5wb3NuID0gcHNbaV07IH0pO1xyXG4gICAgfTtcclxuICAgIFNvbHZlci5wcm90b3R5cGUuc2V0RGVzaXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChwcykge1xyXG4gICAgICAgIHRoaXMudnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gdi5kZXNpcmVkUG9zaXRpb24gPSBwc1tpXTsgfSk7XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5tb3N0VmlvbGF0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pblNsYWNrID0gTnVtYmVyLk1BWF9WQUxVRSwgdiA9IG51bGwsIGwgPSB0aGlzLmluYWN0aXZlLCBuID0gbC5sZW5ndGgsIGRlbGV0ZVBvaW50ID0gbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGxbaV07XHJcbiAgICAgICAgICAgIGlmIChjLnVuc2F0aXNmaWFibGUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdmFyIHNsYWNrID0gYy5zbGFjaygpO1xyXG4gICAgICAgICAgICBpZiAoYy5lcXVhbGl0eSB8fCBzbGFjayA8IG1pblNsYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5TbGFjayA9IHNsYWNrO1xyXG4gICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQb2ludCA9IGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5lcXVhbGl0eSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVsZXRlUG9pbnQgIT09IG4gJiZcclxuICAgICAgICAgICAgKG1pblNsYWNrIDwgU29sdmVyLlpFUk9fVVBQRVJCT1VORCAmJiAhdi5hY3RpdmUgfHwgdi5lcXVhbGl0eSkpIHtcclxuICAgICAgICAgICAgbFtkZWxldGVQb2ludF0gPSBsW24gLSAxXTtcclxuICAgICAgICAgICAgbC5sZW5ndGggPSBuIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLnByb3RvdHlwZS5zYXRpc2Z5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJzID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5icyA9IG5ldyBCbG9ja3ModGhpcy52cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnMuc3BsaXQodGhpcy5pbmFjdGl2ZSk7XHJcbiAgICAgICAgdmFyIHYgPSBudWxsO1xyXG4gICAgICAgIHdoaWxlICgodiA9IHRoaXMubW9zdFZpb2xhdGVkKCkpICYmICh2LmVxdWFsaXR5IHx8IHYuc2xhY2soKSA8IFNvbHZlci5aRVJPX1VQUEVSQk9VTkQgJiYgIXYuYWN0aXZlKSkge1xyXG4gICAgICAgICAgICB2YXIgbGIgPSB2LmxlZnQuYmxvY2ssIHJiID0gdi5yaWdodC5ibG9jaztcclxuICAgICAgICAgICAgaWYgKGxiICE9PSByYikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icy5tZXJnZSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYi5pc0FjdGl2ZURpcmVjdGVkUGF0aEJldHdlZW4odi5yaWdodCwgdi5sZWZ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYudW5zYXRpc2ZpYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBsYi5zcGxpdEJldHdlZW4odi5sZWZ0LCB2LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmIChzcGxpdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnMuaW5zZXJ0KHNwbGl0LmxiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJzLmluc2VydChzcGxpdC5yYik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5icy5yZW1vdmUobGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmUucHVzaChzcGxpdC5jb25zdHJhaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHYudW5zYXRpc2ZpYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodi5zbGFjaygpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluYWN0aXZlLnB1c2godik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJzLm1lcmdlKHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zYXRpc2Z5KCk7XHJcbiAgICAgICAgdmFyIGxhc3Rjb3N0ID0gTnVtYmVyLk1BWF9WQUxVRSwgY29zdCA9IHRoaXMuYnMuY29zdCgpO1xyXG4gICAgICAgIHdoaWxlIChNYXRoLmFicyhsYXN0Y29zdCAtIGNvc3QpID4gMC4wMDAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2F0aXNmeSgpO1xyXG4gICAgICAgICAgICBsYXN0Y29zdCA9IGNvc3Q7XHJcbiAgICAgICAgICAgIGNvc3QgPSB0aGlzLmJzLmNvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvc3Q7XHJcbiAgICB9O1xyXG4gICAgU29sdmVyLkxBR1JBTkdJQU5fVE9MRVJBTkNFID0gLTFlLTQ7XHJcbiAgICBTb2x2ZXIuWkVST19VUFBFUkJPVU5EID0gLTFlLTEwO1xyXG4gICAgcmV0dXJuIFNvbHZlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Tb2x2ZXIgPSBTb2x2ZXI7XHJcbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXBJbk9uZURpbWVuc2lvbihzcGFucywgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xyXG4gICAgdmFyIHZzID0gc3BhbnMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBuZXcgVmFyaWFibGUocy5kZXNpcmVkQ2VudGVyKTsgfSk7XHJcbiAgICB2YXIgY3MgPSBbXTtcclxuICAgIHZhciBuID0gc3BhbnMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBzcGFuc1tpXSwgcmlnaHQgPSBzcGFuc1tpICsgMV07XHJcbiAgICAgICAgY3MucHVzaChuZXcgQ29uc3RyYWludCh2c1tpXSwgdnNbaSArIDFdLCAobGVmdC5zaXplICsgcmlnaHQuc2l6ZSkgLyAyKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgbGVmdE1vc3QgPSB2c1swXSwgcmlnaHRNb3N0ID0gdnNbbiAtIDFdLCBsZWZ0TW9zdFNpemUgPSBzcGFuc1swXS5zaXplIC8gMiwgcmlnaHRNb3N0U2l6ZSA9IHNwYW5zW24gLSAxXS5zaXplIC8gMjtcclxuICAgIHZhciB2TG93ZXIgPSBudWxsLCB2VXBwZXIgPSBudWxsO1xyXG4gICAgaWYgKGxvd2VyQm91bmQpIHtcclxuICAgICAgICB2TG93ZXIgPSBuZXcgVmFyaWFibGUobG93ZXJCb3VuZCwgbGVmdE1vc3Qud2VpZ2h0ICogMTAwMCk7XHJcbiAgICAgICAgdnMucHVzaCh2TG93ZXIpO1xyXG4gICAgICAgIGNzLnB1c2gobmV3IENvbnN0cmFpbnQodkxvd2VyLCBsZWZ0TW9zdCwgbGVmdE1vc3RTaXplKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodXBwZXJCb3VuZCkge1xyXG4gICAgICAgIHZVcHBlciA9IG5ldyBWYXJpYWJsZSh1cHBlckJvdW5kLCByaWdodE1vc3Qud2VpZ2h0ICogMTAwMCk7XHJcbiAgICAgICAgdnMucHVzaCh2VXBwZXIpO1xyXG4gICAgICAgIGNzLnB1c2gobmV3IENvbnN0cmFpbnQocmlnaHRNb3N0LCB2VXBwZXIsIHJpZ2h0TW9zdFNpemUpKTtcclxuICAgIH1cclxuICAgIHZhciBzb2x2ZXIgPSBuZXcgU29sdmVyKHZzLCBjcyk7XHJcbiAgICBzb2x2ZXIuc29sdmUoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV3Q2VudGVyczogdnMuc2xpY2UoMCwgc3BhbnMubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucG9zaXRpb24oKTsgfSksXHJcbiAgICAgICAgbG93ZXJCb3VuZDogdkxvd2VyID8gdkxvd2VyLnBvc2l0aW9uKCkgOiBsZWZ0TW9zdC5wb3NpdGlvbigpIC0gbGVmdE1vc3RTaXplLFxyXG4gICAgICAgIHVwcGVyQm91bmQ6IHZVcHBlciA/IHZVcHBlci5wb3NpdGlvbigpIDogcmlnaHRNb3N0LnBvc2l0aW9uKCkgKyByaWdodE1vc3RTaXplXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlT3ZlcmxhcEluT25lRGltZW5zaW9uID0gcmVtb3ZlT3ZlcmxhcEluT25lRGltZW5zaW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12cHNjLmpzLm1hcCIsIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdXG5cbiAgICB2YXIgaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gICAgfVxuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge31cblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgfSwgdGhpcylcblxuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgIHZhciBsaXN0ID0gdGhpcy5tYXBbbmFtZV1cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBbXVxuICAgICAgdGhpcy5tYXBbbmFtZV0gPSBsaXN0XG4gICAgfVxuICAgIGxpc3QucHVzaCh2YWx1ZSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICByZXR1cm4gdmFsdWVzID8gdmFsdWVzWzBdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSB8fCBbXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IFtub3JtYWxpemVWYWx1ZSh2YWx1ZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLm1hcCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLm1hcFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpXG4gICAgICB9LCB0aGlzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSlcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICAgIGJvZHkudHJpbSgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZm9ybVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgICByYXdIZWFkZXJzLnNwbGl0KCdcXHJcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gJ3N0YXR1cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogMjAwXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsImV4cG9ydCBjb25zdCBVTktOT1dfSU1BR0UgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFKQUFBQUM3Q0FZQUFBQ0tMUmROQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFTNndBQUV1c0J4STh0T3dBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBbnNTVVJCVkhpYzdkeFpTRlQ5SDhmeHo4emtvNklwYUpvb0xiWlJadEVZRlVFVWFoZHRCbUxMaGJSUjFvV1JZRWxpbEMwM1NSc1piYlNMMFlJM2xWRlV0T0ZTNEJKV1R2N1RKRWl4Yk05d3l6bi9peDdpMy9QWEhqM2YzOHlaY1Q0dkdDaW0zNit2OHVZY25UbHpnSjlTQUx3RW9QSEJSeThlTC9HekdaZ0FyQVZ3SEVSOXQ4NEU0RDhBUmhzOUNibWxseVlBWFFETVJrOUNic2x1d3M5ekdwRXVQUEtReUlDZW5nZ09Eb2JWYW5YbUxPU2lLaXNyOGVIRGgyNmY2ekdnS1ZPbTRNYU5HdzRiaXR6SDNMbHpjZlBtelc2ZjR5bU1SQmdRaVRBZ0VtRkFKTUtBU0lRQmtRZ0RJaEVHUkNJTWlFUVlFSWt3SUJKaFFDVENnRWlFQVpFSUF5SVJCa1FpREloRUdCQ0pNQ0FTWVVBa3dvQkloQUdSQ0FNaUVRWkVJZ3lJUkJnUWlUQWdFbUZBSk1LQVNJUUJrUWdESXBFZTd3L2tLUm9iRzlIUTBJRG01bWE4Zi84ZXpjM04rUEhqQno1OSt2VGJ2d3NNRElUWmJNYWdRWU1RRmhhR2lJZ0loSWVISXpRMDFLREpYWU5IQk5UWjJRbWJ6WWFxcWlwVVZWV2h1cm9hcjE2OVFuMTlQZHJhMmtSN0J3VUZZY0tFQ1lpT2pzYTBhZE1RSHgrUDhQQndSWk83dm40WlVGTlRFMHBLU2xCVVZJVFMwbEpVVkZTZ282UERJZi9YeDQ4ZjhlREJBeng0OEFDSER4OEdBSXdiTnc3ejVzMURjbkp5djc5TllMOElxSzZ1RG5mdTNFRkpTUW1LaTR0UlYxZG42RHcybXcwMm13Mzc5dTNEK1BIanNXYk5HcXhac3diKy92Nkd6dVVvM2Q3T2ZzNmNPWnFyc3R2dFduRnhzYlpwMHladDdOaXhSdC8ydjFlUDRPQmdiZnYyN2Rybno1K04vdmIxMlp3NWMvNzB0YmxYUVB2MjdkTWlJeU1ORDBMdkl5d3NUTXZMeTlQc2RydlIzOHBlKzFOQWJ2ZHJmSDUrUHVycjY0MGVRN2VtcGlZc1g3NGNjWEZ4ZVBQbWpkSGppTGxkUVAzRi9mdjNZYlZhZTd4OXJydGdRQVo2Ly80OTVzK2ZqOXpjWEtOSDBZMEJHY3h1dHlNdExRMlptWmxHajZJTEEzSVJPVGs1MkxadG05Rmo5QmtEY2lHN2R1M0MwYU5IalI2alR4aVFpMGxMUzBOSlNZblJZL1JhdjNnbHVxOHNGZ3Vpb3FKZ3RWb3hZc1FJREI4K0hNT0dEVU5FUkFTOHZMd1FHQmdJYjI5dm1NMW1mUG55NWRlanFha0pUNTQ4UVZsWkdjckx5OUhRMEtCOHRzN09UcXhZc1FKUG5qeUJuNStmOHYxVjg0aUF6R1l6cGs2ZGlvU0VCTXlZTVFNeE1URzlmbHZCeDhjSGd3Y1AvdlgzaElTRVgzK3VxNnREUVVFQnpwdzVnNXFhR21YejF0YldJak16RTRjT0hWSzJweU81MVN2UlZxdTFWNi80bWt3bUxUWTJWanQ1OHFUVzFOVGswSm5zZHJ0Mi9mcDFMU1ltUnRrcjFnTUdETkJxYW1vY09uZHY5YXUzTXY0dG9ORFFVQzBqSThPUWI3N2RidGRPbkRpaEJRUUVLSWxvNmRLbFR2OGF1dFB2QXpLWlROcnMyYk8xUzVjdWFlM3Q3VWFQcU5YWDEydVRKazBTQjJRMm03VlhyMTRaL2VYMHIvZkMvcGZGWWtGeWNqS2VQWHVHMjdkdlk4bVNKZmpycjcrTUhndkRodzlIVVZFUlpzMmFKZHJIYnJmajdObXphb1p5RUxjTktDa3BDVGFiRGZuNStZaUtpako2blAvajUrZUhxMWV2SWpvNldyVFB1WFBub0dtYW9xblVjN3VBa3BLU2NQZnVYUlFVRkdEMDZORkdqL05IQVFFQnVIRGhBcnk5dlhYdjhmcjFhMVJYVnl1Y1NpMjNDMmpMbGkySWpZMDFlb3hlaTQ2T1JtcHFxbWlQdTNmdktwcEdQYmNMeUIxbFptYUtmalo3K1BDaHdtblVZa0JPRUJJUzh0c0xrSDJsOGtWSzFSaVFreXhZc0VEMzJ0cmFXdGp0ZG9YVHFNT0FuR1RtekptNjE3YTJ0dUxkdTNjS3AxR0hBVGxKWkdRa2ZIMTlkYS8vOXUyYndtblVZVUJPWWpLWk1HellNTjNyR1JBaElDQkE5MXJwUjdBZGhRRTVrZVFVNXFyWEJqRWdKL3IrL2J2dXRhNzZzV2dHNUVRdExTMjYxeklnd3VmUG4zV3Q4L2IyeHFCQmd4UlBvd1lEY3BLdlg3L2k3ZHUzdXRhT0dERUNGb3RGOFVScU1DQW5zZGxzdWkvTGNPV3JEaGlRazFSVVZPaGVPM0hpUklXVHFNV0FuS1N3c0ZEMzJyaTRPSVdUcU1XQW5LQ2xwUVgzN3QzVHRkYkh4d2ZUcDA5WFBKRTZETWdKVHA4K2pkYldWbDFyNCtMaTRPUGpvM2dpZFJpUWczVjJkbUwvL3YyNjE2OWN1VkxkTUE3QWdCeHM3OTY5ZVAzNnRhNjF3Y0hCV0xod29lS0oxR0pBRGxSVFU0T2RPM2ZxWHArU2tpSzZJTjhaR0pDRHRMVzFJVGs1V2ZlNzZQNysva2hQVDFjOGxYb015RUhXcjErUDh2SnkzZXZUMDlNUkVoS2ljQ0xIWUVBT3NIdjNicHc2ZFVyMytpRkRoaUFqSTBQaFJJN0RnQlE3ZmZvMHNyS3lSSHNjUEhqUVpkOTkveWNHcE5DWk0yZXdkdTFhMFVlUkV4TVRrWmlZcUhBcXgySkFpaHc1Y2dTclY2OUdWMWVYN2oyR0RoMktreWRQS3B6SzhSaVFrS1pweU1yS1FtcHFxdWpJNCtYbGhZc1hMeUlvS0VqaGRJN25FYmU0YzVTV2xoYXNYcjBhbHk5ZkZ1MWpNcGx3L1BoeGwzN1BxeWNNU0tlYW1ob3NXclFJejU0OUUrKzFZOGNPckZxMVNzRlV6c2RUV0I5MWRYWGh3SUVEaUltSlVSSlBlbm82dG03ZHFtQXlZL0FJMUFkUG56NUZTa29LSGo5K3JHUy96WnMzWS9mdTNVcjJNZ3FQUUwzUTN0Nk9yVnUzWXZMa3lVcmlNWnZOMkxObmo5dkhBL0FJOUs5dTNicUZ0TFEwdkhqeFFzbCtQajQrT0hmdUhKWXNXYUprUDZNeG9CN1UxdFppNDhhTnVIcjFxckk5aHd3WmdrdVhMcm5sYjFzOVlVRC84UDM3ZCt6WnN3YzVPVGxLUDQ4ZUh4K1A4K2ZQLzNiWCsvNkFQd1A5VGRNMDVPWGxZZFNvVWRpeFk0ZXllQ3dXQzdLenMzSHIxcTErRncvQUl4QUFvS3lzREJzMmJFQnBhYW5TZlVORFEzSCsvSG5NbmoxYjZiNnV4S09QUUkyTmpWaTNiaDJtVFp1bVBKN0ZpeGZqK2ZQbi9Ub2V3SU9QUUYrK2ZNR1lNV05FZDh6b1RrUkVCSTRkT3lhNko2STc4ZGdqVUVkSGg5SjRUQ1lUbGkxYmhxcXFLbytKQi9EZ0k1QktvMGFOd3JGanh4QWZIMi8wS0U3bnNVY2dGWHg5ZlpHZG5ZMm5UNTk2WkR3QWowQzZMVml3QUxtNXVZaU1qRFI2RkVQeENOUkhJMGVPUkdGaElhNWR1K2J4OFFBOEF2WFpvMGVQWFBadVlVYmdFYWlQdkx5OGpCN0JwVEFnRW1GQUpNS0FTSVFCa1FnREloRUdSQ0lNaUVRWUVJa3dJQkpoUUNUQ2dFaUVBWkVJQXlJUkJrUWlIbnM5a0xlM054WXZYdHpuZGJ5YzQzY2VHMUJBUUlENHptTEVVeGdKTVNBU1lVQWt3b0JJaEFHUkNBTWlFUVpFSWd5SVJCZ1FpVEFnRW1GQUpNS0FTTVJqMzB3dExDeEVZMk9qcnJVTEZ5NUVXRmlZNG9uY2s4Y0d0SC8vZnR5N2QwL1gycWlvS0FiME41N0NTSVFCa1FnREloRUdSQ0lNaUVRWUVJa3dJQkpoUUNUQ2dFaUVBWkVJQXlJUkJrUWlESWhFR0JDSmVPemxIRmV1WE1HUEh6OTByUjA0Y0tEaWFkeVh4d2JFQ05UZ0tZeEVHQkNKTUNBU1lVQWt3b0JJaEFHUkNBTWlFUVpFSWd5SVJCZ1FpVEFnRW1GQUpNS0FTSVFCa1FnREloRUdSQ0lNaUVRWUVJa3dJQkpoUUNUQ2dFaUVBWkVJQXlJUkJrUWlESWhFR0JDSk1DQVNNUUhRdW5zaU9EZ1lWcXZWeWVPUUs2cXNyTVNIRHgrNmZhN0hnSWg2ZzZjd0VqRURzQnM5QkxrdHV4bEFuZEZUa051cXN3Qm9CNUJnOUNUa2xySXNBTW9CTkFJWUJ5REkySG5JVGRRQ3lBUnc0ciswS2gydVAzWjZhQUFBQUFCSlJVNUVya0pnZ2c9PSc7XG5leHBvcnQgY29uc3QgTElOS19PUFRJT05TID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSllBQUFDV0NBWUFBQUE4QVhIaUFBQUFCSE5DU1ZRSUNBZ0lmQWhraUFBQUFBbHdTRmx6QUFBRzdBQUFCdXdCSG5VNE5RQUFBQmwwUlZoMFUyOW1kSGRoY21VQWQzZDNMbWx1YTNOallYQmxMbTl5WjV2dVBCb0FBQmVVU1VSQlZIaWM3WjE1ZEZSVm5zYy9yNnFTeWk2UUJWb2dJUWtFUkZsTXREc3FRUVZFajRiamFMczBLRFNpd29CSFFKd01DTFFnT0tpY1p0aFVtb0c0UkJ0UmJCd1ZCN1ZwUkVBSkFtRUxJcEhGQkFJRWtyQVlRcEpLMVowL1hoSUNabm0zNmxXOVNuaWZjMzZIVUhYdmUzZjUxbjMzM2VWM0ZhNWVBb0RFR29zRFlvRk9RQ1RRcnNZaWE4TGFnWkNhdjh1QlNrQUFwZldzQkRnRzVBTUZ3S0VhYzNnL0svNkhZblFDZkVRb2NCT1FDdHdJWEE4a0FZRmV2bThWY0FENEVjZ0Jzb0Vkd0FVdjM5ZHdXcXV3UW9BMDRDNWdJSEFEWURNMFJaZW9CdllBNjRGL0FwdUFpNGFteUtSSjJnT2pnYTlRSzBxMEVMc0lyQVdlQnFKMUx4VVR0NGdBbmdLK1JXMEpqQmFKcDFZTmZBT01Bc0oxTENjVGpmUUgza1B0cXhndEJtL1pCU0FMOVpGdTRrWHN3QWhnRjhaWHVxOXRKK3BqdnZiTjFFUUh3b0FKd0hHTXIyQ2o3VFF3RTdqR2t3SzkyZ2tEWGtRZEh6SzZRdjNOaW9GcHFNTW9KaHF4b1RiN0p6QytBdjNkVHFPMjV2NHlsT0szREFaK3d2Z0thMm0ySHhqa1JubDdEWDhaSUwwV21BODg0dXNiQndRRWtKaVlTSmN1WFlpTmphVlRwMDVFUlVYUnJsMDcyclZyUjFCUUVDRWhsL2VaeTh2THFhaW9vTFMwbEpLU0VrcEtTamg2OUNnRkJRWDg4c3N2SEQ1OEdJZkRrSm1jbGNBazFOYmVVSXdXbG9JNkR2VlgxREVwcnhJYUdrcEtTZ3AvK01NZlNFbEo0WVliYmlBcEtZbUFnQUJkNytOd09EaHc0QUQ3OXUxaisvYnRiTjI2bFIwN2RsQmVYcTdyZlJyaEhQQThrT21MbS9ram5ZQXY4ZUlqd21hemliUzBOREY3OW15Um5aMHRIQTZITUFxSHd5RzJiTmtpWG5ycEpkR3ZYejloczltOC9YajhBdlZKY0ZYeElIQUdMeFNvM1c0WDZlbnA0dTIzM3hZbEpTV0dDYWs1aW91TFJXWm1wcmp2dnZ0RVlHQ2d0OFJWQXR6dmxScjBNK3pBSXJ4UWlDa3BLV0x4NHNXaXVMallhTTFJYy9yMGFiRnc0VUtSbkp6c0RYRzVVUHV2M2w3SllSaWRnQi9RdVhVYU1XS0UyTFp0bTlIYTBJMGZmdmhCUFA3NDQ4SnV0K3N0c0d4YTRhTXhGUjFIenNQRHc4V1VLVk5FVVZHUjBUcndHaWRPbkJBWkdSa2lMQ3hNVDNFVkFqZDdzWjU5eWpCMFdzWVNHaG9xcGsrZjd0ZDlKNzBwTGk0V1U2ZE9GU0VoSVhxSjZ5THdxRmRyM0FkTVJIM0dlMVFZTnB0TmpCa3pScHc0Y2NMb2VqYU13c0pDOGRSVFR3bXIxYXFIdUp6QWVDL1h2VmRRZ0RubzhBdTc3YmJieE83ZHU0MnVWNzloNTg2ZElqVTFWYS9XNjc4d2ZpeFRNd3F3RUE4ejNhWk5HN0Y4K1hMaGNybU1ya3UvdytsMGlxVkxsNHBycnJsR0QzSE5wd1dJU3hkUkRSNDhXQlFVRkJoZGYzN1A4ZVBIUlhwNnVoN2lXb0tmaTJzK0htUXdLQ2hJdlBIR0cyWXJKWUhMNVJLTEZpM1NZM2ppcno3UWgxdE13NE9NZGVuU1JXemR1dFhvZW1xeDdOaXhRM1R0MnRWVGNmMm5EM1FpeFZONDhQWjM3NzMzaW5QbnpobGROeTJlTTJmT2lIdnV1Y2NUWWJtQWtkNlhpellHb2U3MmRTc3pHUmtab3JxNjJ1ZzZhVFZVVjFlTFNaTW1lU0t1S3VCT0graW1TUkpRVnpGS1o4QnF0WW9sUzVZWVhRK3RsdGRmZjExWUxCWjN4VlVDZFBXSmdob2dBblhsb25UQzdYYTdXTFZxbGRGbDMrcjU4TU1QUGVuVTc4T2d2WTEvZHlPeElqQXdVSHoyMldkR2wvbFZ3OXExYTBWUVVKQzc0bHJwSXkzVk1jNmRoTnJ0ZGxOVUJ1Q2h1Sjcya2Fib2pSdVR5amFielJTVmdYenl5U2Z1empPV28zcm44U28yWUx0czRoUkZFWm1abVVhWDdWWFB1KysrS3hSRmNVZGNPYWoreERSamxSVFdUT0JQa25HWVBYczJFeVpNa0kxbW9qTjkrdlRCNVhMeDdiZmZ5a2I5SGVxUTBrYjlVd1Y5Y1dPOGF1alFvZVlValIvaGNybkVRdzg5NUU2clZZa1hIb2tLOEoxc1lsSlNVa1I1ZWJuUlpXbHlCUmN1WEJCOSt2UnhSMXpmb3ZOazlTalpSSVNIaDRzREJ3NFlYWVltamZEenp6K0xpSWdJZDhRMVhDOVJSUUNuWkJQdzBVY2ZHVjEySnMyd1lzVUtkNFIxRXRWaGk4ZThMSHZ6a1NOSEdsMW1KaHA1N0xISDNCSFh6T1pFMDl6ejhuZkF6MGk0eStuWXNTTjc5KzZsYmR1MldxT1lHTWpaczJmcDFhc1h4NDRkazRsV0JuUkRiYjBheE5MTUJhWWo2WU5wMmJKbHBxaGFFRzNhdE9IMTExK1hqUllHdk9EdVBkdWpqcnBxYmlJZmZQQkJvMXQyRXpjWk1tU0k3T1B3SXREQkhXRzlKbk9qa0pBUWtaK2ZiM1Q1bUxqSjRjT0hSWEJ3c0t5NDVqUW1uc1llaGRjQS95Nmp3a21USmhFYkd5c1R4Y1NQaUkrUGQyZDJaQnlOdUo5cXJQTStFWFZqaENhaW9xSTRkT2dRRVJGZWQzRmw0a1hPbmoxTDE2NWRLU2twa1luMkxQQ2JUbHBETFpZQ2pKRzU4dFNwVTAxUnRRTGF0R25ENU1tVFphTTErR1JycU1VYUNLelRldFdvcUNoKytlVVhRa05OQjc2dGdiS3lNdUxpNGlndExaV0pkZ2ZxZEU4ZERiVllUOGhjY2Z6NDhhYW9XaEZoWVdFOCsreXpzdEZHWHZuQmxTMVdLQkpEOXNIQndSdzllcFRJeU1qbUE1dTBHSXFMaStuY3VUTVZGUlZhbzV4SEhYcW9POFhzeWhicmZpVG1nWVlPSFdxS3FoVVNGUlhGd3c4L0xCTWxBa2l2LzhHVndwSnloejEyN0ZpWjRDWXRDRGZxOWpLZlcvVWZoY0dvUjJsb09naW9aOCtlN051M1QvYm1KaTJJNjYrL25oOS8vRkZyOERJZ0NuVkI0R1V0MWdBa1RwY2FNV0tFMXFBbUxaUS8vVWxxRlhvWWNIdnRmK29MNjE2dFYxQVVSZmFtSmkyUVljT0d5VWE1ci9hUCtzTFN2RjgvT1RtWnVMZzQyWnVhdERBU0V4UHAxYXVYVEpRN2F2K29GVlkwMEVOcjdQVDA5T1lEbWJRSWhCQk5Ic1V5Wk1nUW1jdjFBaUxoa3JEU2tGZ2tmKys5bXArYUpuNkt5K1ZpMWFwVlhIZmRkZlRwMHdjaFJJUGhKT3RhQWZyVi8yQXVFcHNrakR5VHhzUXpxcXFxeER2dnZDUGk0dUl1ODBaejZOQ2hSc09IaG9iS0xLVjVGUzYxV0RkcWxlUnR0OTJHeldhZXU5alNxS2lvNE0wMzN5UTJOcFlubjN5Uy9QeDhBTkxTMHRpNGNTTUpDUWtOeGdzSUNDQTFOVlhtVm4zZ2tyRDZhSTExNjYyM3l0ekV4R0F1WExqQWdnVUw2TlNwRStQSGo2ZW9xQWlBUVlNRzhmMzMzN054NDBiUzB0S2F2RVp6MzE5QjM5by9ya1ZpMWVEbm4zL3U0OGJieEIzT25Uc25Ybm5sRlJFZUhsN25yOEZpc1lpNzc3NWI3Tml4UStwYW4zNzZxZXpLMHZZMklFbEdqamZlcVBtcGFRZ2ZmdmdobVptWmpYWkcvWVdrcENRV0xWcUUxU3JyUHFOcFRwOCt6ZUxGaTVrM2J4NFZGUlVJSWJCYXJmenhqMzlrMXF4WkpDVkpWVGNBZmZ2MmJUN1E1WFFEZFptTUppVzJhOWZPSzc4dVBlbmJ0Njg3KytRTXNmMzc5K3VXNy96OGZQSE1NOC9Vblgyb0tJb0lDQWdRbzBhTkVrZVBIdlg0K3BLSEZZeXdvUG9SMVVSaVlxTFdvSWJoZERxTlRvSm1xcXVyUGI3R2tTTkhHRGR1SEYyN2RtWEpraVZVVjFkanQ5c1pOMjRjK2ZuNVpHWm0wcWxUSjQvdkkxbjNDVFpBOHc2SXh0NGNUSHhQYm00dXMyZlA1dU9QUDBZSWdhSW9oSWFHTW5IaVJKNTc3am5kOTNZbUppYVNrNU9qTlhpY0RYWFVYUk5kdW5SeEowMG1PckpyMXk1bXpKakJtalZyY0xsY0tJcENSRVFFRXlaTTRQbm5uL2ZhM2dQSnVvKzJBVEZhUThmRWFBNXFvak9iTjI5bTVzeVpiTml3QVpmTGhjVmlJU1ltaHFsVHB6Sm16QmlDZ29LOGV2L29hTTN0RDBDMGhacTVIUzFFUlVWSko4algrUHRiYXkzUjBkR2ErajdyMXEwakpTV0YvdjM3ODY5Ly9RdVh5OFcxMTE3TG0yKytTV0ZoSVJNbVRQQzZxR3JUSzBHVURZbWx5QzFoR2ZMYmI3L05yRm16L0w0VDM3NTkrMFkzb2JoY0xyNzQ0Z3RlZU9FRmZ2cnBKNXhPSjFhcmxZU0VCS1pQbjg1amp6Mm0rekJGYzBqV2ZaZ045V1I1VGZqaWwrRXBGb3VseFM3cGNUZ2NmUERCQjh5WU1ZUDgvUHk2TWFqazVHUm16cHhKZW5vNmltTE02VytTZFcrWEVwYmRyam1vWVJRVkZmSGRkOS81Zll2VnQyOWZ1blhyQmtCVlZSVXJWNjVrMnJScG5EaHhBcWZUaWFJb3BLU2tNR1BHRE5tbEsxNUJzdTd0b0o0UHJHbmdLenM3MitPQk5tK1RuSnhzK01DbkZnc0xDeE9uVHAwUzgrZlBGNUdSa2NKcXRRcEZVWVRWYWhXREJnM3l1N0xlc21XTFRQNmN0aHBoTmVjbkMyaCtRTy84K2ZPR3R4U0ZoWVdHM2w4clpXVmxKQ1FrY09IQ0JZUVFXQ3dXQmc4ZXpKdzVjMGhPVGpZNmViL0I0WERJQksrMm9lNnEwT1FjdnJLeXN0SHZ0bS9menMwMzN5eHo4NnVlc3JJeVFPMi9oSVdGc1d2WExrTVdVVnF0Vmxhc1dNSHR0OS9lYUppbTZyNmg0TFhDMHZSbTJOVEZMMTY4aU1WaU1id2ZWanZ4MmxKUUZJWEt5a3JaaXRNOURiWHJzeHJESFdHVm8zRXM2OHlaTTQxK2w1cWF5dXJWcTZtcXFwSkpnTzZNR1RPbXlYVDZFNHFpMUQwR3UzZnZUbHBhbWlGdU5xMVdLM2ZjY1VlVFlTVEw5QUtvNTZSbzZwUXRXTERBNEM1azh5UWtKQmplTWRkaWlxS0lGMTk4VVlTRmhRbWJ6VmJYY2IvLy92dDFYZldnRi9QbXpaUEozelliNmdtcG1qaDlXbk5RdzhqTXpPVExMNzgwT2hsMVZGUlVrSmVYeDNYWFhVZEF3S1d1Yk8vZXZSazJiQmdaR1Jrc1g3NmNXYk5tY2Y3OGVUNzc3RFBXckZuRGdBRURlUFhWVi8ybUl5L3BqSzBZSkE2MEhENTh1TkUvbkZaTFJVV0ZXTHAwcVlpT2p2N04wTU1QUC94Z2RQSmsvY0ZuV1FETkRyNFBIejRzbzFvVENleDJPNk5IaitiWXNXTzg5ZFpiZE96WUVWRG5DbE5UVTBsTFN5TTdPOXV3OUIwNmRFZ20rTkZhdDVCLzB4SzZRNGNPbkRoeHdwMTArWXl2di82YStmUG42N0tJenB2RXg4ZXplUEhpUnQraWE2ZDMvdktYdjFCWVdGZzNYOWluVHg5bXpwenA4OUg0OXUzYmMrclVLYTNCbndhNEM0bE81K25UcDQxdWxadmtycnZ1TXJ4anJ0VTJiZHJVYkg2Y1RxZjQ2S09QUkh4OHZMRFpiQUlRVnF0VkpDY24rK3pFMnFLaUl0bTgzV2tCRG1xVklhZ0x6ZndaZjIrcDZxTWxyUmFMaFljZmZwaURCdyt5ZXZWcXJyOWVQVEl3SnllSEJ4NTRnQjQ5ZXJCcTFTcXZqdDN0M3IxYk5zcEJDL0FMcXFzL1RmaTdzRm9yRm91RklVT0drSnVieTVkZmZrbnYzcjBCT0hEZ0FFT0hEaVVwS1ltc3JDeXZUS250M0xsVEp2Z1o0SmdGdGVuU0xNa3RXN1pJSnN0RWJ3WU5Hc1R1M2J2WnNHRkQzUWJpZ3djUE1tclVLTHAxNjBaV1ZwYXVMZmQzMzMwbkUzd1hxcVlBV0lURzUyZFVWSlJmSDhWNzU1MTNHdDUzMG1yZmZQT05Mbm5ldEdtVEdEQmd3R1hERk8zYnR4Y0xGaXdRRlJVVkhsM2I2WFNLeU1oSW1YeGRkdkRFNHpJRmtwdWJxMHVCZUlQeDQ4Y2JMaGd0RmhvYXF2dlpRems1T1dMSWtDR1hDU3c2T2xyTW56L2Y3U09VZCszYUpadTNZWERKZFZFY2FsOUxFM1BuemlVakkwTnJjSi9pY3Jrb0tDakE1WElablpRbWFkdTJyZGZtQmZmczJjUExMNy9NNnRXcjZ6WmVoSVdGTVdYS0ZNYVBIMDlJaUdhUG9NeVpNNGRwMDZiSjNENFdPRnIvZzN3MHFySi8vLzY2L3RKTXZFTnVicTU0NUpGSExtdkJ3c1BEeFlzdnZpak9uajJyNlJxMzNIS0xUR3ZWNEFoRGx0WUwyR3cydngvUE1ybkVvVU9IeEJOUFBGRTMyVzJ4V0VSd2NMREl5TWdRcGFXbGpjWTdlZktrc0ZxdE1zSmEzcEN3SHBXNGdGaXlaSWtQaThaRUR3NGZQaXllZU9JSkVSQVFJQ3dXaTdCWUxDSW9LRWk4OE1JTG9yS3k4amZoRnk1Y0tOdS9lcUFoWVYwRFZHbTlTTDkrL1F3b0doTTlLQ2dvRUdQSGpoV0JnWUhDWXJFSVJWRkVRVUhCYjhMOS92ZS9seEZWQlJCZUs2WXI5eEt0UjZQM1pFVlJ5TXZMbzJ2WHJscUNtL2doSjArZVpPN2N1Wnc2ZFlyMzMzLy9zdS8yNzk5UHo1NDlaUzczTlhCM1kxK09RNkxwZS83NTV3MzR2Wm40QWplR2JaNnVMNlFyVzZ4MndBa2dVSXRFMjdScFEyRmhvZFRycTRuL2MvSGlSVHAyN0NpekhMa0srQjFRZDhqaGxkdStTbEdiTkUyY1BYdVdyS3dzcmNGTldnaVptWm15YTl5L29KNm9vR0hmN2c4QnE3UmVNVDQrbnJ5OFBOT1RjaXZCNFhEUXJWdTNabmZ0WE1FRHdQL1cvNkNoamFxZkFzZTFYdkhJa1NPc1hMbFNKaEVtZnN6Nzc3OHZLNnBqd0JxdGdXY2kwWEdMajQvM2VMTFR4SGdxS3l2ZDJlVTB2U0VCTmJhMWZobHFoMHdUUjQ0Y1lkbXlaVnFEbS9ncGI3enhodXkraGtvZ3M2RXZtdktKa3dtTTBucUg2T2hvRGh3NFlNaUdTeFBQS1NrcG9YdjM3ckxidkpZQm94djZvaW52WFFkUXg3VTBPV1FxTHkrbnJLek1QTUNwaFRKeDRrUTJiOTRzRThXSnVrU210TG1BRGZFUkVzOWJxOVVxdG0vZmJuUlh3VVNTN096c3l3NXMwbWgvYjBvNHpiVkczWUZjUVBOWVF1L2V2ZG0yYlJ1QmdackdXRTBNcHJLeWtwdHV1b25jM0Z5WmFBN2dldURueGdJMDU4aXlCT2dNcEdpOVkxRlJFWXFpY09lZG1nOXNOVEdRNmRPbjg4a25uOGhHK3h2d2ZyT2htdUZhVk84aG1wdEptODBtdnYvK2U2TmJlSk5tMkxoeG8reDZLd0g4Q25Sb1RqUmFQUGtkQjE3UkxFUFUvWEtQUHZxbzdCdUdpUThwTFMxbCtQRGg3bXdYbXcyYzFDc2RkdFMzUkNsMXA2ZW5DNmZUYWZRUDArUUtuRTZudU9lZWUyUmJLZ0hzUTZQM1I2M093cDFBSGpCY1kzZ0E4dkx5cUs2dVp1REFnVExSVEx6TWxDbFRlUGZkZDJXakNkUlZ4bDd4RFBNV2tpcFhGRVdzV0xIQzZCK3BTUTFaV1ZudXRGUUNXT29OUWRWeURSSzdlV290TURCUWZQMzExMGFYNlZYUCt2WHJoZDF1ZDBkVVI2aTM3TmhiREFaY3NvbUxpSWdRT1RrNVJwZnRWY3YyN2R0RmVIaTRPNkp5QWdPOExhcGFYbk1qZ1NJbUpzYXZkMUczVnZiczJTT2lvNlBkZlFUTzhaR21BSFVrZnJNN0NZMk9qaFo3OXV3eHVxeXZHdmJ2M3k4NmRPamdycWcySWpIcm9oZWRnVlB1SkRnbUpzYWNVL1FCMjdadDg2U2xPZ2wwOUltU0d1QTIxUDFrMGdrUEN3c1RhOWV1TmJyc1d5M3IxcTBURVJFUjdvcXFDdWp2RXdVMXdWTzRsM2dSR0JnbzNucnJMYVByb05XeGJOa3lFUkFRNEs2b0JERFNGOExSZ2x1ZCtWcWJOR21TcUs2dU5ybytXandPaDBOTW1EREJFMEVKZk54WmJ3NEZlQWNQTWpSdzRFQng4dVJKbyt1bXhYTDgrSEU5bk00dFIrUENUbDlpQXo3SGc0eDE2TkJCckZ1M3p1ZzZhbkY4OWRWWElpWW14bE5SNWFCOWlzL25CQUtmNFVFR0ZVVVJvMGVQRm1WbFpVYlhsOTlUWGw0dUprK2U3TTdxejRiTUFmajF1bkk3OEg5NG1OSHUzYnVMelpzM0cxMTNmc3VtVFp0RVVsS1NIb0txYitYQXJkNFVoNmZZZ1Uvd01LT0tvb2dubjN6U2RQSldqMU9uVG9tUkkwY0tSVkgwRmxXdEZRTTl2Q2NOejdFQy80TU9tWTJNakJRTEZpeG8wRG5ZMVVKRlJZV1lOMitlYU51MnJiY0VWZDhPb3pyNThGc1VZQlp1VEZvM1pJbUppV0xGaWhWWDFlTEI2dXBxOGQ1Nzc0bjQrSGhmQ0txKzdRUWk5SmVFdmp5SzVMcjVwaXdoSVVFc1hicFVPQndPbyt2ZGE5U2VvZE9qUnc5ZkM2cStyVU9qU3lzanVSa29STWVNeDhYRmlkZGVlMDJVbEpRWXJRUGRLQzR1RnErODhvcm8zTG16a1lLcWJ4K2diVytFb2NTZyt0L1NOZk1oSVNIaXozLytzOWl3WVlOZm41clJHRTZuVTZ4ZnYxNk1HREZDQkFjSEd5MmtodXkvOVJLQU43RUEwMURIVFhRdmhQajRlREZseWhTeGJkczJ2eGFaeStVU1c3ZHVGWk1uVHhaeGNYRkdDMGVML1lmblZlOGJic0dOblQ4eUZoY1hKOGFPSFN2KzhZOS9pRE5uemhpdEpWRmFXaW8rL3Zoak1XYk1HSDk2MUdrMUYrclJPSm93ZWw0b0JIWFM4MW04L0J5M1dxMzA3dDJiVzI2NWhkVFVWRkpTVXVqV3JkdGxCNERyaWNQaElDOHZqeDA3ZHBDZG5jMldMVnZZdTNldlY0NTk4eUVPSUIwTjdrU05GbFl0dHdKdkFuMThlZFBBd0VDU2twTG8wYU1IY1hGeHhNYkcwcVZMRjlxMWExZG5kcnVkNE9CZ2dvS0NBTlh4YTBWRkJaV1ZsWlNXbGxKYVdrcEpTUW41K2ZsMTl0TlBQNUdYbDRmRDRmQmxkbnpGcjZndTIzY1luUkN0MklDSndEbU1iL1pOYTlwT0Fva05WNlAvRWdtOGlwc3JVNjh5MDJYZzJVMDdBSVExVW9kK1RUZlVNUlFueGxlZ3YxazFxbitxRzRHOUJxYmpwVVpycndXUWdMb0wxeXZERXkzTW5Lak84T3BQRW5jQ0NneEt6NkVHYTZ5RmtZQjZMT3haaks5Z1g5c1o0SzlBZkNObDB4UFZsNW12MCtYQ2p4Y0h5aElHUE1PbFE2MWJzKzBFeHFLdEw5TVBkVDJWTDlQM3E0WjB0VWo2QWd1QUlvd1hnVjUyRXJWbGRtZm81ZDlRKzErK1N1dGxwMUcwUml5b3Y5aUZxT2NSR3kwT1dTdEE3VWNPd2ZPZHgyTjhsR1lIY0pPSGFXMVJLRUF2WUJLd0ZpakRlT0ZjYVdXb3k3ZWZBMjd3UWhtODVPWDBPNEFSWGtoM2k4S0c2cHozR2VBOVZDL1FtaytTMWNHcWF1NzVYazBha3ZHTlA0UmxYc3BQTWRDc0p6MS9tZEx4TlFHb3JzWjdvcjVweFFHeE5kYXV4b0kxWHVzaXFoUDlVdFJIV243TnYwZFFYU3Ztb2Y3Q2ZZMFZkV2ppUVIydnVSZTFIOWVzVjcrclZWaGFDRUY5RzZ0OUl3dXQrZmRDemI5bE5WYnU0M1RKRUF6OEU5WEhocWVzQVI0RHp1dHdMWk5XUUNTd0gvY2ZmVTdnTDVpTmtFa0R1RHM2L3l2cUlaY21KbzF5QTJvL1VLdW9ma1k5MXNURXBGbHVSMzNaYUU1VVh3SG0rWUFtVXR4RjQvT3RMbUF1cldqK3o4UzN4QUtMVVZjblZBTW5nSS9SNSswUmdQOEgrNHNudmlWSnVyVUFBQUFBU1VWT1JLNUNZSUk9JztcbmV4cG9ydCBjb25zdCBGRUVEX1BJUEUgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFYb0FBQUY2Q0FZQUFBQVhvSk9RQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFPeEFBQURzUUJsU3NPR3dBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFDQUFTVVJCVkhpYzdkMTVmRlhWdmZmeHo4bEltRW5DSENCaFJvUXdpRXFRdGpLS1FxMFZVUjhFRkhIcVZieGFleDJlOW5KZnJXM3ZjOXZiWXExQ0JOdUsxRllRUkJtVnlSSW1oWUlKWUFFRndpUmptQUtaay8zOHNSTU1HQ0RKV1h2dk0zemZyOWQraFNIbnR6WjY5amZyckwzMldqNUVBbDhVa0ZEcFNDei8ydlN5UDI4RTFDdC9UWDBndXZ6WFRjcS94bFQ2K3d0QVVmbXZUNWQvTFFiT1YvcjdzMEJPK1hFU09GSHA5NVdQRWlQL1NoR0grTHcrQVpGeVRZRDJWemphWW9kOW9Eb043TDNDc1I4bzllN1VSQlQwNHE0b29CUFFBMGd0LzNvZGRwQkhYK1Yxd2F3SU9BaDhBV3dETXN1L2ZvaytDWWhMRlBUaWxIaWdEOUFUTzlCN1lvZDZIUzlQS29BVVlJZC9GbmJ3WndGYmdGTmVucFNFSmdXOW1OSUtHQURjVXY2MU54RGg2UmtGcDczQU9tQnQrZGN2QU12VE01S2dwNkNYMm9nQitnSnAyTUdlQmpUejlJeEMxekZnUFhid2J3QTJZOTgwRnFrMkJiMVVWd293RkJnQ0RNT2U0U0x1eThNTy9rWEFCMEMycDJjalFVRkJMMWRTQjd1M1BxVDg2T3Z0NmNnVjdBVldZQWYvY3V5eGY1RkxLT2lsc21iQTNjQW80SHRBbktkbkl6V1ZCM3dDZkFqTXg1NzNMeUpDSXZBb2RxK3dCUHZHbjQ3Z1AwcUFqNEZKMkErVGlVaVlhUXlNQnhaaXovUDJPcFIwT0IvNmE0R25zWjhtRnBFUUZRdmNpejJXVzRqMzRhUERtNk1RK3dmOFBkaXpwMFFrQkhRRy9odDdtcDdYSWFNanNJNVRRRHIyQTIwaUVtUmlzWHRzeTRFeXZBOFVIWUYvYk1hK1YxTVhFUWxvUFlCWHNSZlo4am80ZEFUbmNRcDRCYmdlRVFrb3QyQ1B1NnIzcnNQa3NSWjdxcTJtWVl0NEpBWjc1a3dXM2dlQ2p0QStNckdIZGJRZ25ZaExHbUpQa3p1STl3R2dJN3lPbzhCL1lhOU1La0ZFSDhtQ1J4dmdPV0FpOXU1SllhMWh3NFlrSmlaZVBCSVNFa2hJU0tCUm8wYkV4Y1ZkL0o3SXlFZ2lJaUpvMU1oZW1xZE9uVHBZbGtWaFlTRUFaOCtlcGF5c2pKS1NFbkp6Y3dISXo4L256Smt6NU9Ua1hEeE9uanpKeVpNbk9YZnVuRGYvNE1DU0M3d0ovQlk0N1BHNVNEVW82QU5mUytCRjdJL09zUjZmaXl2aTQrTkpUazYrNUVoSlNTRTVPZmxpcUVkSGU3TlBTWEZ4OGNYZ3o4N09adCsrZlpkOHpjN081dlRwMDljdUZCb0tzS2RuL2hwNytxNEVLQVY5NEdvS1BBLzhpQkJkY3lZbEpZVWVQWHJRbzBjUFVsTlQ2ZHk1TThuSnlSZDczOEhxN05tejdOdTNqOTI3ZDVPWm1jbTJiZHZZdG0wYjJkblpYcCthVS9LQTE0RC93ZDViVndLTWdqN3d4R01QMFR4RmlBelJ4TWJHMHFkUEgxSlRVMGxOVGIwWTdnMGJOdlQ2MUZ4MTl1elppNkdmbVpsSlptWW1XN1pzb2FpbzZOb3ZEZzY1MkZNemY4YzNHNjVMQUZEUUI0Nkd3RFBsUjFCM2FSTVRFMGxMUzJQQWdBR2twYVZ4d3cwM1VLZU9KbXhVcGFDZ2dFMmJOckYrL1hyV3JWdkgrdlhyeWNuSjhmcTAvSFVHK0gzNWtldnh1UWdLK2tBUUFUd0UvQkpvN3ZHNTFFcWJObTBZTW1RSUF3Y09wSC8vL25UdDJ0WHJVd3BhbG1XeGMrZE9ObXpZUUVaR0JpdFdyT0RRb1VOZW4xWnRIUUgrTC9BVzlqTWU0aEVGdmJkdUFxWUNOM3Q5SWpVUkZSWEZUVGZkeEtoUm94Z3laQWg5K3ZUQjU5TmJ5U2w3OSs1bDRjS0ZMRnEwaUl5TWpJc3pob0xJRnVEZmdReXZUeVJjNmVyMFJqTDJqYXQ3UEQ2UGFtdlhyaDBqUm96Z3R0dHVZL0Rnd2RTdkh4SzNENEpPYm00dUsxZXVaT25TcFN4YnRvd0RCdzU0ZlVyVlpRSHZZazh3Q0pxVEZxbU51dGdQbk9UaC9jTXYxenphdG0xclRaNDgyY3JJeUxES3lzb3NDVHpidDIrM3BreVpZblhzMk5IejkwczFqenpzMVZRYlZQK3lFUWtlWTdBZkx2SDZRcnRtdVAvNHh6KzJQdjMwVTRWN0VDa3JLN00yYk5oZ1BmUE1NMVpTVXBMbjc2TnFIQWVCSDlid0doSUpXRW5BQjNoL1lWM3hTRXhNdEo1KyttbHIvZnIxQ3ZjUVVGcGFhcTFkdTlaNjZxbW5ySVNFQk0vZlg5YzQ1Z090YW54VmlRUUlIL2FpWXpsNGZ6RlZlZlR0MjlkS1QwKzM4dkx5dk00bWNVaEJRWUUxWjg0Y2E4aVFJWmJQNS9QOFBYZUY0d3oyK2swUk5iL01STHpURVZpSjl4ZlF0NDRXTFZwWXp6Ly92UFhWVjE5NW5VSGlzaSsvL05LYU1tV0sxYVpORzgvZmgxYzRNZ0ROelpXQUZ3MzhGTWpIKzR2bTR1SHorYXpodzRkYjgrZlB0NHFLaXJ6T0cvRllVVkdSOWQ1NzcxbkRoZzBMeEY1K1B2YmFUdDRzWmlSeURUMncxKzMyK2tLNWVNVEd4bG9QUGZTUXRXM2JOcSt6UlFKVVZsYVc5ZUNERDFveE1UR2V2MTh2TzdZQzNXdDlOWW9ZNXNOZVdmSUMzbDhjRm1BMWJOalFtang1c25YdzRFR3ZjMFNDeE5HalI2MHBVNlpZOGZIeG5yOS9LeDM1MlBQdU5YWXZubW9HTE1MN0M4SUNySlNVRkd2cTFLblcrZlBudmM0TkNWSzV1YmxXZW5xNjFhVkxGOC9mejVXT2o5SE1IUEhJOTRIamVIOFJXSjA2ZGJKbXo1NXRsWlNVZUowVEVpSktTa3FzV2JObUJkS0RXTWVBTy95NllrVnFJQTU3S1ZiUE4rSnUyN2F0bFo2ZWJoVVhGM3VkQ3hLaVNrdExyVGx6NWxnZE9uVHdPdWdyamxsQVBiK3VZSkZyNkFuOEM0L2Y3RWxKU2RiMDZkT3R3c0pDcjNOQXdrUmhZYUgxMm11dldhMWJ0L1k2NkMxZ0IzQzluOWV5U0pYRzR2RU4xeFl0V2xpdnZQS0tWVkJRNFBWMUwyRXFQei9mK3YzdmYyODFiOTdjNjdBL0Q5em45MVV0VWk0S2V4RW16OTdVTVRFeDF1VEprNjJ6Wjg5NmZaMkxXSlpsV2VmUG43ZW1USmxpMWFsVHgrdkFUMGR6N3NWUFRmSDRDZGVSSTBkYWUvYnM4ZnE2RnFuU2dRTUhySEhqeG5rZDlobEFTNyt2ZGdsTEE0Q3Y4ZWpOMjYxYk4ydlpzbVZlWDhjaTFiSnExU29yTlRYVnk3QS9ES1FadU80bGpEd0tGT0xCR3pZaEljR2FPbldxcGtwSzBDa3RMYlhlZXVzdEw4ZnZpN0Vmc0JLNXFtamdUVHg0ay9wOFBtdml4SW5XcVZPbnZMNWVSZnlTazVOalBmamdnMTZ1by9NRzlyMDFLYWV0QkwvUkFIdXJzeEZ1Tjl5K2ZYdW1UNS9PMEtGRDNXNWF4REZyMXF6aGtVY2VZZmZ1M1Y0MHZ3SVlEWnoxb3ZGQUUrbjFDUVNJMXNCeVlLQ2JqVVpGUmZIa2swOHlkKzVjdW5YcjVtYlRJbzVyMTY0ZGt5Wk5vcVNraEkwYk4ySlpscHZOdHdkR0FvdFIyS3RIai8wUTFHTHNuYURjYTdSblQyYk9uRW0vZnYzY2JGYkVFNW1abVV5YU5Jbk5temU3M2ZRUllCVHdUN2NiRGlUaDNxTWZDU3dCRXQxcU1EbzZtbC84NGhmTW1qV0xObTNhdU5Xc2lLZGF0R2pCUXc4OVJHeHNMQmtaR1pTVmxiblZkQVBnZnVCejRDdTNHZzAwNGR5am53Uk13OFdiTmlrcEtjeWVQWnUwTk0wQ2svQzFlZk5teG80ZDYvYllmU24yZG9XdnVkbG9vQWpYSHYwdmdOL2k0anJYanp6eUNCOTg4QUVkT25Sd3EwbVJnTlNxVlNzZWV1Z2hqaDgvenRhdFc5MXFOZ0s0SGJ0eis0bGJqUWFLY092Uis3QUQvbG0zR216Y3VESFRwazNqdnZ1MExJZkk1ZDUvLzMwZWVlUVJjbkp5M0d6Mk5lQXA3S21ZWVNHY2d0NEgvQUY0MHEwR0J3OGV6RnR2dlVYcjFxM2RhbElrNkJ3N2RveUhIbnFJcFV1WHV0bnNHOEFUMk11Tmg3eHdHYnFKd2w3SGVwSWJqVVZHUnZLclgvMks5UFIwR2paczZFYVRJa0dyZnYzNjNILy8vVVJIUjdObXpScTNwbUgyeFo2QytTRmgwTE1QaHg1OURQQU9jTGNialNVa0pQRE9PKzh3Yk5nd041b1RDU21yVjYvbXZ2dnU0L2p4NDI0MXVSQzRCM3ZKazVBVjZrRWZDOHpCM3ZiUGNiMTc5MmJldkhta3BLUzQwWnhJU0RwNDhDQ2pSNC9tczg4K2M2dkpwZGdkd1h5M0duUmJLTyt1SG9mOVA5Q1ZrSjg0Y1NMcjE2OVh5SXY0cVUyYk5uenl5U2RNbUREQnJTWkhZUGZzNDl4cTBHMmhHdlF4d0Z6Z1ZxY2JpbzJOWmVyVXFiejU1cHZVcVZQSDZlWkV3a0pjWEJ4LytjdGZTRTlQSnlZbXhvMG1Cd01Mc0VjQlFrNG9EdDFFWVM5TzlrT25HMnJXckJrZmZQQUJOOTk4czlOTmlZU3Q5ZXZYODRNZi9JQVRKMDY0MGR4NzJGc1VscnJSbUZ0Q0xlZ2pzR2ZYakhXNm9ZNGRPN0preVJJNmRlcmtkRk1pWVcvdjNyM2NjY2NkN055NTA0M20zZ1llSklTbVhvYlMwSTBQKzBFSXgwTStMUzJORFJzMktPUkZYTksrZlh2V3IxL1BkNy83WFRlYUd3Zk1JSVE2d3FFMGovNS9zTmV5Y05ROTk5ekRnZ1VMTkQ5ZXhHVnhjWEhjZi8vOVpHZG5rNVdWNVhSenZZSEd3REtuRzNKRHFBVDlMNEFYblc3a3B6LzlLYSsvL2pyUjBkcDBYc1FMVVZGUjNIWFhYUlFYRjVPUmtlRjBjeFUzMy83aGRFTk9DNFdnL3hIdy81eHNJQ29xaXBrelovTHNzOC9pODRYTXB6bVJvT1R6K1JnOGVEQkpTVWtzV2JMRTZTZHB2NGU5cG4xUXIyY2Y3S2sxQXZzUlpzZVdHbzZKaWVHdmYvMHJvMGVQZHFvSkVhbWxEei84a0RGanhsQlk2T2lEcmFYQVhkaHo3WU5TTUFkOUgreVBWUFdkYWlBMk5wWjMzMzJYTysrODA2a21STVJQUzVjdTVlNjc3eVkvMzlFSFczT0I3MkJ2WUJKMGdqWG9Xd01iY1hEN3YzcjE2ckZnd1FLR0RCbmlWQk1pWXNpYU5Xc1lPWElrdWJtNVRqYnpOZmE0L1VFbkczRkNNQVo5UXlBRGU2OVhSelJ1M0pnbFM1YlF2MzkvcDVvUUVjTTJiZHJFaUJFam5GN2JmZ2N3Z0NEYmNEelk1dEZIWXorNTVsakl4OGZIOC9ISEh5dmtSWUpNdjM3OVdMNThPVTJiTm5XeW1lN1lUOTY3dGdXcENjRVc5Tk9Cb1U0VmI5cTBLV3ZXcktGZnYzNU9OU0VpRHVyZHV6ZXJWNjkyT3V5SEE2ODcyWUJwd1JUMFR3RVRuU3JlcUZFamxpNWRTdmZ1M1oxcVFrUmMwTDE3ZDVZdlgwNThmTHlUelR5Q3ZVTlZVQWlXTWZyKzJCdjZPcktNWGQyNmRWbTJiQmtEQnc1MG9yeUllR0RqeG8wTUd6Yk15UnUweGNBZ1lLMVREWmdTREVIZkhQdGhCVWMyWG8yTGkyUHg0c1hjZXF2akt4cUxpTXRXclZyRkhYZmNRVUZCZ1ZOTkhNWGVsdkJycHhvd0lkQ0hicUt4ZDRoeUpPU2pvNk9aTzNldVFsNGtSQTBhTklnUFB2aUEyRmpIbHBsdmdiMzNSVUN2aXhMb1N5Qk1CY1k0VVRneU1wTFpzMmR6MTExM09WRmVSQUpFaHc0ZHVPNjY2NWcvZno1bFpZNnNQTndHcUFkODdFUnhFd0k1Nk1maTRCbzJiNzc1Smc4ODhJQlQ1VVVrZ0hUcjFvMldMVnV5Y0tGanF4ajBCM1ppejdNUE9JRWE5RDJCRDNEbzQ5RFBmdll6bm4zMldTZEtpMGlBNnR1M0wwVkZSYXhkNjlpOTA5dXcxOTV5WlN1c21nakVtN0YxZ0UzQTlVNFV2L2ZlZS9uYjMvNm1WU2hGd3BCbFdZd2ZQNTdaczJjNzFjUVh3QTJBb3d2djFGUWc5dWhmQlc1M292REFnUU9aUDM4K1VWRkI5VkNiaUJqaTgva1lPWElrNjlhdEl6czcyNGttbW1JdjA3TFVpZUsxRldqZDJoSEFZaHc0cjY1ZHU3SnUzVHFuSDZJUWtTQnc2dFFwMHRMUzJMVnJseFBsTGVEN3dDSW5pdGRHSUFWOU15QUxlOTY4VVltSmlXellzSUdPSFR1YUxpMGlRV3Jmdm4zY2ZQUE5IRDkrM0lueUo3RHZOUjUxb25oTkJjbzhlaC93Rmc2RWZHeHNMQXNYTGxUSWk4Z2xVbEpTbUQ5L1BqRXhqanh3M3hTWVNZQjBwZ05salA1cDRFa25DaytiTmswYmg0aElsZHEyYlV0aVlpS0xGeTkyb254bjdKNzlKaWVLMTBRZ0JIM0ZzcC9HcDFLT0d6ZU9sMTkrMlhSWkVRa2gvZnIxNCtEQmcyemR1dFdKOG9Pd3AxdzZNajVVWFY1L3JJakcvbW1YYXJyd0RUZmNRRVpHQm5YcTFERmRXa1JDVEg1K1BnTUdESEFxN0xjQ053SWxUaFN2RHEvSDZKL0hnWkNQajQ5bnpwdzVDbmtScVphNHVEamVmLzk5RWhNVG5TamZHM2pPaWNMVjVXV1B2ak9RaWYyQWxERVJFUkVzV2JLRTRjT0hteXdySW1GZ3hZb1YzSGJiYlpTV2xwb3VYUWowd2w0bXdYVmVqZEZIQVBPQkRxWUwvK3BYditMQkJ4ODBYVlpFd2tENzl1MkppSWhnOWVyVnBrdEhZZCtQbkdXNmNIVjQxYU4vQWdlMjRobzZkQ2dmZmZTUmxqY1FrVm9yS3l0ajJMQmhyRnk1MG9ueWs0QTNuU2g4TlY0a1lpdnNGZDRhbXl5YW1KaElabVltclZxMU1sbFdSTUxRNGNPSFNVMU5KU2NueDNUcHM5ZzkrOE9tQzErTkZ6ZGpYOE53eUFPOC92cnJDbmtSTWFKMTY5Yk1tREhEaWRLTmdOODdVZmhxM0I2akh3UDh6SFRSeHg1N2pPZWZmOTUwV1JFSlk5MjZkWE5xZm4xMzdJa29ydDJZZFhQb3BqNndDM3ZveHBpT0hUdXlkZXRXNnRldmI3S3NpQWdYTGx5Z1Q1OCs3TjY5MjNUcFEwQlg0SUxwd2xWeGMram1SUXlIZkhSME5ILzk2MThWOGlMaWlIcjE2dkhPTys4UUhXMzh3ZjBrNE1lbWkxNkpXME0zeWNCc0RDOXo4UExMTDNQZmZmZVpMQ2tpY29tS2UzOE9UTG04RVh1NjVUblRoUy9uMXRETlhHQzB5WUtwcWFsczJyVEppWiswSWlLWEtDa3A0Y1liYjNSaXZQNnZnT09iVjdzUjlBT0FESk50UlVWRnNYSGpSdnIyN1d1cXBJaklWVzNhdEluKy9mdWJmbXJXQXI0RE9MYVJMVGcvZEJNQnpBTmFteXo2M0hQUE1YNzhlSk1sUlVTdXFuWHIxcHc1YzRhTkd6ZWFMT3ZEWGhwaEpuYm9POExwSHYwa3dPaGsxSlNVRkxadDIwYTlldlZNbGhVUnVhYTh2RHg2OU9qQjNyMTdUWmQrRUh2ekpVYzRPZXVtSVdCME1YaWZ6OGZNbVRNVjhpTGlpYnAxNnpKdDJqUW5TdjhLZXdxNkk1d00rbWN4dkRYZ3d3OC96S0JCZzB5V0ZCR3BrV0hEaGpGdTNEalRaVnRoNzdUbkNLZUdidUtCdmRpUCt4clJyRmt6ZHU3Y1NaTW1UVXlWRkJHcGxaTW5UOUsxYTFmVGErR2NCdG9EWjB3V0JlZHV4djRNR0dLeTROU3BVeGt3WUlESmtpSWl0VkszYmwzcTFhdkhraVZMVEphTkE0cUFUMHdXQldkNjlJbll2ZmtHcGdyMjZ0V0x6WnMzRXhrWkNGdmNpb2hBYVdrcHZYdjNadHUyYlNiTG5zZnUxWjh3V2RTSk1mb1hNUmp5WVBmbUZmSWlFa2dpSXlPWk9uV3E2Ykwxc2U5dkdtVzZSOThTK0Fxb2E2cmc2TkdqbVR0M3JxbHlJaUpHM1hubm5YejQ0WWNtUzE3QTNuM3ZtS21DcG9QK1ZlQkpVOFZpWTJQWnZuMDdIVHQyTkZWU1JNU29QWHYyMEwxN2R3b0xDMDJXL1IwR0Z6MHpPWFRUQ25qWVlEMSsvT01mSytSRkpLQjE2TkNCeVpNbm15NzdJd3l1S0dDeVIvOEtZT3hmMjZKRkMzYnYzazJEQmthSCswVkVqRHQzN2h5ZE9uWGkrUEhqSnNzYTY5V2I2dEUzQVNZYXFnWEFpeSsrcUpBWGthRFFzR0ZESjNhNWV3UkQyNjZhNnRHL0JQelNVQzFhdFdyRlYxOTlSVnhjbkttU0lpS09LaWdvb0dQSGpodytiSFRmNy84QWZ1TnZFUk05K2xnTTNvQUYrTS8vL0UrRnZJZ0VsVHAxNnZEQ0N5K1lMdnMwRU9OdkVSTTkrb25BbXdicUFOQ3VYVHQyNzk1TlRJemYvellSRVZjVkZSWFJwVXNYc3JPelRaWWREN3p0VHdFVFBYcWpDL0ZNbVRKRklTOGlRU2ttSm9ZWFgzelJkTm1mNEdlbjNOOGUvUWpBMkdJUG5UcDE0b3N2dmlBcUtzcFVTUkVSVnhVWEY5TzFhMWZUYTlZUEE1Ylg5c1grcmlzd0hYdGRCaU5lZmZWVlVsTlRUWlVURVhGZFpHUWtqUm8xNG9NUFBqQlp0aGt3dTdZdjlxZEgzd1BJOHVQMWwralFvUU83ZHUzU21qWWlFdlJLU2tybzJMRWorL2Z2TjFYU3dzN2NIYlY1c1Q5ajlJLzU4ZHB2ZWVhWlp4VHlJaElTb3FLaWVQcHBvN2N2ZmRqejZtdjk0dHFJQXc1alB5amx0L2o0ZVBidjMwLzkrbzd0cENVaTRxcmMzRnphdG0zTG1UUEc5aEU1aGIwc1FrRk5YMWpiSHYwOUdBcDVnQ2VlZUVJaEx5SWhwVUdEQmp6Mm1OR0JqM2pncnRxOHNMWTkrZ3pnbGxxKzloS3hzYkhzMjdlUGxpMWJtaWduSWhJd3Z2NzZhMUpTVWlncUtqSlZjalZRNDQyemE5T2o3d0lZMjlOdjdOaXhDbmtSQ1VtdFdyWGkvdnZ2TjFueWUwQ25tcjZvTmtIL0tBWlh2VFI4dzBKRUpLQTg5OXh6K0h6R0l0TkhMWmFEcjJuUXh3TGphdHJJbFF3Yk5veWVQWHVhS2ljaUVuQ3V2LzU2aGd3WllyTGtCQ0M2Smkrb2FkRC9BR2hhdzlkYzBlT1BQMjZxbEloSXdIcjAwVWRObG1zQmpLekpDMnI2ZVdJeGNIc05YMU9sNXMyYmMvRGdRYUtqYS9TRFNVUWs2QlFYRjlPMmJWdU9IajFxcXVRQ2FqQURweVk5K2lhQXNjOGZFeWRPVk1pTFNGaUlqbzVtM0Roam85NWdyelBXcUxyZlhKT2cveUVHMWtVRzhQbDhUSnhvZEVNcUVaR0FObW5TSkpNM1pXT0I3MWYzbTJzUzlHTnFmaTVWR3pSb2tEYjlGcEd3MHJselp3WU9IR2l5NUwzVi9jYnFCbjBpdFppa2Z5V1BQRkxySlJ0RVJJS1c0ZXdiaHYyMDdEVlY5M1BFWTloTEV2c3RJU0dCdzRjUEV4c2JhNktjaUVqUUtDZ29vSFhyMXB3NmRjcFV5WW5BbjYvMVRkWHQwZC9qMzdsODQ0RUhIbERJaTBoWXFsT25EdmZkZDUvSmt0VWF2cWxPMERjRnZ1dmZ1WHpEOEQ5U1JDU28zSHR2dFlmV3EyTXc5cVlrVjFXZG9ac25nTmY5UGgyZ2JkdTJaR2RubTd6emJNd1RUenpCb1VPSFhHM3pwei85S1RmZGRKT3JiWXA0NGROUFArWGxsMTkydGMya3BDU21UWnZtYXB2VlVWWldScHMyYmZqNjY2OU5sWHdVbUhHMWI2ak81cXlqekp3TGpCa3pKaUJESG1EVnFsWHMzcjNiMVRZZmZyakdTMWFJQktValI0NndhTkVpVjl2czNMbXpxKzFWVjBSRUJLTkhqK1lQZi9pRHFaSWp1VWJRWDJ2b3BnNEdoMjNHakRFMlExTkVKR2daenNMQjJQUHFyK2hhUWY4OW9LNkpNMGxKU2VHR0cyNHdVVXBFSktpbHBhWFJybDA3VStYcWNZMzlRYTRWOUxlWk9wTkFIcllSRVhHVHorZmo3cnZ2TmxueXFsbDlyVEY2bzBFZmJKbzNiMjVzS3VqUm8wZE43aklqRXZSaVltSm8wYUtGa1ZxRmhZVWNPM2JNU0MyM2pCa3podC85N25lbXl0MEcvT1JLZjNtMW9FL0IzazNLYiszYXRhTlBuejRtU3JtcVVhTkdOR2pRd0VpdG5Kd2NCYjFJSmRIUjBUUnRhbWJWODl6YzNLQUwraHR2dkpHa3BDUlRzLzJ1QjlvQUI2djZ5NnNOM1l3dzBUckFpQkhHU29tSWhBU2Z6OGZ3NGNOTmxyemlDTXpWZ3Q3WXNJMkNYa1RrMnd4blk0MkRQZ2E0MVVUTE1URXhEQnBrYkQwMEVaR1FNV1RJRUpQN2NnemhDbHNNWGlub2J3RHFtMmg1NE1DQjFLOXZwSlNJU0VocDFLZ1IvZnYzTjFXdUlkQ3Jxcis0VXRBUE1OWHliYmNaR3dFU0VRazVoak95eXV4MlBPZzFQaThpY21XR003TEs3SzVxZXFVUE1QSlpJaWtwaWU3ZHU1c29GWklPSFRyRXYvNzFMNjlQUThSeGJpOFlHRXhTVTFOcDFhcVZxVVhPcXR6Q3FxcWc3MGcxbHIyc2ptSERocGtvRTdLZWV1b3ByMDlCUkR6bTgva1lNbVFJczJiTk1sR3VPZEFlMkZ2NUQ2c2F1cm5xbWdrMWNjc3R4a3FKaUlRc3cxbjVyZUdicW9MZTJQajhnQUhHU29tSWhDekRXZWxlMENjbUp0S3BVeWNUcFVSRVFscTNidDJJajYvV1B0L1Y4YTJQQjVlUDBjZGphSDJidExRMHJWWlpTVVJFQkpHUmtWNmZoa2pBaUlpbzdwYlZvYy9uODlHL2YzOFdMMTVzb2x3M29BbHd1dUlQTGcvNkc2amU5b0xYcFBINVN3WHFiamNpRWhnR0RCaGdLdWdqZ0Q3QXlzcC9VRmtQRTYyQTNhTVhFWkhxTVR4T2YwbVdPeEwwc2JHeDlPM2IxMFFwRVpHdzBLOWZQMkppWWt5VmN6N29lL2Z1VFowNmRVeVVFaEVKQzNGeGNmVHFWZVZTTmJYUnMvSnZLZ2Q5RkhDZGlSWjY5KzV0b295SVNGZ3hHUFRkZ1l1elB5b0hmUmZBU0RlOFJ3OWpRLzBpSW1IRFlIYkdBUjBxZmxNNTZIdCsrM3RycDJkUFk2VkVSTUtHNGV5OFdLeHkwQnY1VWVMeitkU2pGeEdwaFo0OWU1cDgvdWhpRUJzUCt1VGtaQm8yYkdpaWxJaElXR25jdURGSlNVbW15bFhabys5bW9ySjY4eUlpdFdjd1F5OW1la1hRUndKdFRWUk9UVTAxVVVaRUpDd1pIS2R2UjNuR1Z3UjlhNjZ3cVd4TnFVY3ZJbEo3QmpPMER0QUN2Z242RkZPVnRhYUxpRWp0ZGVsaVpGM0pDc253VGRBbkc2dWFiS3lVaUVqWU1aeWhLV0M0Ung4ZkgwK2pSbzFNbEJJUkNVc0pDUWttWnk1ZUV2VHRURlJVYjE1RXhIOEdzelFaRFBmb1UxS01EZldMaUlRdGcwRi9TWS9lU0ZYMTZFVkUvR2V3MDV3TWR0QkhZVSt2OUwraWdsNUV4RzhHZzc0dEVCa0JKUEx0TFFWclJVTTNJaUwrTTlocGpnTGlJN0EzQkRlaWJWc2pEOWVLaUlRMXc2TWpDUkZBVTFQVm1qVnJacXFVaUVqWWF0clVXQ3dESkVZQUNTWXErWHcrNHVPTmZUZ1FFUWxiaVltSkpzc2xWSXpSKzYxUm8wWkVSeHRaTGtkRUpLekZ4TVRRb0VFRFUrWE05ZWdURW95VUVSRVJqR1pxZ3JHZ04veFJRMFFrckJuTVZITkROK3JSaTRpWVl6QlR6UTNkcUVjdkltS082UjY5a2VVbU5lTkdSTVFjZ3ozNnhoRkFySWxLV3A1WVJNUWNnNWthYXl6b1kyT05sQkVSRWV3cGxxWktSUUJHcWhrOEtSR1JzR2V3ODZ3ZXZZaElJRElkOU9yUmk0Z0VHQTNkaUlpRU9BM2RpSWlFT1BYb1JVUkNuTWJvUlVSQ25PbWdGeEdSRUJZQkZKa29WRlJrcEl5SWlBQ0ZoWVhHU2lub1JVUUNrT21nTjFMTjRFbUppSVE5ZzUzbkl2WG9SVVFDa0ladVJFUkNuTUdnTDlMUWpZaElBRExZZVZhUFhrUWtFT2xtckloSWlETjlNOVpJUXA4OWU5WkVHUkVSd1dpbUZrWUFaMHhVeXNuSk1WRkdSRVNBRXlkT21DcDFPZ0k0YWFMU3laTkd5b2lJQ0VZN3p5Y2pBQ1BWRlBRaUl1WVl6TlFjWTBHdm9Sc1JFWE1NWm1xT2htNUVSQUpRUVBib3o1MDdwN24wSWlJR0ZCUVVjT0hDQlZQbFRocnIwUU9jT25YS1ZDa1JrYkJsZUNqY1hJOGU0UGp4NDZaS2lZaUVMWU5USzhGMDBCODRjTUJVS1JHUnNMVi8vMzZUNVM1T3J5d3hVVzNmdm4wbXlvaUloTFhzN0d4VHBZb3BmMkNxQkRoc29xTGhuMElpSW1ISllLZjVJRkJhc1RsNHRvbUs2dEdMaVBqUFlKYnVBM3R6OEl1LzhaZkJqeHNpSW1ITFlKWm13emRCYjZTcWdsNUV4SDhHcy9TU0hyMlJxcWRPbmRKeXhTSWlmc2pKeWVIY3VYT215cGtmdWdIMTZrVkUvR0g0WG1jMkdPN1JBK3pjdWROVUtSR1JzTE5yMXk2VDVTN3AwUi9HME42eDI3WnRNMUZHUkNRc0djelFBdUFvZkJQMHBZQ1J4MXF6c3JKTWxCRVJDVXNHZ3o0YnNPQ2JvQWY0d2tSbDllaEZSR292TXpQVFZLa2RGYitvSFBSR3V1TDc5Ky9uekJrajI5Q0tpSVNWVTZkT2NmaXdrWVVLQUM3MnVpT3Era04vV0piRjl1M2JUWlFTRVFrcmhrZEVuQXQ2MERpOWlFaHRHTTdPaThVcUIvMXVJTjlFZFkzVGk0alVuTUhzdkFEc3JmaE41YUF2eGRBTjJjOC8vOXhFR1JHUnNHTDRSbXhaeFc4aUx2dExJNThidG16WlFuNitrUThISWlKaElUOC8zMlFuK1pJc3Z6em9qWHh1S0NvcTRwLy8vS2VKVWlJaVllSFRUeitscU1qSWM2dHdXWlk3RXZRQTY5YXRNMVZLUkNUa0djN01TM3IwVVpmOTVSYnNKNmw4L3JhaW9ML1U3dDI3eWN2TDgvbzBSQUpHM2JwMTZkeTVzOWVuRVREV3IxOXZxbFFaY01rWTBPVkJmd3I0RjNDZHZ5MnRYNzhleTdMdytmeittUkVTeXNyS0tDMHQ5Zm8wUkFKR1dWblp0YjhwVEZpV3hjYU5HMDJWMnc1Yzh0VHE1VU0zQUVhNjRqazVPYVpYWVJNUkNVazdkdXpnMUtsVHBzcDlLOE1kQzNyUThJMklTSFVZemtvRnZZaElvREdjbGQ4YTdMOThqQjdnSyt3MWpGdjQyOXJ5NWNzMVRuOFZyNzc2S29NSEQvYjZORVFjdDNMbFNwNTY2aW12VHlNZ1daYkZpaFVyVEpYN21pcDJES3dxNkFFMkFIZjUyK0toUTRmWXZuMDdQWHIwOExkVVNFcEtTcUpidDI1ZW40YUk0M1MvN3NvKy8veHpqaHc1WXFyYzJxcitzS3FoR3pBNGZMTnMyVEpUcFVSRVFzN1NwVXRObHFzeXV4MFBlc1AvQ0JHUmtPSmwwRzhCemh0cGRkMDZjbk56VFpRU0VRa3BaODZjTVRsLy9peFE1YXBvVndyNkltQ1ZpWmFMaW9wWWJkSjVJQUFBR0NoSlJFRlV1WEtsaVZJaUlpRmwrZkxsbEpTVW1DcTNBcWl5MkpXQ0hzRFk0THJHNlVWRXZzMXdObDZ4Mk5XQzN0akEwZEtsUzdFc3kxUTVFWkdnWjFrV0gzMzBrY21TVnd6NkswMnZCTWdHZGdKZC9XMzl3SUVEYk42OG1YNzkrdmxieWxWbno1NmxvS0RBU0szaTRtSWpkVVJDUlhGeE1TZE9uREJTcTdDdzBFZ2ROMjNZc01IMFJ1Q0hydlNYVnd0NnNIOUMrQjMwQUhQbnpnMjZvRDkyN0pqWHB5QVNzb3FLaWpodzRJRFhwK0daT1hQbW1DeDMxUkdZcXczZFhQUEZOZkgzdi85ZHd6Y2lJdGdyZDc3MzNuc21TMTUxc1A5YVFiOEdNTEtJK3NHREIvbjAwMDlObEJJUkNXcHIxNjQxT1d4emdTcld0Nm5zV2tGZkFIeGk2bXdNZjFRUkVRbEtock53QlhEVm14VFhHcU1IV0FqY2J1SnM1czZkeTI5Lysxc2lJcTcxODhWOWd3WU5jbjIzbTVZdFc3cmFub2hYV3Jac3ljaVJJMTF0TXlrcHlkWDJxcXUwdEpSNTgrYVpMTG5vV3Q5UW5XVWxFNEVqVk8rSHdqV3RYYnVXQVFNR21DZ2xJaEowVnE5ZXphQkJnMHlWS3daYUFqbFgrNmJxZEsxUEFxdE5uQkhBdSsrK2E2cVVpRWpRTVp5Qks3aEd5RVAxTndHZkJNenc2M1RLSlNRa2NPalFJZXJVcVdPaW5JaEkwTWpQejZkMTY5YWNQbjNhVk1rSGdiZXU5VTNWSFN5Zmg3MytqZDl5Y25KWXNHQ0JpVklpSWtGbDd0eTVKa08rQ1Bpd090OVkzYUEvRFJoYm1XekdEQ01mRGtSRWdvcmg3RnVHbmMzWFZKUHBMOGJtQTYxZXZab3Z2L3pTVkRrUmtZQzNhOWN1MDN2RFZqdVRheEwwQzdqR1hNM3FzaXlMUC8zcFR5WktpWWdFaFJrelpwaGNIYUFBZStwN3RkUjAxKzZGZ0pISnNNMmJOK2Znd1lORVIwZWJLQ2NpRXJDS2lvcG8wNllOeDQ4Zk4xVnlQbkIzZGIrNXBrOHV6YXJoOTEvUnNXUEhXTFRvbXZQOFJVU0Mzb0lGQzB5R1BNRGJOZm5tbWdiOUI0Q3hzNTArZmJxcFVpSWlBZXVOTjk0d1dlNG9zTGdtTDZocDBCZGhzRmYvOGNjZms1bFo1UmFISWlJaElTc3JpMVdyak96TVd1SFAyRS9FVmx0dEZwMlpBUmk3b3pCMTZsUlRwVVJFQXM1dmZ2TWJremRoTGFER00xbHFlak8yd2orQTc5VHl0WmVJam81bTc5NjlBYnNBa1loSWJSMCtmSmoyN2R0VFZHVGtlVk9BVmNEZ21yNm90c3RJR3B2MVgxeGN6R3V2dldhcW5JaEl3Smc2ZGFySmtJZGFabTl0ZS9SMWdNTkFmQzFmZjRrbVRacHc0TUFCNnRldmI2S2NpSWpuY25OemFkT21EV2ZQbmpWVk1nZEl3cDVEWHlPMTdkRVhBTE5yK2Rwdk9YMzZORysrK2FhcGNpSWlua3RQVHpjWjhtQlBoS2x4eUVQdGUvUUEzYkYzSHZlbnhrWEp5Y2w4K2VXWFJFVVpXZlplUk1RenhjWEZkT3pZMGVUbTV4WndQZkJGYlY3c3oxWlBPNERsZnJ6K0V0bloyYnp6emp1bXlvbUllT2J0dDk4MkdmSmdMMkJXcTVBSC8zdmp3NENQL0t4eFVYSnlNcnQyN1NJbUpzWlVTUkVSVnhVWEY5TzFhMWYyN3QxcnN1d1EvRmhCMk4vTld6OEdQdmV6eGtYWjJkbk1tbVhzZVN3UkVkZTkrZWFicGtNK0MzdGFaYTJaR0YrZkFQekZRQjBBMnJadHkrN2R1NG1OalRWVlVrVEVGWVdGaFhUcTFJbURCdythTERzVzhHdGMyOThlUGVVbllPeGZkZURBQWMzQUVaR2dsSjZlYmpya0R3RnovUzFpWk1ZTThEenczNFpxMGJKbFMvYnMyVU5jWEp5cGtpSWlqaW9vS0tCang0NGNQbnpZWk5rZkE3L3p0NGlKSGozQU5PQ2NvVm9jT1hLRTlQUjBVK1ZFUkJ6M3h6LyswWFRJbndPTURHK1k2dEVEVEFXZU5sV3NXYk5tZlBubGx6UnMyTkJVU1JFUlI1dzllNVpPblRweDRzUUprMlYvQS95SGlVS1JKb3FVeXdKK0JCalpNdXJDaFF1VWxaVXhkT2hRRStWRVJCenowa3N2c1hKbHJXYy9WaVVmK0Q5QXJvbGlKbnYwQUs4QWswMFZpNG1KWWZ2MjdYVHExTWxVU1JFUm83NzY2aXV1di81NkNndU5iS2xkd1ZodkhzeU4wVmY0TlpCbnFsaFJVUkgvOFIvRy9xMGlJc1k5L2ZUVHBrUCtQUEJia3dWTkIvMVI0SFdUQlJjc1dNREhIMzlzc3FTSWlCRXJWcXhneVpJbHBzdStnc0V0VzhIODBBMUFJckFYYUdDcTRIWFhYVWRtWnFZV1BCT1JnRkZTVWtLdlhyM1lzV09IeWJKbmdmYkFLWk5GVGZmb0FVNENyNW9zK01VWFh6Qmpockc5VGtSRS9QYkhQLzdSZE1nRC9CN0RJUS9POU9nQm1tRDM2aHViS3BpWW1Nak9uVHRKU0Vnd1ZWSkVwRmFPSHo5TzE2NWRPWDM2dE1teXA3Qjc4MFlYc1FkbmV2UUFwN0YvTWhsejh1UkpubnZ1T1pNbFJVUnE1WmxubmpFZDhtRGZnRFVlOHVCY2p4N3NNZnJkUUF0VEJYMCtIeDk5OUpIbTFvdUlaNVlzV2NJZGQ5eGh1dXhob0F0d3dYUmhjRGJvQVI0Qy9tU3lZSEp5TXR1MmJkUCtzaUxpdWdzWEx0Q2pSdy8yN2R0bnV2UTRERzdQZWptVFQ4WldKUXU0SFdodHF1Q1pNMmNvTGk1bTJMQmhwa3FLaUZUTFQzN3lFejc2eU5oZVN4VTJBdjl1dW1obFR2Zm9BZm9ENjB5MkZSa1p5Y2FORzduaGhodE1sUlFSdWFyUFB2dU10TFEwU2t0TFRaYTFzRFB5VTVORkwrZlV6ZGpLTmdCelRCWXNMUzNsNFljZnByaTQyR1JaRVpFcWxaU1U4TmhqajVrT2VZQzNjVGprd2ZtaG13cWZBWTlqYU1FemdHUEhqaEVURThOM3Z2TWRVeVZGUktyMGkxLzhnci8vL2UrbXkxNEE3c0xRd21WWDQ4YlFUWVdmQXo4eldUQXFLb3ExYTlkeTAwMDNtU3dySW5MUjVzMmJTVXRMYzJJRTRhZkFMMDBYcllxYlFSOEg3QVRhbWl6YW9VTUh0bTdkU29NR3hsWmNFQkVCNFB6NTgvVHQyNWZkdTNlYkxuMFE2SXJCUlNDdnhxMmhHNEFTN1AwUHg1Z3NldnIwYVU2Y09NSDN2Lzk5azJWRlJIajAwVWRadFdxVkU2VW5BTnVkS0Z3Vk4zdjBGZVpqajBzWjllNjc3ekptak5HZklTSVN4dWJObThmbzBhT2RLUDB1Y0o4VGhhL0VpNkJ2Q2V6QVhnL0htQ1pObXZENTU1L1R0cTNSa1NFUkNVT0hEaDBpTlRXVlU2ZU1yeTkyRnJnTytOcDA0YXR4WTNybDVZNEFMNW91ZXZyMGFjYVBIMDlaV1pucDBpSVNSc3JLeXBnd1lZSVRJUS93REM2SFBMZzdSbC9aRnVCN1FMTEpvdnYzNzllVVN4SHh5ODkvL25QKy9PYy9PMUY2RmZDc0U0V3Z4WXVobXdxZGdFenMyVGpHUkVSRXNHalJJa2FNR0dHeXJJaUVnZVhMbHpOaXhBZ25Ib3pLQjNvQ1g1a3VYQjFlRE4xVStCSjQyWFRSc3JJeXhvNGR5OTY5ZTAyWEZwRVFscDJkemYzMzMrOUV5QVA4Rng2RlBIamJvd2Y3U2RuUGdGNm1DL2ZwMDRlMWE5Y1NGMmYwQTRPSWhLQzh2RHpTMHRMSXpNeDBvdndXNENic0tlYWU4TEpIRDFBTWpNWCtXR1BVbGkxYmVQVFJSMDJYRlpFUTlHLy85bTlPaFh3QjhDQWVoang0ZHpPMnNoUEFPY0Q0b0hwV1ZoWXRXclRRS3BjaWNrV3Z2dm9xdi83MXI1MHFQeGxZN0ZUeDZ2SjY2S2FDRDFpRXZYYTlVVEV4TWF4ZXZacTB0RFRUcFVVa3lLMWR1NVpCZ3dZNXRSTHVRdUJPN0tXSVBSVW9RUS9RRkh1akVtTmJEMVpJVEV4ay9mcjFkT3JVeVhScEVRbFNlL2Z1cFgvLy9ody9mdHlKOHNleFo5a2NjNko0VFhrOVJsL1pDZXl0QjQzLzlEdDU4aVFqUm96Z3hJa1Rwa3VMU0JES3ljbGh4SWdSVG9XOEJVd2tRRUllQWl2b0FaWUJyenRSZU0rZVBkeDk5OTBVRmhZNlVWNUVna1JCUVFGMzNubW5FeXRTVnZnREFUQXVYMW1nQlQzQWM4QTJKd3BuWkdRd2Z2eDRMTXZ6SVRNUjhZQmxXVXlhTklsMTY5WTUxY1FPSEZqaXhWK0JNT3ZtY2lWQUJ2WXluakdtaSsvWXNZUGk0bUlHRHg1c3VyU0lCTGdYWG5pQjZkT25PMVUrRnhpR3ZaNVhRQW5Fb0FmN1JzWmV3SkUxUWpNeU1raEtTcUpQbno1T2xCZVJBRFI5K25SZWV1a2xwOHBid0FQQUdxY2E4RWVnQmozWWkvSTN3dDRoM2JnbFM1YlF1WE5ucnIvK2VpZktpMGdBbVQ5L1BoTW5UblJ5ZGR2ZkFxODRWZHhmZ1RTOXNpcFJ3QXJndTA0VWo0Nk9adjc4K1l3Y09kS0o4aUlTQUQ3NjZDUHV2UE5PSnlkaXJNWWVzdkgwNmRlckNmU2dCMmdPYkFhU25DZ2VFeFBEaHg5K3lQRGh3NTBvTHlJZVdybHlKU05IanFTZ29NQ3BKZzRDTjJBUE53ZXNZQWg2c0JjRStnY1E2MFR4dW5YcnNtelpNZ1lPSE9oRWVSSHh3TWFOR3hrNmRDam56NTkzcW9saTRGYkFzU2s4cGdUaTlNcXFmSXE5TTRzajh2THlHRFZxRlAvODV6K2Rha0pFWEpTWm1jbnR0OS91Wk1nRFBFa1FoRHdFVDQrK3dodkFJMDRWYjlxMEthdFhyNlo3OSs1T05TRWlEdHUrZlR1MzNub3JKMCtlZExLWjZjQVRUalpnVXJBRmZTU3dBSERzN21tVEprMVl0bXdaTjk1NG8xTk5pSWhEdG16Wnd2RGh3NTBPK1dYQUtBTDQ1dXZsZ2kzb0FScGdQMUNWNmxRRGpSbzFZc21TSlZyeFVpU0lmUGJaWjR3WU1jS3BUYjByYkFkdUFjNDYyWWhwd1RKR1gxa3U5bkxHQjUxcTRPelpzd3diTm96bHk1YzcxWVNJR1BUSko1OHdaTWdRcDBQK2ErenNDYXFRaCtBTWVuRGhQL2lGQ3hjWU5Xb1VDeFlzY0tvSkVURmc4ZUxGakJneGd0emNYQ2ViY2J5RDZhUmdEWHF3UDBMZGg0UGpaSVdGaFl3Wk00YTVjK2M2MVlTSStPSGRkOS9scnJ2dWNuS2VQTmdaY3cvZ3lGNkRiZ2prSlJDcTR5dnNkZXdkdXpsYlZsYkcvUG56YWRteUpYMzc5bldxR1JHcG9mVDBkQjUrK0dGS1NoeS9KL29ZRU5TOXZXQVBlckNmbXZVQjMzT3FBY3V5V0xod0lVVkZSUXdhTkFpZkx4anZZWXVFQnN1eWVPR0ZGM2p4eFJmZFdITDhQNEdwVGpmaXRGQUllb0JQZ0xyQUFDY2JXYnQyTGR1M2IyZlVxRkZFUjBjNzJaU0lWS0d3c0pBSkV5WTR1ZFJ3WlZNQng1YTdkRk1vZFUxOXdHdTQ4QkREelRmZnpJY2Zma2pUcGsyZGJrcEV5cDA2ZFlxNzdycUxOV3RjV1FuNGRlRGYzR2pJRGFFVTlHRC9lMllBRHp2ZFVJY09IVmk4ZURGZHVuUnh1aW1Sc0xkbnp4N3V1T01PZHUzYTVVWnpid01QQW82dGFleTJZSjUxVXhVTGVCeVk1M1JEZS9ic1llREFnVTV1U1NZaTJFT21OOTk4czFzaC94N3dFQ0VVOGhBNlkvU1ZsUUh2QTcyQnprNDJsSmVYeDZ4WnM0aU5qZVdXVzI1eHNpbVJzUFRHRzI5dzMzMzNPVDFIdnNMSDJOTW9pOTFvekUyaE5uUlRXUnl3RUhCbGM5Z0pFeVl3YmRvMDR1TGkzR2hPSktUbDVlWHgrT09QOC9iYmI3dlY1RXJzOVd2eTNXclFUYUVjOUdDdlgvOTM0QWR1Tk5hclZ5L216WnRIKy9idDNXaE9KQ1FkT0hDQXUrKyttODJiTjd2VjVCTHMvYWxETXVRaDlNYm9MMWNJM0lzOTd1YTR6ei8vbkg3OStyRnMyVEkzbWhNSk9VdVhMcVZYcjE1dWh2d0h3QThKNFpDSDBCeWp2MXdwTUI5SXhzRVZMeXZrNStmenQ3LzlqY2pJU0c2NTVSWTlYQ1ZTRFdWbFpmejg1ei9uc2NjZUl6L2Z0Y3g5Q3hoTENJN0pYeTZjVXNpSC9RREVaTGNhdlBYV1c1azFheFpKU1k1c2R5c1NFZzRlUE1qNDhlUDU1Sk5QM0d4Mk92WTgrWkNhWFhNbDRkQ2pyK3dqb0I3Z3lrTHoyZG5aL09sUGY2SmR1M2IwNk5IRGpTWkZnc3E4ZWZPNDQ0NDcrTmUvL3VWbXMvOEQvRHYyZE95d0VHNUJEMUN4eVB6MzNHaXNzTENRZWZQbWNlalFJUVlOR2tSTVRJd2J6WW9FdE56Y1hCNS8vSEZlZXVrbE40ZHF3RjY3NW1kdU5oZ0l3bW5vNW5JVHNUKyt1YlpvVFhKeU1yTm56MmJBQUVlWDVCRUphSnMyYldMczJMRjgrZVdYYmpaYmdqMXNPODNOUmdORk9QYm9LMnpGWHZueSs5alRNQjEzNXN3WjNuNzdiWHcrSC8zNzl5Y3lNcHovODB1NEtTNHU1cGUvL0NVVEpreHdlay9YeTUzRG5tTDlycHVOQnBKdzd0Rlg2QUVzQXRxNjJtaVBIc3lZTVlPYmJyckp6V1pGUExGMTYxWW1UWnJFbGkxYjNHNzZhK3o5S3JhNjNYQWdDZlY1OU5XeERlZ1B1UG9PM0xadEcybHBhVHoyMkdPY1AzL2V6YVpGWEpPWGw4Y0xMN3hBdjM3OXZBajViY0ROaEhuSXk2WHFZL2ZzTGJlUDVPUmthOW15WlpaSUtGbXlaSW5WcmwwNzE2K244dU1qb0tHUlpKQ1FFd1c4Z1RkdlRHdmN1SEhXaVJNbnZMNCtSZnh5L1BoeGErellzVjRGdklWOXd6WEtRQjZFRE4wTnZGUVo5a0pvUjREaHVQemZKeXNyaTVrelp3Snc0NDAzNm1hdEJKV1NraEptenB6SjZOR2oyYmh4b3hlblVBZzhoejE5TWl3ZWhCTC85UVd5OGFoWDBxVkxGMnZ4NHNWZWQ4NUVxbVhGaWhWV2p4NDl2T3pGSDhJZWp4ZXBzVVJnQmQ2OWVhMGhRNFpZTzNiczhQbzZGcW5TN3QyN3JYdnV1Y2ZMZ0xlQWZ3QXQvTDdhSmF4RkFmK04vVkhRa3pkeWRIUzBOWG55Wk92TW1UTmVYOWNpbG1WWlZtNXVyalZseWhRck5qYlc2NUJQeDhXSEhpWDAzUXZrNHVHYnVtblRwdGIvL3UvL1dubDVlVjVmNXhLbUxseTRZUDNtTjcreEVoTVR2UTc0YzlocnlJc1kxeDNZanJkdmNLdGx5NWJXcTYrK2FoVVVGSGg5M1V1WXlNL1B0NlpPbldxMWFOSEM2NEMzZ0N5Z201L1hzc2hWMWNFZXlpbkY0emQ4bXpadHJLbFRweXJ3eFRGRlJVVldlbnE2bFpTVTVIVzRXOWpEcCtsQVhiK3VZSkVhdUIwNGl2ZHZmcXQ5Ky9iV1gvN3lGNnU0dU5qclhKQVFVVlJVWk0yY09kUExCNTR1UDQ0QXQvbDF4WXJVVWxQZ1E3eS9DQ3l3aDNTbVRKbGluVDU5MnV1Y2tDQjE3dHc1YStyVXFWYmJ0bTA5Zno5WE9wWUJMZjI0VGtXTUdBK2N4L3NMd2dLc0JnMGFXSk1uVDdZT0hEamdkVzVJa0RoeTVJZzFaY29VcTBtVEpwNi9meXNkK2NEVGFQRkZDU0RYWVMrTTV2WEZjZkdJaVlteEpreVlZR1ZsWlhtZEl4S2d0bTdkYWozd3dBTldkSFMwNSsvWHk0N05RTmRhWDQwaURvb0NYZ0R5OFA1Q3VYajRmRDVyNk5DaDFudnZ2V2NWRlJWNW5TM2lzY0xDUW12T25Eblc0TUdEUFg5dlZuRmNBSDZDMXFxUklOQWVlOHRDcnkrYWJ4MU5talN4SG4zMFVXdmJ0bTFlNTQyNGJOZXVYZGJ6eno5dk5Xdld6UFAzNFJXT2Z3QmRhblhGaVhqRWh6MTJmeEx2TDZBcWo3NTkrMXJwNmVuV2hRc1h2TTRnY1VoQlFZRTFaODRjYThpUUlaYlA1L1A4UFhlRjR6VHdLQnFMbHlEV0VuZ1A3eSttS3g1Tm1qU3hmdlNqSDFuLytNYy9yTkxTVXErelNmeFVXbHBxclY2OTJucjg4Y2V0eG8wYmUvNyt1c2J4ZDZCNWphOHFrUUQxQStBQTNsOVlWejFhdFdwbFRaNDgyVnE3ZHExVlZsYm1kV1pKTlpXV2xsb1pHUm5XazA4K2FiVnMyZEx6OTFFMWpuM0FxQnBlUXlKQklRNTRIbnVkRHE4dnRHc2VTVWxKMXVUSms2Mk1qQXlGZm9EYXZuMjdOV1hLRkt0OSsvYWV2MStxZVZ3QS9xdjhXaENYYUV6TUc2MkJYd01QRUNUL0Q1bzFhOGJ3NGNNWk5Xb1VRNGNPcFhIanhsNmZVbGk2Y09FQ3ExYXRZdEdpUlN4ZHVwU0RCdzk2ZlVyVlpXRVBZVDZIL2NsV1hCUVVJUlBDK2dGVGdUU3ZUNlFtSWlNajZkV3JGeU5Iam1UVXFGSDA2ZE1IbjA5dkphZnMyTEdEUllzV3NXTEZDdGFzV1VOUlVaSFhwMVJUbTRGL0I5WjVmU0xoU2xlbjl5S0FjZGc5L0tCOHpMdGx5NVlNSFRxVVcyNjVoYlMwTks2Nzdqb0ZmeTJWbFpYeHhSZGZzRzdkT3RhdFc4Znk1Y3M1ZXZTbzE2ZFZXNGVCRjRIWjJEMTY4WWl1eHNCUkg3dlg4eXpReE9OejhVdDhmRHo5Ky9kbndJQUJEQmd3Z0g3OStoRVhweUhacXVUbDViRnAwNmFMd2I1aHd3Wk9uejd0OVduNTZ4VHd2OEFyMkdQeTRqRUZmZUJwRER5REhmb05QVDRYSTZLam8rblRwdytwcWFuMDdObVRIajE2MExObno3QWI1ejk5K2pSWldWbHMyN2FOckt3c01qTXoyYnAxSzhYRnhWNmZtaWxuc1ljaWYxLythd2tRQ3ZyQWxZQjk0K29wb0o3SDUrS0l0bTNiY3YzMTE5T3paMDk2OXV4SjU4NmRTVWxKSVQ0KzN1dFQ4MHRPVGc3Nzl1MWo5KzdkWkdWbFhRejNRNGNPZVgxcVRqa1B2QXI4RnJzM0x3RkdRUi80bW1Hdm4vTTRZVElscldIRGhpUW5KNU9Ta25MeGEwcEtDdTNhdGFOcDA2WWtKQ1FRR3h2cnlia1ZGaGFTazVQRGlSTW55TTdPSmpzN20zMzc5ckZ2Mzc2THY4N056ZlhrM0R5UUIwd0QvaDl3d3VOemthdFEwQWVQVnRqajk0OFFJa002L3FoZnZ6NEpDUWswYmRxVXhNUkVFaElTU0VoSW9INzkralJzYVAvbnFWdTM3c1VmQ0UyYTJMYzlLbjVmV0ZnSWNIRTh2TEN3a0x5OFBBRE9uVHZIK2ZQbnljbkpJU2NuaDVNblQzTGl4QWx5Y25JNGYvNjhxLy9PQUhVT2VBUDRIZmFHSUNKaVdBUHNOYnIzNC8zREx6ckM2emlDL2JCVFVFOFdFQWttMGNBOXdLZDRId0E2UXZ2NEhIdUJ2bWhFeERPM0FBdXhOMC8yT2hSMGhNNnhGbnM5R2czeGlnU1E2N0NudCtYZ2ZVam9DTTdqSlBiMHlPc1FrWUFXaXoyc3N4ejE4blZVNzlpTXZTWjhYVVFrNkhURXZvRVc4RXNrNjNEOU9BTDhOL1o3UkVSQ1FEVHdRK0I5SUIvdlEwYUhOMGMrTUI5N2Z3VHR5eW9Td3VwaUQrMHNCQXJ4UG54ME9IdVVZQS9qalVmUFlJaUVwU2JBUThBeW9CanZRMG1IbWFNSVdBSThpTDEra29ReFRadVN5aEt3aDNkR0FZTUkwVFYyUXRoNVlDV3dDSHQ0UnV2T0NLQ2dseXVMQW00R1JnSkRnRDdvL1JLSTlnSXJzTVA5WSt5aE9KRkw2TUtWNm1vT0RNY08vcUZvT01BckY0QU4yTUgrUHRxV1Q2cEJRUysxRVlYZHcwOERCcFFmUWJrN1ZoRDRHbnNMdm5YQWVtQXI5czFWa1dwVDBJc3ByYkFELzVieXI3Mnh0MG1VbXRtTEhlcHJ5NzkrZ1gxelZhVFdGUFRpbE1iWXZmNGU1VWNxOW1QMWV2TFNsZ2ZzQUxLQWJlWEhGdUNNbHljbG9VbEJMMjZLQk5wamgzN0ZENERyZ0dUc1pSdENVU0dRamQwenJ3ajBUR0FQOXZJVUlvNVQwRXVnYUlMOVErRHlveFdRUXVEdXJsV012UkRZMTlqRExwY2YrNEZTejg1T0JBVzlCSWNJSUJGN252L2xSOVB5cjRuWTgvNHJaZ1BWNFpzZkRvM0thMFFEOWN2LzdEeDJTSmZ4elViVytVQkIrYS9QbEg5UFR2bHhvdEt2YzdERHZlTFg2cGxMUVB2L0ZTSDUrK1NTOU1ZQUFBQUFTVVZPUks1Q1lJST0nOyIsIi8qKlxyXG4gKiBNYXBzIGlzIHRoZSBzZXQgb2YgdGhlIG1hcCBmdW5jdGlvbnNcclxuICogQHR5cGVkZWYge09iamVjdH0gTWFwc1xyXG4gKiBAcHJvcGVydHkge1tpZDogc3RyaW5nXTogTm9kZX0gbm9kZU1hcCAtIG1hcCBpZCB0byBbTm9kZV17QGxpbmsgTm9kZX0gLSBSZXR1cm5zIE5vZGUgYnkgaWQgYW5kIChvcHRpb25hbCkgcm9sZS5cclxuICogQHByb3BlcnR5IHtbaWQ6IHN0cmluZ106IExpbmt9IGxpbmtNYXAgLSBtYXAgaWQgdG8gIFtMaW5rXXtAbGluayBMaW5rfSAtIFJldHVybnMgTGluayBieSBpZCBhbmQgKG9wdGlvbmFsKSByb2xlLlxyXG4gKiBAcHJvcGVydHkge1tpZDogc3RyaW5nXTogTGlua30gc291cmNlTWFwIC0gbWFwIGlkIHRvICBbTGlua117QGxpbmsgTGlua31bXSAtIFJldHVybnMgYWxsIGluY29taW5nIGxpbmtzIGZvciB0aGUgbm9kZSB3aXRoIHNwZWNpZmllZCBpZCAoZmlsdGVycyBieSByb2xlKS5cclxuICogQHByb3BlcnR5IHtbaWQ6IHN0cmluZ106IExpbmt9IHRhcmdldE1hcCAtIG1hcCBpZCB0byAgW0xpbmtde0BsaW5rIExpbmt9W10gLSBSZXR1cm5zIGFsbCBvdXRnb2luZyBsaW5rcyBmb3IgdGhlIG5vZGUgd2l0aCBzcGVjaWZpZWQgaWQgKGZpbHRlcnMgYnkgcm9sZSkuXHJcbiovXHJcblxyXG4vKipcclxuICogRW5kIGVsZW1lbnRzIG9mIHRoZSBncmFwaCwgd2hpY2ggd2VyZSBjcmVhdGVkIGZyb20ge0BsaW5rIFNlcnZlckRhdGF9LlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHcmFwaERhdGFcclxuICogQHByb3BlcnR5IHtMaW5rW119IGxpbmtzIC0gTGlzdCBvZiBMaW5rcyBvZiB0aGUgZ3JhcGhcclxuICogQHByb3BlcnR5IHtOb2RlW119IG5vZGVzIC0gTGlzdCBvZiBOb2RlcyBvZiB0aGUgZ3JhcGhcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBEYXRhQ29udGFpbmVyIC0gYW4gb2JqZWN0IHdoaWNoIGlzIGEgZGF0YSBtb2RlbCBvZiB0aGUgTGluZWdlR3JhbS4gSXQgc3RvcmVzIGFuZCBvcmdpbml6ZXNcclxuICogZGF0YSBmb3IgdGhlIHZpZXdzIGFuZCBhbHNvIHByb3ZpZGVzIHNldCBvZiBtYXBzIChkaWN0aW9uYXJpZXMpIGZvciBsaW5rcyBhbmQgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBZb3UgY2FuIGdldCB0aGlzIG1vZGVsIHVzaW5nIGEgTGluZWFHcmFtIG1ldGhvZCB3aGljaCBpcyBjYWxsZWQgJ2dldEdyYXBoTW9kZWwnLlxyXG4gKiBEYXRhQ29udGFpbmVyIGltcGxlbWVudHMgc2VwYXJhdGlvbiBhbmQgZmlsdHJhdGlvbiBtZWNoYW5pc21zLCBpbiBvdGhlciB3b3JkcyxcclxuICogeW91IGNhbiByZXR1cm4gZGlmZmVyZW50IGRhdGEgZm9yIGRpZmZlcmVudCByb2xlcy5cclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7R3JhcGhEYXRhfSBkYXRhIC0gUmF3IGRhdGEgLSBtb2RlbHMgZm9yIGxpbmtzIGFuZCBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgc2V0XHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge01hcHN9IG1hcHMgLSBTZXQgb2YgdGhlIG1hcCBmdW5jdGlvbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBEYXRhQ29udGFpbmVyIChkYXRhLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBpZiAoIWRhdGEpIGRhdGEgPSB7fTtcclxuICAgIGlmICghZGF0YS5ub2RlcykgZGF0YS5ub2RlcyA9IFtdO1xyXG4gICAgaWYgKCFkYXRhLmxpbmtzKSBkYXRhLmxpbmtzID0gW107XHJcblxyXG4gICAgc2VsZi5ub2RlcyA9IGRhdGEubm9kZXM7XHJcbiAgICBzZWxmLmxpbmtzID0gZGF0YS5saW5rcztcclxuICAgIHNlbGYubWFwcyA9IHsgc291cmNlTWFwOiB7fSwgdGFyZ2V0TWFwOiB7fSwgbm9kZU1hcDoge30sIGxpbmtNYXA6IHt9LCBpZE1hcDoge30gfTtcclxuICAgIHNlbGYuem9uZXMgPSBbXTtcclxuICAgIFxyXG4gICAgY29uc3QgX3pvbmVTaXplID0gcGFyYW1ldGVycy5kYXRhWm9uZVNpemU7XHJcbiAgICBjb25zdCBfZWxlbWVudFNpemUgPSBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplO1xyXG4gICAgY29uc3QgX3pvbmVzSW5Hcm91cCA9IHBhcmFtZXRlcnMuem9uZXNJbkdyb3VwO1xyXG5cclxuICAgIC8vIElmIHNvbWUgbm9kZSBkb250IGhpdCBhbnkgcmVhbCB6b25lIGl0IHdpbGwgaGl0IHRoaXMgb25lLlxyXG4gICAgY29uc3QgX2Zha2Vab25lID0gbmV3IE5vZGVzWm9uZShudWxsLCB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICBlbGVtZW50U2l6ZTogMCxcclxuICAgICAgICBmYWtlWm9uZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgaWYgKF9lbGVtZW50U2l6ZS53aWR0aCA+PSBfem9uZVNpemUud2lkdGggfHwgX2VsZW1lbnRTaXplLmhlaWdodCA+PSBfem9uZVNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgX3pvbmVTaXplLndpZHRoID0gX2VsZW1lbnRTaXplLndpZHRoICogMjA7XHJcbiAgICAgICAgX3pvbmVTaXplLmhlaWdodCA9IF9lbGVtZW50U2l6ZS5oZWlnaHQgKiAyMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbm9kZXMgYW5kIGxpbmtzIHdoaWNoIGFyZSBsaWUgbmVhciB0aGUgcG9pbnRcclxuICAgICAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzIC0gQXJyYXkgb2YgcG9pbnRzXHJcbiAgICAgKiBAcmV0dXJuIHtHcmFwaERhdGF9IC0gTm9kZXMgYW5kIExpbmtzXHJcbiAgICAgKiBAbWVtYmVyb2YgRGF0YUNvbnRhaW5lclxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0RWxlbWVudHNOZWFyVGhlUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgIGNvbnN0IHN1aXRhYmxlWm9uZXMgPSBfem9uZXNGb3JQb2ludHMgKHBvaW50cyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0Tm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCByZXN1bHRMaW5rcyA9IFtdO1xyXG5cclxuICAgICAgICBzdWl0YWJsZVpvbmVzLmZvckVhY2goeiA9PiB7XHJcbiAgICAgICAgICAgIHoucmVsYXRlZE5vZGVzLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Tm9kZXMuaW5kZXhPZihuKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgei5ub2Rlcy5mb3JFYWNoKG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdE5vZGVzLmluZGV4T2YobikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXMucHVzaChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHoubGlua3MuZm9yRWFjaChsID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRMaW5rcy5pbmRleE9mKGwpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdExpbmtzLnB1c2gobCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub2RlczogcmVzdWx0Tm9kZXMsXHJcbiAgICAgICAgICAgIGxpbmtzOiByZXN1bHRMaW5rcyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3RhbmdsZVxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUmVjdGFuZ2xlXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geCAtIFBvc2l0aW9uIGJ5IHggYXhpc1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBieSB5IGF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbm9kZXMgYW5kIGxpbmtzIHdoaWNoIGFyZSBsaWUgaW50byB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIEhpdCByZWN0YW5nbGVcclxuICAgICAqIEByZXR1cm4ge0dyYXBoRGF0YX0gLSBOb2RlcyBhbmQgTGlua3NcclxuICAgICAqIEBtZW1iZXJvZiBEYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRFbGVtZW50c0ZvclJlY3RhbmdsZSA9IGZ1bmN0aW9uIChyZWN0KSB7XHJcblxyXG4gICAgICAgIGlmICghcmVjdCkgcmV0dXJuIHsgbm9kZXM6IFtdLCBsaW5rczogW10gfTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgICAgICBpZiAocmVjdC53aWR0aCA8PSBfem9uZVNpemUud2lkdGggJiYgcmVjdC5oZWlnaHQgPD0gX3pvbmVTaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHJlY3QueCwgICAgICAgICAgICAgIHk6IHJlY3QueX0pO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSB9KTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiByZWN0LngsICAgICAgICAgICAgICB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9KTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcmVjdC54IDs7IHggKz0gX3pvbmVTaXplLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gcmVjdC55IDs7IHkgKz0gX3pvbmVTaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5taW4oeCwgcmVjdC54ICsgcmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKHksIHJlY3QueSArIHJlY3QuaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID49IHJlY3QueSArIHJlY3QuaGVpZ2h0KSBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IHJlY3QueCArIHJlY3Qud2lkdGgpIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxmLmdldEVsZW1lbnRzTmVhclRoZVBvaW50cyhwb2ludHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbm9kZXMgcmVsYXRlZCB3aXRoIHRoZSB0YXJnZXQgbm9kZVxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gdGFyZ2V0IG5vZGVcclxuICAgICAqIEByZXR1cm4ge05vZGVbXX1cclxuICAgICAqIEBtZW1iZXJvZiBEYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRSZWxhdGVkTm9kZXMgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xyXG4gICAgICAgIGlmIChzZWxmLm1hcHMudGFyZ2V0TWFwW25vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgIHNlbGYubWFwcy50YXJnZXRNYXBbbm9kZS5pZF1cclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGwgPT4gbmVpZ2hib3JzLnB1c2goc2VsZi5tYXBzLm5vZGVNYXBbbC5tb2RlbC50YXJnZXRdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLm1hcHMuc291cmNlTWFwW25vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgIHNlbGYubWFwcy5zb3VyY2VNYXBbbm9kZS5pZF1cclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGwgPT4gbmVpZ2hib3JzLnB1c2goc2VsZi5tYXBzLm5vZGVNYXBbbC5tb2RlbC5zb3VyY2VdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZWlnaGJvcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGNvbnRhaW5lci4gSXQgbWVhbnMgdGhhdCBhbGwgbWFwcyB3aWxsXHJcbiAgICAgKiBiZSB1cGRhdGVkIGFuZCBub2RlcyBpbiB0aGUgY29udGFpbmVyIHdpbGwgYmUgb3JnYW5pemVkLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGFyZ2V0IG5vZGUgKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIERhdGFDb250YWluZXJcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAobmV3RGF0YSkge1xyXG4gICAgICAgIGlmIChuZXdEYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdEYXRhLm5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLm5vZGVzID0gbmV3RGF0YS5ub2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3RGF0YS5saW5rcykge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5saW5rcyA9IG5ld0RhdGEubGlua3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3JlZnJlc2hNYXBzKCk7XHJcbiAgICAgICAgX3JlZnJlc2hHcmlkKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIG5vZGUgZnJvbSBvbmUgem9uZSB0byBhbm90aGVyLlxyXG4gICAgICogV2UgYXJlIHVzaW5nIGl0IHdoZW4gbm9kZSBpcyBkcmFnZ2VkIHRvIHNvbWV3aGVyZSBvbiB0aGUgcGFwZXJcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHRhcmdldCBub2RlXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvbGRQb3MgLSBwcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGVcclxuICAgICAqIEBtZW1iZXJvZiBEYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51cGRhdGVab25lc0Zvck5vZGUgPSBmdW5jdGlvbiAobm9kZSwgb2xkUG9zKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUG9zID0gbm9kZS5tb2RlbC5wb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBvbGRab25lcyA9IF96b25lc0ZvclBvaW50cyAoW29sZFBvc10pO1xyXG5cclxuICAgICAgICBvbGRab25lcy5mb3JFYWNoKHpvbmUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IHpvbmUubm9kZXMuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XHJcbiAgICAgICAgICAgIF9jbGVhclpvbmUoem9uZSk7XHJcbiAgICAgICAgICAgIF9maWxsWm9uZSAoem9uZSwgbmV3Tm9kZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBuZXdab25lcyA9IF96b25lc0ZvclBvaW50cyAoW2N1clBvc10pO1xyXG4gICAgICAgIGlmIChuZXdab25lcykge1xyXG4gICAgICAgICAgICBuZXdab25lcy5mb3JFYWNoKHogPT4ge1xyXG4gICAgICAgICAgICAgICAgX2ZpbGxab25lICh6LCBbbm9kZV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfZmlsbFpvbmUgKF9mYWtlWm9uZSwgW25vZGVdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgem9uZXMgd2hpY2ggY29udGFpbiBvYnRhaW5lZCBwb2ludHMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQb2ludFtdfSBwb2ludHNcclxuICAgICAqIEByZXR1cm4ge05vZGVzWm9uZVtdfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF96b25lc0ZvclBvaW50cyAocG9pbnRzKSB7XHJcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzIHx8IFtdO1xyXG4gICAgICAgIGNvbnN0IHN1aXRhYmxlWm9uZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChwLCB6b25lcykge1xyXG4gICAgICAgICAgICB6b25lcy5mb3JFYWNoKHogPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHouaGl0VGVzdChwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh6IGluc3RhbmNlb2YgR3JvdXBPZlpvbmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbihwLCB6LnpvbmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1aXRhYmxlWm9uZXMuaW5kZXhPZih6KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VpdGFibGVab25lcy5wdXNoKHopOyBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgcmVjdXJzaW9uIChwLCBzZWxmLnpvbmVzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdWl0YWJsZVpvbmVzLnB1c2goX2Zha2Vab25lKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc3VpdGFibGVab25lcztcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgem9uZXMgdHJlZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3JlZnJlc2hHcmlkICgpIHtcclxuICAgICAgICBsZXQgbWluWCA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWluWSA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWF4WCA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbWF4WSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgc2VsZi5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBub2RlLm1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBtaW5YID0gKG1pblggPT09IHVuZGVmaW5lZCA/IHBvcy54IDogTWF0aC5taW4obWluWCwgcG9zLngpKTtcclxuICAgICAgICAgICAgbWluWSA9IChtaW5ZID09PSB1bmRlZmluZWQgPyBwb3MueSA6IE1hdGgubWluKG1pblksIHBvcy55KSk7XHJcbiAgICAgICAgICAgIG1heFggPSAobWF4WCA9PT0gdW5kZWZpbmVkID8gcG9zLnggOiBNYXRoLm1heChtYXhYLCBwb3MueCkpO1xyXG4gICAgICAgICAgICBtYXhZID0gKG1heFkgPT09IHVuZGVmaW5lZCA/IHBvcy55IDogTWF0aC5tYXgobWF4WSwgcG9zLnkpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHpvbmVzID0gW107XHJcbiAgICAgICAgbGV0IG5vZGVzID0gW10uY29uY2F0KHNlbGYubm9kZXMpO1xyXG4gICAgICAgIGZvciAobGV0IHggPSBtaW5YLCBpID0gMDsgeCA8PSBtYXhYOyB4ICs9IChfem9uZVNpemUud2lkdGggLSBfZWxlbWVudFNpemUud2lkdGgpLCBpKyspIHtcclxuICAgICAgICAgICAgem9uZXNbaV0gPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG1pblksIGogPSAwOyB5IDw9IG1heFk7IHkgKz0gKF96b25lU2l6ZS5oZWlnaHQgLSBfZWxlbWVudFNpemUuaGVpZ2h0KSwgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdab25lID0gbmV3IE5vZGVzWm9uZShudWxsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfem9uZVNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfem9uZVNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiBfZWxlbWVudFNpemUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG5vZGVzID0gX2ZpbGxab25lIChuZXdab25lLCBub2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB6b25lc1tpXVtqXSA9IG5ld1pvbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi56b25lcyA9IF9ncm91cFpvbmVzKHpvbmVzKTtcclxuICAgICAgICBzZWxmLnpvbmVzLnB1c2goX2Zha2Vab25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyB6b25lcyBieSBncm91cHMgb2YgKGJ5IGRlZmF1bHQpIGZvdXIuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtOb2RlWm9uZVtdfSB6b25lc1xyXG4gICAgICogQHJldHVybiB7Tm9kZVpvbmVbXSB8IEdyb3VwT2Zab25lc31cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ3JvdXBab25lcyAoem9uZXMpIHtcclxuICAgICAgICBjb25zdCBNQVhfREVFUCA9IDEwMDA7XHJcbiAgICAgICAgY29uc3Qgc2lkZSA9IE1hdGguc3FydChfem9uZXNJbkdyb3VwKTsgLy8gbGVuZ3RoIG9mIHNpZGUgb2YgZ3JvdXBcclxuICAgICAgICBsZXQgbmV3Wm9uZXM7XHJcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBNQVhfREVFUCAmJiB6b25lcy5sZW5ndGggIT09IDE7IG4rKykgeyAvLyBpdGVyYXRpb25zXHJcbiAgICAgICAgICAgIG5ld1pvbmVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuaSA9IDA7IGkgPCB6b25lcy5sZW5ndGg7IGkgKz0gc2lkZSwgbmkrKykge1xyXG4gICAgICAgICAgICAgICAgbmV3Wm9uZXNbbmldID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbmogPSAwOyBqIDwgem9uZXNbaV0ubGVuZ3RoOyBqICs9IHNpZGUsIG5qKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB6b25lc09mR3JvdXAgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB6b25lc09mR3JvdXAucHVzaCh6b25lc1tpXVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvbmVzW2kgKyAxXSAmJiB6b25lc1tpICsgMV1bal0pIHpvbmVzT2ZHcm91cC5wdXNoKHpvbmVzW2kgKyAxXVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvbmVzW2ldICYmIHpvbmVzW2ldW2ogKyAxXSkgem9uZXNPZkdyb3VwLnB1c2goem9uZXNbaV1baiArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoem9uZXNbaSArIDFdICYmIHpvbmVzW2kgKyAxXVtqICsgMV0pIHpvbmVzT2ZHcm91cC5wdXNoKHpvbmVzW2kgKyAxXVtqICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1pvbmVzW25pXVtual0gPSBuZXcgR3JvdXBPZlpvbmVzKHpvbmVzT2ZHcm91cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgem9uZXMgPSBuZXdab25lcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld1pvbmVzKSB6b25lcyA9IG5ld1pvbmVzO1xyXG4gICAgICAgIHJldHVybiB6b25lc1swXSB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFB1dHMgbm9kZXMgYW5kIGxpbmtzIGludG8gem9uZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge05vZGVab25lfSB6b25lXHJcbiAgICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXNcclxuICAgICAqIEByZXR1cm4ge05vZGVbXX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZmlsbFpvbmUgKHpvbmUsIG5vZGVzKSB7XHJcbiAgICAgICAgY29uc3Qgbm90Rml0ZWROb2RlcyA9IFtdOyAvLyBpbmRleGVzIHRvIHJlbW92ZSB0aGUgY2F0Y2hlZCBub2RlcyBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoem9uZS5ub2RlSGl0VGVzdChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgem9uZS5ub2Rlcy5wdXNoKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0UmVsYXRlZE5vZGVzKG5vZGUpLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvbmUucmVsYXRlZE5vZGVzLmluZGV4T2YobikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUucmVsYXRlZE5vZGVzLnB1c2gobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubWFwcy5zb3VyY2VNYXBbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1hcHMuc291cmNlTWFwW25vZGUuaWRdLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvbmUubGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1hcHMudGFyZ2V0TWFwW25vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXBzLnRhcmdldE1hcFtub2RlLmlkXS5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lLmxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub3RGaXRlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbm90Rml0ZWROb2RlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIHpvbmUgLSByZW1vdmUgYWxsIGRhdGEgZnJvbSB0aGUgem9uZS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge05vZGVab25lfSB6b25lXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NsZWFyWm9uZSAoem9uZSkge1xyXG4gICAgICAgIHpvbmUucmVsYXRlZE5vZGVzID0gW107XHJcbiAgICAgICAgem9uZS5ub2RlcyA9IFtdO1xyXG4gICAgICAgIHpvbmUubGlua3MgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbWFwIGZvciBub2Rlc1xyXG4gICAgICogYW5kIHVwZGF0ZXMgYXNwZWN0IHJlbGF0aW9ucyBiZXR3ZWVuIG5vZGVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMgbm9kZU1hcFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVOb2RlTWFwcyAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGlkTWFwID0ge307XHJcbiAgICAgICAgc2VsZi5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZU1hcFtub2RlLm1vZGVsLmlkXSA9IG5vZGUuaWQ7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGVNYXA6IG5vZGVNYXAsXHJcbiAgICAgICAgICAgIGlkTWFwOiBpZE1hcCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBtYXBzIGZvciBsaW5rcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZU1hcFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlkTWFwXHJcbiAgICAgKiBAcmV0dXJucyB7bGlua01hcCwgaWRNYXB9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUxpbmtNYXBzIChub2RlTWFwLCBpZE1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxpbmtNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgc2VsZi5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBsaW5rTWFwW2xpbmsuaWRdID0gbGluaztcclxuICAgICAgICAgICAgaWRNYXBbbGluay5tb2RlbC5pZF0gPSBsaW5rLmlkO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzb3VyY2VNYXBbdGFyZ2V0LmlkXSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlTWFwW3RhcmdldC5pZF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzb3VyY2VNYXBbdGFyZ2V0LmlkXS5wdXNoKGxpbmspO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0YXJnZXRNYXBbc291cmNlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0TWFwW3NvdXJjZS5pZF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YXJnZXRNYXBbc291cmNlLmlkXS5wdXNoKGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxpbmtNYXA6IGxpbmtNYXAsXHJcbiAgICAgICAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwLFxyXG4gICAgICAgICAgICB0YXJnZXRNYXA6IHRhcmdldE1hcCxcclxuICAgICAgICAgICAgaWRNYXA6IGlkTWFwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIG1hcHMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoTWFwcyAoKSB7XHJcbiAgICAgICAgY29uc3QgeyBub2RlTWFwLCBpZE1hcCB9ID0gX2NyZWF0ZU5vZGVNYXBzKCk7XHJcbiAgICAgICAgY29uc3QgbGlua01hcHMgPSBfY3JlYXRlTGlua01hcHMobm9kZU1hcCwgaWRNYXApO1xyXG5cclxuICAgICAgICBzZWxmLm1hcHMgPSB7XHJcbiAgICAgICAgICAgIHNvdXJjZU1hcDogbGlua01hcHMuc291cmNlTWFwLFxyXG4gICAgICAgICAgICB0YXJnZXRNYXA6IGxpbmtNYXBzLnRhcmdldE1hcCxcclxuICAgICAgICAgICAgbm9kZU1hcDogbm9kZU1hcCxcclxuICAgICAgICAgICAgaWRNYXA6IGxpbmtNYXBzLmlkTWFwLFxyXG4gICAgICAgICAgICBsaW5rTWFwOiBsaW5rTWFwcy5saW5rTWFwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5yZWZyZXNoKCk7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRGF0YUNvbnRhaW5lcjtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBPYmplY3QgdGhhdCBpcyB0aGUgbGVhZiBvZiB0aGUgem9uZXMgdHJlZVxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtOb2RlWm9uZVtdfSB6b25lcyAtIEFycmF5IG9mIHpvbm5lcyBmb3IgY29udGFpbmluZ1xyXG4gKiBAcHJvcGVydHkge05vZGVab25lW119IHpvbmVzIC0gQXJyYXkgb2Ygem9ubmVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gR3JvdXBPZlpvbmVzICh6b25lcykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IHt9O1xyXG4gICAgc2VsZi56b25lcyA9IHpvbmVzO1xyXG5cclxuICAgIF9jYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDYWxjdWxhdGVzIGJvdW5kcyBvZiB0aGUgdG90YWwgYXJlYSBvZiBjb250YWluZWQgem9uZXMuIFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVCb3VuZHMgKCkge1xyXG4gICAgICAgIGxldCBtaW5YID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtaW5ZID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhYID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBtYXhZID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBzZWxmLnpvbmVzLmZvckVhY2goem9uZSA9PiB7XHJcbiAgICAgICAgICAgIG1pblggPSAobWluWCA9PT0gdW5kZWZpbmVkID8gem9uZS5tb2RlbC54IDogTWF0aC5taW4obWluWCwgem9uZS5tb2RlbC54KSk7XHJcbiAgICAgICAgICAgIG1pblkgPSAobWluWSA9PT0gdW5kZWZpbmVkID8gem9uZS5tb2RlbC55IDogTWF0aC5taW4obWluWSwgem9uZS5tb2RlbC55KSk7XHJcbiAgICAgICAgICAgIG1heFggPSAobWF4WCA9PT0gdW5kZWZpbmVkID8gem9uZS5tb2RlbC54ICsgem9uZS5tb2RlbC53aWR0aCA6IE1hdGgubWF4KG1heFgsIHpvbmUubW9kZWwueCArIHpvbmUubW9kZWwud2lkdGgpKTtcclxuICAgICAgICAgICAgbWF4WSA9IChtYXhZID09PSB1bmRlZmluZWQgPyB6b25lLm1vZGVsLnkgKyB6b25lLm1vZGVsLmhlaWdodCA6IE1hdGgubWF4KG1heFksIHpvbmUubW9kZWwueSArIHpvbmUubW9kZWwuaGVpZ2h0KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2VsZi5tb2RlbC54ID0gbWluWDtcclxuICAgICAgICBzZWxmLm1vZGVsLnkgPSBtaW5ZO1xyXG4gICAgICAgIHNlbGYubW9kZWwud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICBzZWxmLm1vZGVsLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciBhIHBvaW50IGZhbGwgaW50byB0aGlzIGdyb3VwIG9mIHpvbmVzIG9yIG5vLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBUZXN0ZWQgcG9pbnRcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIEdyb3VwT2Zab25lc1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuaGl0VGVzdCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHBvaW50LnggPj0gc2VsZi5tb2RlbC54ICYmXHJcbiAgICAgICAgICAgIHBvaW50LnggPD0gc2VsZi5tb2RlbC54ICsgc2VsZi5tb2RlbC53aWR0aCAmJlxyXG4gICAgICAgICAgICBwb2ludC55ID49IHNlbGYubW9kZWwueSAmJlxyXG4gICAgICAgICAgICBwb2ludC55IDw9IHNlbGYubW9kZWwueSArIHNlbGYubW9kZWwuaGVpZ2h0XHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBPcHRpb25zIG9mIGEgTm9kZVpvbmVcclxuICogQHR5cGVkZWYge09iamVjdH0gTm9kZVpvbmVPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gYnkgeCBheGlzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gYnkgeSBheGlzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplIC0gU2l6ZSBvZiBlbGVtZW50cyBvZiB0aGUgZ3JhcGhcclxuICogQHByb3BlcnR5IHtib29sZWFufSBmYWtlWm9uZSAtIElzIGl0IGZha2Ugem9uZSAoYWJzdHJhY3Qgb3IgZG9uJ3QgaGFzIHBvc2l0aW9uKVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIE9iamVjdCB0aGF0IGlzIHRoZSBsZWFmIG9mIHRoZSB0cmVlIG9mIHpvbmVzXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge05vZGVbXX0gbm9kZXMgLSBOb2RlcyBvZiB0aGUgem9uZSAoY2FuIGJlIHVuZGVmaW5lZClcclxuICogQHBhcmFtIHtOb2RlWm9uZU9wdGlvbnN9IHBhcmFtZXRlcnMgLSBQcm9wZXJ0aWVzIHNldFxyXG4gKiBcclxuICogQHByb3BlcnR5IHtOb2RlWm9uZU9wdGlvbnN9IG1vZGVsIC0gUHJvcGVydGllcyBzZXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBOb2Rlc1pvbmUgKG5vZGVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLm1vZGVsID0gcGFyYW1ldGVycztcclxuICAgIHNlbGYubm9kZXMgPSBub2RlcyB8fCBbXTtcclxuICAgIHNlbGYucmVsYXRlZE5vZGVzID0gW107XHJcbiAgICBzZWxmLmxpbmtzID0gW107XHJcblxyXG4gICAgY29uc3QgX2VsZW1lbnRTaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgYSBOb2RlIGZhbGwgaW50byB0aGUgem9uZSBvciBuby5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRlc3RlZCBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBtZW1iZXJvZiBOb2Rlc1pvbmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLm5vZGVIaXRUZXN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAoc2VsZi5tb2RlbC5mYWtlWm9uZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gbm9kZS5tb2RlbC5wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgX2VsZW1lbnRTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSB9O1xyXG4gICAgICAgIGNvbnN0IHAzID0geyB4OiBub2RlUG9zaXRpb24ueCwgeTogbm9kZVBvc2l0aW9uLnkgKyBfZWxlbWVudFNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgX2VsZW1lbnRTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIF9lbGVtZW50U2l6ZS5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChzZWxmLmhpdFRlc3QocDEpKSAmJlxyXG4gICAgICAgICAgICAgICAoc2VsZi5oaXRUZXN0KHAyKSkgJiZcclxuICAgICAgICAgICAgICAgKHNlbGYuaGl0VGVzdChwMykpICYmXHJcbiAgICAgICAgICAgICAgIChzZWxmLmhpdFRlc3QocDQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIGEgcG9pbnQgZmFsbCBpbnRvIHRoZSB6b25lIG9yIG5vLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBUZXN0ZWQgcG9pbnRcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVzWm9uZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuaGl0VGVzdCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHNlbGYubW9kZWwuZmFrZVpvbmUgfHxcclxuICAgICAgICAgICAgcG9pbnQueCA+PSBzZWxmLm1vZGVsLnggJiZcclxuICAgICAgICAgICAgcG9pbnQueCA8PSBzZWxmLm1vZGVsLnggKyBzZWxmLm1vZGVsLndpZHRoICYmXHJcbiAgICAgICAgICAgIHBvaW50LnkgPj0gc2VsZi5tb2RlbC55ICYmXHJcbiAgICAgICAgICAgIHBvaW50LnkgPD0gc2VsZi5tb2RlbC55ICsgc2VsZi5tb2RlbC5oZWlnaHRcclxuICAgICAgICApO1xyXG4gICAgfTtcclxufSIsImV4cG9ydCBjb25zdCBMR19HUk9VUF9UWVBFX0lEID0gJ3RxLWxnLWdyb3VwJztcclxuXHJcbmV4cG9ydCBjb25zdCBOT0RFX01PREVMX0ZJRUxEUyA9IFtcclxuICAgICdpZCcsXHJcbiAgICAnbGFiZWwnLFxyXG4gICAgJ3ZpZXdGcmFtZScsXHJcbiAgICAndHlwZUlkJyxcclxuICAgICdhY3RpdmVSZXNvdXJjZScsXHJcbiAgICAncmVzb3VyY2UnLFxyXG4gICAgJ3Jlc291cmNlVHlwZScsXHJcbiAgICAncG9zaXRpb24nLFxyXG4gICAgJ2RlZmF1bHRQb3NpdGlvbicsXHJcbiAgICAnZGF0YScsXHJcbiAgICAnb2Zmc2V0J1xyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IExJTktfTU9ERUxfRklFTERTID0gW1xyXG4gICAgJ2lkJyxcclxuICAgICdzb3VyY2UnLFxyXG4gICAgJ3RhcmdldCcsXHJcbiAgICAnbGlua1R5cGUnLFxyXG4gICAgJ2FjdGl2ZVJlc291cmNlc0xpc3QnLFxyXG4gICAgJ2dyb3VwJyxcclxuICAgICdkYXRhJyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gZmlsdGVycyB0aGUgZGF0YSwgc2V0cyBhdXRob3JpdGllcyBhbmQgY29sbGFwc2VzIGxpbmtzLlxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgbm9kZXM6IE5vZGVNb2RlbFtdLFxyXG4gKiAgbGlua3M6IExpbmtNb2RlbFtdXHJcbiAqIH0gZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEYXRhIChkYXRhKSB7XHJcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubm9kZXMpIHJldHVybjtcclxuICAgIGRhdGEubGlua3MgPSBkYXRhLmxpbmtzIHx8IFtdO1xyXG5cclxuICAgIGNvbnN0IG5vZGVNYXAgPSB7fTtcclxuXHJcbiAgICBkYXRhLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgbm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIC8vIGV4dHJhY3RpbmcgYWRkaXRpb25hbCBkYXRhXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm90UGVybWFuZW50RmllbGQgPSBOT0RFX01PREVMX0ZJRUxEUy5pbmRleE9mKGtleSkgPT09IC0xO1xyXG4gICAgICAgICAgICBpZiAobm90UGVybWFuZW50RmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IG5vZGVba2V5XTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBub2RlLmRhdGEgPSBkYXRhO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uTWFwID0ge307XHJcbiAgICBkYXRhLmxpbmtzLmZvckVhY2gocmF3TGluayA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGVNYXBbcmF3TGluay5zb3VyY2VdICYmIG5vZGVNYXBbcmF3TGluay50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtDYWNoZUlkID0gZ2V0Q2FjaGVJZChyYXdMaW5rKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0pIHtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uTWFwW2xpbmtDYWNoZUlkXSA9IGdyb3VwKGRlc3RpbmF0aW9uTWFwW2xpbmtDYWNoZUlkXSwgcmF3TGluayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbk1hcFtsaW5rQ2FjaGVJZF0gPSByYXdMaW5rO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlTWFwW3Jhd0xpbmsuc291cmNlXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTb3VyY2Ugbm90IGZvdW5kISBUaGUgbGluayBmcm9tICcgKyByYXdMaW5rLnNvdXJjZSArICcgdG8gJyArIHJhd0xpbmsudGFyZ2V0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGFyZ2V0IG5vdCBmb3VuZCEgVGhlIGxpbmsgZnJvbSAnICsgcmF3TGluay5zb3VyY2UgKyAnIHRvICcgKyByYXdMaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzb3VyY2VNYXAgPSB7fTtcclxuICAgIGNvbnN0IHRhcmdldE1hcCA9IHt9O1xyXG4gICAgY29uc3QgbGlua3MgPSBPYmplY3Qua2V5cyhkZXN0aW5hdGlvbk1hcCkubWFwKGNhY2hlSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxpbmsgPSBkZXN0aW5hdGlvbk1hcFtjYWNoZUlkXTtcclxuICAgICAgICBPYmplY3Qua2V5cyhsaW5rKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdFBlcm1hbmVudEZpZWxkID0gTElOS19NT0RFTF9GSUVMRFMuaW5kZXhPZihrZXkpID09PSAtMTtcclxuICAgICAgICAgICAgaWYgKG5vdFBlcm1hbmVudEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBsaW5rW2tleV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbGlua1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghc291cmNlTWFwW2xpbmsudGFyZ2V0XSkgc291cmNlTWFwW2xpbmsudGFyZ2V0XSA9IFtdO1xyXG4gICAgICAgIHNvdXJjZU1hcFtsaW5rLnRhcmdldF0ucHVzaChsaW5rKTtcclxuXHJcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBbbGluay5zb3VyY2VdKSB0YXJnZXRNYXBbbGluay5zb3VyY2VdID0gW107XHJcbiAgICAgICAgdGFyZ2V0TWFwW2xpbmsuc291cmNlXS5wdXNoKGxpbmspO1xyXG5cclxuICAgICAgICByZXR1cm4gbGluaztcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IE9iamVjdC5rZXlzKG5vZGVNYXApLm1hcChrZXkgPT4gbm9kZU1hcFtrZXldKSxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldENhY2hlSWQgKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gYHNvdXJjZTooJHtsaW5rLnNvdXJjZX0pfiN+dGFyZ2V0Oigke2xpbmsudGFyZ2V0fSlgO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdyb3VwIChleGlzdGVkTGluaywgbmV3TGluaykge1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZXhpc3RlZExpbmsuZ3JvdXAgPyBleGlzdGVkTGluayA6IHtcclxuICAgICAgICAgICAgaWQ6IGdldENhY2hlSWQoZXhpc3RlZExpbmspLFxyXG4gICAgICAgICAgICBzb3VyY2U6IGV4aXN0ZWRMaW5rLnNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBleGlzdGVkTGluay50YXJnZXQsXHJcbiAgICAgICAgICAgIGxpbmtUeXBlOiBMR19HUk9VUF9UWVBFX0lELCAvLyBleGlzdGVkTGluay5saW5rVHlwZSxcclxuICAgICAgICAgICAgZ3JvdXA6IFtleGlzdGVkTGlua10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBncm91cC5ncm91cC5wdXNoKG5ld0xpbmspO1xyXG4gICAgICAgIC8vIGV4dHJhY3RpbmcgYWRkaXRpb25hbCBkYXRhXHJcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHByb2Nlc3NEYXRhO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBmaWx0ZXJzIHRoZSBkYXRhLCBzZXRzIGF1dGhvcml0aWVzIGFuZCBjb2xsYXBzZXMgbGlua3MuXHJcbiAqIEBwYXJhbSB7XHJcbiAqICBub2RlczogTm9kZU1vZGVsW10sXHJcbiAqICBsaW5rczogTGlua01vZGVsW11cclxuICogfSBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXNwZWN0UmVsYXRpb25zIChub2Rlcykge1xyXG4gICAgY29uc3QgYXNwZWN0TWFwID0ge307XHJcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIC8vIGNvbWJpbmUgbm9kZXMgd2l0aCB0aGUgc2FtZSBpZFxyXG4gICAgICAgIGNvbnN0IGNsZWFySWQgPSBub2RlLm1vZGVsLnJlc291cmNlO1xyXG4gICAgICAgIGlmIChjbGVhcklkKSB7XHJcbiAgICAgICAgICAgIGlmICghYXNwZWN0TWFwW2NsZWFySWRdKSB7XHJcbiAgICAgICAgICAgICAgICBhc3BlY3RNYXBbY2xlYXJJZF0gPSBbbm9kZV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3BlY3RNYXBbY2xlYXJJZF0ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmtleXMoYXNwZWN0TWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKGFzcGVjdE1hcFtrZXldLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgYXNwZWN0TWFwW2tleV0uZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYXNwZWN0TWFwW2tleV0uaW5kZXhPZihuKTtcclxuICAgICAgICAgICAgICAgIG4uYXNwZWN0cyA9IGFzcGVjdE1hcFtrZXldLnNsaWNlKDAsIGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoYXNwZWN0TWFwW2tleV0uc2xpY2UoaW5kZXggKyAxLCBhc3BlY3RNYXBba2V5XS5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlZmF1bHREYXRhUHJvdmlkZXIgKHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0ge307XHJcblxyXG4gICAgY29uc3QgX3NlcnZlclVSTCA9IHBhcmFtZXRlcnMuc2VydmVyVVJMIHx8ICcvYXBpL3RibC9zd3AnO1xyXG4gICAgY29uc3QgX2RlZmF1bHRMaW5lYWdlR3JhbVZpZXdDbGFzcyA9IHBhcmFtZXRlcnMubGdWaWV3Q2xhc3MgfHwgJ2h0dHA6Ly9lZGcudG9wYnJhaWQuc29sdXRpb25zL21vZGVsL0J1aWxkSlNPTmZvckxpbmVhZ2VNb2RlbExpbmVhZ2VHcmFtJztcclxuICAgIGNvbnN0IF92ZlZpZXdDbGFzcyA9IHBhcmFtZXRlcnMudmZWaWV3Q2xhc3MgfHwgJ2VkZzpnZXRWaWV3RnJhbWVzRm9yUmVzb3VyY2UnO1xyXG4gICAgY29uc3QgX2RtVmlld0NsYXNzID0gcGFyYW1ldGVycy5kbVZpZXdDbGFzcyB8fCAnZWRnOkRlcml2YXRpb25NYXBEYXRhU2VydmljZSc7XHJcbiAgICBjb25zdCBfdmNWaWV3Q2xhc3MgPSBwYXJhbWV0ZXJzLnZjVmlld0NsYXNzIHx8ICdlZGc6Z2V0TGluZWFnZUdyYW1EYXRhUHJvdmlkZXInO1xyXG5cclxuICAgIGNvbnN0IF9ncmFwaCA9IHBhcmFtZXRlcnMuZ3JhcGggfHwgJ3VuZGVmaW5lZCc7XHJcbiAgICBjb25zdCBfY29uZmlnR3JhcGggPSBwYXJhbWV0ZXJzLmNvbmZpZ0dyYXBoIHx8ICdodHRwOi8vZWRnLnRvcGJyYWlkbGl2ZS5vcmcvMS4wL2NvbmZpZy9kaWFncmFtcyc7XHJcbiAgICBjb25zdCBfYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSB8fCAndW5kZWZpbmVkJztcclxuXHJcbiAgICBsZXQgX3JlYWNoID0gcGFyYW1ldGVycy5yZWFjaDtcclxuICAgIGNvbnN0IF9yYW5nZSA9IHBhcmFtZXRlcnMucmFuZ2U7XHJcbiAgICBsZXQgX2JyZWFkdGggPSBwYXJhbWV0ZXJzLmJyZWFkdGg7XHJcbiAgICBjb25zdCBfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoO1xyXG5cclxuICAgIHNlbGYuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX2V4ZWN1dFF1ZXJ5KGdldEZldGNoRGF0YVVybChcclxuICAgICAgICAgICAgb3B0aW9ucy50YXJnZXROb2RlSWQsXHJcbiAgICAgICAgICAgIG9wdGlvbnMudmlld0ZyYW1lLFxyXG4gICAgICAgICAgICBvcHRpb25zLmxpbmVhZ2VHcmFtVmlld0NsYXNzLFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpYWdyYW1UeXBlLFxyXG4gICAgICAgICAgICAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykgPyBvcHRpb25zLm9mZnNldCA6IG51bGwpXHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0Vmlld0ZyYW1lcyA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfZXhlY3V0UXVlcnkoZ2V0Vmlld0ZyYW1lc1VybChyZXNvdXJjZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldFZpZXdDbGFzc0ZvclJlc291cmNlID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9leGVjdXRRdWVyeShnZXRWaWV3Q2xhc3NVcmwocmVzb3VyY2UpKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRSZWFjaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfcmVhY2g7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0UmVhY2ggPSBmdW5jdGlvbihyZWFjaCkge1xyXG4gICAgICAgIGlmKHJlYWNoID4gMCAmJiByZWFjaCA8IDExKXtcclxuICAgICAgICAgICAgX3JlYWNoID0gcmVhY2g7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldEJyZWFkdGggPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBfYnJlYWR0aDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRCcmVhZHRoID0gZnVuY3Rpb24gKGJyZWFkdGgpIHtcclxuICAgICAgICBpZihicmVhZHRoID4gMCAmJiBicmVhZHRoIDwgMTEpIHtcclxuICAgICAgICAgICAgX2JyZWFkdGggPSBicmVhZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5yZWxhdGlvbkluZm8gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgICAgICBsZXQgc291cmNlUmVzb3VyY2UgPSByZWxhdGlvbi5zb3VyY2UucmVzb3VyY2U7XHJcblxyXG4gICAgICAgIGlmKHJlbGF0aW9uLnNvdXJjZS5oYXNPd25Qcm9wZXJ0eSgnYWN0aXZlUmVzb3VyY2UnKSl7XHJcbiAgICAgICAgICAgIHNvdXJjZVJlc291cmNlID0gcmVsYXRpb24uc291cmNlLmFjdGl2ZVJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRhcmdldFJlc291cmNlID0gcmVsYXRpb24udGFyZ2V0LnJlc291cmNlO1xyXG5cclxuICAgICAgICBpZihyZWxhdGlvbi50YXJnZXQuaGFzT3duUHJvcGVydHkoJ2FjdGl2ZVJlc291cmNlJykpe1xyXG4gICAgICAgICAgICB0YXJnZXRSZXNvdXJjZSA9IHJlbGF0aW9uLnRhcmdldC5hY3RpdmVSZXNvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBfcG9zdFF1ZXJ5KF9zZXJ2ZXJVUkwsIGdldERlcml2YXRpb25EYXRhUGFyYW1zKFxyXG4gICAgICAgICAgICBzb3VyY2VSZXNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0UmVzb3VyY2UsXHJcbiAgICAgICAgICAgIHJlbGF0aW9uLmxpbmtUeXBlLFxyXG4gICAgICAgICAgICByZWxhdGlvbi5hY3RpdmVSZXNvdXJjZXNMaXN0XHJcbiAgICAgICAgKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFZpZXdGcmFtZXNVcmwgKHJlc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zZXJ2ZXJVUkwgKyAnPycgK1xyXG4gICAgICAgICAgICAnX3ZpZXdDbGFzcz0nICsgX3ZmVmlld0NsYXNzICsgJyYnICtcclxuICAgICAgICAgICAgJ2dyYXBoPScgKyBfZ3JhcGggKyAnJicgK1xyXG4gICAgICAgICAgICAncmVzb3VyY2U9JyArIHJlc291cmNlICsgJyYnICtcclxuICAgICAgICAgICAgJ2NvbmZpZ0dyYXBoPScgKyBfY29uZmlnR3JhcGggKyAnJicgK1xyXG4gICAgICAgICAgICAnX2Jhc2U9JyArIF9iYXNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFZpZXdDbGFzc1VybCAocmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX3NlcnZlclVSTCArICc/JyArXHJcbiAgICAgICAgICAgICdfdmlld0NsYXNzPScgKyBfdmNWaWV3Q2xhc3MgKyAnJicgK1xyXG4gICAgICAgICAgICAnZ3JhcGg9JyArIF9ncmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdyZXNvdXJjZT0nICsgcmVzb3VyY2UgKyAnJicgK1xyXG4gICAgICAgICAgICAnY29uZmlnR3JhcGg9JyArIF9jb25maWdHcmFwaCArICcmJyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RmV0Y2hEYXRhVXJsIChmb2N1c05vZGUsIHZpZXdGcmFtZSwgbGluZWFnZUdyYW1WaWV3Q2xhc3MsIGRpYWdyYW1UeXBlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgZGF0YVVybCA9IF9zZXJ2ZXJVUkwgKyAnPycgK1xyXG4gICAgICAgICAgICAnX3ZpZXdDbGFzcz0nICsgKGxpbmVhZ2VHcmFtVmlld0NsYXNzIHx8IF9kZWZhdWx0TGluZWFnZUdyYW1WaWV3Q2xhc3MpICsgJyYnICtcclxuICAgICAgICAgICAgJ2dyYXBoPScgKyBfZ3JhcGggKyAnJicgK1xyXG4gICAgICAgICAgICAnZm9jdXNOb2RlPScgKyBlbmNvZGVVUklDb21wb25lbnQoZm9jdXNOb2RlKSArICcmJyArXHJcbiAgICAgICAgICAgICdfYmFzZT0nICsgX2Jhc2U7XHJcblxyXG4gICAgICAgIGlmICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgZGF0YVVybCArPSAnJnZpZXdGcmFtZT0nICsgdmlld0ZyYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9mZnNldCkge1xyXG4gICAgICAgICAgICBkYXRhVXJsICs9ICcmb2Zmc2V0PScgKyBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX3JlYWNoKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZyZWFjaD0nICsgX3JlYWNoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9yYW5nZSkge1xyXG4gICAgICAgICAgICBkYXRhVXJsICs9ICcmcmFuZ2U9JyArIF9yYW5nZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfYnJlYWR0aCkge1xyXG4gICAgICAgICAgICBkYXRhVXJsICs9ICcmYnJlYWR0aD0nICsgX2JyZWFkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2RlcHRoKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZkZXB0aD0nICsgX2RlcHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpYWdyYW1UeXBlKSB7XHJcbiAgICAgICAgICAgIGRhdGFVcmwgKz0gJyZkaWFncmFtVHlwZT0nICsgZGlhZ3JhbVR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YVVybDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZXhlY3V0UXVlcnkgKHVybCkge1xyXG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXHJcbiAgICAgICAgICAgIG1vZGU6ICdjb3JzJyxcclxuICAgICAgICAgICAgY2FjaGU6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3R1cnRsZScsXHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpOyAvLyBBbHNvIHBvc3NpYmxlIHRvIHVzZTogcmVzcG9uc2UudGV4dCgpOyAvL3Jlc3BvbnNlLnR5cGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcG9zdFF1ZXJ5ICh1cmwsIHBhcmFtcykge1xyXG5cclxuICAgICAgICBsZXQgcmVxdWVzdEFyZ3MgPSB7fTtcclxuXHJcbiAgICAgICAgaWYocGFyYW1zICE9IG51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBwYXJhbXMpe1xyXG4gICAgICAgICAgICAgICAgLy9kZWNvZGUgZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3Nba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocmVxdWVzdEFyZ3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxyXG4gICAgICAgICAgICBjYWNoZTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvdHVydGxlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogcXVlcnlQYXJhbXNcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7IC8vIEFsc28gcG9zc2libGUgdG8gdXNlOiByZXNwb25zZS50ZXh0KCk7IC8vcmVzcG9uc2UudHlwZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldERlcml2YXRpb25EYXRhUGFyYW1zIChsZWZ0Tm9kZSwgcmlnaHROb2RlLCBsaW5rVHlwZSwgYWN0aXZlUmVzb3VyY2VzTGlzdCkge1xyXG5cclxuICAgICAgICBsZXQgZGVyaXZhdGlvblBhcmFtcyA9IHtcclxuICAgICAgICAgICAgX2Jhc2U6IF9iYXNlLFxyXG4gICAgICAgICAgICBfdmlld0NsYXNzOl9kbVZpZXdDbGFzcyxcclxuICAgICAgICAgICAgbGVmdE5vZGU6bGVmdE5vZGUsXHJcbiAgICAgICAgICAgIHJpZ2h0Tm9kZTpyaWdodE5vZGUsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihsaW5rVHlwZSl7XHJcbiAgICAgICAgICAgIGRlcml2YXRpb25QYXJhbXNbJ2xpbmtUeXBlJ10gPSBsaW5rVHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGFjdGl2ZVJlc291cmNlc0xpc3Qpe1xyXG4gICAgICAgICAgICBkZXJpdmF0aW9uUGFyYW1zWydhY3RpdmVSZXNvdXJjZXNMaXN0J10gPSBhY3RpdmVSZXNvdXJjZXNMaXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRlcml2YXRpb25QYXJhbXM7XHJcblxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IERlZmF1bHREYXRhUHJvdmlkZXI7XHJcbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgaW1hZ2VzIGZyb20gJy4vYmFzZTY0SW1hZ2VzJztcclxuXHJcbmV4cG9ydCBjb25zdCBGRUVEX1BJUEVfVFlQRSA9ICdmZWVkcGlwZSc7XHJcblxyXG5leHBvcnQgY29uc3QgTEdfR1JPVVBfVFlQRV9JRCA9ICd0cS1sZy1ncm91cCc7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9ERVJJVkFUSU9OX01BUF9MSU5LX1NUWUxFID0ge1xyXG4gICAgY3NzQ2xhc3M6ICdkZXJpdmF0aW9uLWxpbmsnLFxyXG4gICAgbGluZVR5cGU6ICdzb2xpZCcsIC8vICdkYXNoZWQnXHJcbiAgICBjb2xvcjogJ2JsYWNrJyxcclxuICAgIHRleHRDb2xvcjogJ2JsYWNrJyxcclxuICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsIFxyXG4gICAgdGhpY2tuZXNzOiAyLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTElOS19TVFlMRSA9IHtcclxuICAgIGNzc0NsYXNzOiAnbGluZWFnZS1ncmFtLWxpbmsnLFxyXG4gICAgbGluZVR5cGU6ICdzb2xpZCcsIC8vICdkYXNoZWQnXHJcbiAgICBjb2xvcjogJyMzYzQyNjAnLFxyXG4gICAgdG9vbEJ1dHRvbjoge1xyXG4gICAgICAgIGltYWdlOiBpbWFnZXMuTElOS19PUFRJT05TLFxyXG4gICAgICAgIHdpZHRoOiAzMCxcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIGFsd2F5c1Zpc2libGU6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHRoaWNrbmVzczogMixcclxuICAgIGhhc0Fycm93OiB0cnVlLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfR1JPVVBfTElOS19TVFlMRSA9IHtcclxuICAgIGNzc0NsYXNzOiAnbGluZWFnZS1ncmFtLWxpbmtzLWdyb3VwJyxcclxuICAgIGxpbmVUeXBlOiAnc29saWQnLCAvLyAnZGFzaGVkJ1xyXG4gICAgY29sb3I6ICcjM2M0MjYwJyxcclxuICAgIHRoaWNrbmVzczogMixcclxuICAgIGhhc0Fycm93OiB0cnVlLFxyXG4gICAgdG9vbEJ1dHRvbjoge1xyXG4gICAgICAgIGFsd2F5c1Zpc2libGU6IHRydWUsXHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgRkVFRF9QSVBFX0xJTktfU1RZTEUgPSB7XHJcbiAgICBjc3NDbGFzczogJ2xpbmVhZ2UtZ3JhbS1mZWVkLXBpcGUtbGluaycsXHJcbiAgICBsaW5lVHlwZTogJ3NvbGlkJywgLy8gJ2Rhc2hlZCdcclxuICAgIGNvbG9yOiAnIzNjNDI2MCcsXHJcbiAgICB0b29sQnV0dG9uOiB7XHJcbiAgICAgICAgaW1hZ2U6IGltYWdlcy5GRUVEX1BJUEUsXHJcbiAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgIGhlaWdodDogMzAsXHJcbiAgICAgICAgYWx3YXlzVmlzaWJsZTogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICB0aGlja25lc3M6IDMsXHJcbiAgICBoYXNBcnJvdzogdHJ1ZSxcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBSZXNvdXJjZVByb3ZpZGVyIChfcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5nZXRMaW5rU3R5bGUgPSBfZ2V0TGlua1N0eWxlO1xyXG4gICAgc2VsZi5nZXRJbWFnZSA9IF9nZXRJbWFnZTtcclxuICAgIHNlbGYuZ2V0Q29sb3IgPSBfZ2V0Q29sb3I7XHJcbiAgICBzZWxmLmdldEljb24gPSBfZ2V0SWNvbjtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0Q29sb3IgKHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd3aGl0ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMuY29sb3JzWydkZWZhdWx0J107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmNvbG9yc1t0eXBlXSB8fCBfcGFyYW1ldGVycy5jb2xvcnNbJ2RlZmF1bHQnXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEltYWdlICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZXMuVU5LTk9XX0lNQUdFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIV9wYXJhbWV0ZXJzLmltYWdlc1t0eXBlXSAmJiB0eXBlID09PSAnbGluay1vcHRpb25zJyB8fCB0eXBlID09PSAnZGVmYXVsdC1saW5rLW9wdGlvbnMnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZXMuTElOS19PUFRJT05TO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIV9wYXJhbWV0ZXJzLmltYWdlc1t0eXBlXSAmJiB0eXBlID09PSAnZmVlZC1waXBlJyB8fCB0eXBlID09PSAnZGVmYXVsdC1mZWVkLXBpcGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZXMuRkVFRF9QSVBFO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMucmVzb3VyY2VQYXRoICsgKFxyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5pbWFnZXNbdHlwZV0gfHxcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuaW1hZ2VzWyd1bmtub3duJ10gfHxcclxuICAgICAgICAgICAgaW1hZ2VzLlVOS05PV19JTUFHRVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRMaW5rU3R5bGUgKHR5cGUpIHtcclxuICAgICAgICBjb25zdCBsaW5rU3R5bGVzID0gX3BhcmFtZXRlcnMubGlua1N0eWxlcztcclxuICAgICAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBfLmNsb25lRGVlcChsaW5rU3R5bGVzWydkZWZhdWx0LWxpbmstc3R5bGUnXSB8fCBERUZBVUxUX0xJTktfU1RZTEUpO1xyXG5cclxuICAgICAgICBsZXQgbGlua1N0eWxlO1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICBsaW5rU3R5bGUgPSBkZWZhdWx0U3R5bGUgfHwgZGVmYXVsdFN0eWxlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5rU3R5bGVzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rU3R5bGUgPSBsaW5rU3R5bGVzW3R5cGVdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlID0gZGVmYXVsdFN0eWxlIHx8IGRlZmF1bHRTdHlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXy5tZXJnZShkZWZhdWx0U3R5bGUsIGxpbmtTdHlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEljb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzLmljb25zW3R5cGVdO1xyXG5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSBcInZpc3VhbGl6YXRpb25zLWxpYnJhcnlcIjtcclxuaW1wb3J0IHsgVmlld0ZyYW1lQnV0dG9ucyB9IGZyb20gXCIuL3ZpZXdGcmFtZUJ1dHRvbnNcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi9tYXBcIjtcclxuaW1wb3J0IEluZm9QYW5lbCBmcm9tIFwiLi9pbmZvUGFuZWxcIjtcclxuaW1wb3J0IE9wdGlvbnNQYW5lbCBmcm9tIFwiLi9vcHRpb25zUGFuZWxcIjtcclxuXHJcbi8qKlxyXG4gKiBQYXJhbWV0ZXJzIHNldCBmb3IgYSB7QGxpbmsgVG9vbGJhcn0uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRVSU9wdGlvbnNcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudCB8IFN0cmluZ30gYmFzZUVsZW1lbnQgLSBSb290IEhUTUxFbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExlZ2VuZERlc2NyaXB0b3I+fSBsZWdlbmRzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuZWlnaGJvckdyYW1WaWV3Q2xhc3NcclxuICovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEZWZhdWx0VUlPcHRpb25zfSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGVmYXVsdFVJKG9wdGlvbnMpIHtcclxuICBjb25zdCBzZWxmID0gdGhpcztcclxuICAvLyBJbml0aWFsaXphdGlvblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG4gIGNvbnN0IG1hcmt1cCA9IGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwidHEtbGctZGVmYXVsdC11c2VyLXVpXCI+XHJcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJ0cUxnVG9vbGJhclwiPjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGlkPVwidHFMZ01pbmlNYXBcIj48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBpZD1cInRxTGdJbmZvUGFuZWxcIj48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBpZD1cInRxTGdPcHRpb25zUGFuZWxcIj48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBpZD1cInRxTGdTZWFyY2hQYW5lbFwiPjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYDtcclxuXHJcbiAgbGV0IF9lbDtcclxuICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIF9lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuYmFzZUVsZW1lbnQpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIF9lbCA9IG9wdGlvbnMuYmFzZUVsZW1lbnQ7XHJcbiAgfVxyXG4gIGlmICghX2VsKSByZXR1cm47XHJcbiAgX2VsLmlubmVySFRNTCA9IG1hcmt1cDtcclxuXHJcbiAgY29uc3QgdHFMZ1Rvb2xiYXIgPSBfZWwucXVlcnlTZWxlY3RvcihcIiN0cUxnVG9vbGJhclwiKTtcclxuICBjb25zdCB0cUxnTWluaU1hcCA9IF9lbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdNaW5pTWFwXCIpO1xyXG4gIGNvbnN0IHRxTGdJbmZvUGFuZWwgPSBfZWwucXVlcnlTZWxlY3RvcihcIiN0cUxnSW5mb1BhbmVsXCIpO1xyXG4gIGNvbnN0IHRxTGdPcHRpb25zUGFuZWwgPSBfZWwucXVlcnlTZWxlY3RvcihcIiN0cUxnT3B0aW9uc1BhbmVsXCIpO1xyXG4gIGNvbnN0IHRxTGdTZWFyY2hQYW5lbCA9IF9lbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdTZWFyY2hQYW5lbFwiKTtcclxuXHJcbiAgbGV0IF96b29taW5nID0gX2xpbmVhZ2VHcmFtLnpvb20oKTtcclxuICBsZXQgX2V4cGFuZEFsbCA9IGZhbHNlO1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgY29uc3QgX2NvbG9yZWRCdXR0b25zID0gbmV3IFZpZXdGcmFtZUJ1dHRvbnMoe1xyXG4gICAgbGluZWFnZUdyYW06IF9saW5lYWdlR3JhbSxcclxuICB9KTtcclxuICBjb25zdCBfc3dpdGNoZXIgPSBuZXcgVFFHcmFtVUkuU3dpdGNoZXIoe1xyXG4gICAgc3RhdGVzOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCJsaW5lYWdlRGlhZ3JhbVwiLFxyXG4gICAgICAgIGxhYmVsOiBcIkxpbmVhZ2UgZGlhZ3JhbSB2aWV3XCIsXHJcbiAgICAgICAgaWNvbjogXCJmYXMgZmEtY2xvbmVcIixcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBcImJpcmRFeWVcIixcclxuICAgICAgICBsYWJlbDogXCJCaXJkIGV5ZSB2aWV3XCIsXHJcbiAgICAgICAgaWNvbjogXCJmYXMgZmEtZXllXCIsXHJcbiAgICAgIH0sXHJcbiAgICBdLFxyXG4gICAgdmVydGljYWxPcmllbnRhdGlvbjogdHJ1ZSxcclxuICB9KTtcclxuXHJcbiAgX3N3aXRjaGVyLm9uKFwic3RhdGUtY2hhbmdlZFwiLCAodGFiSWQpID0+IHtcclxuICAgIF9saW5lYWdlR3JhbS5zZXRDdXJyZW50Vmlldyh0YWJJZCk7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IF90b29sYmFyID0gbmV3IFRRR3JhbVVJLlRvb2xiYXIoe1xyXG4gICAgYmFzZUVsZW1lbnQ6IHRxTGdUb29sYmFyLFxyXG4gICAgdG9vbHM6IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBcInRxTGdTZWFyY2hcIixcclxuICAgICAgICBpY29uOiBcImZhcyBmYS1zZWFyY2hcIixcclxuICAgICAgICBsYWJlbDogXCJTZWFyY2hcIixcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiBcInRxTGdab29tSW5cIixcclxuICAgICAgICBpY29uOiBcImZhcyBmYS1zZWFyY2gtcGx1c1wiLFxyXG4gICAgICAgIGxhYmVsOiBcIlpvb20gaW5cIixcclxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgX3pvb21pbmcgPSBfbGluZWFnZUdyYW0uem9vbUluKCk7XHJcbiAgICAgICAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdab29tSW5cIikuZGlzYWJsZWQgPVxyXG4gICAgICAgICAgICBfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1heDtcclxuICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdHFMZ1pvb21PdXRcIikuZGlzYWJsZWQgPVxyXG4gICAgICAgICAgICBfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1pbjtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IFwidHFMZ1pvb21PdXRcIixcclxuICAgICAgICBpY29uOiBcImZhcyBmYS1zZWFyY2gtbWludXNcIixcclxuICAgICAgICBsYWJlbDogXCJab29tIG91dFwiLFxyXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBfem9vbWluZyA9IF9saW5lYWdlR3JhbS56b29tT3V0KCk7XHJcbiAgICAgICAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdab29tSW5cIikuZGlzYWJsZWQgPVxyXG4gICAgICAgICAgICBfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1heDtcclxuICAgICAgICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdHFMZ1pvb21PdXRcIikuZGlzYWJsZWQgPVxyXG4gICAgICAgICAgICBfem9vbWluZy5jdXIgPT09IF96b29taW5nLm1pbjtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IFwidHFMZ1pvb21Ub0ZpdFwiLFxyXG4gICAgICAgIGljb246IFwiZmFzIGZhLWV4cGFuZFwiLFxyXG4gICAgICAgIGxhYmVsOiBcIlpvb20gdG8gZml0XCIsXHJcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIF96b29taW5nID0gX2xpbmVhZ2VHcmFtLnpvb21Ub0ZpdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCJ0cUxnUmVzZXRcIixcclxuICAgICAgICBpY29uOiBcImZhcyBmYS1zeW5jXCIsXHJcbiAgICAgICAgbGFiZWw6IFwiUmVzZXQgbGF5b3V0XCIsXHJcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIF9saW5lYWdlR3JhbS5yZXNldExheW91dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCJ0cUxnR2F0aGVyXCIsXHJcbiAgICAgICAgaWNvbjogXCJmYXMgZmEtdGh1bWJ0YWNrXCIsXHJcbiAgICAgICAgbGFiZWw6IFwiR2F0aGVyIHJlbGF0aXZlc1wiLFxyXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBfbGluZWFnZUdyYW0uY29tYmluZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCJleHBhbmRBbGxcIixcclxuICAgICAgICBpY29uOiBcImZhcyBmYS1jb21wcmVzcy1hbHRcIixcclxuICAgICAgICBpY29uMjogXCJmYXMgZmEtZXhwYW5kLWFsdFwiLFxyXG4gICAgICAgIGxhYmVsOiBcIkV4cGFuZCBhbGwgbm9kZXNcIixcclxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKF9leHBhbmRBbGwpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VHcmFtLmV4cGFuZEFsbE5vZGVzKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfbGluZWFnZUdyYW0uY29sbGFwc2VBbGxOb2RlcygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX2V4cGFuZEFsbCA9ICFfZXhwYW5kQWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIF9jb2xvcmVkQnV0dG9ucyxcclxuICAgICAgX3N3aXRjaGVyLFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IFwiaW5mb1BhbmVsQnRuXCIsXHJcbiAgICAgICAgaWNvbjogXCJmYXMgZmEtaW5mby1jaXJjbGVcIixcclxuICAgICAgICBsYWJlbDogXCJJbmZvIFBhbmVsXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogXCJ0cUxnT3B0aW9uc0J1dHRvblwiLFxyXG4gICAgICAgIGljb246IFwiZmFzIGZhLWJhcnNcIixcclxuICAgICAgICBsYWJlbDpcIk9wdGlvbnMgUGFuZWxcIixcclxuICAgICAgfSxcclxuICAgIF0sXHJcbiAgfSk7XHJcbiAgc2VsZi50b29sYmFyID0gX3Rvb2xiYXI7XHJcblxyXG4gIF9saW5lYWdlR3JhbS5vbihcImN1cnJlbnQtdmlldy1jaGFuZ2VkXCIsICh2aWV3SWQpID0+IHtcclxuICAgIGNvbnN0IGRpc2FibGVkID0gdmlld0lkICE9PSBcImxpbmVhZ2VEaWFncmFtXCI7XHJcbiAgICBfc3dpdGNoZXIuc2V0U3RhdGUodmlld0lkKTtcclxuICAgIF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjZXhwYW5kQWxsXCIpLmRpc2FibGVkID0gZGlzYWJsZWQ7XHJcbiAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdSZXNldFwiKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cUxnWm9vbUluXCIpLmRpc2FibGVkID0gZGlzYWJsZWQ7XHJcbiAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdab29tT3V0XCIpLmRpc2FibGVkID0gZGlzYWJsZWQ7XHJcbiAgICBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdab29tVG9GaXRcIikuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICB9KTtcclxuXHJcbiAgbmV3IFRRR3JhbVVJLlNlYXJjaFBhbmVsKHtcclxuICAgIGJhc2VFbGVtZW50OiB0cUxnU2VhcmNoUGFuZWwsXHJcbiAgICB0cmlnZ2VyQnV0dG9uOiBfdG9vbGJhci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxTGdTZWFyY2hcIiksXHJcbiAgICBhY3RpdmU6IGZhbHNlLFxyXG4gIH0pO1xyXG5cclxuICBuZXcgSW5mb1BhbmVsKHtcclxuICAgIGJhc2VFbGVtZW50OiB0cUxnSW5mb1BhbmVsLFxyXG4gICAgYWN0aXZlOiBmYWxzZSxcclxuICAgIHRyaWdnZXJCdXR0b246IF90b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjaW5mb1BhbmVsQnRuXCIpLFxyXG4gICAgbGluZWFnZUdyYW06IF9saW5lYWdlR3JhbSxcclxuICB9KTtcclxuXHJcbiAgbmV3IE9wdGlvbnNQYW5lbCh7XHJcbiAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtLFxyXG4gICAgYmFzZUVsZW1lbnQ6IHRxTGdPcHRpb25zUGFuZWwsXHJcbiAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgdHJpZ2dlckJ1dHRvbjogX3Rvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cUxnT3B0aW9uc0J1dHRvblwiKSxcclxuICAgIGxlZ2VuZHM6IG9wdGlvbnMubGVnZW5kcyxcclxuICAgIG9uUHJlc3NIZWxwOiBvcHRpb25zLm9uUHJlc3NIZWxwLFxyXG4gIH0pO1xyXG5cclxuICBuZXcgTWFwKHtcclxuICAgIGJhc2VFbGVtZW50OiB0cUxnTWluaU1hcCxcclxuICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICBsaW5lYWdlR3JhbTogX2xpbmVhZ2VHcmFtLFxyXG4gICAgcG9zaXRpb246IHtcclxuICAgICAgeDogXCJjYWxjKDEwMCUgLSAyNjVweClcIixcclxuICAgICAgeTogXCJjYWxjKDEwMCUgLSAyNjVweClcIixcclxuICAgIH0sXHJcbiAgfSk7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdFVJO1xyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSBcInZpc3VhbGl6YXRpb25zLWxpYnJhcnlcIjtcclxuaW1wb3J0IHsgRE1JbmZvUGFuZWwgfSBmcm9tIFwiLi9kbUluZm9QYW5lbFwiO1xyXG5cclxuLyoqXHJcbiAqIFBhcmFtZXRlcnMgc2V0IGZvciBhIHtAbGluayBUb29sYmFyfS5cclxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdFVJT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBiYXNlRWxlbWVudCAtIFJvb3QgSFRNTEVsZW1lbnRcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgTGVnZW5kRGVzY3JpcHRvcj59IGxlZ2VuZHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5laWdoYm9yR3JhbVZpZXdDbGFzc1xyXG4gKiBAcHJvcGVydHkge0Rlcml2YXRpb25NYXB9IGRlcml2YXRpb25NYXBcclxuICovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtEZWZhdWx0VUlPcHRpb25zfSBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRE1EZWZhdWx0VUkob3B0aW9ucykge1xyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gIGNvbnN0IF9kZXJpdmF0aW9uTWFwID0gb3B0aW9ucy5kZXJpdmF0aW9uTWFwO1xyXG4gIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2UoXHJcbiAgICBfZ2V0SHRtbEVsZW1lbnQob3B0aW9ucy5iYXNlRWxlbWVudCksXHJcbiAgICBfZ2V0SHRtbEVsZW1lbnQob3B0aW9ucy5pbmZvUGFuZWwpXHJcbiAgKTtcclxuICBsZXQgX2V4cGFuZEFsbCA9IHRydWU7XHJcbiAgbGV0IF9kaWFncmFtSW5mbyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgLy8gSW5pdGlhbGl6YXRpb25cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBsZXQgYmFzZVRvb2xzID0gW1xyXG4gICAge1xyXG4gICAgICBpZDogXCJ0cURNU2VhcmNoXCIsXHJcbiAgICAgIGljb246IFwiZmFzIGZhLXNlYXJjaFwiLFxyXG4gICAgICBsYWJlbDogXCJTZWFyY2hcIixcclxuICAgICAgY2FsbGJhY2s6IF9vcGVuQ2xvc2VTZWFyY2hQYW5lbCxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGlkOiBcInRxRE1FeHBvcnRTVkdcIixcclxuICAgICAgaWNvbjogXCJ0b29sLWJhci1zdmctaWNvblwiLFxyXG4gICAgICBsYWJlbDogXCJFeHBvcnQgdG8gU1ZHXCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgX2Rlcml2YXRpb25NYXAuZXhwb3J0VG9TdmcoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGlkOiBcInRxRE1FeHBvcnRQTkdcIixcclxuICAgICAgaWNvbjogXCJ0b29sLWJhci1wbmctaWNvblwiLFxyXG4gICAgICBsYWJlbDogXCJFeHBvcnQgdG8gUE5HXCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgX2Rlcml2YXRpb25NYXAuZXhwb3J0VG9QbmcoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGlkOiBcInRxUHJpbnRcIixcclxuICAgICAgaWNvbjogXCJmYXMgZmEtcHJpbnRcIixcclxuICAgICAgbGFiZWw6IFwiUHJpbnRcIixcclxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICBfZGVyaXZhdGlvbk1hcC5wcmludCgpO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgaWQ6IFwidHFETVpvb21JblwiLFxyXG4gICAgICBpY29uOiBcImZhcyBmYS1zZWFyY2gtcGx1c1wiLFxyXG4gICAgICBsYWJlbDogXCJab29tIGluXCIsXHJcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XHJcbiAgICAgICAgX2Rlcml2YXRpb25NYXAuem9vbUluKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBpZDogXCJ0cURNWm9vbU91dFwiLFxyXG4gICAgICBpY29uOiBcImZhcyBmYS1zZWFyY2gtbWludXNcIixcclxuICAgICAgbGFiZWw6IFwiWm9vbSBvdXRcIixcclxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICBfZGVyaXZhdGlvbk1hcC56b29tT3V0KCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBpZDogXCJ0cURNWm9vbVRvRml0XCIsXHJcbiAgICAgIGljb246IFwiZmFzIGZhLWV4cGFuZFwiLFxyXG4gICAgICBsYWJlbDogXCJab29tIHRvIGZpdFwiLFxyXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgIF9kZXJpdmF0aW9uTWFwLnpvb21Ub0ZpdCgpO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgaWQ6IFwiaW5mb1BhbmVsQnRuXCIsXHJcbiAgICAgIGljb246IFwiZmFzIGZhLWluZm8tY2lyY2xlXCIsXHJcbiAgICAgIGxhYmVsOiBcIk9wZW4gSW5mbyBwYW5lbFwiLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgaWQ6IFwiZXhwYW5kQWxsXCIsXHJcbiAgICAgIGljb246IFwiZmFzIGZhLWNvbXByZXNzLWFsdFwiLFxyXG4gICAgICBpY29uMjogXCJmYXMgZmEtZXhwYW5kLWFsdFwiLFxyXG4gICAgICBsYWJlbDogXCJFeHBhbmQgYWxsXCIsXHJcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9leHBhbmRBbGwpIHtcclxuICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLmV4cGFuZEFsbEVsZW1lbnRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIF9kZXJpdmF0aW9uTWFwLmNvbGxhcHNlQWxsRWxlbWVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2V4cGFuZEFsbCA9ICFfZXhwYW5kQWxsO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICBdO1xyXG5cclxuICBpZiAob3B0aW9ucy50b29scykge1xyXG4gICAgb3B0aW9ucy50b29scy5mb3JFYWNoKCh0b29sKSA9PiB7XHJcbiAgICAgIGlmICh0b29sLnBvc2l0aW9uIDwgYmFzZVRvb2xzLmxlbmd0aCkge1xyXG4gICAgICAgIGJhc2VUb29scy5zcGxpY2UodG9vbC5wb3NpdGlvbiwgMCwgdG9vbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmFzZVRvb2xzLnB1c2godG9vbCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc2VsZi50b29sYmFyID0gbmV3IFRRR3JhbVVJLlRvb2xiYXIoe1xyXG4gICAgYmFzZUVsZW1lbnQ6IF9iYXNlLnRvb2xiYXIsXHJcbiAgICB0b29sczogYmFzZVRvb2xzLFxyXG4gIH0pO1xyXG5cclxuICBzZWxmLmluZm9QYW5lbCA9IG5ldyBETUluZm9QYW5lbCh7XHJcbiAgICBiYXNlRWxlbWVudDogX2Jhc2UuaW5mb1BhbmVsLFxyXG4gICAgdHJpZ2dlckJ1dHRvbjogc2VsZi50b29sYmFyLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjaW5mb1BhbmVsQnRuXCIpLFxyXG4gIH0pO1xyXG5cclxuICBzZWxmLmluZm9QYW5lbC5vbihcInNpemUtY2hhbmdlZFwiLCAoKSA9PiBfZGVyaXZhdGlvbk1hcC5yZXNldEZvY3VzKCkpO1xyXG5cclxuICBzZWxmLmluZm9QYW5lbC5vbihcImVsZW1lbnQtY2xpY2tcIiwgKGVsZW1lbnRJZCkgPT4ge1xyXG4gICAgX2Rlcml2YXRpb25NYXAuc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRJZCk7XHJcbiAgfSk7XHJcblxyXG4gIF9kZXJpdmF0aW9uTWFwLm9uKFwiZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkXCIsIChzdGF0ZUlkKSA9PiB7XHJcbiAgICBpZiAoc3RhdGVJZCA9PT0gXCJjb21wbGV0ZWRcIikge1xyXG4gICAgICBfZGlhZ3JhbUluZm8gPSBfZGVyaXZhdGlvbk1hcC5nZXREaWFncmFtSW5mbygpO1xyXG4gICAgICBpZiAoX2RpYWdyYW1JbmZvICYmIF9kaWFncmFtSW5mby50aXRsZSkge1xyXG4gICAgICAgIF9iYXNlLmRpYWdyYW1UaXRsZS5pbm5lclRleHQgPSBfZGlhZ3JhbUluZm8udGl0bGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2Jhc2UuZGlhZ3JhbVRpdGxlLmlubmVyVGV4dCA9IFwiXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBsZXQgc2VhcmNoUGFuZVZpc2libGUgPSBmYWxzZTtcclxuICBsZXQgZGVib3VuY2UgPSBmYWxzZTtcclxuICBjb25zdCBzZWFyY2hCdXR0b24gPSBzZWxmLnRvb2xiYXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cURNU2VhcmNoXCIpO1xyXG4gIGNvbnN0IHNlYXJjaElucHV0ID0gX2Jhc2Uuc2VhcmNoUGFuZWwucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xyXG4gIHNlYXJjaElucHV0Lm9ua2V5dXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZGVib3VuY2UpIGNsZWFyVGltZW91dChkZWJvdW5jZSk7XHJcblxyXG4gICAgZGVib3VuY2UgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgY29uc3Qgc2VhcmNoS2V5ID0gc2VhcmNoSW5wdXQudmFsdWU7XHJcbiAgICAgIF9kZXJpdmF0aW9uTWFwLnNldFNlYXJjaEtleShzZWFyY2hLZXkpO1xyXG4gICAgfSwgMzAwKTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIF9vcGVuQ2xvc2VTZWFyY2hQYW5lbCgpIHtcclxuICAgIGlmIChzZWFyY2hQYW5lVmlzaWJsZSkge1xyXG4gICAgICBfZGVyaXZhdGlvbk1hcC5zZXRTZWFyY2hLZXkodW5kZWZpbmVkKTtcclxuICAgICAgX2Jhc2Uuc2VhcmNoUGFuZWwuY2xhc3NMaXN0LmFkZChcInRxLWRtLWhpZGRlblwiKTtcclxuICAgICAgc2VhcmNoQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cS11aS1zZWxlY3RlZFwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9kZXJpdmF0aW9uTWFwLnNldFNlYXJjaEtleShzZWFyY2hJbnB1dC52YWx1ZSk7XHJcbiAgICAgIF9iYXNlLnNlYXJjaFBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJ0cS1kbS1oaWRkZW5cIik7XHJcbiAgICAgIHNlYXJjaEJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwidHEtdWktc2VsZWN0ZWRcIik7XHJcbiAgICB9XHJcbiAgICBzZWFyY2hQYW5lVmlzaWJsZSA9ICFzZWFyY2hQYW5lVmlzaWJsZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRIdG1sRWxlbWVudChiYXNlRWxlbWVudCkge1xyXG4gICAgbGV0IGJhc2VIdG1sO1xyXG4gICAgaWYgKHR5cGVvZiBiYXNlRWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBiYXNlSHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGJhc2VFbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJhc2VFbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIGJhc2VIdG1sID0gYmFzZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIWJhc2VIdG1sKSB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlIGVsZW1lbnQgaXMgbm90IGZvdW5kIVwiKTtcclxuICAgIHJldHVybiBiYXNlSHRtbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgaHRtbCBtYXJrdXAuXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sTm9kZSAtIFJvb3Qgbm9kZSBmb3IgbWFya3VwXHJcbiAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCBIVE1MRWxlbWVudD59IC0gTWFwIG9mIGh0bWwgZWxlbWVudHNcclxuICAgKi9cclxuICBmdW5jdGlvbiBfY3JlYXRlQmFzZShodG1sTm9kZSwgaW5mb1BhbmVsKSB7XHJcbiAgICBodG1sTm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgaHRtbE5vZGUudGFiSW5kZXggPSAwO1xyXG5cclxuICAgIGNvbnN0IHRvb2xiYXJCYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgIHRvb2xiYXJCYXNlLmNsYXNzTmFtZSA9IFwidHEtZGVyaXZhdGlvbi1tYXBfX3Rvb2xiYXJcIjtcclxuICAgIHRvb2xiYXJCYXNlLmlkID0gXCJ0cS1kZXJpdmF0aW9uLW1hcC10b29sYmFyXCI7XHJcbiAgICBodG1sTm9kZS5hcHBlbmRDaGlsZCh0b29sYmFyQmFzZSk7XHJcblxyXG4gICAgY29uc3QgZGlhZ3JhbVRpdGxlQ29udGFpbnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICBkaWFncmFtVGl0bGVDb250YWludGVyLmNsYXNzTmFtZSA9IFwidHEtZGVyaXZhdGlvbi1tYXBfY29udGFpbmVyXCI7XHJcbiAgICBjb25zdCBkaWFncmFtVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xyXG4gICAgZGlhZ3JhbVRpdGxlLmNsYXNzTmFtZSA9IFwidHEtZGVyaXZhdGlvbi1tYXBfY29udGFpbmVyX190aXRsZVwiO1xyXG4gICAgZGlhZ3JhbVRpdGxlLmlubmVyVGV4dCA9IFwiXCI7XHJcbiAgICBkaWFncmFtVGl0bGVDb250YWludGVyLmFwcGVuZENoaWxkKGRpYWdyYW1UaXRsZSk7XHJcbiAgICBodG1sTm9kZS5hcHBlbmRDaGlsZChkaWFncmFtVGl0bGVDb250YWludGVyKTtcclxuXHJcbiAgICBjb25zdCBzZWFyY2hQYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICBzZWFyY2hQYW5lbC5jbGFzc05hbWUgPSBcInRxLWRlcml2YXRpb24tbWFwX3NlYXJjaC1wYW5lIHRxLWRtLWhpZGRlblwiO1xyXG4gICAgc2VhcmNoUGFuZWwuaW5uZXJIVE1MID0gYFxyXG4gICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIGlkPVwidHEtZG0tc2VhcmNoLXBhbmVcIlxyXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS1kZXJpdmF0aW9uLW1hcF9zZWFyY2gtcGFuZV9faW5wdXRcIlxyXG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNlYXJjaCBpbnB1dCBmb3IgRGVyaXZhdGlvbiBNYXBcIj5cclxuICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICBgO1xyXG4gICAgaHRtbE5vZGUuYXBwZW5kQ2hpbGQoc2VhcmNoUGFuZWwpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNlYXJjaFBhbmVsOiBzZWFyY2hQYW5lbCxcclxuICAgICAgcm9vdEh0bWw6IGh0bWxOb2RlLFxyXG4gICAgICBpbmZvUGFuZWw6IGluZm9QYW5lbCxcclxuICAgICAgdG9vbGJhcjogdG9vbGJhckJhc2UsXHJcbiAgICAgIGRpYWdyYW1UaXRsZTogZGlhZ3JhbVRpdGxlLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRE1EZWZhdWx0VUk7XHJcbiIsImltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSBcIi4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI7XG5pbXBvcnQgeyBMaW5rLCBOb2RlIH0gZnJvbSBcIi4uL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9tYXBFbGVtZW50c1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGUgZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgRE1JbmZvUGFuZWx9IG9iamVjdC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IERNSW5mb1BhbmVsTW9kZWxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBiYXNlRWxlbWVudCAtIFJvb3QgZm9yIHRoaXMgcGFuZWxcbiAqIEBwcm9wZXJ0eSB7TGluZWFnZUdyYW19IGRlcml2YXRpb25NYXAgLSBEZXJpdmF0aW9uTWFwIG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RE1JbmZvUGFuZWxNb2RlbH0gLSBEYXRhIG1vZGVsLlxuICogQGZpcmVzIHNpemUtY2hhbmdlZFxuICogQGZpcmVzIGVsZW1lbnQtY2xpY2sgKGlkOnN0cmluZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIERNSW5mb1BhbmVsKHBhcmFtZXRlcnMpIHtcbiAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGlmICghcGFyYW1ldGVycykgcGFyYW1ldGVycyA9IHt9O1xuXG4gIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gcGFyYW1ldGVycy5zZWxlY3RlZEVsZW1lbnQ7XG4gIGxldCBfd2lkdGggPSAyNTA7XG4gIGxldCBfaGlkZGVuID0gdHJ1ZTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHNlbGYucm9vdEh0bWwgPSBfZ2V0RWxlbWVudChwYXJhbWV0ZXJzLmJhc2VFbGVtZW50KTtcblxuICBjb25zdCBfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgX2NvbnRhaW5lci5jbGFzc05hbWUgPSBcInRxLWxnLWRtLXByb3BlcnR5LXBhbmUtY29udGFpbmVyXCI7XG4gIHNlbGYucm9vdEh0bWwuYXBwZW5kQ2hpbGQoX2NvbnRhaW5lcik7XG5cbiAgY29uc3QgX3RyaWdnZXJCdXR0b24gPSBwYXJhbWV0ZXJzLnRyaWdnZXJCdXR0b247XG4gIF90cmlnZ2VyQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgaWYgKF9oaWRkZW4pIHtcbiAgICAgIF9zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IF9zbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICBfc2xpZGVyLmNsYXNzTmFtZSA9IFwidHEtbGctZG0tc2xpZGVyXCI7XG4gIF9zbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBldmVudCA9PiB7XG4gICAgX29uTW91c2Vkb3duKGV2ZW50KTtcbiAgfSk7XG4gIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoX3NsaWRlcik7XG5cbiAgY29uc3QgX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgX2Nsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiQ2xvc2UgaW5mbyBwYW5lbFwiKTtcbiAgX2Nsb3NlQnV0dG9uLmNsYXNzTmFtZSA9IFwidHEtbGctZG0taGlkZS1idXR0b25cIjtcbiAgX2Nsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgX2hpZGUoKTtcbiAgfTtcbiAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChfY2xvc2VCdXR0b24pO1xuXG4gIHNlbGYuYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gIF9jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5ib2R5KTtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHNlbGYuaWQgPSBcImRlcml2YXRpb25NYXBJbmZvUGFuZWxcIjtcbiAgc2VsZi5yZWRyYXcgPSBfcmVkcmF3O1xuICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IF9zZXRTZWxlY3RlZEVsZW1lbnQ7XG4gIHNlbGYuc2hvdyA9IF9zaG93O1xuICBzZWxmLmhpZGRlID0gX2hpZGU7XG4gIC8vIHdpZHRoOiAyNTBweDtcblxuICBfcmVkcmF3KCk7XG5cbiAgZnVuY3Rpb24gX3JlZHJhdygpIHtcbiAgICBpZiAoX2hpZGRlbikgcmV0dXJuO1xuICAgIGxldCBtYXJrdXA7XG4gICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBtYXJrdXAgPSBfZ2V0Tm9kZUluZm8oX3NlbGVjdGVkRWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBMaW5rKSB7XG4gICAgICAgIG1hcmt1cCA9IF9nZXRMaW5rSW5mbyhfc2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmt1cCA9IGBcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmUgdHEtbGctZG0tZW1wdHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+VW5rbm93biB0eXBlIG9mIGVsZW1lbnQ8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS1sZy1kbS1wcm9wZXJ0eS1wYW5lIHRxLWxnLWRtLWVtcHR5XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+U2VsZWN0IGEgZGlhZ3JhbSBlbGVtZW50PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBzZWxmLmJvZHkuc3R5bGUud2lkdGggPSBgJHtfd2lkdGh9cHhgO1xuICAgIHNlbGYuYm9keS5pbm5lckhUTUwgPSBtYXJrdXA7XG5cbiAgICBpZiAoX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2VsZi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudHEtbGctZG0tY2hpbGQtYnV0dG9uXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKFwiZWxlbWVudC1jbGlja1wiLCB0aGlzLmlkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBMaW5rKSB7XG4gICAgICBzZWxmLmJvZHkucXVlcnlTZWxlY3RvcihcIi50cS1sZy1kbS1zb3VyY2UtYnV0dG9uXCIpLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwiZWxlbWVudC1jbGlja1wiLCB0aGlzLmlkKTtcbiAgICAgIH07XG4gICAgICBzZWxmLmJvZHkucXVlcnlTZWxlY3RvcihcIi50cS1sZy1kbS10YXJnZXQtYnV0dG9uXCIpLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwiZWxlbWVudC1jbGlja1wiLCB0aGlzLmlkKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vLi4uXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2dldE5vZGVJbmZvKG5vZGUpIHtcbiAgICBjb25zdCBjaGlscmVuID0gbm9kZS5jaGlsZHJlblxuICAgICAgLm1hcChjaGlsZCA9PiB7XG4gICAgICAgIHJldHVybiBgPGRpdlxuICAgICAgICAgICAgICAgIGlkPVwiJHtjaGlsZC5pZH1cIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwiJHtjaGlsZC5sYWJlbH0oJHtjaGlsZC5lbmRwb2ludElkfSlcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRxLXVpLXByb3BlcnR5LWJ1dHRvbiB0cS1sZy1kbS1jaGlsZC1idXR0b25cIj5cbiAgICAgICAgICAgICAgICAke2NoaWxkLmxhYmVsfVxuICAgICAgICAgICAgPC9kaXY+YDtcbiAgICAgIH0pXG4gICAgICAuam9pbihcIlwiKTtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmVcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPklEPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCIke25vZGUuZW5kcG9pbnRJZH1cIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIiR7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZS5lbmRwb2ludElkXG4gICAgICAgICAgICAgICAgICAgIH1cIiB0eXBlPVwidGV4dFwiIGFyaWEtbGFiZWw9XCJJbnB1dCBmb3IgSURcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPkRpYWdyYW0gSUQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIiR7bm9kZS5pZH1cIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIiR7bm9kZS5pZH1cIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIlxuICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiSW5wdXQgZm9yIExhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCIke25vZGUubGFiZWx9XCIgdGl0bGU9XCIke1xuICAgICAgbm9kZS5sYWJlbFxuICAgIH1cIiB0eXBlPVwidGV4dFwiIGFyaWEtbGFiZWw9XCJJbnB1dCBmb3IgVHlwZXNcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+PC9pbnB1dD5cbiAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgY2hpbHJlbi5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gJzxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+Q2hpbGRyZW48L2xhYmVsPidcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR7Y2hpbHJlbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldExpbmtJbmZvKGxpbmspIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLWxnLWRtLXByb3BlcnR5LXBhbmVcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCIke2xpbmsubGFiZWx9XCIgdGl0bGU9XCIke2xpbmsubGFiZWx9XCIgdHlwZT1cInRleHRcIiBhcmlhLWxhYmVsPVwiSW5wdXQgZm9yIGxhYmVsXCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5Tb3VyY2U8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCIke2xpbmsuc291cmNlLmlkfVwiXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiJHtsaW5rLnNvdXJjZS5sYWJlbH0oJHtsaW5rLnNvdXJjZS5lbmRwb2ludElkfSlcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidHEtdWktcHJvcGVydHktYnV0dG9uIHRxLWxnLWRtLXNvdXJjZS1idXR0b25cIj5cbiAgICAgICAgICAgICAgICAgICAgJHtsaW5rLnNvdXJjZS5sYWJlbH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPlRhcmdldDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cIiR7bGluay50YXJnZXQuaWR9XCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9XCIke2xpbmsudGFyZ2V0LmxhYmVsfSgke2xpbmsudGFyZ2V0LmVuZHBvaW50SWR9KVwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eS1idXR0b24gdHEtbGctZG0tdGFyZ2V0LWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAke2xpbmsudGFyZ2V0LmxhYmVsfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gIH1cblxuICBjb25zdCBTRUxFQ1RFRF9DTEFTUyA9IFwidHEtdWktc2VsZWN0ZWRcIjtcbiAgZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgX2hpZGRlbiA9IGZhbHNlO1xuICAgIF9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IG51bGw7XG4gICAgX3RyaWdnZXJCdXR0b24uY2xhc3NMaXN0LmFkZChTRUxFQ1RFRF9DTEFTUyk7XG4gICAgX3JlZHJhdygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi50cmlnZ2VyKFwic2l6ZS1jaGFuZ2VkXCIpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgX2hpZGRlbiA9IHRydWU7XG4gICAgX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgX3RyaWdnZXJCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShTRUxFQ1RFRF9DTEFTUyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLnRyaWdnZXIoXCJzaXplLWNoYW5nZWRcIik7XG4gICAgfSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBfb25Nb3VzZWRvd24oZXZlbnQpIHtcbiAgICBsZXQgc3RhcnRYID0gMDtcbiAgICBjb25zdCBNSU5fV0lEVEggPSAxMDA7XG5cbiAgICBpZiAoZXZlbnQucGFnZVgpIHN0YXJ0WCA9IGV2ZW50LnBhZ2VYO1xuICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIHN0YXJ0WCA9IGV2ZW50LmNsaWVudFg7XG5cbiAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX29uY2hhbmdlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9vbm1vdXNldXApO1xuXG4gICAgZnVuY3Rpb24gX29uY2hhbmdlKGV2ZW50KSB7XG4gICAgICBsZXQgZW5kWCA9IDA7XG5cbiAgICAgIGlmIChldmVudC5wYWdlWCkgZW5kWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCkgZW5kWCA9IGV2ZW50LmNsaWVudFg7XG5cbiAgICAgIGNvbnN0IGRpZmZYID0gc3RhcnRYIC0gZW5kWDtcbiAgICAgIHN0YXJ0WCA9IGVuZFg7XG5cbiAgICAgIF93aWR0aCArPSBkaWZmWDtcbiAgICAgIF93aWR0aCA9IE1hdGgubWF4KE1JTl9XSURUSCwgX3dpZHRoKTtcbiAgICAgIHNlbGYudHJpZ2dlcihcInNpemUtY2hhbmdlZFwiKTtcbiAgICAgIF9yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25tb3VzZXVwKGV2ZW50KSB7XG4gICAgICBpZiAoc2VsZi5fbW91c2VNb3ZlKSB7XG4gICAgICAgIF9vbmNoYW5nZShldmVudCwgdHJ1ZSk7XG4gICAgICAgIHNlbGYuX21vdXNlTW92ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5vbm1vdXNlbW92ZSA9IGRvY3VtZW50LmJvZHkub25tb3VzZXVwID0gbnVsbDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfb25jaGFuZ2UpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfb25tb3VzZXVwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBfc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudDtcbiAgICBfcmVkcmF3KCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERNSW5mb1BhbmVsO1xuXG5mdW5jdGlvbiBfZ2V0RWxlbWVudChlbCkge1xuICBsZXQgZWxlbWVudDtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm9iamVjdFwiKSB7XG4gICAgZWxlbWVudCA9IGVsO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBJbmZvUGFuZWx9IG9iamVjdC5cclxuICogQHR5cGVkZWYge09iamVjdH0gSW5mb1BhbmVsTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IGJhc2VFbGVtZW50IC0gUm9vdCBmb3IgdGhpcyBwYW5lbFxyXG4gKiBAcHJvcGVydHkge0xpbmVhZ2VHcmFtfSBsaW5lYWdlR3JhbSAtIExpbmVhZ2VHcmFtIG9iamVjdC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBhY3RpdmUgLSBmYWxzZSAtIGNvbGxhcHNlZCwgdHJ1ZSAtIGV4cGFuZGVkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSB0cmlnZ2VyQnV0dG9uXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9uUHJlc3NFeHRlcm5hbFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB3aGljaCBpcyBhIHNpbXBsZSBVSSBwYW5lbC5cclxuICogVGhpcyBwYW5lbCBjYW4gcmVwcmVzZW50IGFuIGluZm9ybWF0aW9uIGFib3V0IHNlbGVjdGVkIGVsZW1lbnRcclxuICogYW5kIGFsc28sIGl0IHN1cHBvcnRzIHNpbXBsZSBuYXZpZ2F0aW9uIGJldHdlZW4gZWxlbWVudHMuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge0luZm9QYW5lbE1vZGVsfSBvcHRpb25zIC0gRGF0YSBtb2RlbC5cclxuICogQGZpcmVzIHN0YXRlLWNoYW5nZWRcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEluZm9QYW5lbCAob3B0aW9ucykge1xyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAgIC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuXHJcbiAgICBjb25zdCBpbmZvVGVtcGxhdGUgPSBuZXcgVFFHcmFtVUkuSW5mb1BhbmVsKHtsYXVuY2hFeHRlcm5hbDpvcHRpb25zLmxpbmVhZ2VHcmFtLmxhdW5jaEV4dGVybmFsfSk7XHJcblxyXG4gICAgY29uc3QgX2xpbmVhZ2VHcmFtID0gb3B0aW9ucy5saW5lYWdlR3JhbTtcclxuXHJcbiAgICBUUUdyYW1VSS5GbHlpbmdQYW5lbC5hcHBseSh0aGlzLCBbe1xyXG4gICAgICAgIGJhc2VFbGVtZW50OiBvcHRpb25zLmJhc2VFbGVtZW50LFxyXG4gICAgICAgIGFjdGl2ZTogb3B0aW9ucy5hY3RpdmUsXHJcbiAgICAgICAgaGVhZGVyOiAnSW5mbyBwYW5lbCcsXHJcbiAgICAgICAgdHJpZ2dlckJ1dHRvbjogb3B0aW9ucy50cmlnZ2VyQnV0dG9uLFxyXG4gICAgICAgIGxhdW5jaEV4dGVybmFsOiBvcHRpb25zLm9uUHJlc3NFeHRlcm5hbCxcclxuICAgICAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgICAgIHNpemU6IHsgd2lkdGg6ICczMDBweCcsIGhlaWdodDogJzQ1MHB4JyB9LFxyXG4gICAgICAgIGJvZHk6IGluZm9UZW1wbGF0ZSxcclxuICAgICAgICByZXNpemFibGU6IHRydWUsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLm9uKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBmdW5jdGlvbiAoZWxlbWVudE1vZGVsKSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhNb2RlbCA9IF9saW5lYWdlR3JhbS5nZXRHcmFwaE1vZGVsKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudE1vZGVsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbZWxlbWVudE1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbZWxlbWVudE1vZGVsLnRhcmdldF07XHJcblxyXG4gICAgICAgICAgICBsZXQgZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnRNb2RlbC5saW5rVHlwZSAmJiBlbGVtZW50TW9kZWwuZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5ncm91cC5mb3JFYWNoKGVsID0+IGRhdGEgPSBfLm1lcmdlKGRhdGEsIGVsLmRhdGEpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBfLmNsb25lRGVlcChlbGVtZW50TW9kZWwuZGF0YSkgfHwge307XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TW9kZWwubGlua1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TW9kZWwubGlua1R5cGUgJiYgIWVsZW1lbnRNb2RlbC5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbJ0xpbmsgdHlwZSddID0gZWxlbWVudE1vZGVsLmxpbmtUeXBlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlTWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1vZGVsLmdyb3VwLmZvckVhY2goZWwgPT4gdHlwZU1hcFtlbC5saW5rVHlwZV0gPSBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyh0eXBlTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWydMaW5rIHR5cGUnXSA9IGVsZW1lbnRNb2RlbC5saW5rVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVsnR3JvdXBlZCB0eXBlcyddID0gdHlwZXMuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhWydMaW5rIHR5cGUnXSA9IHR5cGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhWydJRHMnXSA9IGVsZW1lbnRNb2RlbC5ncm91cC5tYXAoZWwgPT4gZWwuaWQpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGVsZW1lbnRNb2RlbC5hY3RpdmVSZXNvdXJjZSkgZGF0YVtcIkFjdGl2ZSBSZXNvdXJjZVwiXSA9IGRlY29kZVVSSUNvbXBvbmVudChlbGVtZW50TW9kZWwuYWN0aXZlUmVzb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLm9mZnNldCkgZGF0YVsnT2Zmc2V0J10gPSBlbGVtZW50TW9kZWwub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnZpZXdGcmFtZSkgZGF0YVsnVmlldyBmcmFtZSddID0gZWxlbWVudE1vZGVsLnZpZXdGcmFtZTtcclxuXHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGVsZW1lbnRNb2RlbC5pZCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBlbGVtZW50TW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogZWxlbWVudE1vZGVsLnJlc291cmNlLFxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VUeXBlOiBlbGVtZW50TW9kZWwucmVzb3VyY2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IGVsZW1lbnRNb2RlbC5kaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgICAgIHR5cGVzOiBlbGVtZW50TW9kZWwudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc291cmNlLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0ID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRhcmdldC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zOiBfZ2V0UmVsYXRpb25zKGVsZW1lbnRNb2RlbCwgZ3JhcGhNb2RlbCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGluZm9UZW1wbGF0ZS5zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpbmZvVGVtcGxhdGUub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBfbGluZWFnZUdyYW0uc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRJZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0QXNwZWN0cyAoZWxlbWVudE1vZGVsLCBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdHMgPSBbXTtcclxuICAgICAgICBpZiAoZWxlbWVudE1vZGVsLnJlc291cmNlKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yZXNvdXJjZSA9PT0gZWxlbWVudE1vZGVsLnJlc291cmNlKSBhc3BlY3RzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFzcGVjdHMucHVzaChlbGVtZW50TW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXNwZWN0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVsYXRpb25zIChlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2VNYXAgPSBncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IGdyYXBoTW9kZWwubWFwcy50YXJnZXRNYXA7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1hcCA9IGdyYXBoTW9kZWwubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgICAgICBjb25zdCBpZHMgPSBfZ2V0QXNwZWN0cyhlbGVtZW50TW9kZWwsIGdyYXBoTW9kZWwubm9kZXMpLm1hcChhID0+IGEuaWQpO1xyXG5cclxuICAgICAgICBsZXQgc291cmNlcyA9IFtdO1xyXG4gICAgICAgIGxldCB0YXJnZXRzID0gW107XHJcbiAgICAgICAgaWRzLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlTWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlcyA9IHNvdXJjZXMuY29uY2F0KHNvdXJjZU1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wuc291cmNlXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWFwW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHRhcmdldE1hcFtpZF0ubWFwKGwgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW2wudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc291cmNlcyAmJiBzb3VyY2VzLmxlbmd0aCA+IDAgfHwgdGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGluY29taW5nczogc291cmNlcyxcclxuICAgICAgICAgICAgICAgIG91dGdvaW5nczogdGFyZ2V0cyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgSW5mb1BhbmVsO1xyXG4iLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSBcInZpc3VhbGl6YXRpb25zLWxpYnJhcnlcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBNYXAob3B0aW9ucykge1xyXG4gIGNvbnN0IG1hcmt1cCA9IGBcclxuICAgICAgICA8ZGl2IGlkPVwibWFwQnV0dG9uXCIgY2xhc3M9XCJ0cS1sZy1tYXBcIj5cclxuICAgICAgICAgICAgPHNwYW4gdGl0bGU9XCJNaW5pIG1hcFwiIGNsYXNzPVwidHEtbGctY29sbGFwc2UtcGFuZWxfYm9keV9fbGFiZWwgZmFzIGZhLWltYWdlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgaWQ9XCJiYXNlRWxlbWVudEZvck1hcFwiPjwvZGl2PlxyXG4gICAgYDtcclxuICBjb25zdCBfbGluZWFnZUdyYW0gPSBvcHRpb25zLmxpbmVhZ2VHcmFtO1xyXG5cclxuICBsZXQgX2VsO1xyXG5cclxuICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIF9lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuYmFzZUVsZW1lbnQpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZUVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIF9lbCA9IG9wdGlvbnMuYmFzZUVsZW1lbnQ7XHJcbiAgfVxyXG4gIGlmICghX2VsKSByZXR1cm47XHJcblxyXG4gIF9lbC5pbm5lckhUTUwgPSBtYXJrdXA7XHJcblxyXG4gIGNvbnN0IG1hcEZseWluZ1BhbmVsID0gbmV3IFRRR3JhbVVJLkZseWluZ1BhbmVsKHtcclxuICAgIGJhc2VFbGVtZW50OiBfZWwucXVlcnlTZWxlY3RvcihcIiNiYXNlRWxlbWVudEZvck1hcFwiKSxcclxuICAgIGFjdGl2ZTogb3B0aW9ucy5hY3RpdmUsXHJcbiAgICBoZWFkZXI6IFwiTWFwXCIsXHJcbiAgICB0cmlnZ2VyQnV0dG9uOiBfZWwucXVlcnlTZWxlY3RvcihcIiNtYXBCdXR0b25cIiksXHJcbiAgICBlbXB0eUJvZHk6IGZhbHNlLFxyXG4gICAgc2l6ZTogeyB3aWR0aDogXCIyNTBweFwiLCBoZWlnaHQ6IFwiMjUwcHhcIiB9LFxyXG4gICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICBib2R5OiBcIlwiLFxyXG4gICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gIH0pO1xyXG5cclxuICBfbGluZWFnZUdyYW0uc2V0Um9vdEh0bWxGb3JNYXAoXHJcbiAgICBtYXBGbHlpbmdQYW5lbC5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWJvZHlfY29udGFpbmVyXCIpXHJcbiAgKTtcclxuXHJcbiAgbWFwRmx5aW5nUGFuZWwub24oXCJzaXplLWNoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgX2xpbmVhZ2VHcmFtLnJlZnJlc2goXCJncmFwaE1hcFwiKTtcclxuICB9KTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBNYXA7XHJcbiIsImltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSBcIi4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI7XHJcbmltcG9ydCBUUUdyYW1VSSBmcm9tIFwidmlzdWFsaXphdGlvbnMtbGlicmFyeVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBPcHRpb25zUGFuZWx9IG9iamVjdC5cclxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1BhbmVsTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IGJhc2VFbGVtZW50IC0gUm9vdCBmb3IgdGhpcyBwYW5lbFxyXG4gKiBAcHJvcGVydHkge0xpbmVhZ2VHcmFtfSBsaW5lYWdlR3JhbSAtIExpbmVhZ2VHcmFtIG9iamVjdC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBhY3RpdmUgLSBmYWxzZSAtIGNvbGxhcHNlZCwgdHJ1ZSAtIGV4cGFuZGVkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSB0cmlnZ2VyQnV0dG9uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHdoaWNoIGlzIGEgc2ltcGxlIFVJIHBhbmVsLlxyXG4gKiBUaGlzIHBhbmVsIGNhbiByZXByZXNlbnQgYW4gaW5mb3JtYXRpb24gYWJvdXQgc2VsZWN0ZWQgZWxlbWVudFxyXG4gKiBhbmQgYWxzbywgaXQgc3VwcG9ydHMgc2ltcGxlIG5hdmlnYXRpb24gYmV0d2VlbiBlbGVtZW50cy5cclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7T3B0aW9uc1BhbmVsTW9kZWx9IG9wdGlvbnMgLSBEYXRhIG1vZGVsLlxyXG4gKiBAZmlyZXMgc3RhdGUtY2hhbmdlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE9wdGlvbnNQYW5lbChvcHRpb25zKSB7XHJcbiAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gIGNvbnN0IGxlZ2VuZHMgPSBvcHRpb25zLmxlZ2VuZHMgfHwgW107XHJcbiAgY29uc3QgX2xpbmVhZ2VHcmFtID0gb3B0aW9ucy5saW5lYWdlR3JhbTtcclxuICBjb25zdCBzZWxmID0gdGhpcztcclxuICBcclxuICBUUUdyYW1VSS5GbHlpbmdQYW5lbC5hcHBseSh0aGlzLCBbXHJcbiAgICB7XHJcbiAgICAgIGJhc2VFbGVtZW50OiBvcHRpb25zLmJhc2VFbGVtZW50LFxyXG4gICAgICBhY3RpdmU6IG9wdGlvbnMuYWN0aXZlLFxyXG4gICAgICBoZWFkZXI6IFwiT3B0aW9ucyBwYW5lbFwiLFxyXG4gICAgICB0cmlnZ2VyQnV0dG9uOiBvcHRpb25zLnRyaWdnZXJCdXR0b24sXHJcbiAgICAgIGVtcHR5Qm9keTogdHJ1ZSxcclxuICAgICAgc2l6ZToge1xyXG4gICAgICAgIHdpZHRoOiBcIjQwMHB4XCIsXHJcbiAgICAgICAgaGVpZ2h0OiBcIjUwMHB4XCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlbW92ZUJhY2tncm91bmQ6IHRydWUsXHJcbiAgICAgIGJvZHk6IG5ldyBUUUdyYW1VSS5UYWJQYW5lbCh7XHJcbiAgICAgICAgdGFiczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogXCJ0cVVpR2VuZXJhbFwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJHZW5lcmFsXCIsXHJcbiAgICAgICAgICAgIGJvZHk6IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtbGFiZWxcIj5EaXNwbGF5PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImRpc3BsYXlHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGFyaWEtbGFiZWw9XCJEcm9wZG93biBmb3Igc2V0dGluZyBvcmllbnRhdGlvblwiIGlkPVwidHFVaU9yaWVudGF0aW9uXCIgc2l6ZT1cIjFcIiBuYW1lPVwib3JpZW50YXRpb25cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImxlZnQtdG8tcmlnaHRcIj5sZWZ0IHRvIHJpZ2h0PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyaWdodC10by1sZWZ0XCI+cmlnaHQgdG8gbGVmdDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwidG9wLXRvLWJvdHRvbVwiPnRvcCB0byBib3R0b208L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImJvdHRvbS10by10b3BcIj5ib3R0b20gdG8gdG9wPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gR3JhcGggb3JpZW50YXRpb248L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGFyaWEtbGFiZWw9XCJEcm9wZG93biBmb3Igc2V0dGluZyBMaW5rIHJvdXRpbmdcIiBpZD1cInRxVWlSb3V0aW5nXCIgc2l6ZT1cIjFcIiBuYW1lPVwicm91dGluZ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibWV0cm9cIj5NZXRybzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibGdyb3V0ZXJcIj5SYWlsUm9hZDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibm9ybWFsXCI+Tm9ybWFsPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtYW5oYXR0YW5cIj5NYW5oYXR0YW48L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4gLSBMaW5rIHJvdXRpbmc8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9fc2VsZWN0LWxpbmVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IGFyaWEtbGFiZWw9XCJEcm9wZG93biBmb3Igc2V0dGluZyBMYXlvdXQgYWxnb3JpdGhtXCIgaWQ9XCJ0cVVpTGF5b3V0XCIgc2l6ZT1cIjFcIiBuYW1lPVwibGF5b3V0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzYW5rZXlcIj5TYW5rZXk8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImZsb3ctZGlyZWN0ZWRcIj5GbG93LWRpcmVjdGVkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+IC0gTGF5b3V0IGFsZ29yaXRobTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWdyb3VwX19jaGVjay1ib3gtbGluZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpbnB1dCBhcmlhLWxhYmVsPVwiQ2hlY2tib3ggdG8gc2V0IHNob3dpbmcgZnVsbCBsYWJlbHNcIiBpZD1cInRxVWlFeHBhbmRDb2xsYXBzZVwiIHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9XCJjaGVja2VkXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPkV4cGFuZCBub2RlIGNvbnRhaW5lcnMgdG8gc2hvdyBmdWxsIHRleHQgbGFiZWxzPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZ3JvdXBfX2NoZWNrLWJveC1saW5lXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PGlucHV0IGFyaWEtbGFiZWw9XCJDaGVja2JveCB0byBzZXQgdHJpbW1pbmcgb24gYm9yZGVyc1wiIGlkPVwidHFVaUNsaXBOb2Rlc1wiIHR5cGU9XCJjaGVja2JveFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5Ob2RlcyB0cmltbWluZyBvbiBib3JkZXJzPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiZGF0YVByb3ZpZGVyR3JvdXBcIiBjbGFzcz1cInRxLWxhYmVsXCI+RGF0YSBQcm92aWRlcjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJkYXRhUHJvdmlkZXJHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXAgdHEtdWktZGF0YS1wcm92aWRlci1ncm91cFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ncm91cF9faW5wdXQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBhcmlhLWxhYmVsPVwiUmVhY2ggZm9yIGRhdGEgXCIgY2xhc3M9XCJ0cS11aS1vcHRpb25zX19pbnB1dFwiIGFyaWEtbGFiZWw9XCJSZWFjaDogdGhlIG51bWJlciBvZiBncmFwaCB0cmF2ZXJzYWxzLlwiIGlkPVwidHFVaVJlYWNoXCIgdmFsdWU9XCIzXCIgdHlwZT1cIm51bWJlclwiIG1pbj1cIjFcIiBtYXg9XCIxMFwiIHJlcXVpcmVkIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFVaVJlYWNoQXBwbHlcIiB0aXRsZT1cIkFwcGx5IFJlYWNoXCIgY2xhc3M9XCJ0cS1idXR0b24gdHEtcHJvdmlkZXItYnV0dG9uXCI+PGkgY2xhc3M9XCJ0cS1wcm92aWRlci1pY29uXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGxhYmVsRm9yPVwidHFVaVJlYWNoXCIgdGl0bGU9XCJSZWFjaDogdGhlIG51bWJlciBvZiBncmFwaCB0cmF2ZXJzYWxzLlwiPiAtIFJlYWNoPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZ3JvdXBfX2lucHV0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJ0cS11aS1vcHRpb25zX19pbnB1dFwiIGFyaWEtbGFiZWw9XCJCcmVhZHRoOiB0aGUgbnVtYmVyIG9mIHBhdGhzIGV2YXVsYXRlZCBwZXIgbm9kZS5cIiBpZD1cInRxVWlCcmVhZHRoXCIgdmFsdWU9XCIxMFwiIHR5cGU9XCJudW1iZXJcIiBtaW49XCIxXCIgIG1heD1cIjEwXCIgcmVxdWlyZWQvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInRxVWlCcmVhZHRoQXBwbHlcIiB0aXRsZT1cIkFwcGx5IEJyZWFkdGhcIiBjbGFzcz1cInRxLWJ1dHRvbiB0cS1wcm92aWRlci1idXR0b25cIj48aSBjbGFzcz1cInRxLXByb3ZpZGVyLWljb25cIj48L2k+PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgbGFiZWxGb3I9XCJ0cVVpQnJlYWR0aFwiIHRpdGxlPVwiQnJlYWR0aDogdGhlIG51bWJlciBvZiBwYXRocyBldmFsdWF0ZWQgcGVyIG5vZGUuXCI+IC0gQnJlYWR0aDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiZXhwb3J0R3JvdXBcIiBjbGFzcz1cInRxLWxhYmVsXCI+RXhwb3J0IGFzPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImV4cG9ydEdyb3VwXCIgY2xhc3M9XCJ0cS11aS1ncm91cCB0cS11aS1leHBvcnQtZ3JvdXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJ0cVVpRXhwb3J0U1ZHXCIgdGl0bGU9XCJFeHBvcnQgZGlhZ3JhbSB0byBTVkdcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlNWRzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInRxVWlFeHBvcnRQTkdcIiB0aXRsZT1cIkV4cG9ydCBkaWFncmFtIHRvIFBOR1wiIGNsYXNzPVwidHEtYnV0dG9uXCI+UE5HPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFVaVByaW50XCIgdGl0bGU9XCJQcmludFwiIGNsYXNzPVwidHEtYnV0dG9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYXMgZmEtcHJpbnRcIj48L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJob3dUb1VzZUdyb3VwXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPkhvdyB0byB1c2U8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiaG93VG9Vc2VHcm91cFwiIGNsYXNzPVwidHEtdWktZ3JvdXAgdHEtdWktb3B0LWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGlkPVwidHFVaUhlbHBCdG5cIiB0aXRsZT1cIkhlbHBcIiBjbGFzcz1cInRxLWJ1dHRvblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFzIGZhLWluZm8tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cInRxLWJ1dHRvblwiIHRpdGxlPVwiRG9jdW1lbnRhdGlvblwiIGhyZWY9XCIuL2RvY3VtZW50YXRpb24vaW5kZXguaHRtbFwiPkRPQzwvYT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgYCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiBcInRxVWlMZWdlbmRzXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIkxlZ2VuZHNcIixcclxuICAgICAgICAgICAgYm9keTogbmV3IFRRR3JhbVVJLkxlZ2VuZHMoeyBsZWdlbmRzOiBsZWdlbmRzIH0pLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9KSxcclxuICAgIH0sXHJcbiAgXSk7XHJcblxyXG4gIC8vIEdlbmVyYWxcclxuXHJcbiAgY29uc3Qgc3ZnQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxVWlFeHBvcnRTVkdcIik7XHJcbiAgY29uc3QgcG5nQnV0dG9uID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxVWlFeHBvcnRQTkdcIik7XHJcbiAgY29uc3QgcHJpbnRCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdHFVaVByaW50XCIpO1xyXG4gIGNvbnN0IGV4cGFuZENvbGxhcHNlID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3RxVWlFeHBhbmRDb2xsYXBzZVwiKTtcclxuICBjb25zdCBvcmllbnRhdGlvbiA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cVVpT3JpZW50YXRpb25cIik7XHJcbiAgY29uc3Qgcm91dGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cVVpUm91dGluZ1wiKTtcclxuICBjb25zdCBsYXlvdXQgPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdHFVaUxheW91dFwiKTtcclxuICBjb25zdCBjbGlwcGluZyA9IHNlbGYucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiN0cVVpQ2xpcE5vZGVzXCIpO1xyXG4gIGNvbnN0IGhlbHBCdXR0b24gPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjdHFVaUhlbHBCdG5cIik7XHJcbiAgY29uc3QgcmVhY2ggPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpUmVhY2gnKTtcclxuICBjb25zdCBhcHBseVJlYWNoID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaVJlYWNoQXBwbHknKTtcclxuICBjb25zdCBicmVhZHRoID0gc2VsZi5yb290SHRtbC5xdWVyeVNlbGVjdG9yKCcjdHFVaUJyZWFkdGgnKTtcclxuICBjb25zdCBhcHBseUJyZWFkdGggPSBzZWxmLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJyN0cVVpQnJlYWR0aEFwcGx5Jyk7XHJcblxyXG4gIF9saW5lYWdlR3JhbS5vbihcImN1cnJlbnQtdmlldy1jaGFuZ2VkXCIsIGZ1bmN0aW9uICh2aWV3SWQpIHtcclxuICAgIHN2Z0J1dHRvbi5kaXNhYmxlZCA9IHZpZXdJZCAhPT0gXCJsaW5lYWdlRGlhZ3JhbVwiO1xyXG4gICAgZXhwYW5kQ29sbGFwc2UuZGlzYWJsZWQgPSB2aWV3SWQgIT09IFwibGluZWFnZURpYWdyYW1cIjtcclxuICB9KTtcclxuXHJcbiAgc3ZnQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfbGluZWFnZUdyYW0uZXhwb3J0KHtcclxuICAgICAgdHlwZTogXCJzdmdcIixcclxuICAgICAgdmlldzogXCJsaW5lYWdlRGlhZ3JhbVwiLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuICBwbmdCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9saW5lYWdlR3JhbS5leHBvcnQoe1xyXG4gICAgICB0eXBlOiBcInBuZ1wiLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuICBwcmludEJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xpbmVhZ2VHcmFtLnByaW50KCk7XHJcbiAgfTtcclxuXHJcbiAgZXhwYW5kQ29sbGFwc2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoZXhwYW5kQ29sbGFwc2UuY2hlY2tlZCkge1xyXG4gICAgICBfbGluZWFnZUdyYW0uZXhwYW5kQWxsTm9kZXMoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9saW5lYWdlR3JhbS5jb2xsYXBzZUFsbE5vZGVzKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgb3JpZW50YXRpb24udmFsdWUgPSBfbGluZWFnZUdyYW0uZ2V0T3JpZW50YXRpb24oKTtcclxuICBvcmllbnRhdGlvbi5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9saW5lYWdlR3JhbS5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbi52YWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgcm91dGluZy52YWx1ZSA9IF9saW5lYWdlR3JhbS5nZXRSb3V0aW5nKCk7XHJcbiAgcm91dGluZy5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9saW5lYWdlR3JhbS5zZXRSb3V0aW5nKHJvdXRpbmcudmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIGxheW91dC52YWx1ZSA9IF9saW5lYWdlR3JhbS5nZXRMYXlvdXRBbGdvcml0aG0oKTtcclxuICBsYXlvdXQub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfbGluZWFnZUdyYW0uc2V0TGF5b3V0QWxnb3JpdGhtKGxheW91dC52YWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgcmVhY2gudmFsdWUgPSBfbGluZWFnZUdyYW0uZ2V0UmVhY2goKTtcclxuICAgIFxyXG4gIGFwcGx5UmVhY2gub25jbGljayA9IHJlYWNoLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gcmVhY2guY2hlY2tWYWxpZGl0eSgpO1xyXG5cclxuICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgX2xpbmVhZ2VHcmFtLnNldFJlYWNoKHJlYWNoLnZhbHVlKTtcclxuICB9O1xyXG5cclxuICBicmVhZHRoLnZhbHVlID0gX2xpbmVhZ2VHcmFtLmdldEJyZWFkdGgoKTtcclxuXHJcbiAgYXBwbHlCcmVhZHRoLm9uY2xpY2sgPSBicmVhZHRoLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gYnJlYWR0aC5jaGVja1ZhbGlkaXR5KCk7XHJcblxyXG4gICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9saW5lYWdlR3JhbS5zZXRCcmVhZHRoKGJyZWFkdGgudmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIGhlbHBCdXR0b24ub25jbGljayA9IG9wdGlvbnMub25QcmVzc0hlbHA7XHJcblxyXG4gIGNsaXBwaW5nLmNoZWNrZWQgPSBfbGluZWFnZUdyYW0uZ2V0Q2xpcHBpbmcoKTtcclxuICBjbGlwcGluZy5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9saW5lYWdlR3JhbS5zZXRDbGlwcGluZyhjbGlwcGluZy5jaGVja2VkKTtcclxuICB9O1xyXG5cclxuICBoZWxwQnV0dG9uLm9uY2xpY2sgPSBvcHRpb25zLm9uUHJlc3NIZWxwO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE9wdGlvbnNQYW5lbDtcclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogXHJcbiAqIEh0bWwtVUkgZWxlbWVudCB3aGljaCBtYW5hZ2Ugc2l6ZSBvZiB0d28gc3BsaXR0ZWQgd2luZG93cy5cclxuICogXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIHZpZXdGcmFtZUE6IFZpZXdGcmFtZSxcclxuICogIHZpZXdGcmFtZUI6IFZpZXdGcmFtZSxcclxuICogfSBtb2RlbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqIFxyXG4gKiBQdWJsaWMgcHJvcGVydGllczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBlbDogSFRNTEVMZW1lbnRcclxuICogXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIG9uIChldmVudDogc3RyaW5nLCBjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHRyaWdnZXIgKGV2ZW50OiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSk6IHZvaWRcclxuICogXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgZGlmZih7IGRpZmY6IG51bWJlciwgbGFzdENoYW5nZTogYm9vbGVhbiB9KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNwbGl0dGVyIChtb2RlbCwgcGFyYW1ldGVycykge1xyXG4gICAgLy8gSW5pdFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpOyAgIC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9ncmFwaE9yaWVudGF0aW9uID0gcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCcgfHwgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcbiAgICBsZXQgX3Zpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuICAgIGlmIChwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdib3R0b20tdG8tdG9wJykge1xyXG4gICAgICAgIF9zd2FwVmlld0ZyYW1lcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIHNlbGYuZWwuY2xhc3NOYW1lID0gX2dyYXBoT3JpZW50YXRpb24gPyAndHFfbGluZWFnZV91aV9fdmlldy1mcmFtZS1zcGxpdHRlcicgOiAndHFfbGluZWFnZV91aV9fdmlldy1mcmFtZS1zcGxpdHRlci12ZXJ0aWNhbCc7XHJcbiAgICBzZWxmLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9vbm1vdXNlZG93bik7XHJcbiAgICBcclxuICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICBmdW5jdGlvbiBfb25tb3VzZWRvd24gKGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoX2dyYXBoT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYKSBzdGFydCA9IGV2ZW50LnBhZ2VYO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYKSBzdGFydCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VZKSBzdGFydCA9IGV2ZW50LnBhZ2VZO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRZKSBzdGFydCA9IGV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29ubW91c2V1cCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9vbmNoYW5nZSAoZXZlbnQsIG9uTW91c2VVcCkge1xyXG4gICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgbGV0IGVuZCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2dyYXBoT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5wYWdlWCkgZW5kID0gZXZlbnQucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYKSBlbmQgPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VZKSBlbmQgPSBldmVudC5wYWdlWTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkpIGVuZCA9IGV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc3BsaXR0ZXItcG9zaXRpb24tY2hhbmdlZCcsIHsgZGlmZjogX2xpbWl0RGlmZihkaWZmKSwgbGFzdENoYW5nZTogb25Nb3VzZVVwIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX29ubW91c2V1cCAoZXZlbnQpIHtcclxuICAgICAgICAgICAgX29uY2hhbmdlKGV2ZW50LCB0cnVlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5vbm1vdXNlbW92ZSA9IGRvY3VtZW50LmJvZHkub25tb3VzZXVwID0gbnVsbDtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25tb3VzZXVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHNlbGYudXBkYXRlTmVpZ2hib3VyID0gZnVuY3Rpb24gKG5ld05laWdoYm91cikge1xyXG4gICAgICAgIGlmIChzZWxmLm1vZGVsLnZpZXdGcmFtZUIgIT09IG5ld05laWdoYm91cikge1xyXG4gICAgICAgICAgICBzZWxmLm1vZGVsLnZpZXdGcmFtZUIgPSBuZXdOZWlnaGJvdXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF92aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgX3Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV92aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICBfdmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfc3dhcFZpZXdGcmFtZXMgKCkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBtb2RlbC52aWV3RnJhbWVBO1xyXG4gICAgICAgIG1vZGVsLnZpZXdGcmFtZUEgPSBtb2RlbC52aWV3RnJhbWVCO1xyXG4gICAgICAgIG1vZGVsLnZpZXdGcmFtZUIgPSB0ZW1wO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9saW1pdERpZmYgKGRpZmYpIHtcclxuICAgICAgICBpZiAoZGlmZiA9PT0gMCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHZmQSA9IHNlbGYubW9kZWwudmlld0ZyYW1lQTtcclxuICAgICAgICBjb25zdCB2ZkIgPSBzZWxmLm1vZGVsLnZpZXdGcmFtZUI7XHJcblxyXG4gICAgICAgIGxldCBzaWRlQTtcclxuICAgICAgICBsZXQgc2lkZUI7XHJcbiAgICAgICAgbGV0IG1pblNpZGVTaG91bGRCZTtcclxuXHJcbiAgICAgICAgaWYgKF9ncmFwaE9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHNpZGVBID0gdmZBLnNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIHNpZGVCID0gdmZCLnNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIG1pblNpZGVTaG91bGRCZSA9IHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnggKiAyICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzaWRlQSA9IHZmQS5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgc2lkZUIgPSB2ZkIuc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIG1pblNpZGVTaG91bGRCZSA9IHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnkgKiAyICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdFNpZGVBID0gc2lkZUEgKyBkaWZmO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdFNpZGVCID0gc2lkZUIgLSBkaWZmO1xyXG5cclxuICAgICAgICBsZXQgbGltaXRhdGlvbkEgPSAwO1xyXG4gICAgICAgIGxldCBsaW1pdGF0aW9uQiA9IDA7XHJcbiAgICAgICAgaWYgKHJlc3VsdFNpZGVBIDwgbWluU2lkZVNob3VsZEJlICYmIHJlc3VsdFNpZGVCIDwgbWluU2lkZVNob3VsZEJlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdFNpZGVBIDwgbWluU2lkZVNob3VsZEJlKSB7XHJcbiAgICAgICAgICAgIGxpbWl0YXRpb25BID0gIG1pblNpZGVTaG91bGRCZSAtIHJlc3VsdFNpZGVBO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0U2lkZUIgPCBtaW5TaWRlU2hvdWxkQmUpIHtcclxuICAgICAgICAgICAgbGltaXRhdGlvbkIgPSAgcmVzdWx0U2lkZUIgLSBtaW5TaWRlU2hvdWxkQmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW1pdGF0aW9uQSAhPT0gMCB8fCBsaW1pdGF0aW9uQiAhPT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHREaWZmID0gTWF0aC5hYnMobGltaXRhdGlvbkEpID4gTWF0aC5hYnMobGltaXRhdGlvbkIpID8gZGlmZiArIGxpbWl0YXRpb25BIDogZGlmZiArIGxpbWl0YXRpb25CO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRTaWRlQSA9IHNpZGVBICsgcmVzdWx0RGlmZjtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0U2lkZUIgPSBzaWRlQiAtIHJlc3VsdERpZmY7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRTaWRlQSA8IG1pblNpZGVTaG91bGRCZSB8fCByZXN1bHRTaWRlQiA8IG1pblNpZGVTaG91bGRCZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHREaWZmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuU3BsaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5zaGFwZXMuYmFzaWMuUmVjdC5wcm90b3R5cGUpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3BsaXR0ZXI7IiwiLyoqXHJcbiAqIENvbG9yZWRCdXR0b25Nb2RlbCAtIGRhdGEgbW9kZWwgZm9yIENvbG9yZWRCdXR0b25zIGluIHRoZSBDb2xvcmVkQnV0dG9uc0xpc3RcclxuICogQHR5cGVkZWYge09iamVjdH0gQ29sb3JlZEJ1dHRvbk1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIFN0cmluZyBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBhcmUgdXNlZCBmb3IgaW1wbGVtZW50aW5nIHRvb2x0aXAgYW5kIGljb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQm9yZGVyIGNvbG9yXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgLSBCYWNrZ3JvdW5kIGNvbG9yXHJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gd2ljaCB3aWxsIGJlIGNvbGxlZCBvbiBtb3VzZSBjbGljayBvbiBidXR0b25cclxuKi9cclxuXHJcbmxldCB1bmlxdWVJZCA9IDA7XHJcblxyXG4vKipcclxuICogQ2xhc3MgaXMgYSBjb2xsZWN0aW9uIG9mIGNvbG9yZWQgYnV0dG9ucyxcclxuICogd2hpY2ggdXNlIGZpcnN0IGxldHRlcnMgb2YgdGhlIGxhYmVsIGFzIGFuIGljb25zIGZvciB0aGUgYnV0dG9ucy5cclxuICogKEluaXRpYWxseSBpdCB3YXMgZGV2ZWxvcGVkIGFzIGEgY29sbGVjdGlvbiBvZiBjb2xsYXBzZWQgdmlld0ZyYW1lcyBmb3IgTGluZWFnZUdyYW0pXHJcbiAqIEBjbGFzc1xyXG4gKiBAYXVnbWVudHMgVFFVSUVsZW1lbnRcclxuICogQHBhcmFtIHtMaW5lYWdlR3JhbX0gbGluZWFnZUdyYW1cclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7Q29sb3JlZEJ1dHRvbk1vZGVsW119IGJ1dHRvbnMgLSBsaXN0IG9mIGJ1dHRvbiBtb2RlbHNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdGcmFtZUJ1dHRvbnMgKHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSB0aHJvdyBFcnJvcignVGhlIGFyZ3VtZW50cyBwYXJhbWV0ZXJzIHNob3VsZG5cXCd0IGJlIHVuZGVmaW5lZCEnKTtcclxuICAgIGlmICghcGFyYW1ldGVycy5saW5lYWdlR3JhbSkgdGhyb3cgRXJyb3IoJ2xpbmVhZ2VHcmFtIGZpZWxkIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICBzZWxmLnJvb3RIdG1sID0gX2luaXRSb290RWxlbWVudCgpO1xyXG4gICAgc2VsZi5pZCA9IHBhcmFtZXRlcnMubGluZWFnZUdyYW0uaWQgfHwgJ2NvbG9yZWRCdXR0b25zLScgKyB1bmlxdWVJZCsrO1xyXG4gICAgc2VsZi5yb290SHRtbC5pZCA9IHNlbGYuaWQ7XHJcbiAgICBcclxuICAgIGxldCBfbGluZWFnZUdyYW0gPSBwYXJhbWV0ZXJzLmxpbmVhZ2VHcmFtO1xyXG4gICAgbGV0IF9zdGF0ZSA9IHt9O1xyXG4gICAgbGV0IF9idXR0b25zID0ge307XHJcbiAgICBsZXQgX292ZXJWaWV3RnJhbWVCdXR0b247XHJcblxyXG4gICAgX2NyZWF0ZUJ1dHRvbnMoKTtcclxuXHJcbiAgICBfbGluZWFnZUdyYW0ub24oJ3ZpZXctZnJhbWUtc3RhdGUtY2hhbmdlZCcsIF91cGRhdGVCdXR0b25zKTtcclxuICAgIF9saW5lYWdlR3JhbS5vbignaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkJywgX2NyZWF0ZUJ1dHRvbnMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCdXR0b25zICgpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gX2xpbmVhZ2VHcmFtLmdldFZpZXdGcmFtZXMoKTtcclxuICAgICAgICBjb25zdCBvdmVyVmlld0ZyYW1lID0gX2xpbmVhZ2VHcmFtLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuXHJcbiAgICAgICAgX3N0YXRlID0ge307XHJcbiAgICAgICAgX2J1dHRvbnMgPSB7fTtcclxuICAgICAgICBzZWxmLnJvb3RIdG1sLmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgICAgICBpZiAob3ZlclZpZXdGcmFtZSkge1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbiA9IGNyZWF0ZUJ1dHRvbihvdmVyVmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgX292ZXJWaWV3RnJhbWVCdXR0b24uc3R5bGUuYm9yZGVyQ29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi5zdHlsZS5jb2xvciA9IG51bGw7XHJcbiAgICAgICAgICAgIF9vdmVyVmlld0ZyYW1lQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLWNvbG9yZWQtYnV0dG9ucy1vdmVydmlldycpO1xyXG4gICAgICAgICAgICBzZWxmLnJvb3RIdG1sLmFwcGVuZENoaWxkKF9vdmVyVmlld0ZyYW1lQnV0dG9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lLmlkICE9PSBvdmVyVmlld0ZyYW1lLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBodG1sQnV0dG9uID0gY3JlYXRlQnV0dG9uKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgICAgICBfYnV0dG9uc1t2aWV3RnJhbWUuaWRdID0gaHRtbEJ1dHRvbjtcclxuICAgICAgICAgICAgICAgIHNlbGYucm9vdEh0bWwuYXBwZW5kQ2hpbGQoaHRtbEJ1dHRvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3VwZGF0ZUJ1dHRvbnMoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uICh2aWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgaHRtbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0JVVFRPTicpO1xyXG5cclxuICAgICAgICAgICAgaHRtbEJ1dHRvbi5jbGFzc05hbWUgPSAndHEtdWktdG9vbGJhcl9fYnV0dG9uIHRxLXVpLWNvbG9yZWQtYnV0dG9uJztcclxuXHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuaXNPdmVyVmlldykge1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd0cS11aS1jb2xvcmVkLWJ1dHRvbnMtb3ZlcnZpZXcnKTtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N0YXRlW3ZpZXdGcmFtZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VHcmFtLnNldEZ1bGxTY3JlZW5Nb2RlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0uc2V0RnVsbFNjcmVlbk1vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24uaW5uZXJIVE1MID0gYDxzcGFuPiR7X2dldFNob3J0TGFiZWwodmlld0ZyYW1lLmxhYmVsKX08L3NwYW4+YDtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdmlld0ZyYW1lLmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5zdHlsZS5ib3JkZXJDb2xvciA9IHZpZXdGcmFtZS5ib3JkZXJDb2xvciB8fCAnYmxhY2snO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5zdHlsZS5jb2xvciA9IHZpZXdGcmFtZS5ib3JkZXJDb2xvciB8fCAnYmxhY2snO1xyXG4gICAgICAgICAgICAgICAgaHRtbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3RhdGVbdmlld0ZyYW1lLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0uY29sbGFwc2VWaWV3RnJhbWUodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGluZWFnZUdyYW0uZXhwYW5kVmlld0ZyYW1lKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3N0YXRlW3ZpZXdGcmFtZS5pZF0gPSB2aWV3RnJhbWUuZXhwYW5kZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBodG1sQnV0dG9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQnV0dG9ucyAoKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IF9saW5lYWdlR3JhbS5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICAgICAgY29uc3Qgb3ZlclZpZXdGcmFtZSA9IF9saW5lYWdlR3JhbS5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcblxyXG4gICAgICAgIGlmIChvdmVyVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIF9zdGF0ZVtvdmVyVmlld0ZyYW1lLmlkXSA9IG92ZXJWaWV3RnJhbWUuYWN0aXZlO1xyXG4gICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi5pbm5lckhUTUwgPSBgPHNwYW4+JHtvdmVyVmlld0ZyYW1lLmFjdGl2ZSA/ICdGJyA6ICdPJ308L3NwYW4+YDtcclxuICAgICAgICAgICAgaWYgKG92ZXJWaWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi50aXRsZSA9ICdTd2l0Y2ggdG8gRnJhbWVzIG1vZGUnO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb290SHRtbC5jbGFzc0xpc3QuYWRkKCd0cS11aS1jb2xvcmVkLWJ1dHRvbnMtY29sbGFwc2VkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfb3ZlclZpZXdGcmFtZUJ1dHRvbi50aXRsZSA9ICdTd2l0Y2ggdG8gc2luZ2xlIGZyYW1lIG1vZGUnO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb290SHRtbC5jbGFzc0xpc3QucmVtb3ZlKCd0cS11aS1jb2xvcmVkLWJ1dHRvbnMtY29sbGFwc2VkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lLmlkICE9PSBvdmVyVmlld0ZyYW1lLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGVbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZS5leHBhbmRlZDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUJ1dHRvbih2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUJ1dHRvbiAodmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGh0bWxCdXR0b24gPSBfYnV0dG9uc1t2aWV3RnJhbWUuaWRdO1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlW3ZpZXdGcmFtZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24udGl0bGUgPSAnQ29sbGFwc2UgJyArIHZpZXdGcmFtZS5sYWJlbDtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgndHEtdWktc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh0bWxCdXR0b24udGl0bGUgPSAnRXhwYW5kICcgKyB2aWV3RnJhbWUubGFiZWw7XHJcbiAgICAgICAgICAgICAgICBodG1sQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3RxLXVpLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldFNob3J0TGFiZWwgKGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKCFsYWJlbCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHdvcmRzID0gbGFiZWwubWF0Y2goL1thLXonXFwtXSsvZ2kpO1xyXG4gICAgICAgIHJldHVybiB3b3Jkcy5maWx0ZXIodyA9PiAody50b0xvd2VyQ2FzZSgpICE9PSAnYW5kJyAmJiB3ICE9PSAnJicpKS5tYXAodyA9PiB3WzBdKS5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaW5pdFJvb3RFbGVtZW50ICgpIHtcclxuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSAndHEtdWktY29sb3JlZC1idXR0b25zLWxpc3QnO1xyXG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBWaWV3RnJhbWVCdXR0b25zOyIsImltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSBcIi4uL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI7XHJcbmltcG9ydCBTcGxpdHRlciBmcm9tIFwiLi9zcGxpdHRlclwiO1xyXG5pbXBvcnQge1xyXG4gIGNoZWNrUGFnaW5hdGlvbixcclxuICBjYWNoZUlkRm9yVmlld0ZyYW1lVUlcclxufSBmcm9tIFwiLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlsc1wiO1xyXG5pbXBvcnQgeyBhcnJheVRvTWFwIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICpcclxuICogTWFuYWdlcyB0aGUgbWFpbiB2aWV3IG9mIGFwcGxpY2F0aW9uIChWaWV3LTIpXHJcbiAqXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIHJvb3RFbDogSFRNTEVsZW1lbnRcclxuICogIHZpZXdGcmFtZXM6IEFycmF5IG9mIFZpZXdGcmFtZVxyXG4gKiB9IG9wdGlvbnNcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKlxyXG4gKiBQdWJsaWMgbWV0aG9kczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiByZWZyZXNoU3RhdGUgKCk6IHZvaWRcclxuICogdXBkYXRlVmlld0ZyYW1lcyAodmlld0ZyYW1lczogVmlld0ZyYW1lW10pOiB2b2lkXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogb24gKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdW5zdWJzY3JpYmUgKGNhbGxiYWNrOiBmdW5jdGlvbik6IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KTogdm9pZFxyXG4gKlxyXG4gKiBFdmVudHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGZpcmVzIHZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkIChWaWV3RnJhbWUpXHJcbiAqIEBmaXJlcyBzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkICh2ZjogVmlld0ZyYW1lLCBkaWZmOiB7IGRpZmY6IG51bWJlciwgbGFzdENoYW5nZTogYm9vbGVhbiB9KVxyXG4gKiBAZmlyZXMgdmlldy1mcmFtZS1jb2xsYXBzZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBWaWV3RnJhbWVzVUkob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gIC8vIEluaXRcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7IC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuXHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgY29uc3QgX3Jvb3QgPSBvcHRpb25zLnJvb3RFbDtcclxuXHJcbiAgbGV0IF9vcmllbnRhdGlvbiA9XHJcbiAgICBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09IFwicmlnaHQtdG8tbGVmdFwiIHx8XHJcbiAgICBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09IFwiYm90dG9tLXRvLXRvcFwiO1xyXG4gIGxldCBfZ3JhcGhPcmllbnRhdGlvbiA9XHJcbiAgICBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09IFwibGVmdC10by1yaWdodFwiIHx8XHJcbiAgICBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09IFwicmlnaHQtdG8tbGVmdFwiO1xyXG5cclxuICBsZXQgX3ZpZXdNYW5hZ2VyID0gb3B0aW9ucy52aWV3TWFuYWdlcjtcclxuICBsZXQgX3ZpZXdGcmFtZXMgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpIHx8IFtdO1xyXG4gIGxldCBfdmlld0ZyYW1lc01hcCA9IGFycmF5VG9NYXAoX3ZpZXdGcmFtZXMpO1xyXG4gIGxldCBfdWlTZXRGb3JWaWV3RnJhbWVzO1xyXG4gIGxldCBfYnV0dG9uczRTZXRzO1xyXG4gIGxldCBfc3BsaXR0ZXJzO1xyXG4gIGxldCBfdWlCb2R5O1xyXG5cclxuICBfY3JlYXRlVUkoKTtcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVmcmVzaGVzIGEgc3RhdGUgb2YgVUkuIChDaGFuZ2UgYXJyb3dzIHN0YXRlcylcclxuICAgKi9cclxuICBzZWxmLnJlZnJlc2ggPSBfcmVmcmVzaDtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IG5ldyB2aWV3IG1hbmFnZXJcclxuICAgKiBAcGFyYW0ge0FycmF5IG9mIFZpZXdGcmFtZX0gdmlld0ZyYW1lc1xyXG4gICAqL1xyXG4gIHNlbGYuc2V0Vmlld01hbmFnZXIgPSBmdW5jdGlvbih2aWV3TWFuYWdlcikge1xyXG4gICAgX3ZpZXdNYW5hZ2VyID0gdmlld01hbmFnZXI7XHJcbiAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICBfY3JlYXRlVUkoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJdCBjaGFuZ2VzIG9yaWVudGF0aW9uIG9mIHRoZSBncmFwaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gLSBWYWx1ZXM6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAqIEBtZW1iZXJvZiBWaWV3RnJhbWVzVUlcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXHJcbiAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICBfb3JpZW50YXRpb24gPVxyXG4gICAgICBvcmllbnRhdGlvbiA9PT0gXCJyaWdodC10by1sZWZ0XCIgfHwgb3JpZW50YXRpb24gPT09IFwiYm90dG9tLXRvLXRvcFwiO1xyXG4gICAgX2dyYXBoT3JpZW50YXRpb24gPVxyXG4gICAgICBvcmllbnRhdGlvbiA9PT0gXCJsZWZ0LXRvLXJpZ2h0XCIgfHwgb3JpZW50YXRpb24gPT09IFwicmlnaHQtdG8tbGVmdFwiO1xyXG4gICAgX2NyZWF0ZVVJKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVmcmVzaGVzIGEgc3RhdGUgb2YgVUkuIChDaGFuZ2UgYXJyb3dzIHN0YXRlcylcclxuICAgKi9cclxuICBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcclxuICAgIF91cGRhdGVWaWV3RnJhbWVzKCk7XHJcbiAgICBfcmVmcmVzaFVJKCk7XHJcbiAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgaWYgKHZmLmN1c3RvbWVTaXplZCkge1xyXG4gICAgICAgIGlmICh2Zi5zaXplLndpZHRoKVxyXG4gICAgICAgICAgX3VpU2V0Rm9yVmlld0ZyYW1lc1t2Zi5pZF0uc3R5bGUud2lkdGggPSB2Zi5zaXplLndpZHRoICsgXCJweFwiO1xyXG4gICAgICAgIGlmICh2Zi5zaXplLmhlaWdodClcclxuICAgICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmhlaWdodCA9IHZmLnNpemUuaGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdLnN0eWxlLmZsZXhHcm93ID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBfdWlTZXRGb3JWaWV3RnJhbWVzW3ZmLmlkXS5zdHlsZS5mbGV4R3JvdyA9IHZmLnNwYWNlU2hhcmU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3VwZGF0ZVZpZXdGcmFtZXMoKSB7XHJcbiAgICBfdmlld0ZyYW1lcyA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICBjb25zdCB2Zk1hcCA9IGFycmF5VG9NYXAoX3ZpZXdGcmFtZXMpO1xyXG4gICAgX3NwbGl0dGVycy5mb3JFYWNoKHNwbGl0dGVyID0+IHtcclxuICAgICAgc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQSA9IHZmTWFwW3NwbGl0dGVyLm1vZGVsLnZpZXdGcmFtZUEuaWRdO1xyXG4gICAgICBzcGxpdHRlci5tb2RlbC52aWV3RnJhbWVCID0gdmZNYXBbc3BsaXR0ZXIubW9kZWwudmlld0ZyYW1lQi5pZF07XHJcbiAgICB9KTtcclxuICAgIF92aWV3RnJhbWVzTWFwID0gYXJyYXlUb01hcChfdmlld0ZyYW1lcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGh0bWwgbmF2aWdhdGUgYnV0dG9ucyBmb3IgdGhlIHZpZXdzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9jcmVhdGVVSSgpIHtcclxuICAgIGlmICghX3Jvb3QpIHJldHVybjtcclxuICAgIGVsc2UgX3Jvb3QuaW5uZXJIVE1MID0gXCJcIjtcclxuXHJcbiAgICBfdWlCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgIF91aUJvZHkuY2xhc3NOYW1lID0gXCJ0cV9saW5lYWdlX3VpXCI7XHJcbiAgICBfcm9vdC5hcHBlbmRDaGlsZChfdWlCb2R5KTtcclxuICAgIF9zcGxpdHRlcnMgPSBbXTtcclxuXHJcbiAgICBfdWlCb2R5LmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICBfdWlTZXRGb3JWaWV3RnJhbWVzID0ge307XHJcbiAgICBfYnV0dG9uczRTZXRzID0ge307XHJcblxyXG4gICAgY29uc3QgTU9ESUZJRVIgPSAwLjU7XHJcblxyXG4gICAgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gXCJyaWdodC10by1sZWZ0XCIpIHtcclxuICAgICAgX3VpQm9keS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJyb3ctcmV2ZXJzZVwiO1xyXG4gICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09IFwidG9wLXRvLWJvdHRvbVwiKSB7XHJcbiAgICAgIF91aUJvZHkuc3R5bGUuZmxleERpcmVjdGlvbiA9IFwiY29sdW1uXCI7XHJcbiAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gXCJib3R0b20tdG8tdG9wXCIpIHtcclxuICAgICAgX3VpQm9keS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW4tcmV2ZXJzZVwiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaG9yaXpvbnRhbFxyXG4gICAgICBfdWlCb2R5LnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcInJvd1wiO1xyXG4gICAgfVxyXG5cclxuICAgIF92aWV3RnJhbWVzLmZvckVhY2goKHZmLCBpbmRleCwgYXJyKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZpZXdGcmFtZVVpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgICAgdmlld0ZyYW1lVWkuaWQgPSBjYWNoZUlkRm9yVmlld0ZyYW1lVUkodmYpO1xyXG4gICAgICBpZiAoX29yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgdmlld0ZyYW1lVWkuY2xhc3NOYW1lID1cclxuICAgICAgICAgIFwidHFfbGluZWFnZV91aV92aWV3LWZyYW1lX1wiICsgcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZpZXdGcmFtZVVpLmNsYXNzTmFtZSA9XHJcbiAgICAgICAgICBcInRxX2xpbmVhZ2VfdWlfdmlldy1mcmFtZV9cIiArIHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZmLmN1c3RvbWVTaXplZCkge1xyXG4gICAgICAgIGlmICh2Zi5zaXplLndpZHRoKSB2aWV3RnJhbWVVaS5zdHlsZS53aWR0aCA9IHZmLnNpemUud2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgaWYgKHZmLnNpemUuaGVpZ2h0KSB2aWV3RnJhbWVVaS5zdHlsZS5oZWlnaHQgPSB2Zi5zaXplLmhlaWdodCArIFwicHhcIjtcclxuICAgICAgICB2aWV3RnJhbWVVaS5zdHlsZS5mbGV4R3JvdyA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmlld0ZyYW1lVWkuc3R5bGUuZmxleEdyb3cgPSB2Zi5zcGFjZVNoYXJlO1xyXG4gICAgICB9XHJcbiAgICAgIF91aUJvZHkuYXBwZW5kQ2hpbGQodmlld0ZyYW1lVWkpO1xyXG5cclxuICAgICAgY29uc3QgdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU1HXCIpO1xyXG4gICAgICB1cC5jbGFzc05hbWUgPSBcInRxX2xpbmVhZ2VfdWlfX2J1dHRvbiB0cV9saW5lYWdlX3VpX191cC1idXR0b25cIjtcclxuICAgICAgdXAuc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiVXAgYnV0dG9uXCIpO1xyXG4gICAgICB1cC5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICBjb25zdCBjdXJQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZFwiLCB7XHJcbiAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgIHg6IGN1clBvcy54LFxyXG4gICAgICAgICAgICB5OiBjdXJQb3MueSAtIHZpZXdGcmFtZS5zaXplLmhlaWdodCAqIE1PRElGSUVSXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKHVwKTtcclxuXHJcbiAgICAgIGNvbnN0IGRvd24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU1HXCIpO1xyXG4gICAgICBkb3duLmNsYXNzTmFtZSA9IFwidHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX2Rvd24tYnV0dG9uXCI7XHJcbiAgICAgIGRvd24uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiRG93biBidXR0b25cIik7XHJcbiAgICAgIGRvd24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld0ZyYW1lc01hcFt2Zi5pZF07XHJcbiAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1wb3J0LXBvc2l0aW9uLWNoYW5nZWRcIiwge1xyXG4gICAgICAgICAgaWQ6IHZmLmlkLFxyXG4gICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjoge1xyXG4gICAgICAgICAgICB4OiBjdXJQb3MueCxcclxuICAgICAgICAgICAgeTogY3VyUG9zLnkgKyB2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgKiBNT0RJRklFUlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICB2aWV3RnJhbWVVaS5hcHBlbmRDaGlsZChkb3duKTtcclxuXHJcbiAgICAgIGNvbnN0IGxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU1HXCIpO1xyXG4gICAgICBsZWZ0LmNsYXNzTmFtZSA9IFwidHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX2xlZnQtYnV0dG9uXCI7XHJcbiAgICAgIGxlZnQuc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiTGVmdCBidXR0b25cIik7XHJcbiAgICAgIGxlZnQub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld0ZyYW1lc01hcFt2Zi5pZF07XHJcbiAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1wb3J0LXBvc2l0aW9uLWNoYW5nZWRcIiwge1xyXG4gICAgICAgICAgaWQ6IHZmLmlkLFxyXG4gICAgICAgICAgdmlld1BvcnRQb3NpdGlvbjoge1xyXG4gICAgICAgICAgICB4OiBjdXJQb3MueCAtIHZpZXdGcmFtZS5zaXplLndpZHRoICogTU9ESUZJRVIsXHJcbiAgICAgICAgICAgIHk6IGN1clBvcy55XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKGxlZnQpO1xyXG5cclxuICAgICAgY29uc3QgcmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU1HXCIpO1xyXG4gICAgICByaWdodC5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJSaWdodCBidXR0b25cIik7XHJcbiAgICAgIHJpZ2h0LmNsYXNzTmFtZSA9IFwidHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX3JpZ2h0LWJ1dHRvblwiO1xyXG4gICAgICByaWdodC5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF92aWV3RnJhbWVzTWFwW3ZmLmlkXTtcclxuICAgICAgICBjb25zdCBjdXJQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ2aWV3LXBvcnQtcG9zaXRpb24tY2hhbmdlZFwiLCB7XHJcbiAgICAgICAgICBpZDogdmYuaWQsXHJcbiAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgIHg6IGN1clBvcy54ICsgdmlld0ZyYW1lLnNpemUud2lkdGggKiBNT0RJRklFUixcclxuICAgICAgICAgICAgeTogY3VyUG9zLnlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgdmlld0ZyYW1lVWkuYXBwZW5kQ2hpbGQocmlnaHQpO1xyXG5cclxuICAgICAgY29uc3QgY29sbGFwc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU1HXCIpO1xyXG4gICAgICBjb2xsYXBzZS5jbGFzc05hbWUgPVxyXG4gICAgICAgIFwidHFfbGluZWFnZV91aV9fYnV0dG9uIHRxX2xpbmVhZ2VfdWlfX2NvbGxhcHNlLWJ1dHRvblwiO1xyXG4gICAgICBjb2xsYXBzZS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJDb2xsYXBzZSBidXR0b25cIik7XHJcblxyXG4gICAgICBjb2xsYXBzZS5vbmNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcihcInZpZXctZnJhbWUtY29sbGFwc2VkXCIsIHsgaWQ6IHZmLmlkLCBleHBhbmRlZDogZmFsc2UgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHZpZXdGcmFtZVVpLmFwcGVuZENoaWxkKGNvbGxhcHNlKTtcclxuXHJcbiAgICAgIF9idXR0b25zNFNldHNbdmYuaWRdID0ge1xyXG4gICAgICAgIHVwOiB1cCxcclxuICAgICAgICBkb3duOiBkb3duLFxyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoaW5kZXggIT09IGFyci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgY29uc3Qgc3BsaXR0ZXIgPSBuZXcgU3BsaXR0ZXIoXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZUE6IHZmLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVCOiBhcnJbaW5kZXggKyAxXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHBhcmFtZXRlcnNcclxuICAgICAgICApO1xyXG4gICAgICAgIF9zcGxpdHRlcnMucHVzaChzcGxpdHRlcik7XHJcbiAgICAgICAgX3VpQm9keS5hcHBlbmRDaGlsZChzcGxpdHRlci5lbCk7XHJcbiAgICAgICAgc3BsaXR0ZXIub24oXCJzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkXCIsIGZ1bmN0aW9uKGRpZmYpIHtcclxuICAgICAgICAgIHNlbGYudHJpZ2dlcihcInNwbGl0dGVyLXBvc2l0aW9uLWNoYW5nZWRcIiwgW3NwbGl0dGVyLCBkaWZmXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF91aVNldEZvclZpZXdGcmFtZXNbdmYuaWRdID0gdmlld0ZyYW1lVWk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfcmVmcmVzaFVJKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoIG5hdmlnYXRpb24gYnV0dG9ucy4gQnV0dG9uIGlzbid0IGFjdGl2ZSBpZiB0aGUgdmlld1BvcnQgY2FuJ3QgbW92ZSBieSB0aGlzIGRpcmVjdGlvbi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcmVmcmVzaFVJKCkge1xyXG4gICAgaWYgKCFfcm9vdCkgcmV0dXJuO1xyXG4gICAgX3JlZnJlc2hTcGxpdHRlcnNTdGF0ZSgpO1xyXG5cclxuICAgIF92aWV3RnJhbWVzLmZvckVhY2godmYgPT4ge1xyXG4gICAgICBjb25zdCBjaGVjayA9IGNoZWNrUGFnaW5hdGlvbih2Zik7XHJcblxyXG4gICAgICBfdWlTZXRGb3JWaWV3RnJhbWVzW3ZmLmlkXS5zdHlsZS5kaXNwbGF5ID0gdmYuYWN0aXZlID8gXCJcIiA6IFwibm9uZVwiO1xyXG5cclxuICAgICAgY29uc3QgdXAgPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS51cDtcclxuICAgICAgY29uc3QgZG93biA9IF9idXR0b25zNFNldHNbdmYuaWRdLmRvd247XHJcbiAgICAgIGNvbnN0IGxlZnQgPSBfYnV0dG9uczRTZXRzW3ZmLmlkXS5sZWZ0O1xyXG4gICAgICBjb25zdCByaWdodCA9IF9idXR0b25zNFNldHNbdmYuaWRdLnJpZ2h0O1xyXG5cclxuICAgICAgdXAuc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZVVwID8gXCJwb2ludGVyXCIgOiBcIm5vdC1hbGxvd2VkXCI7XHJcbiAgICAgIGRvd24uc3R5bGUuY3Vyc29yID0gY2hlY2suY2FuTW92ZURvd24gPyBcInBvaW50ZXJcIiA6IFwibm90LWFsbG93ZWRcIjtcclxuICAgICAgbGVmdC5zdHlsZS5jdXJzb3IgPSBjaGVjay5jYW5Nb3ZlTGVmdCA/IFwicG9pbnRlclwiIDogXCJub3QtYWxsb3dlZFwiO1xyXG4gICAgICByaWdodC5zdHlsZS5jdXJzb3IgPSBjaGVjay5jYW5Nb3ZlUmlnaHQgPyBcInBvaW50ZXJcIiA6IFwibm90LWFsbG93ZWRcIjtcclxuXHJcbiAgICAgIHVwLnN0eWxlLm9wYWNpdHkgPSBjaGVjay5jYW5Nb3ZlVXAgPyBcIlwiIDogXCIwLjAzXCI7XHJcbiAgICAgIGRvd24uc3R5bGUub3BhY2l0eSA9IGNoZWNrLmNhbk1vdmVEb3duID8gXCJcIiA6IFwiMC4wM1wiO1xyXG4gICAgICBsZWZ0LnN0eWxlLm9wYWNpdHkgPSBjaGVjay5jYW5Nb3ZlTGVmdCA/IFwiXCIgOiBcIjAuMDNcIjtcclxuICAgICAgcmlnaHQuc3R5bGUub3BhY2l0eSA9IGNoZWNrLmNhbk1vdmVSaWdodCA/IFwiXCIgOiBcIjAuMDNcIjtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3JlZnJlc2hTcGxpdHRlcnNTdGF0ZSgpIHtcclxuICAgIGNvbnN0IGFjdGl2ZUZyYW1lcyA9IF92aWV3RnJhbWVzXHJcbiAgICAgIC5maWx0ZXIodmYgPT4gdmYuYWN0aXZlKVxyXG4gICAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBvc0EgPSBhLnBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHBvc0IgPSBiLnBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChfZ3JhcGhPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIHBvc0EueCAtIHBvc0IueDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHBvc0EueSAtIHBvc0IueTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgY29uc3QgYWN0aXZlSWRzID0gYWN0aXZlRnJhbWVzLm1hcCh2ZiA9PiB2Zi5pZCk7XHJcblxyXG4gICAgaWYgKF9vcmllbnRhdGlvbikge1xyXG4gICAgICBfc3BsaXR0ZXJzLmZvckVhY2goc3BsaXR0ZXIgPT4ge1xyXG4gICAgICAgIHVwZGF0ZVNwbGl0dGVyKHNwbGl0dGVyKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGxldCBpID0gX3NwbGl0dGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHVwZGF0ZVNwbGl0dGVyKF9zcGxpdHRlcnNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlU3BsaXR0ZXIoc3BsaXR0ZXIpIHtcclxuICAgICAgaWYgKHNwbGl0dGVyLm1vZGVsLnZpZXdGcmFtZUEuYWN0aXZlKSB7XHJcbiAgICAgICAgY29uc3QgbmVpZ2hib3VyID0gZ2V0TmVpZ2hib3VyKHNwbGl0dGVyLm1vZGVsLnZpZXdGcmFtZUEuaWQpO1xyXG4gICAgICAgIGlmICghbmVpZ2hib3VyKSB7XHJcbiAgICAgICAgICBzcGxpdHRlci5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNwbGl0dGVyLnVwZGF0ZU5laWdoYm91cihuZWlnaGJvdXIpO1xyXG4gICAgICAgICAgc3BsaXR0ZXIuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzcGxpdHRlci5oaWRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXROZWlnaGJvdXIodmlld0ZyYW1lSWQpIHtcclxuICAgICAgaWYgKCF2aWV3RnJhbWVJZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gYWN0aXZlSWRzLmluZGV4T2Yodmlld0ZyYW1lSWQpO1xyXG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGFjdGl2ZUlkcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUZyYW1lc1tpbmRleCArIDFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZXNVSTtcclxuIiwiaW1wb3J0IHsgdW5pcXVlSWQsIGNsb25lLCBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBOb2RlLCBMaW5rLCBHcmFwaE5vZGUsIEdyYXBoTGluaywgR3JhcGhDcm9zc05vZGUsIEdyYXBoQ3Jvc3NMaW5rIH0gZnJvbSAnLi9tYXBFbGVtZW50cyc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NEYXRhIChyYXdEYXRhLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCB0b3BOb2RlTW9kZWxzID0gcHJvY2Vzc05vZGVzKHJhd0RhdGEubm9kZXMsIHBhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcE5vZGVzID0gY3JlYXRlRGlhZ3JhbU5vZGVzKHRvcE5vZGVNb2RlbHMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IG1hcExpbmtNb2RlbHMgPSBwcm9jZXNzTGlua3MocmF3RGF0YS5lZGdlcywgZGVyaXZhdGlvbk1hcE5vZGVzKTtcclxuICAgIC8vIENyZWF0ZSBmYWtlIGxpbmsgaWYgdGhlcmUgYXJlIG5vIGxpbmtzIGF0IGFsbCAoaXQgbWVhbnMgd2UgaGF2ZSBhIHByb2JsZW0gd2l0aCBhIGRhdGEpXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgaWYgKG1hcExpbmtNb2RlbHMubGVuZ3RoID09PSAwICYmIHRvcE5vZGVNb2RlbHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgY29uc3QgdG9wSWRzID0gdG9wTm9kZU1vZGVscy5tYXAodG0gPT4gdG0uaWQpO1xyXG4gICAgICAgIGNvbnN0IHRvcFZpZXdzID0gZGVyaXZhdGlvbk1hcE5vZGVzLmZpbHRlcihuID0+IHRvcElkcy5pbmRleE9mKG4uaWQpICE9PSAtMSk7XHJcbiAgICAgICAgbWFwTGlua01vZGVscy5wdXNoKHtcclxuICAgICAgICAgICAgc291cmNlOiB0b3BWaWV3c1swXSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0b3BWaWV3c1sxXSxcclxuICAgICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGNvbnN0IGZpbmFsTGlua01vZGVscyA9IGdyb3VwTGlua3MobWFwTGlua01vZGVscywgcGFyYW1ldGVycyk7XHJcbiAgICBjb25zdCBkZXJpdmF0aW9uTWFwTGlua3MgPSBmaW5hbExpbmtNb2RlbHMubWFwKG1vZGVsID0+IG5ldyBMaW5rKG1vZGVsLCBwYXJhbWV0ZXJzKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnRzOiBkZXJpdmF0aW9uTWFwTm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGRlcml2YXRpb25NYXBMaW5rcyxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgcHJvY2Vzc0RhdGE7XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzTGlua3MgKHJhd0xpbmtzLCBkZXJpdmF0aW9uTWFwTm9kZXMpIHtcclxuICAgIGlmICghcmF3TGlua3MpIHJldHVybiBbXTtcclxuIFxyXG4gICAgY29uc3Qgbm9kZU1hcCA9IHt9O1xyXG4gICAgZGVyaXZhdGlvbk1hcE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGVNYXBbbm9kZS5lbmRwb2ludElkXSkge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0ucHVzaChub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlTWFwW25vZGUuZW5kcG9pbnRJZF0gPSBbbm9kZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gY29uc3QgZXhpc3RpbmdMaW5rcyA9IHt9O1xyXG4gICAgLy8gcmF3TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgIC8vICAgICAobm9kZU1hcFtsaW5rLnNvdXJjZV0gfHwgW10pLmZvckVhY2goc291cmNlID0+IHtcclxuICAgIC8vICAgICAgICAgKG5vZGVNYXBbbGluay50YXJnZXRdIHx8IFtdKS5mb3JFYWNoKHRhcmdldCA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICBpZiAoIShleGlzdGluZ0xpbmtzW3NvdXJjZS5pZF0gJiYgZXhpc3RpbmdMaW5rc1tzb3VyY2UuaWRdW3RhcmdldC5pZF0pKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxMaW5rID0ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsaW5rLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKGxpbmsuaWQpLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICB0eXBlSWQ6IGxpbmsuaWQsXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgW3NvdXJjZS5pZF0uY29uY2F0KHNvdXJjZS5vcmRlcmVkUG9zc2libGVJZHMpLmZvckVhY2goc291cmNlSWQgPT4ge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nTGlua3Nbc291cmNlSWRdKSBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXSA9IHt9O1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0LmlkXS5jb25jYXQodGFyZ2V0Lm9yZGVyZWRQb3NzaWJsZUlkcykuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXVt0YXJnZXRJZF0gPSBmaW5hbExpbms7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgICB9KTtcclxuICAgIC8vICAgICB9KTtcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIC8vIGNvbnN0IGxpbmtzID0gW107XHJcbiAgICAvLyBPYmplY3Qua2V5cyhleGlzdGluZ0xpbmtzKS5mb3JFYWNoKHNvdXJjZUlkID0+IHtcclxuICAgIC8vICAgICBPYmplY3Qua2V5cyhleGlzdGluZ0xpbmtzW3NvdXJjZUlkXSkuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGxpbmsgPSBleGlzdGluZ0xpbmtzW3NvdXJjZUlkXVt0YXJnZXRJZF07XHJcbiAgICAvLyAgICAgICAgIGlmIChsaW5rcy5pbmRleE9mKGxpbmspID09PSAtMSkge1xyXG4gICAgLy8gICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH0pO1xyXG4gICAgLy8gfSk7XHJcblxyXG4gICAgY29uc3QgdW5pcU1hcCA9IHt9O1xyXG4gICAgY29uc3QgbGlua3MgPSBbXTtcclxuICAgIHJhd0xpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IG5vZGVNYXBbbGluay5zb3VyY2VdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBub2RlTWFwW2xpbmsudGFyZ2V0XTtcclxuICAgICAgICBpZiAoc291cmNlcyAmJiB0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtJZCA9IGNhY2hlRnVuY3Rpb24obGluayk7XHJcbiAgICAgICAgICAgIGlmICghdW5pcU1hcFtsaW5rSWRdKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlxTWFwW2xpbmtJZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsaW5rLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKGxpbmsuaWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUlkOiBsaW5rLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmtzO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhY2hlRnVuY3Rpb24gKHJhd0xpbmspIHtcclxuICAgICAgICByZXR1cm4gYCR7cmF3TGluay5zb3VyY2V9fiN0cURNTGluayN+JHtyYXdMaW5rLnRhcmdldH1gO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBncm91cExpbmtzIChsaW5rTW9kZWxzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBncm91cHNCeVNvdXJjZSA9IHt9O1xyXG4gICAgY29uc3QgZ3JvdXBzQnlUYXJnZXQgPSB7fTtcclxuXHJcbiAgICBsaW5rTW9kZWxzLmZvckVhY2gobGlua01vZGVsID0+IHtcclxuICAgICAgICBjb25zdCB0eXBlSWQgPSBsaW5rTW9kZWwudHlwZUlkIHx8IGxpbmtNb2RlbC5sYWJlbDtcclxuICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUlkID0gY2FjaGVGdW5jdGlvbih0eXBlSWQsIGxpbmtNb2RlbC5zb3VyY2UuaWQpO1xyXG4gICAgICAgIGlmICghZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0pIHtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0gPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0uc291cmNlID0gbGlua01vZGVsLnNvdXJjZTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0ubGFiZWwgPSBsaW5rTW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5U291cmNlW3NvdXJjZUNhY2hlSWRdLnR5cGVJZCA9IHR5cGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXBzQnlTb3VyY2Vbc291cmNlQ2FjaGVJZF0ucHVzaChsaW5rTW9kZWwpO1xyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXRDYWNoZUlkID0gY2FjaGVGdW5jdGlvbih0eXBlSWQsIGxpbmtNb2RlbC50YXJnZXQuaWQpO1xyXG4gICAgICAgIGlmICghZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0pIHtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0gPSBbXTtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0udGFyZ2V0ID0gbGlua01vZGVsLnRhcmdldDtcclxuICAgICAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0ubGFiZWwgPSBsaW5rTW9kZWwubGFiZWw7XHJcbiAgICAgICAgICAgIGdyb3Vwc0J5VGFyZ2V0W3RhcmdldENhY2hlSWRdLnR5cGVJZCA9IHR5cGVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXBzQnlUYXJnZXRbdGFyZ2V0Q2FjaGVJZF0ucHVzaChsaW5rTW9kZWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzQnlTb3VyY2UpLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNCeVNvdXJjZVtncm91cElkXTtcclxuICAgICAgICBjb25zdCBjcm9zc2VkRWxlbWVudHMgPSBncm91cC5sZW5ndGggPiAxID8gZ3JvdXAgOiBbXTtcclxuICAgICAgICBjb25zdCBjcm9zc05vZGUgPSBuZXcgR3JhcGhDcm9zc05vZGUoe2Nyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzfSk7XHJcbiAgICAgICAgY29uc3Qgc291cmNlTGluayA9IG5ldyBHcmFwaExpbmsoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IGdyb3VwLnNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgIGxhYmVsOiBncm91cC5sYWJlbCxcclxuICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgIGNyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNyb3NzZWRFbGVtZW50cy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpbmsgPSBuZXcgR3JhcGhDcm9zc0xpbmsoe1xyXG4gICAgICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGNyb3NzTm9kZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbGlua01vZGVsLnRhcmdldCxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmtNb2RlbC5ncmFwaFByaW1pdGl2ZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBjcm9zc05vZGUsIHNvdXJjZUxpbmssIHRhcmdldExpbmssXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGxpbmtNb2RlbC5ncm91cGVkQnkgPSAnc291cmNlJztcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGdyb3Vwc0J5VGFyZ2V0KS5mb3JFYWNoKGdyb3VwSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzQnlUYXJnZXRbZ3JvdXBJZF07XHJcbiAgICAgICAgY29uc3QgY3Jvc3NlZEVsZW1lbnRzID0gZ3JvdXAubGVuZ3RoID4gMSA/IGdyb3VwLmZpbHRlcihsaW5rTW9kZWwgPT4gIWxpbmtNb2RlbC5ncmFwaFByaW1pdGl2ZXMpIDogW107XHJcbiAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gbmV3IEdyYXBoQ3Jvc3NOb2RlKHtjcm9zc2VkRWxlbWVudHM6IGNyb3NzZWRFbGVtZW50c30pO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldExpbmsgPSBuZXcgR3JhcGhDcm9zc0xpbmsoe1xyXG4gICAgICAgICAgICBzb3VyY2U6IGNyb3NzTm9kZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiBncm91cC50YXJnZXQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBncm91cC5sYWJlbCxcclxuICAgICAgICAgICAgdHlwZUlkOiBncm91cC50eXBlSWQsXHJcbiAgICAgICAgICAgIGNyb3NzZWRFbGVtZW50czogY3Jvc3NlZEVsZW1lbnRzLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNyb3NzZWRFbGVtZW50cy5mb3JFYWNoKGxpbmtNb2RlbCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxpbmsgPSBuZXcgR3JhcGhMaW5rKHtcclxuICAgICAgICAgICAgICAgIHR5cGVJZDogZ3JvdXAudHlwZUlkLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBsaW5rTW9kZWwuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjcm9zc05vZGUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JhcGhQcmltaXRpdmVzID0gW1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NOb2RlLCBzb3VyY2VMaW5rLCB0YXJnZXRMaW5rLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsaW5rTW9kZWwuZ3JvdXBlZEJ5ID0gJ3RhcmdldCc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbGlua01vZGVscztcclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoZUZ1bmN0aW9uIChsYWJlbCwgdGVybWluYWxJZCkge1xyXG4gICAgICAgIHJldHVybiBgJHtsYWJlbH1+I3RxRE1MaW5rI34ke3Rlcm1pbmFsSWR9YDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc05vZGVzIChyYXdOb2RlcywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgdG9wTm9kZXNNYXAgPSB7fTtcclxuICAgIGNvbnN0IGFsbE5vZGVzTWFwID0ge307XHJcbiAgICBjb25zdCBwYXJlbnRNYXAgPSB7fTtcclxuICAgIGNvbnN0IHJlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHJhd05vZGVzLmZvckVhY2gocmF3Tm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHJhd05vZGUuaWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnRNYXBbcmF3Tm9kZS5pZF07XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVJY29uID0gcmVzLmdldEljb24ocmF3Tm9kZS50eXBlKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBhbGxOb2Rlc01hcFtyYXdOb2RlLmlkXSB8fCBjcmVhdGVNb2RlbChyYXdOb2RlLCBjaGlsZHJlbiwgdHlwZUljb24pO1xyXG4gICAgICAgICAgICBhbGxOb2Rlc01hcFtyYXdOb2RlLmlkXSA9IG1vZGVsO1xyXG4gICAgICAgICAgICBkZWxldGUgcGFyZW50TWFwW3Jhd05vZGUuaWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJhd05vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNNYXBbcmF3Tm9kZS5wYXJlbnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNNYXBbcmF3Tm9kZS5wYXJlbnRdLmNoaWxkcmVuLnB1c2gobW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE1hcFtyYXdOb2RlLnBhcmVudF0pIHBhcmVudE1hcFtyYXdOb2RlLnBhcmVudF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRNYXBbcmF3Tm9kZS5wYXJlbnRdLnB1c2gobW9kZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0b3BOb2Rlc01hcFtyYXdOb2RlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgdG9wTm9kZXNNYXBbcmF3Tm9kZS5pZF0gPSBtb2RlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByb2Nlc3Mgb3JwaGFuIG5vZGVzLlxyXG4gICAgLy8gVGhlcmUgd2VyZSBsaW5rcyB0byB0aGVtIGJ1dCBubyBkZWZlbml0aW9ucy5cclxuICAgIE9iamVjdC5rZXlzKHBhcmVudE1hcCkuZm9yRWFjaChpZCA9PiB7XHJcbiAgICAgICAgdG9wTm9kZXNNYXBbaWRdID0gY3JlYXRlTW9kZWwoe1xyXG4gICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBnZXRMYWJlbEZyb21JZChpZCksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBwYXJlbnRNYXBbaWRdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG9wTm9kZXMgPSBPYmplY3Qua2V5cyh0b3BOb2Rlc01hcCkubWFwKGtleSA9PiB0b3BOb2Rlc01hcFtrZXldKTtcclxuXHJcbiAgICAvLyByZW1vdmUgY3ljbGVzXHJcbiAgICBjb25zdCBwcm9jZXNzZWROb2Rlc01hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gcmVjdXJzaW9uIChyb290Tm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuSWRzID0ge307XHJcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4gPSByb290Tm9kZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoKCFwcm9jZXNzZWROb2Rlc01hcFtjaGlsZC5pZF0pICYmICghY2hpbGRyZW5JZHNbY2hpbGQuaWRdKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5JZHNbY2hpbGQuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVzTWFwW2NoaWxkLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZWN1cnNpb24oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNNYXBbY2hpbGQuaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b3BOb2Rlcy5maWx0ZXIodG9wID0+IHtcclxuICAgICAgICBpZiAoIXByb2Nlc3NlZE5vZGVzTWFwW3RvcC5pZF0pIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXNNYXBbdG9wLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlY3Vyc2lvbih0b3ApO1xyXG4gICAgICAgICAgICBwcm9jZXNzZWROb2Rlc01hcFt0b3AuaWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTW9kZWwgKHJhd05vZGUsIGNoaWxkcmVuLCB0eXBlSWNvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogdW5pcXVlSWQoJ21hcEVsZW1lbnQnKSxcclxuICAgICAgICBlbmRwb2ludElkOiByYXdOb2RlLmlkLFxyXG4gICAgICAgIGxhYmVsOiByYXdOb2RlLmxhYmVsIHx8IGdldExhYmVsRnJvbUlkKHJhd05vZGUuaWQpLFxyXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcclxuICAgICAgICByZXNvdXJjZVR5cGU6IHJhd05vZGUucmVzb3VyY2VUeXBlIHx8ICd1bmRlZmluZWQnLFxyXG4gICAgICAgIHJlc291cmNlOiByYXdOb2RlLnJlc291cmNlIHx8ICd1bmRlZmluZWQnLFxyXG4gICAgICAgIHR5cGU6IHJhd05vZGUudHlwZSB8fCAndW5kZWZpbmVkJyxcclxuICAgICAgICBjb2xsYXBzZWQ6IHJhd05vZGUuY29sbGFwc2VkLFxyXG4gICAgICAgIGljb246IHJhd05vZGUuaWNvbiB8fCB0eXBlSWNvbixcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURpYWdyYW1Ob2RlcyAodG9wTm9kZU1vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcE5vZGVzID0gW107XHJcblxyXG4gICAgZnVuY3Rpb24gY29weSAoZWxlbWVudCwgZHVibGljYXRpb25NYXApIHtcclxuICAgICAgICBjb25zdCBkdWJsaWNhdGlvbiA9IGR1YmxpY2F0aW9uTWFwIHx8IHt9O1xyXG4gICAgICAgIGlmICghZHVibGljYXRpb25bZWxlbWVudC5pZF0pIHtcclxuICAgICAgICAgICAgY29uc3QgY2xvbmVkRWxlbWVudCA9IGNsb25lKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjbG9uZWRFbGVtZW50LmlkID0gdW5pcXVlSWQoJ2NvcHlPZk1hcEVsZW1lbnQnKTtcclxuXHJcbiAgICAgICAgICAgIGR1YmxpY2F0aW9uW2VsZW1lbnQuaWRdID0gY2xvbmVkRWxlbWVudDtcclxuICAgICAgICAgICAgY2xvbmVkRWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNvcHkoY2hpbGQsIGR1YmxpY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkdWJsaWNhdGlvbltlbGVtZW50LmlkXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cCAobW9kZWwxLCBtb2RlbDIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogdW5pcXVlSWQoJ0dyb3VwJyksXHJcbiAgICAgICAgICAgIGxhYmVsOiAnR3JvdXAnLFxyXG4gICAgICAgICAgICBlbmRwb2ludElkOiAnbm9uZScsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbIG1vZGVsMSwgbW9kZWwyIF0sXHJcbiAgICAgICAgICAgIHN5bnRoZXRpYzogdHJ1ZSxcclxuICAgICAgICAgICAgY29sbGFwc2VkOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVG9Hcm91cCAoZ3JvdXAsIG1vZGVsKSB7XHJcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4ucHVzaChtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgbW9yZSB0aGVuIG9uZSB0b3BFbGVtZW50IGZvciBzb21lIG1vZGVsXHJcbiAgICBjb25zdCB0b3BFbGVtZW50Rm9ySWQgPSB7fTtcclxuICAgIGNvbnN0IGZpbHRlcmVkVG9wTW9kZWxzID0ge307XHJcbiAgICB0b3BOb2RlTW9kZWxzLmZvckVhY2godG9wRWxlbWVudCA9PiB7XHJcbiAgICAgICAgcmVjdXJzaW9uKHRvcEVsZW1lbnQpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWN1cnNpb24gKGN1ck1vZGVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uc3ludGhldGljICYmIHRvcEVsZW1lbnQuaWQgIT09IHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmlsdGVyZWRUb3BNb2RlbHNbdG9wRWxlbWVudC5pZF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdID0gY3JlYXRlR3JvdXAodG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXSwgdG9wRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkVG9wTW9kZWxzW3RvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0uaWRdID0gdG9wRWxlbWVudEZvcklkW2N1ck1vZGVsLmlkXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9Hcm91cCh0b3BFbGVtZW50Rm9ySWRbY3VyTW9kZWwuaWRdLCB0b3BFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5KGN1ck1vZGVsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRvcEVsZW1lbnRGb3JJZFtjdXJNb2RlbC5pZF0gPSB0b3BFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRUb3BNb2RlbHNbdG9wRWxlbWVudC5pZF0gPSB0b3BFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgY3VyTW9kZWwuY2hpbGRyZW4gPSBjdXJNb2RlbC5jaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPT4gcmVjdXJzaW9uKGNoaWxkKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyTW9kZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3Qua2V5cyhmaWx0ZXJlZFRvcE1vZGVscykuZm9yRWFjaCh0b3BFbGVtZW50SWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRvcEVsZW1lbnQgPSBmaWx0ZXJlZFRvcE1vZGVsc1t0b3BFbGVtZW50SWRdO1xyXG5cclxuICAgICAgICBjb25zdCBncmFwaE5vZGUgPSBuZXcgR3JhcGhOb2RlKHRvcEVsZW1lbnQsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZE5vZGVzID0ge307XHJcbiAgICAgICAgcmVjdXJzaW9uKHRvcEVsZW1lbnQsIFtdKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChjdXJNb2RlbCwgcG9zc2libGVJZHMpIHtcclxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gY2xvbmVEZWVwKGN1ck1vZGVsKTtcclxuICAgICAgICAgICAgICAgIG1vZGVsLm9yZGVyZWRQb3NzaWJsZUlkcyA9IHBvc3NpYmxlSWRzO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwuZ3JhcGhOb2RlID0gZ3JhcGhOb2RlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0gPSBuZXcgTm9kZShtb2RlbCwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2Rlc1tjdXJNb2RlbC5pZF0uY2hpbGRyZW4gPSBjdXJNb2RlbC5jaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPT4gcmVjdXJzaW9uKGNoaWxkLCBwb3NzaWJsZUlkcy5jb25jYXQoW2N1ck1vZGVsLmlkXSkpLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGRlcml2YXRpb25NYXBOb2Rlcy5wdXNoKHByb2Nlc3NlZE5vZGVzW2N1ck1vZGVsLmlkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZE5vZGVzW2N1ck1vZGVsLmlkXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGVyaXZhdGlvbk1hcE5vZGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRMYWJlbEZyb21JZCAoaWQpIHtcclxuICAgIGNvbnN0IHRlcm1zID0gaWQuc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHNsYXNoTGFiZWwgPSB0ZXJtc1t0ZXJtcy5sZW5ndGggLSAxXTtcclxuICAgIGlmIChzbGFzaExhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNsYXNoTGFiZWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IGlkLmluZGV4T2YoJyMnKTtcclxuICAgICAgICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNoTGFiZWwgPSBpZC5zdWJzdHJpbmcoaGFzaEluZGV4LCBpZC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hMYWJlbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBUUUdyYW1VSSBmcm9tIFwidmlzdWFsaXphdGlvbnMtbGlicmFyeVwiO1xyXG5pbXBvcnQgKiBhcyBfIGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHByb2Nlc3NEYXRhIGZyb20gXCIuL2RhdGFQcm9jZXNzaW5nXCI7XHJcbmltcG9ydCAqIGFzIG1hcEVsZW1lbnRzIGZyb20gXCIuL21hcEVsZW1lbnRzXCI7XHJcbmltcG9ydCB7IE1hcExheW91dCB9IGZyb20gXCIuL21hcExheW91dFwiO1xyXG5pbXBvcnQgeyBETURlZmF1bHRVSSB9IGZyb20gXCIuLi8uLi9odG1sVUkvZG1EZWZhdWx0VUlcIjtcclxuaW1wb3J0IHsgREVGQVVMVF9ERVJJVkFUSU9OX01BUF9MSU5LX1NUWUxFIH0gZnJvbSBcIi4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlclwiO1xyXG5pbXBvcnQgeyBjaGVja0RtUmF3RGF0YSB9IGZyb20gXCIuLi8uLi91dGlscy9kYXRhVXRpbHNcIjtcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tIFwiLi4vLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBMaW5rIHN0eWxlIGRlZmluaXRpb24gZm9yIERNXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERNTGlua1N0eWxlRGVmaW5pdGlvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3NzQ2xhc3MgLSBDU1MgY2xhc3Mgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgc3ZnIGNvbXBvbmVudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZVR5cGUgLSAnc29saWQnIG9yICdkYXNoZWQnXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAtIENvbG9yIG9mIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0Q29sb3IgLSBDb2xvciBvZiB0aGUgdGV4dCBvbiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dEJhY2tncm91bmRDb2xvciAtIENvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG9mIHRoZSB0ZXh0IG9uIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGlja25lc3NcclxuICovXHJcblxyXG4vKipcclxuICogU2V0IG9mIHBhcmFtZXRlcnMgZm9yIERlcml2YXRpb24gTWFwXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlcml2YXRpb25NYXBQYXJhbWV0ZXJzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIExpbmtTdHlsZURlZmluaXRpb24+fSBsaW5rU3R5bGVzIC0gTWFwIGJldHdlZW4gdGhlIGxpbmtUeXBlcyBhbmQgTGlua1N0eWxlcy5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRFbGVtZW50V2lkdGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZmF1bHRFbGVtZW50SGVpZ2h0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0TGlua0xhYmVsTGVuZ3RoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZWZhdWx0TGF5b3V0U3RlcFxyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvckNhbGxCYWNrIC0gaXQgaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHdhcm5pbmdzIGFuZCBlcnJvcnNcclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBkZWZhdWx0IHNldCBvZiBwYXJhbWV0ZXJzXHJcbiAqIEByZXR1cm5zIHtEZXJpdmF0aW9uTWFwUGFyYW1ldGVyc31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UGFyYW1ldGVyc1NldCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZGVmYXVsdEVsZW1lbnRXaWR0aDogMjUwLFxyXG4gICAgZGVmYXVsdEVsZW1lbnRIZWlnaHQ6IDI1MCxcclxuICAgIGRlZmF1bHRMaW5rTGFiZWxMZW5ndGg6IDEwMCxcclxuICAgIGRlZmF1bHRMYXlvdXRTdGVwOiAxNTAsXHJcbiAgICBsaW5rU3R5bGVzOiB7XHJcbiAgICAgIFwiZGVmYXVsdC1saW5rLXN0eWxlXCI6IERFRkFVTFRfREVSSVZBVElPTl9NQVBfTElOS19TVFlMRSxcclxuICAgICAgLy8gRXhhbXBsZTpcclxuICAgICAgLy8gJ3R5cGUtaWQtMTIzNCc6IHtcclxuICAgICAgLy8gICAgIGxpbmVUeXBlOiAnZGFzaGVkJywgLy8gJ3NvbGlkJ1xyXG4gICAgICAvLyAgICAgY3NzQ2xhc3M6ICdjbGFzcy0xMjMnXHJcbiAgICAgIC8vICAgICBjb2xvcjogJ2dyZWVuJyxcclxuICAgICAgLy8gICAgIHRleHRDb2xvcjogJ2JsdWUnLFxyXG4gICAgICAvLyAgICAgdGV4dEJhY2tncm91bmRDb2xvcjogJ3llbGxvdycsXHJcbiAgICAgIC8vICAgICB0aGlja25lc3M6IDUsXHJcbiAgICAgIC8vIH0sXHJcbiAgICB9LFxyXG4gICAgaWNvbnM6IHtcclxuICAgICAgXCJTUUwgc2NyaXB0XCI6IFwiZmFzIGZhLWNvZ1wiLFxyXG4gICAgICBcIkRhdGFiYXNlIFRhYmxlXCI6IFwiZmFzIGZhLWZvbGRlclwiLFxyXG4gICAgfSxcclxuICAgIHRvb2xzOiBbXSxcclxuICAgIGVycm9yQ2FsbEJhY2s6IHVuZGVmaW5lZCwgLy8gSXQgaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHdhcm5pbmdzIGFuZCBlcnJvcnNcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqIERpc3BsYXlzIGRlcml2YXRpb24gdmlldyBmb3Igc2VsZWN0ZWQgbGlua1xyXG4gKlxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBwYXJhbSB7XHJcbiAqICBkYXRhUHJvdmlkZXI6IERhdGFDb250YWluZXJcclxuICogIHJvb3RFbGVtZW50OiBIVE1MRWxlbWVudFxyXG4gKiAgcmVsYXRpb246IHsgc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nIH1cclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7RGVyaXZhdGlvbk1hcFBhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBwYXJhbWV0ZXJzIHNldFxyXG4gKlxyXG4gKiBQdWJsaWMgcHJvcGVydGllczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiByZWxhdGlvbjogeyBzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcgfVxyXG4gKlxyXG4gKiBQdWJsaWMgbWV0aG9kczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBvcGVuV2l0aFJlbGF0aW9uIChyZWxhdGlvbjogeyBzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcgfSkgLSBJbml0aWFsaXplcyBETSBkaWFncmFtXHJcbiAqIGV4cG9ydFRvU3ZnKClcclxuICogZXhwb3J0VG9QbmcoKVxyXG4gKiByZXNldEZvY3VzKClcclxuICogem9vbUluKClcclxuICogem9vbU91dCgpXHJcbiAqIHpvb21Ub0ZpdCgpXHJcbiAqIHByaW50KClcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB1bnN1YnNjcmliZSAoY2FsbGJhY2s6IGZ1bmN0aW9uKTogdm9pZFxyXG4gKiB0cmlnZ2VyIChldmVudDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBhbnkpOiB2b2lkXHJcbiAqXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkIChzdGF0ZUlkOiBzdHJpbmcpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gRGVyaXZhdGlvbk1hcChwcm9wZXJ0aWVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgU3Vic2NyaWJhYmxlLmFwcGx5KHRoaXMpO1xyXG5cclxuICBjb25zdCBkZWZhdWx0UGFyYW1ldGVyU2V0ID0gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQoKTtcclxuICAvLyBNZXJnaW5nIHBhcmFtZXRlcnMgZGVmYXVsdCBhbmQgdXNlclxyXG4gIGNvbnN0IF9wYXJhbWV0ZXJzID0gXy5tZXJnZShkZWZhdWx0UGFyYW1ldGVyU2V0LCBwYXJhbWV0ZXJzIHx8IHt9KTtcclxuXHJcbiAgY29uc3QgX2Vycm9yQ2FsbGJhY2sgPSAoZSkgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrICYmXHJcbiAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIGUgPT09IFwic3RyaW5nXCIgPyBuZXcgRXJyb3IoZSkgOiBlO1xyXG4gICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXRlIGNoYW5nZWQgZXZlbnQgLSBmaXJlcyB3aGVuIERNIHN0YXRlIGNoYW5nZXMuXHJcbiAgICogRS5nLiBmcm9tIGEgZmV0Y2hpbmcgc3RhdGUgdG8gYSByZW5kZXJpbmcgc3RhdGUuXHJcbiAgICogVGhlIHN0YXRlIHN0cmluZyBpZGVudGlmaWVyIGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudFxyXG4gICAqIEBldmVudCBkaWFncmFtLXN0YXRlLWNoYW5nZWRcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIFBhcmFtZXRlciBjYW4gdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczogJ2ZldGNoaW5nJyB8ICdyZW5kZXJpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnZXJyb3InXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gIGNvbnN0IF9kYXRhUHJvdmlkZXIgPSBwcm9wZXJ0aWVzLmRhdGFQcm92aWRlcjtcclxuICBjb25zdCBfYmFzZSA9IF9jcmVhdGVCYXNlKHByb3BlcnRpZXMucm9vdEVsZW1lbnQpO1xyXG5cclxuICBjb25zdCBfbGF5b3V0ID0gbmV3IE1hcExheW91dChcclxuICAgIHtcclxuICAgICAgcm9vdEVsZW1lbnQ6IF9iYXNlLmRlcml2YXRpb25NYXBSb290SHRtbCxcclxuICAgIH0sXHJcbiAgICBfcGFyYW1ldGVyc1xyXG4gICk7XHJcbiAgY29uc3QgX3Byb2dyZXNzU2NyZWVuID0gbmV3IFRRR3JhbVVJLlByb2dyZXNzU2NyZWVuKHtcclxuICAgIGJhc2VFbGVtZW50OiBfYmFzZS5jb250YWluZXIsXHJcbiAgfSk7XHJcblxyXG4gIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gIGxldCBfZGlhZ3JhbUluZm8gPSB1bmRlZmluZWQ7XHJcblxyXG4gIC8vIEluaXRpYWxpemF0aW9uXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgY29uc3QgX2RlZmF1bHRVSSA9IG5ldyBETURlZmF1bHRVSSh7XHJcbiAgICBiYXNlRWxlbWVudDogX2Jhc2UudG9vbGJhcixcclxuICAgIGluZm9QYW5lbDogX2Jhc2UuaW5mb1BhbmVsLFxyXG4gICAgdG9vbHM6IF9wYXJhbWV0ZXJzLnRvb2xzIHx8IG51bGwsXHJcbiAgICBkZXJpdmF0aW9uTWFwOiBzZWxmLFxyXG4gIH0pO1xyXG5cclxuICBpZiAocHJvcGVydGllcy5yZWxhdGlvbikge1xyXG4gICAgX29wZW5XaXRoUmVsYXRpb24ocHJvcGVydGllcy5yZWxhdGlvbik7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWMgZnVuY3Rpb25zXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgc2VsZi5yZWxhdGlvbjtcclxuICBzZWxmLm9wZW5XaXRoUmVsYXRpb24gPSBfb3BlbldpdGhSZWxhdGlvbjtcclxuXHJcbiAgc2VsZi5yZXNldEZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xheW91dC56b29tKCk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5nZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX3NlbGVjdGVkRWxlbWVudDtcclxuICB9O1xyXG5cclxuICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkRUxlbWVudCA9IF9sYXlvdXRcclxuICAgICAgLmdldE5vZGVzKClcclxuICAgICAgLmZpbmQoKGVsKSA9PiBlbC5pZCA9PT0gZWxlbWVudElkKTtcclxuICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoc2VsZWN0ZWRFTGVtZW50KTtcclxuICB9O1xyXG5cclxuICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIF9sYXlvdXQuc2V0U2VhcmNoS2V5KGtleSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5leHBhbmRBbGxFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9sYXlvdXQuZ2V0Tm9kZXMoKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5leHBhbmQoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHNlbGYuY29sbGFwc2VBbGxFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9sYXlvdXQuZ2V0Tm9kZXMoKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5jb2xsYXBzZSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5leHBvcnRUb1N2ZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9sYXlvdXQuZXhwb3J0KHsgdHlwZTogXCJzdmdcIiB9KTtcclxuICB9O1xyXG5cclxuICBzZWxmLmV4cG9ydFRvUG5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xheW91dC5leHBvcnQoeyB0eXBlOiBcInBuZ1wiIH0pO1xyXG4gIH07XHJcblxyXG4gIHNlbGYuem9vbUluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xheW91dC56b29tKDAuMiwgeyBtYXg6IDQgfSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi56b29tT3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xheW91dC56b29tKC0wLjIsIHsgbWluOiAwLjIgfSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi56b29tVG9GaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfbGF5b3V0Lnpvb20oKTtcclxuICB9O1xyXG5cclxuICBzZWxmLnByaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX2xheW91dC5wcmludCgpO1xyXG4gIH07XHJcblxyXG4gIHNlbGYuZ2V0RGlhZ3JhbUluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2RpYWdyYW1JbmZvO1xyXG4gIH07XHJcblxyXG4gIC8vIFByaXZhdGUgZnVuY3Rpb25zXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZnVuY3Rpb24gX29wZW5XaXRoUmVsYXRpb24ocmVsYXRpb24pIHtcclxuICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKTtcclxuICAgIGlmIChyZWxhdGlvbikge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXNlbGYucmVsYXRpb24gfHxcclxuICAgICAgICByZWxhdGlvbi5zb3VyY2UgIT09IHNlbGYucmVsYXRpb24uc291cmNlIHx8XHJcbiAgICAgICAgcmVsYXRpb24udGFyZ2V0ICE9PSBzZWxmLnJlbGF0aW9uLnRhcmdldCB8fFxyXG4gICAgICAgIHJlbGF0aW9uLmxpbmtUeXBlICE9PSBzZWxmLnJlbGF0aW9uLmxpbmtUeXBlXHJcbiAgICAgICkge1xyXG4gICAgICAgIF9sYXlvdXQuY2xlYXIoKTtcclxuICAgICAgICBzZWxmLnJlbGF0aW9uID0gcmVsYXRpb247XHJcbiAgICAgICAgX3NldERpYWdyYW1TdGF0ZShcImZldGNoaW5nXCIpO1xyXG4gICAgICAgIF9kYXRhUHJvdmlkZXJcclxuICAgICAgICAgIC5yZWxhdGlvbkluZm8ocmVsYXRpb24pXHJcbiAgICAgICAgICAudGhlbigocmF3RGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKFwicmVuZGVyaW5nXCIpO1xyXG5cclxuICAgICAgICAgICAgY2hlY2tEbVJhd0RhdGEocmF3RGF0YSk7XHJcblxyXG4gICAgICAgICAgICBfZGlhZ3JhbUluZm8gPSByYXdEYXRhLmRpYWdyYW1JbmZvO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbWFwRWxlbWVudHMgPSBwcm9jZXNzRGF0YShyYXdEYXRhLCBfcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIF9sYXlvdXQuc2V0RWxlbWVudHMoXHJcbiAgICAgICAgICAgICAgbWFwRWxlbWVudHMuZWxlbWVudHMuY29uY2F0KG1hcEVsZW1lbnRzLmxpbmtzKSxcclxuICAgICAgICAgICAgICBfZGlhZ3JhbUluZm9cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc2VsZi5yZXNldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIF9zdWJzY3JpYmVPbkVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoXCJjb21wbGV0ZWRcIik7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmNhdGNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIGUgPT09IFwic3RyaW5nXCIgPyBuZXcgRXJyb3IoZSkgOiBlO1xyXG5cclxuICAgICAgICAgICAgX3NldERpYWdyYW1TdGF0ZShcImVycm9yXCIsIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYucmVzZXRGb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBlcnJvclRleHQgPSBcIlRoZSByZWxhdGlvbiB5b3Ugd2FudCB0byB1c2UgaXMgZW1wdHkhXCI7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yVGV4dCk7XHJcbiAgICAgIF9zZXREaWFncmFtU3RhdGUoXCJlcnJvclwiLCBlcnJvclRleHQpO1xyXG4gICAgICBfZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3N1YnNjcmliZU9uRWxlbWVudHMoKSB7XHJcbiAgICBfbGF5b3V0LmdldE5vZGVzKCkuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgZWwub24oXCJlbGVtZW50LWNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KGVsKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGVsLm9uKFwiY29sbGFwc2UtYnV0dG9uLWNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICBjb25zdCBtb2RlbCA9IGVsLmdldE1vZGVsKCk7XHJcbiAgICAgICAgaWYgKG1vZGVsLmNvbGxhcHNlZCkge1xyXG4gICAgICAgICAgZWwuZXhwYW5kKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVsLmNvbGxhcHNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9sYXlvdXQuZ2V0TGlua3MoKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5vbihcImVsZW1lbnQtY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgIF9zZXRTZWxlY3RlZEVsZW1lbnQoZWwpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2xheW91dC5vbihcImJsYW5rLWNsaWNrXCIsICgpID0+IF9zZXRTZWxlY3RlZEVsZW1lbnQodW5kZWZpbmVkKSk7XHJcblxyXG4gIGZ1bmN0aW9uIF9zZXRTZWxlY3RlZEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQpIF9zZWxlY3RlZEVsZW1lbnQuaGlnaGxpZ2h0aW5nKGZhbHNlKTtcclxuICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSBfc2VsZWN0ZWRFbGVtZW50LmhpZ2hsaWdodGluZyh0cnVlKTtcclxuICAgIF9kZWZhdWx0VUkuaW5mb1BhbmVsLnNldFNlbGVjdGVkRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICBzZWxmLnRyaWdnZXIoXCJzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcIiwgX2dldE1vZGVsKGVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhdGUgb2YgaW5kaWNhdG9yXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGUgLSBmZXRjaGluZyB8IHJlbmRlcmluZyB8IGNvbXBsZXRlZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQ3VzdG9tIG1lc3NhZ2VcclxuICAgKi9cclxuICBmdW5jdGlvbiBfc2V0RGlhZ3JhbVN0YXRlKHN0YXRlLCBtZXNzYWdlKSB7XHJcbiAgICBzZWxmLnN0YXRlID0gc3RhdGU7XHJcbiAgICBpZiAoc3RhdGUgPT09IFwiZmV0Y2hpbmdcIikge1xyXG4gICAgICBfcHJvZ3Jlc3NTY3JlZW4uc2V0U3RhdGUoXCJhY3RpdmVcIiwgbWVzc2FnZSB8fCBcIkZldGNoaW5nIGRhdGFcIik7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcInJlbmRlcmluZ1wiKSB7XHJcbiAgICAgIF9wcm9ncmVzc1NjcmVlbi5zZXRTdGF0ZShcImFjdGl2ZVwiLCBtZXNzYWdlIHx8IFwiUmVuZGVyaW5nIGdyYXBoXCIpO1xyXG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xyXG4gICAgICBfcHJvZ3Jlc3NTY3JlZW4uc2V0U3RhdGUoXCJjb21wbGV0ZWRcIik7XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKFwiZXJyb3JcIiwgbWVzc2FnZSB8fCBcIkVycm9yIGhhcyBvY2N1cnJlZCFcIik7XHJcbiAgICB9XHJcbiAgICBzZWxmLnRyaWdnZXIoXCJkaWFncmFtLXN0YXRlLWNoYW5nZWRcIiwgbWVzc2FnZSB8fCBzdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0TW9kZWwoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBtYXBFbGVtZW50cy5Ob2RlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGVsZW1lbnQuaWQsXHJcbiAgICAgICAgbGFiZWw6IGVsZW1lbnQubGFiZWwsXHJcbiAgICAgICAgcmVzb3VyY2U6IGVsZW1lbnQucmVzb3VyY2UsXHJcbiAgICAgICAgcGFyZW50OiBlbGVtZW50LnBhcmVudCxcclxuICAgICAgICByZXNvdXJjZVR5cGU6IGVsZW1lbnQucmVzb3VyY2VUeXBlLFxyXG4gICAgICAgIGRpYWdyYW1UeXBlOiBcIm5vZGVcIixcclxuICAgICAgICBlbmRwb2ludElkOiBlbGVtZW50LmVuZHBvaW50SWQsXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBtYXBFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGVsZW1lbnQuaWQsXHJcbiAgICAgICAgc291cmNlOiBlbGVtZW50LnNvdXJjZS5lbmRwb2ludElkLFxyXG4gICAgICAgIHRhcmdldDogZWxlbWVudC50YXJnZXQuZW5kcG9pbnRJZCxcclxuICAgICAgICBkaWFncmFtVHlwZTogXCJsaW5rXCIsXHJcbiAgICAgICAgdHlwZUlkOiBlbGVtZW50LnR5cGVJZCxcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGh0bWwgbWFya3VwLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbE5vZGUgLSBSb290IG5vZGUgZm9yIG1hcmt1cFxyXG4gICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgSFRNTEVsZW1lbnQ+fSAtIE1hcCBvZiBodG1sIGVsZW1lbnRzXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2NyZWF0ZUJhc2UoaHRtbE5vZGUpIHtcclxuICAgIGh0bWxOb2RlLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICBodG1sTm9kZS50YWJJbmRleCA9IDA7XHJcblxyXG4gICAgY29uc3Qgcm93Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgIHJvd0NvbnRhaW5lci5jbGFzc05hbWUgPSBcInRxLXJvdy1jb250YWluZXJcIjtcclxuICAgIGh0bWxOb2RlLmFwcGVuZENoaWxkKHJvd0NvbnRhaW5lcik7XHJcblxyXG4gICAgY29uc3QgYmFzZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICBiYXNlRGl2LmNsYXNzTmFtZSA9IFwidHEtZGVyaXZhdGlvbi1tYXBcIjtcclxuICAgIGJhc2VEaXYuaWQgPSBcInRxLWRlcml2YXRpb24tbWFwXCI7XHJcbiAgICByb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFzZURpdik7XHJcblxyXG4gICAgY29uc3QgZGVyaXZhdGlvbk1hcFJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgIGRlcml2YXRpb25NYXBSb290SHRtbC5jbGFzc05hbWUgPSBcInRxLWRlcml2YXRpb24tbWFwLWRpYWdyYW1cIjtcclxuICAgIGRlcml2YXRpb25NYXBSb290SHRtbC5pZCA9IFwidHEtZGVyaXZhdGlvbi1tYXAtZGlhZ3JhbVwiO1xyXG4gICAgYmFzZURpdi5hcHBlbmRDaGlsZChkZXJpdmF0aW9uTWFwUm9vdEh0bWwpO1xyXG5cclxuICAgIGNvbnN0IHByb2dyZXNzSW5kaWNhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICBwcm9ncmVzc0luZGljYXRpb24uY2xhc3NOYW1lID0gXCJ0cS1sZy1wcm9ncmVzcy1zY3JlZW5cIjtcclxuICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQocHJvZ3Jlc3NJbmRpY2F0aW9uKTtcclxuXHJcbiAgICBjb25zdCB0b29sYmFyQmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICB0b29sYmFyQmFzZS5jbGFzc05hbWUgPSBcInRxLWRlcml2YXRpb24tbWFwX190b29sYmFyXCI7XHJcbiAgICB0b29sYmFyQmFzZS5pZCA9IFwidHEtZGVyaXZhdGlvbi1tYXAtdG9vbGJhclwiO1xyXG4gICAgYmFzZURpdi5hcHBlbmRDaGlsZCh0b29sYmFyQmFzZSk7XHJcblxyXG4gICAgY29uc3QgaW5mb1BhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcclxuICAgIGluZm9QYW5lbC5jbGFzc05hbWUgPSBcInRxLXJvdy1jb250YWluZXJfX3Byb3BlcnRpZXMtcGFuZVwiO1xyXG4gICAgaW5mb1BhbmVsLmlkID0gXCJ0cS1wcm9wZXJ0aWVzLXBhbmVcIjtcclxuICAgIHJvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChpbmZvUGFuZWwpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvbnRhaW5lcjogaHRtbE5vZGUsXHJcbiAgICAgIGJhc2VEaXY6IGJhc2VEaXYsXHJcbiAgICAgIGluZm9QYW5lbDogaW5mb1BhbmVsLFxyXG4gICAgICB0b29sYmFyOiB0b29sYmFyQmFzZSxcclxuICAgICAgZGVyaXZhdGlvbk1hcFJvb3RIdG1sOiBkZXJpdmF0aW9uTWFwUm9vdEh0bWwsXHJcbiAgICAgIHByb2dyZXNzOiBwcm9ncmVzc0luZGljYXRpb24sXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGVyaXZhdGlvbk1hcDtcclxuIiwiaW1wb3J0IHsgZ2V0RGlzdCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgZ2V0Q3Jvc1BvaW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcblxyXG5jb25zdCBFTEVNRU5UX09GRlNFVCA9IDEwO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRtcm91dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobWFudWFsVmVydGljZXMsIG9wdHMsIGxpbmtWaWV3KSB7XHJcbiAgICAgICAgdGhpcy5fZmluZENvbm5lY3Rpb25Qb2ludHMoW10pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBidWlsZFdheSh0aGlzLnNvdXJjZVBvaW50LCB0aGlzLnRhcmdldFBvaW50KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYnVpbGRXYXkgKHN0YXJ0LCBmaW5pc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBsaW5rVmlldy5tb2RlbC5ncmFwaC5nZXRFbGVtZW50cygpLm1hcChlbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZWwuZ2V0QkJveCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gcmVjdC5jZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdEE6IGdldERpc3QoY2VudGVyLCBzdGFydCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5kaXN0ID4gYi5kaXN0KSByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLmRpc3QgPCBiLmRpc3QpIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB7IHAxOiBzdGFydCwgcDI6IGZpbmlzaCB9O1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQucmVjdDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50U2lkZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwMTogeyB4OiByZWN0LngsIHk6IHJlY3QueSB9LCBwMjogeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgcDE6IHsgeDogcmVjdC54LCB5OiByZWN0LnkgfSwgcDI6IHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwMTogeyB4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0sIHAyOiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB7IHAxOiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSB9LCBwMjogeyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCAgfSB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBlbGVtZW50U2lkZXMubWFwKHNpZGUgPT4gZ2V0Q3Jvc1BvaW50KGxpbmUucDEsIGxpbmUucDIsIHNpZGUucDEsIHNpZGUucDIpKS5maWx0ZXIocG9pbnQgPT4gcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0V2l0aE9iamVjdCA9IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggIT09IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdFdpdGhPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50UG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHJlY3QueCAtIEVMRU1FTlRfT0ZGU0VULCB5OiByZWN0LnkgLSBFTEVNRU5UX09GRlNFVCB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGggKyBFTEVNRU5UX09GRlNFVCwgeTogcmVjdC55IC0gRUxFTUVOVF9PRkZTRVQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiByZWN0LnggKyByZWN0LndpZHRoICsgRUxFTUVOVF9PRkZTRVQsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgRUxFTUVOVF9PRkZTRVQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiByZWN0LnggLSBFTEVNRU5UX09GRlNFVCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgKyBFTEVNRU5UX09GRlNFVCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsUG9pbnRzID0gZWxlbWVudFBvaW50cy5jb25jYXQoW3N0YXJ0LCBmaW5pc2hdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBodWxsID0gZ2V0Q29udmV4SHVsbChhbGxQb2ludHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWhjZSA9IGh1bGwubWFwKHAgPT4gcG9pbnRUb1N0cmluZyhwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGNhaGNlLmluZGV4T2YocG9pbnRUb1N0cmluZyhzdGFydCkpOyBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNhaGNlLmluZGV4T2YocG9pbnRUb1N0cmluZyhmaW5pc2gpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdheTEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCAhPT0gLTEgJiYgZW5kSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydEluZGV4OyBqICE9PSBlbmRJbmRleDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBodWxsLmxlbmd0aCkgeyBqID0gMDsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IHN0YXJ0SW5kZXggJiYgaiAhPT0gZW5kSW5kZXgpIHdheTEucHVzaChodWxsW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YXkxLmxlbmd0aCA+PSBodWxsLmxlbmd0aCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdheTIgPSBodWxsLmZpbHRlcigocCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT09IHN0YXJ0SW5kZXggJiYgaSAhPT0gZW5kSW5kZXggJiYgd2F5MS5pbmRleE9mKHApID09PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXkxID0gY29ycmVjdERpcmVjdGlvbihzdGFydCwgd2F5MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdheTIgPSBjb3JyZWN0RGlyZWN0aW9uKHN0YXJ0LCB3YXkyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxXYXkxID0gW3N0YXJ0XS5jb25jYXQod2F5MSkuY29uY2F0KGZpbmlzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxXYXkyID0gW3N0YXJ0XS5jb25jYXQod2F5MikuY29uY2F0KGZpbmlzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aDEgPSBjYWxjdWxhdGVXYXlMZW5ndGgoZnVsbFdheTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGgyID0gY2FsY3VsYXRlV2F5TGVuZ3RoKGZ1bGxXYXkyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2F5ID0gbGVuZ3RoMSA8IGxlbmd0aDIgPyB3YXkxIDogd2F5MjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YXk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gY29ycmVjdERpcmVjdGlvbiAoc3RhcnQsIHdheSkge1xyXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHdheVswXTtcclxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHdheVt3YXkubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKHdheS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaWYgKGdldERpc3QoZmlyc3RQb2ludCwgc3RhcnQpID4gZ2V0RGlzdChsYXN0UG9pbnQsIHN0YXJ0KSkge1xyXG4gICAgICAgICAgICB3YXkucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gd2F5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVXYXlMZW5ndGggKHdheSkge1xyXG4gICAgbGV0IGxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdheS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBjb25zdCBmcm9tID0gd2F5W2ldO1xyXG4gICAgICAgIGNvbnN0IHRvID0gd2F5W2kgKyAxXTtcclxuICAgICAgICBsZW5ndGggKz0gZ2V0RGlzdChmcm9tLCB0byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2ludFRvU3RyaW5nIChwKSB7XHJcbiAgICByZXR1cm4gJycgKyBwLnggKyAnOicgKyBwLnk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbnZleEh1bGwgKG5vZGVzKSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSBbXS5jb25jYXQobm9kZXMpO1xyXG4gICAgcG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS54ICE9IGIueCA/IGEueCAtIGIueCA6IGEueSAtIGIueTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgY29uc3QgaHVsbCA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAqIG47IGkrKykge1xyXG4gICAgICAgIGxldCBqID0gaSA8IG4gPyBpIDogMiAqIG4gLSAxIC0gaTtcclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgIGh1bGwubGVuZ3RoID49IDIgJiZcclxuICAgICAgICAgICAgcmVtb3ZlTWlkZGxlKFxyXG4gICAgICAgICAgICAgICAgICBodWxsW2h1bGwubGVuZ3RoIC0gMl0sXHJcbiAgICAgICAgICAgICAgICAgIGh1bGxbaHVsbC5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApIGh1bGwucG9wKCk7XHJcbiAgICAgICAgaHVsbC5wdXNoKHBvaW50c1tqXSk7XHJcbiAgICB9XHJcbiAgICBodWxsLnBvcCgpO1xyXG5cclxuICAgIGNvbnN0IGZpbHRlckR1YmxpY2F0aW9uID0ge307XHJcbiAgICByZXR1cm4gaHVsbC5maWx0ZXIocCA9PiB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJZChwKTtcclxuICAgICAgICBpZiAoZmlsdGVyRHVibGljYXRpb25baWRdKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZmlsdGVyRHVibGljYXRpb25baWRdID0gcDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU1pZGRsZSAoYSwgYiwgYykge1xyXG4gICAgICAgIGNvbnN0IGNyb3NzID0gKGEueCAtIGIueCkgKiAoYy55IC0gYi55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGIueCk7XHJcbiAgICAgICAgLy8gY29uc3QgZG90ID0gKGEueCAtIGIueCkgKiAoYy54IC0gYi54KSArIChhLnkgLSBiLnkpICogKGMueSAtIGIueSk7XHJcbiAgICAgICAgcmV0dXJuIGNyb3NzIDwgMDsvLyB8fCAoY3Jvc3MgPT0gMCAmJiBkb3QgPD0gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SWQgKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LnggKyAnOicgKyBwb2ludC55O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi8uLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBkbXJvdXRlciB9IGZyb20gJy4vbGluZVJvdXRpbmcnO1xyXG5cclxuY29uc3QgREVGQVVMVF9MSU5LX1RZUEUgPSAnZGVyaXZhdGlvbi1saW5rJztcclxuY29uc3QgTUFSS0VSX1RBUkdFVCA9IHtcclxuICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsXHJcbn07XHJcbmV4cG9ydCBjb25zdCBMSU5LX0xBQkVMX0ZPTlRfU0laRSA9IDE2O1xyXG5leHBvcnQgY29uc3QgWl9JTkRFWEVTID0ge1xyXG4gICAgTk9ERTogMzAsXHJcbiAgICBTRUxFQ1RFRF9FTEVNRU5UOiAyMCxcclxuICAgIExJTks6IDE1LFxyXG4gICAgQkxVUkVEX05PREU6IDEwLFxyXG4gICAgQkxVUkVEX0xJTks6IDUsXHJcbn07XHJcblxyXG5qb2ludC5yb3V0ZXJzLmRtcm91dGVyID0gZG1yb3V0ZXI7XHJcblxyXG4vKipcclxuICogTm9kZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBlbGVtZW50LWNsaWNrXHJcbiAqIEBmaXJlcyBjb2xsYXBzZS1idXR0b24tY2xpY2tcclxuICogQGZpcmVzIHBvcnRzLXN0YXRlLWNoYW5nZWRcclxuICogQGZpcmVzIGVsZW1lbnQtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgcG9zaXRpb24tY2hhbmdlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5vZGUgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGZpcmVzIHdoZW4gdXNlciBjbGljayBvbiBub2RlLlxyXG4gICAgICogQGV2ZW50IGVsZW1lbnQtY2xpY2tcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge01vdXNlRXZlbnR9IGV2ZW50IC0gb3JpZ2luIE1vdXNlRXZ0bnRcclxuICAgICovXHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfZ3JhcGhOb2RlID0gb3B0aW9ucy5ncmFwaE5vZGUgfHwgbmV3IEdyYXBoTm9kZShvcHRpb25zLm1vZGVsLCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBzZWxmLmlkID0gb3B0aW9ucy5pZDtcclxuICAgIHNlbGYuZW5kcG9pbnRJZCA9IG9wdGlvbnMuZW5kcG9pbnRJZDtcclxuICAgIHNlbGYucmVzb3VyY2VUeXBlID0gb3B0aW9ucy5yZXNvdXJjZVR5cGU7XHJcbiAgICBzZWxmLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xyXG4gICAgc2VsZi5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XHJcbiAgICBzZWxmLmNoaWxkcmVuID0gb3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIHNlbGYub3JkZXJlZFBvc3NpYmxlSWRzID0gb3B0aW9ucy5vcmRlcmVkUG9zc2libGVJZHM7XHJcbiAgICBzZWxmLnJlc291cmNlID0gb3B0aW9ucy5yZXNvdXJjZTtcclxuXHJcbiAgICBzZWxmLmhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX2dyYXBoTm9kZS5zZXRIaWdobGlnaHRlZElkKHNlbGYuaWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaWQgPT09IF9ncmFwaE5vZGUuaGlnaGxpZ2h0ZWRJZCkge1xyXG4gICAgICAgICAgICAgICAgX2dyYXBoTm9kZS5zZXRIaWdobGlnaHRlZElkKHVuZGVmaW5lZCk7ICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9ncmFwaE5vZGUuaGlnaGxpZ2h0ZWRJZCA9PT0gc2VsZi5pZDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5jb2xsYXBzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfZ3JhcGhOb2RlLl9jb2xsYXBzZUVsZW1lbnQoc2VsZi5pZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9ncmFwaE5vZGUuX2V4cGFuZEVsZW1lbnQoc2VsZi5pZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBub3QgaW1wbGVtZW50ZWQuLlxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkLi5cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtfZ3JhcGhOb2RlXTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBfZ2V0QXZhaWxhYmxlUG9ydElkKCksXHJcbiAgICAgICAgICAgIHByaW1pdGl2ZTogX2dyYXBoTm9kZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmdldE1vZGVsID0gX2dldE1vZGVsO1xyXG5cclxuICAgIHNlbGYuZ2V0UG9ydFBvc2l0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN2Z09iamVjdCA9IF9ncmFwaE5vZGUuYXR0cihgLiR7Z2V0UG9ydElkKF9nZXRBdmFpbGFibGVQb3J0SWQoKSwgZGlyZWN0aW9uKX1gKTtcclxuICAgICAgICBjb25zdCBwcmltaXRpdmVQb3NpdGlvbiA9IHNlbGYuZ2V0UG9ydCgpLnByaW1pdGl2ZS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGlmIChzdmdPYmplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHN2Z09iamVjdFsncmVmLXgnXSArIHByaW1pdGl2ZVBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgICAgICB5OiBzdmdPYmplY3RbJ3JlZi15J10gKyBwcmltaXRpdmVQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVQb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYub25QYXBlckNlbGxQb2ludGVyRG93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAuLi5cclxuICAgIH07XHJcblxyXG4gICAgX2dyYXBoTm9kZS5vbigncG9ydHMtc3RhdGUtY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3BvcnRzLXN0YXRlLWNoYW5nZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9ncmFwaE5vZGUub24oJ2VsZW1lbnRzLXN0YXRlLWNoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdlbGVtZW50LXN0YXRlLWNoYW5nZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9ncmFwaE5vZGUub24oJ2JvZHktY2xpY2snLCBmdW5jdGlvbiAoe2V2ZW50LCBlbGVtZW50SWR9KSB7XHJcbiAgICAgICAgaWYgKHNlbGYuaWQgPT09IGVsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnQtY2xpY2snLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2dyYXBoTm9kZS5vbignY2hhbmdlOnBvc2l0aW9uJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigncG9zaXRpb24tY2hhbmdlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2dyYXBoTm9kZS5vbignY29sbGFwc2UtYnV0dG9uLWNsaWNrJywgZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQgPT09IHNlbGYuaWQpIHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjb2xsYXBzZS1idXR0b24tY2xpY2snKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TW9kZWwgKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGhOb2RlLmVsZW1lbnRzTWFwW3NlbGYuaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRBdmFpbGFibGVQb3J0SWQgKCkge1xyXG4gICAgICAgIGNvbnN0IG1vZGVsID0gX2dldE1vZGVsKCk7XHJcbiAgICAgICAgaWYgKCFtb2RlbC5pbnZpc2libGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5vcmRlcmVkUG9zc2libGVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY3VySWQgPSBzZWxmLm9yZGVyZWRQb3NzaWJsZUlkc1tpXTtcclxuICAgICAgICAgICAgaWYgKF9ncmFwaE5vZGUuZWxlbWVudHNNYXBbY3VySWRdLmludmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldklkID0gc2VsZi5vcmRlcmVkUG9zc2libGVJZHNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZi5vcmRlcmVkUG9zc2libGVJZHNbc2VsZi5vcmRlcmVkUG9zc2libGVJZHMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaW5rXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBMaW5rIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2VsZi5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcclxuICAgIHNlbGYudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XHJcbiAgICBzZWxmLmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcclxuICAgIHNlbGYudHlwZUlkID0gb3B0aW9ucy50eXBlSWQ7XHJcbiAgICBzZWxmLmdyb3VwZWRCeSA9IG9wdGlvbnMuZ3JvdXBlZEJ5OyAvLyBzb3VyY2UgfCB0YXJnZXQgfCB1bmRlZmluZWRcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgIH0gPSBfZ2V0Q29ubmVjdGlvblBhcmFtZXRlcnMoKTtcclxuXHJcbiAgICBjb25zdCBwcmltaXRpdmVzQXJlRGVmaW5lZCA9IG9wdGlvbnMuZ3JhcGhQcmltaXRpdmVzICYmIG9wdGlvbnMuZ3JhcGhQcmltaXRpdmVzLmxlbmd0aCA+IDA7XHJcbiAgICBjb25zdCBfZ3JhcGhQcmltaXRpdmVzID0gcHJpbWl0aXZlc0FyZURlZmluZWQgP1xyXG4gICAgb3B0aW9ucy5ncmFwaFByaW1pdGl2ZXMgOiBbXHJcbiAgICAgICAgbmV3IEdyYXBoTGluayh7XHJcbiAgICAgICAgICAgIHR5cGVJZDogb3B0aW9ucy50eXBlSWQsXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgbGFiZWw6IF9nZXRMYWJlbCgpLFxyXG4gICAgICAgIH0sIHBhcmFtZXRlcnMpLFxyXG4gICAgXTtcclxuXHJcbiAgICBfcmVmcmVzaFBvcnRzKCk7XHJcblxyXG4gICAgc2VsZi5nZXRDZWxscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dyYXBoUHJpbWl0aXZlcztcclxuICAgIH07XHJcblxyXG4gICAgbGV0IF9oaWdobGlnaHRlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5oaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBfaGlnaGxpZ2h0ZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgX2dyYXBoUHJpbWl0aXZlcy5mb3JFYWNoKHByaW1pdGl2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUuaGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZS51bmhpZ2hsaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9oaWdobGlnaHRlZDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9ncmFwaFByaW1pdGl2ZXMuZm9yRWFjaChwcmltaXRpdmUgPT5cclxuICAgICAgICAgICAgcHJpbWl0aXZlLnNob3coKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfZ3JhcGhQcmltaXRpdmVzLmZvckVhY2gocHJpbWl0aXZlID0+XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5oaWRlKClcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXNlbGYuZ2V0KCdoaWRkZW4nKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5vblBhcGVyQ2VsbFBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgICBjb25zdCBjZWxsSXNNeVByaW1pdGl2ZSA9IF9ncmFwaFByaW1pdGl2ZXMuaW5kZXhPZihjZWxsKSAhPT0gLTE7XHJcbiAgICAgICAgaWYgKGNlbGxJc015UHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudC1jbGljaycsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuYWxpZ25Dcm9zc05vZGUgPSBfYWxpZ25Dcm9zc05vZGU7XHJcbiAgICBzZWxmLmdldENyb3NzTm9kZSA9IF9nZXRDcm9zc05vZGU7XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldENyb3NzTm9kZSAoKSB7XHJcbiAgICAgICAgY29uc3QgaXNDcm9zc2VkID0gX2dyYXBoUHJpbWl0aXZlcy5sZW5ndGggPiAxO1xyXG4gICAgICAgIGlmIChpc0Nyb3NzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ncmFwaFByaW1pdGl2ZXNbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FsaWduQ3Jvc3NOb2RlICgpIHtcclxuICAgICAgICBjb25zdCBjcm9zc05vZGUgPSBfZ2V0Q3Jvc3NOb2RlKCk7XHJcbiAgICAgICAgaWYgKCFjcm9zc05vZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY3Jvc3NlZEVsZW1lbnRzID0gY3Jvc3NOb2RlLmdldENyb3NzZWRFbGVtZW50cygpO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0Q3Jvc3NlZEVsZW1lbnQgPSBjcm9zc2VkRWxlbWVudHNbMF07XHJcbiAgICAgICAgY29uc3QgZ3JvdXBlZEJ5U291cmNlID0gZmlyc3RDcm9zc2VkRWxlbWVudC5ncm91cGVkQnkgPT09ICdzb3VyY2UnO1xyXG4gICAgICAgIGNvbnN0IERFRkFVTFRfUEFERElORyA9IDMwO1xyXG4gICAgICAgIGxldCBzdW1ZID0gMDtcclxuICAgICAgICBsZXQgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXhYID0gLUluZmluaXR5O1xyXG5cclxuICAgICAgICBjcm9zc2VkRWxlbWVudHMuZm9yRWFjaChjcm9zc2VkTGlua3MgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhbGxpZ25UbyA9IGdyb3VwZWRCeVNvdXJjZSA/XHJcbiAgICAgICAgICAgICAgICBjcm9zc2VkTGlua3MudGFyZ2V0LmdldFBvcnRQb3NpdGlvbignaW4nKSA6XHJcbiAgICAgICAgICAgICAgICBjcm9zc2VkTGlua3Muc291cmNlLmdldFBvcnRQb3NpdGlvbignb3V0Jyk7XHJcblxyXG4gICAgICAgICAgICBzdW1ZICs9IGFsbGlnblRvLnk7XHJcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBhbGxpZ25Uby54KTtcclxuICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGFsbGlnblRvLngpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHhQb3NpdGlvbiA9IGdyb3VwZWRCeVNvdXJjZSA/IG1pblggLSBERUZBVUxUX1BBRERJTkcgOiBtYXhYICsgREVGQVVMVF9QQURESU5HO1xyXG4gICAgICAgIGNvbnN0IHlQb3NpdGlvbiA9IHN1bVkgLyBjcm9zc2VkRWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGNyb3NzTm9kZS5wb3NpdGlvbih4UG9zaXRpb24sIHlQb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldExhYmVsICgpIHtcclxuICAgICAgICByZXR1cm4gam9pbnQudXRpbC5icmVha1RleHQoc2VsZi5sYWJlbCwge1xyXG4gICAgICAgICAgICB3aWR0aDogcGFyYW1ldGVycy5kZWZhdWx0TGlua0xhYmVsTGVuZ3RoLFxyXG4gICAgICAgIH0sIHsgJ2ZvbnQtc2l6ZSc6IExJTktfTEFCRUxfRk9OVF9TSVpFIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9yZWZyZXNoUG9ydHMgKCkge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdGFyZ2V0VG9wSWQsXHJcbiAgICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIH0gPSBfZ2V0Q29ubmVjdGlvblBhcmFtZXRlcnMoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlUHJpbWl0aXZlID0gX2dyYXBoUHJpbWl0aXZlc1sxXSB8fCBfZ3JhcGhQcmltaXRpdmVzWzBdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFByaW1pdGl2ZSA9IF9ncmFwaFByaW1pdGl2ZXNbMl0gfHwgX2dyYXBoUHJpbWl0aXZlc1swXTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB0YXJnZXRMaW5rU3R5bGUgPSB0YXJnZXRQcmltaXRpdmUuZ2V0TGlua1N0eWxlKCk7XHJcbiAgICAgICAgaWYgKHRhcmdldC5pZCA9PT0gdGFyZ2V0VG9wSWQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0UHJpbWl0aXZlLmF0dHIoJy5tYXJrZXItdGFyZ2V0JywgZ2V0TGlua01hcmtlclRhcmdldCh0YXJnZXRMaW5rU3R5bGUpKTtcclxuICAgICAgICAgICAgdGFyZ2V0UHJpbWl0aXZlLnRyaWdnZXIoJ3VwZGF0ZU1hcmtlcnMnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRQcmltaXRpdmUucmVtb3ZlQXR0cignLm1hcmtlci10YXJnZXQnKTtcclxuICAgICAgICAgICAgdGFyZ2V0UHJpbWl0aXZlLnRyaWdnZXIoJ3VwZGF0ZU1hcmtlcnMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNvdXJjZVByaW1pdGl2ZS5wcm9wKHsgc291cmNlOiBzb3VyY2UgfSk7XHJcbiAgICAgICAgdGFyZ2V0UHJpbWl0aXZlLnByb3AoeyB0YXJnZXQ6IHRhcmdldCB9KTtcclxuICAgICAgICBcclxuICAgICAgICBfYWxpZ25Dcm9zc05vZGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0Q29ubmVjdGlvblBhcmFtZXRlcnMgKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVBvcnQgPSBzZWxmLnNvdXJjZS5nZXRQb3J0KCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UG9ydCA9IHNlbGYudGFyZ2V0LmdldFBvcnQoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBzb3VyY2VQb3J0LnByaW1pdGl2ZS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9ydC5wcmltaXRpdmUucG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHNvdXJjZVBvc2l0aW9uLnggPiB0YXJnZXRQb3NpdGlvbi54O1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHtcclxuICAgICAgICAgICAgaWQ6IHNvdXJjZVBvcnQucHJpbWl0aXZlLmlkLFxyXG4gICAgICAgICAgICBwb3J0OiBnZXRQb3J0SWQoc291cmNlUG9ydC5pZCwgKHJldmVyc2UgPyAnaW4nIDogJ291dCcpKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHtcclxuICAgICAgICAgICAgaWQ6IHRhcmdldFBvcnQucHJpbWl0aXZlLmlkLFxyXG4gICAgICAgICAgICBwb3J0OiBnZXRQb3J0SWQodGFyZ2V0UG9ydC5pZCwgKHJldmVyc2UgPyAnb3V0JyA6ICdpbicpKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzb3VyY2VUb3BJZDogc291cmNlUG9ydC5pZCxcclxuICAgICAgICAgICAgdGFyZ2V0VG9wSWQ6IHRhcmdldFBvcnQuaWQsXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuc291cmNlLm9uKCdlbGVtZW50LXN0YXRlLWNoYW5nZWQnLCBfcmVmcmVzaFBvcnRzKTtcclxuICAgIHNlbGYudGFyZ2V0Lm9uKCdlbGVtZW50LXN0YXRlLWNoYW5nZWQnLCBfcmVmcmVzaFBvcnRzKTtcclxuICAgIHNlbGYuc291cmNlLm9uKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJywgX2FsaWduQ3Jvc3NOb2RlKTtcclxuICAgIHNlbGYudGFyZ2V0Lm9uKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJywgX2FsaWduQ3Jvc3NOb2RlKTtcclxuICAgIHNlbGYuc291cmNlLm9uKCdwb3NpdGlvbi1jaGFuZ2VkJywgX3JlZnJlc2hQb3J0cyk7XHJcbiAgICBzZWxmLnRhcmdldC5vbigncG9zaXRpb24tY2hhbmdlZCcsIF9yZWZyZXNoUG9ydHMpO1xyXG4gICAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBKb2ludE5vZGVcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgYm9keS1jbGlja1xyXG4gKiBAZmlyZXMgaGlnaGxpZ2h0ZWQtaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaE5vZGUgKG1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGZpcmVzIHdoZW4gdXNlciBjbGljayBvbiBub2RlLlxyXG4gICAgICogQGV2ZW50IGJvZHktY2xpY2tcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1xyXG4gICAgICogIGV2ZW50OiBNb3VzZUV2ZW50LCAvLyBvcmlnaW5hbCBtb3VzZSBldmVudFxyXG4gICAgICogIGVsZW1lbnRJZDogc3RyaW5nLCAvLyBpZCBvZiB0aGUgY2xpY2tlZCBlbGVtZW50XHJcbiAgICAgKiB9XHJcbiAgICAqL1xyXG5cclxuICAgIHNlbGYuZWxlbWVudHNNYXAgPSBfZ2V0RmxhdEVsZW1lbnRzTWFwKG1vZGVsKTtcclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuICAgIHNlbGYuc2NhbGUgPSAxO1xyXG4gICAgc2VsZi5hY3RpdmVQb3J0cyA9IHt9O1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG1vZGVsLmlkLFxyXG4gICAgICAgIG1hcmt1cDogYDxnIGNsYXNzPVwicm90YXRhYmxlXCI+XHJcbiAgICAgICAgICAgIDxnIGNsYXNzPVwic2NhbGFibGUgZXhwb3J0LWFuY2hvclwiPlxyXG4gICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJib2R5XCIvPlxyXG4gICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICR7X3BvcnRzVGVtcGxhdGUoKX1cclxuICAgICAgICA8L2c+YCxcclxuICAgICAgICB0eXBlOiAnZ3JhcGgtZGVyaXZhdGlvbi1ub2RlLkdyYXBoTm9kZScsXHJcbiAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5OT0RFLFxyXG4gICAgICAgIHNpemU6IHtcclxuICAgICAgICAgICAgd2lkdGg6IHBhcmFtZXRlcnMuZGVmYXVsdEVsZW1lbnRXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJhbWV0ZXJzLmRlZmF1bHRFbGVtZW50SGVpZ2h0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjaXJjbGU6IHtcclxuICAgICAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAncmVkJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5kbi1pbi1wb3J0Jzoge1xyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi14JzogMCxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcuZG4tb3V0LXBvcnQnOiB7XHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiBwYXJhbWV0ZXJzLmRlZmF1bHRFbGVtZW50V2lkdGggKyAyMCxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH1dKTtcclxuXHJcbiAgICBzZWxmLnNldCgnY29sbGFwc2VkJywgZmFsc2UpO1xyXG4gICAgc2VsZi5zY3RvbGxUb3AgPSAwO1xyXG5cclxuICAgIHNlbGYuc2V0SGlnaGxpZ2h0ZWRJZCA9IGZ1bmN0aW9uICh0YXJnZXRJZCkge1xyXG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0ZWRJZCA9IHRhcmdldElkO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRJZHMgPSBfdXBkYXRlU3RhdGUodGhpcy5tb2RlbCk7XHJcbiAgICAgICAgY2hhbmdlZElkcy5jb25jYXQoX3VwZGF0ZVZpc2liaWxpdHkodGhpcy5tb2RlbCkpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLk5PREUgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuX2NvbGxhcHNlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHNNYXBbZWxlbWVudElkXS5jb2xsYXBzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkSWRzID0gX3VwZGF0ZVZpc2liaWxpdHkoc2VsZi5lbGVtZW50c01hcFtlbGVtZW50SWRdKTsgICBcclxuICAgICAgICAgICAgY2hhbmdlZElkcy5wdXNoKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkSWRzLmxlbmd0aCA+IDApIHNlbGYudHJpZ2dlcignZWxlbWVudHMtc3RhdGUtY2hhbmdlZCcsIFtjaGFuZ2VkSWRzXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2NvbGxhcHNlZCcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5fZXhwYW5kRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudHNNYXBbZWxlbWVudElkXS5jb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IF91cGRhdGVWaXNpYmlsaXR5KHNlbGYuZWxlbWVudHNNYXBbZWxlbWVudElkXSk7ICAgXHJcbiAgICAgICAgICAgIGNoYW5nZWRJZHMucHVzaChlbGVtZW50SWQpO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZElkcy5sZW5ndGggPiAwKSBzZWxmLnRyaWdnZXIoJ2VsZW1lbnRzLXN0YXRlLWNoYW5nZWQnLCBbY2hhbmdlZElkc10pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdjb2xsYXBzZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLm9uQ2xpY2tDb2xsYXBzZUJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2NvbGxhcHNlLWJ1dHRvbi1jbGljaycsIGVsZW1lbnRJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudXBkYXRlUG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdwb3J0cy1zdGF0ZS1jaGFuZ2VkJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZmlyZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnRJZCkge1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignYm9keS1jbGljaycsIHtcclxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICBlbGVtZW50SWQ6IGVsZW1lbnRJZCxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRBbGxDaGlsZHJlbiA9IF9nZXRBbGxDaGlsZHJlbjtcclxuXHJcbiAgICBzZWxmLmFjdGl2ZVBvcnRzID0ge307XHJcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZWRyYXctdmlldycpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgc2VsZi5zY2FsZSA9IHNjYWxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChzZWFyY2hLZXkpIHtcclxuICAgICAgICBzZWxmLnNlYXJjaEtleSA9IHNlYXJjaEtleSA/IHNlYXJjaEtleS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRJZHMgPSBfdXBkYXRlVmlzaWJpbGl0eSh0aGlzLm1vZGVsKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2VsZW1lbnRzLXN0YXRlLWNoYW5nZWQnLCBbY2hhbmdlZElkc10pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlU3RhdGUgKHJvb3RNb2RlbCkge1xyXG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVkSWQgPSBzZWxmLmhpZ2hsaWdodGVkSWQ7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZElkcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHVwZGF0ZVN0YXRlKHJvb3RNb2RlbCk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFuZ2VkSWRzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlIChtb2RlbCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gbW9kZWwuaWQgPT09IGhpZ2hsaWdodGVkSWQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgY29udGFpblNlbGVjdGVkRWxlbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5TZWxlY3RlZEVsZW1lbnQgPSB1cGRhdGVTdGF0ZShjaGlsZCkgfHwgY29udGFpblNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXdDb2xsYXBzZWRTdGF0ZSA9IG1vZGVsLmNvbGxhcHNlZCAmJiAhY29udGFpblNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKEJvb2xlYW4obmV3Q29sbGFwc2VkU3RhdGUpICE9PSBCb29sZWFuKG1vZGVsLmNvbGxhcHNlZCkpIGNoYW5nZWRJZHMucHVzaChtb2RlbC5pZCk7XHJcbiAgICAgICAgICAgIG1vZGVsLmNvbGxhcHNlZCA9IG5ld0NvbGxhcHNlZFN0YXRlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQgfHwgY29udGFpblNlbGVjdGVkRWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZVZpc2liaWxpdHkgKHJvb3RNb2RlbCkge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaEtleSA9IHNlbGYuc2VhcmNoS2V5O1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRJZHMgPSBbXTtcclxuXHJcbiAgICAgICAgdXBkYXRlVmlzaWJpbGl0eShyb290TW9kZWwsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRJZHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlzaWJpbGl0eSAobW9kZWwsIHBhcmVudEludmlzaWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3RDb250YWluS2V5ID0gKCFzZWFyY2hLZXkpIHx8IG1vZGVsLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2hLZXkpID09PSAtMTtcclxuICAgICAgICAgICAgY29uc3QgaW52aXNpYmxlID0gcGFyZW50SW52aXNpYmxlICYmIG5vdENvbnRhaW5LZXk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9WaXNpYmxlQ2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgIG5vVmlzaWJsZUNoaWxkcmVuID0gdXBkYXRlVmlzaWJpbGl0eShjaGlsZCwgcGFyZW50SW52aXNpYmxlIHx8IG1vZGVsLmNvbGxhcHNlZCkgJiYgbm9WaXNpYmxlQ2hpbGRyZW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWaXNpYmlibGl0eSA9IGludmlzaWJsZSAmJiBub1Zpc2libGVDaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKEJvb2xlYW4obmV3VmlzaWJpYmxpdHkpICE9PSBCb29sZWFuKG1vZGVsLmludmlzaWJsZSkpIGNoYW5nZWRJZHMucHVzaChtb2RlbC5pZCk7XHJcbiAgICAgICAgICAgIG1vZGVsLmludmlzaWJsZSA9IGludmlzaWJsZSAmJiBub1Zpc2libGVDaGlsZHJlbjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5pbnZpc2libGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9nZXRBbGxDaGlsZHJlbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlbGYuZWxlbWVudHNNYXApLm1hcChpZCA9PiBzZWxmLmVsZW1lbnRzTWFwW2lkXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldEZsYXRFbGVtZW50c01hcCAobW9kZWwpIHtcclxuICAgICAgICBsZXQgZWxlbWVudHNNYXAgPSB7fTtcclxuICAgICAgICByZWN1cnNpb24obW9kZWwsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gZWxlbWVudHNNYXA7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAoZWxlbWVudCwgaW52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNNYXBbZWxlbWVudC5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzTWFwW2VsZW1lbnQuaWRdID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW52aXNpYmxlID0gaW52aXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbihjaGlsZCwgZWxlbWVudC5jb2xsYXBzZWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3BvcnRzVGVtcGxhdGUgKCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0QWxsQ2hpbGRyZW4oKS5tYXAoZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluUG9ydElkID0gZ2V0UG9ydElkKGVsZW1lbnQuaWQsICdpbicpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQoZWxlbWVudC5pZCwgJ291dCcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJkbi1pbi1wb3J0ICR7aW5Qb3J0SWR9XCIgcG9ydD1cIiR7aW5Qb3J0SWR9XCIvPlxyXG4gICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImRuLW91dC1wb3J0ICR7b3V0UG9ydElkfVwiIHBvcnQ9XCIke291dFBvcnRJZH1cIi8+XHJcbiAgICAgICAgICAgIGA7XHJcbiAgICAgICAgfSkuam9pbignJyk7XHJcbiAgICB9XHJcbn1cclxuR3JhcGhOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmRldnMuTW9kZWwucHJvdG90eXBlKTtcclxuXHJcblxyXG5jb25zdCBERUZBVUxUX0NST1NTX05PREVfU0laRSA9IHtcclxuICAgIHdpZHRoOiAxLCBoZWlnaHQ6IDEsXHJcbn07XHJcbi8qKlxyXG4gKiBKb2ludENyb3NzTm9kZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gR3JhcGhDcm9zc05vZGUgKG1vZGVsKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuXHJcbiAgICBzZWxmLm1vZGVsID0gbW9kZWw7XHJcbiAgICBzZWxmLmhpZGRlbiA9IGZhbHNlO1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgdHlwZTogJ2Rlcml2YXRpb25Dcm9zc05vZGUnLFxyXG4gICAgICAgIG1hcmt1cDogYDxnIGNsYXNzPVwicm90YXRhYmxlXCI+XHJcbiAgICAgICAgICAgIDxnIGNsYXNzPVwic2NhbGFibGUgZXhwb3J0LWFuY2hvclwiPlxyXG4gICAgICAgICAgICAgICAgPGNpcmNsZSBjbGFzcz1cImJvZHlcIi8+XHJcbiAgICAgICAgICAgIDwvZz5cclxuICAgICAgICA8L2c+YCxcclxuICAgICAgICBzaXplOiBERUZBVUxUX0NST1NTX05PREVfU0laRSxcclxuICAgICAgICB6OiBaX0lOREVYRVMuTElOSyxcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICBjaXJjbGU6IHtcclxuICAgICAgICAgICAgICAgIHI6ICc1cHgnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH1dKTtcclxuXHJcbiAgICBzZWxmLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnVuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5MSU5LIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkxJTksgfSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUtc3RhdGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX0xJTksgfSk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd1cGRhdGUtc3RhdGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRDcm9zc2VkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYubW9kZWwuY3Jvc3NlZEVsZW1lbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZWRyYXctdmlldycpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgICAgICAgc2VsZi5zY2FsZSA9IHNjYWxlO1xyXG4gICAgfTtcclxufVxyXG5HcmFwaENyb3NzTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLnByb3RvdHlwZSk7XHJcblxyXG4vKipcclxuICogRE1MaW5rTW9kZWwgLSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBMaW5rfSBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gRE1MaW5rTW9kZWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVJZCAtIExpbmsgdHlwZSBpZGVudGlmeWVyXHJcbiAqIEBwcm9wZXJ0eSB7R3JhcGhOb2RlfSB0YXJnZXQgLSBUYXJnZXQgTm9kZVxyXG4gKiBAcHJvcGVydHkge0dyYXBoTm9kZX0gc291cmNlIC0gU291cmNlIE5vZGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsIC0gVGV4dCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBsaW5rXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5rdHlwZSAtIFR5cGUgb2YgdGhlIExpbmtcclxuICogQHByb3BlcnR5IHtHcmFwaExpbmtbXX0gY3Jvc3NlZEVsZW1lbnRzIC0gaW4gY2FzZSBvZiB0aGUgbGluayBpcyBhIHBhcnQgb2YgZ3JvdXBlZCBsaW5rc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEpvaW50TGlua1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtETUxpbmtNb2RlbH0gbW9kZWxcclxuICogQHBhcmFtIHtQYXJhbXRlcnN9IHBhcmFtZXRlcnNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gR3JhcGhMaW5rIChtb2RlbCwgcGFyYW1ldGVycykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuICAgIHNlbGYuaGlkZGVuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgY29uc3QgX2xpbmtTdHlsZSA9IF9yZXMuZ2V0TGlua1N0eWxlKG1vZGVsLnR5cGVJZCk7XHJcbiAgICBjb25zdCB0eXBlcyA9IFtERUZBVUxUX0xJTktfVFlQRV07XHJcblxyXG4gICAgaWYgKF9saW5rU3R5bGUuY3NzQ2xhc3MgJiYgX2xpbmtTdHlsZS5jc3NDbGFzcyAhPT0gREVGQVVMVF9MSU5LX1RZUEUpIHtcclxuICAgICAgICB0eXBlcy5wdXNoKF9saW5rU3R5bGUuY3NzQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGpvaW50LmRpYS5MaW5rLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgdHlwZTogdHlwZXMuam9pbignICcpLFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIHNvdXJjZTogbW9kZWwuc291cmNlLFxyXG4gICAgICAgIHRhcmdldDogbW9kZWwudGFyZ2V0LFxyXG4gICAgICAgIGF0dHJzOiBfZ2V0TGlua0F0dHJpYnV0ZXMoX2xpbmtTdHlsZSksXHJcbiAgICAgICAgbGFiZWxzOiBbe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogLjUsXHJcbiAgICAgICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICByZWN0OiB7IGZpbGw6IF9saW5rU3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB9LFxyXG4gICAgICAgICAgICAgICAgdGV4dDogeyBmaWxsOiBfbGlua1N0eWxlLnRleHRDb2xvciwgdGV4dDogbW9kZWwubGFiZWwgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnfSxcclxuICAgICAgICAvLyBjb25uZWN0b3I6IHsgbmFtZTogJ2p1bXBvdmVyJywgYXJnczogeyB0eXBlOiAnZ2FwJyB9fSxcclxuICAgICAgICByb3V0ZXI6IHtcclxuICAgICAgICAgICAgbmFtZTogJ2Rtcm91dGVyJyxcclxuICAgICAgICB9XHJcbiAgICB9XSk7XHJcblxyXG4gICAgc2VsZi5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TGlua1N0eWxlID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBfbGlua1N0eWxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3VwZGF0ZS1zdGF0ZScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0TGlua0F0dHJpYnV0ZXMgKGxpbmtTdHlsZSwgaGFzQXJyb3cpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlc1snLmNvbm5lY3Rpb24nXSA9IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGxpbmtTdHlsZS5saW5lVHlwZSA9PT0gJ3NvbGlkJyA/IHVuZGVmaW5lZCA6ICc1LDUnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXR0cmlidXRlc1snLm1hcmtlci10YXJnZXQnXSA9IGhhc0Fycm93ID8gZ2V0TGlua01hcmtlclRhcmdldChsaW5rU3R5bGUpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoTGluay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rLnByb3RvdHlwZSk7XHJcblxyXG4vKipcclxuICogSm9pbnRMaW5rXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHcmFwaENyb3NzTGluayAobW9kZWwsIHBhcmFtdGVycykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBtb2RlbDtcclxuXHJcbiAgICBHcmFwaExpbmsuYXBwbHkoc2VsZiwgW21vZGVsLCBwYXJhbXRlcnNdKTtcclxuXHJcbiAgICBzZWxmLmdldENyb3NzZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5tb2RlbC5jcm9zc2VkRWxlbWVudHM7XHJcbiAgICB9O1xyXG59XHJcbkdyYXBoQ3Jvc3NMaW5rLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3JhcGhMaW5rLnByb3RvdHlwZSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9ydElkIChwb3J0SWQsIGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgaXNUYXJnZXQgPSBkaXJlY3Rpb24gPT09ICdpbic7XHJcbiAgICByZXR1cm4gYCR7aXNUYXJnZXQgPyAnSW5fJyA6ICdPdXRfJ31Qb3J0XyR7ZW5jb2RlVVJJKHBvcnRJZCl9YDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmtNYXJrZXJUYXJnZXQgKGxpbmtTdHlsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaWxsOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgZDogTUFSS0VSX1RBUkdFVC5kLFxyXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgfTtcclxufSIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCBzYXZlQXMgZnJvbSAnZmlsZS1zYXZlcmpzJztcclxuXHJcbmltcG9ydCB7IEdyYXBoTm9kZVZpZXcsIEdyYXBoTGlua1ZpZXcgfSBmcm9tICcuL21hcFZpZXdzJztcclxuaW1wb3J0IHsgTm9kZSwgTGluaywgR3JhcGhOb2RlLCBHcmFwaExpbmsgfSBmcm9tICcuL21hcEVsZW1lbnRzJztcclxuaW1wb3J0IHsgZXhwb3J0VG9TVkcsIHRvRGF0YVVSTCB9IGZyb20gJy4uL3RvU3ZnJztcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tICcuLi8uLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCBTYW5rZXkgZnJvbSAnLi4vLi4vbGF5b3V0L3NhbmtleSc7XHJcbmltcG9ydCB7IHJlbW92ZUN5Y2xlcyB9IGZyb20gJy4uLy4uL2xheW91dC9sYXlvdXQnO1xyXG5pbXBvcnQgeyBjb252ZXJ0RE1FbGVtZW50c1RvTGF5b3V0TW9kZWxzLCBjb252ZXJ0Sm9pbnRFbGVtZW50c1RvTGF5b3V0TW9kZWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbGF5b3V0VXRpbHMnO1xyXG5pbXBvcnQgeyBkYXRlMlN0cmluZywgcG5nMkJsb2IgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhVXRpbHMnO1xyXG5pbXBvcnQgeyBhZGp1c3RWZXJ0aWNlcyB9IGZyb20gJy4uLy4uL3V0aWxzL2xpbmVhZ2VEaWFncmFtVXRpbHMnO1xyXG5pbXBvcnQgeyBhcnJheVRvTWFwIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuam9pbnQuc2hhcGVzWydncmFwaC1kZXJpdmF0aW9uLW5vZGUnXSA9IHtcclxuICAgIEdyYXBoTm9kZTogR3JhcGhOb2RlLFxyXG4gICAgR3JhcGhOb2RlVmlldzogR3JhcGhOb2RlVmlldyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgb2Ygb3B0aW9ucyBmb3IgZGVyaXZhdGlvbiBtYXAgbGF5b3V0IGNsYXNzLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBETUxheW91dE9wdGlvbnNcclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVUeXBlIC0gJ3NvbGlkJyBvciAnZGFzaGVkJ1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3IgLSBDb2xvciBvZiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGV4dENvbG9yIC0gQ29sb3Igb2YgdGhlIHRleHQgb24gdGhlIGxpbmVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHRCYWNrZ3JvdW5kQ29sb3IgLSBDb2xvciBvZiB0aGUgYmFja2dyb3VuZCBvZiB0aGUgdGV4dCBvbiB0aGUgbGluZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhpY2tuZXNzXHJcbiovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtETUxheW91dE9wdGlvbnN9IHByb3BlcnRpZXNcclxuICogQGZpcmVzIGJsYW5rLWNsaWNrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWFwTGF5b3V0IChwcm9wZXJ0aWVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7XHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfZ3JhcGggPSBuZXcgam9pbnQuZGlhLkdyYXBoKCk7XHJcbiAgICBsZXQgX3N0YXJ0UG9pbnQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3QgX3BhcGVyID0gbmV3IGpvaW50LmRpYS5QYXBlcih7XHJcbiAgICAgICAgbW9kZWw6IF9ncmFwaCxcclxuICAgICAgICAvLyBlbGVtZW50VmlldzogR3JhcGhOb2RlVmlldyxcclxuICAgICAgICBsaW5rVmlldzogR3JhcGhMaW5rVmlldyxcclxuICAgICAgICBncmlkU2l6ZTogMSxcclxuICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnU6IGZhbHNlLFxyXG4gICAgICAgIGludGVyYWN0aXZlOiAoKSA9PiB7IHJldHVybiB7IHZlcnRleEFkZDogZmFsc2UgfTsgfSxcclxuICAgICAgICB3aWR0aDogNTAwMCxcclxuICAgICAgICBoZWlnaHQ6IDUwMDAsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IF9wYXBlclNjcm9sbGVyID0gbmV3IGpvaW50LnVpLlBhcGVyU2Nyb2xsZXIoe1xyXG4gICAgICAgIHBhcGVyOiBfcGFwZXIsXHJcbiAgICAgICAgYXV0b1Jlc2l6ZVBhcGVyOiB0cnVlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IF9ub2RlcyA9IFtdO1xyXG4gICAgbGV0IF9saW5rcyA9IFtdO1xyXG5cclxuICAgIHByb3BlcnRpZXMucm9vdEVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XHJcbiAgICBwcm9wZXJ0aWVzLnJvb3RFbGVtZW50LmFwcGVuZENoaWxkKF9wYXBlclNjcm9sbGVyLnJlbmRlcigpLmVsKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXphdGlvblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxpbmcgbXVsdGlwbGUgbGluayBzaXR1YXRpb25zIC0gYmVuZHMgdGhlbSBzbyB0aGV5IGRvbid0IGNyb3NzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBKdXN0IHJlZnJlc2hlcyByZWxhdGVkIGVsZW1lbnRzIG9uIGNoYW5nZXMuXHJcbiAgICBfZ3JhcGgub24oJ2NoYW5nZTpzb3VyY2UgY2hhbmdlOnRhcmdldCcsIF9yZWZyZXNoUmVsYXRlZEVsZW1lbnQpO1xyXG5cclxuICAgIF9wYXBlci5vbignYmxhbms6cG9pbnRlcmRvd24nLCAoZXZlbnQsIHgsIHkpID0+IHtcclxuICAgICAgICBfc3RhcnRQb2ludCA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XHJcbiAgICAgICAgX3BhcGVyU2Nyb2xsZXIuc3RhcnRQYW5uaW5nKGV2ZW50LCB4LCB5KTtcclxuICAgIH0pO1xyXG4gICAgX3BhcGVyLm9uKCdibGFuazpwb2ludGVyY2xpY2snLCAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoIV9zdGFydFBvaW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld1BvaW50ID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfTtcclxuICAgICAgICBjb25zdCBPRkZTRVRfVEhSRVNIT0xEID0gNTtcclxuICAgICAgICBjb25zdCBvZmZzZXRFeGNlZWRUaHJlc2hvbGQgPSBNYXRoLmFicyhuZXdQb2ludC54IC0gX3N0YXJ0UG9pbnQueCkgPCBPRkZTRVRfVEhSRVNIT0xEIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhuZXdQb2ludC54IC0gX3N0YXJ0UG9pbnQueCkgPCBPRkZTRVRfVEhSRVNIT0xEO1xyXG4gICAgICAgIGlmIChvZmZzZXRFeGNlZWRUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdibGFuay1jbGljaycsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N0YXJ0UG9pbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuICAgIF9wYXBlci5vbignY2VsbDpwb2ludGVyZG93bicsIGZ1bmN0aW9uIChjZWxsVmlldykge1xyXG4gICAgICAgIF9ub2Rlcy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsLm9uUGFwZXJDZWxsUG9pbnRlckRvd24pIGVsLm9uUGFwZXJDZWxsUG9pbnRlckRvd24oY2VsbFZpZXcubW9kZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9saW5rcy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsLm9uUGFwZXJDZWxsUG9pbnRlckRvd24pIGVsLm9uUGFwZXJDZWxsUG9pbnRlckRvd24oY2VsbFZpZXcubW9kZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb25Nb3VzZVdoZWVsID0gKGV2dCwgeCwgeSwgZGVsdGEpID0+IHtcclxuICAgICAgICBpZiAoZXZ0LmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgc2VsZi56b29tKDAuMSAqIChkZWx0YSA8IDAgPyAtMSA6IDEpLCB7IG1heDogNCB9KTtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9wYXBlci5vbignY2VsbDptb3VzZXdoZWVsJywgKGNlbGwsIGV2dCwgeCwgeSwgZGVsdGEpID0+IG9uTW91c2VXaGVlbChldnQsIHgsIHksIGRlbHRhKSk7XHJcbiAgICBfcGFwZXIub24oJ2JsYW5rOm1vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBzZWxmLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbm9kZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0TGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9saW5rcztcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRHcmFwaE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0RWxlbWVudHMoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRHcmFwaExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ3JhcGguZ2V0TGlua3MoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbm9kZXM9W107XHJcbiAgICAgICAgX2xpbmtzPVtdO1xyXG4gICAgICAgIF9ncmFwaC5jbGVhcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnpvb20gPSBmdW5jdGlvbiAoc2NhbGVEaWZmLCBvcHQpIHtcclxuICAgICAgICBpZiAoIXNjYWxlRGlmZikge1xyXG4gICAgICAgICAgICBfcGFwZXJTY3JvbGxlci56b29tVG9GaXQoKTtcclxuICAgICAgICAgICAgX3BhcGVyU2Nyb2xsZXIuem9vbSgtMC4yLCB7IG1heDogMiwgbWluOiAwLjIgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3BhcGVyU2Nyb2xsZXIuem9vbShzY2FsZURpZmYsIG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdTY2FsZSA9IF9wYXBlclNjcm9sbGVyLl9zeDtcclxuXHJcbiAgICAgICAgX2dyYXBoLmdldEVsZW1lbnRzKCkuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZS5zZXRTY2FsZShuZXdTY2FsZSk7XHJcbiAgICAgICAgICAgIG5vZGUucmVmcmVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldEVsZW1lbnRzID0gZnVuY3Rpb24gKG5ld0VsZW1lbnRzLCBkaWFncmFtSW5mbykge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbmV3TGlua3MgPSBbXTtcclxuICAgICAgICBuZXdFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaChlbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdMaW5rcy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBfbm9kZXMgPSBfbm9kZXMuY29uY2F0KG5ld05vZGVzKTtcclxuICAgICAgICBfbGlua3MgPSBfbGlua3MuY29uY2F0KG5ld0xpbmtzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkSWRzID0ge307XHJcbiAgICAgICAgY29uc3QgY2VsbHMgPSBbXTtcclxuXHJcbiAgICAgICAgbmV3RWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudENlbGxzID0gZWxlbWVudC5nZXRDZWxscygpO1xyXG4gICAgICAgICAgICBlbGVtZW50Q2VsbHMuZm9yRWFjaChjZWxsID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkSWRzW2NlbGwuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkSWRzW2NlbGwuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjZWxscy5zb3J0KChjZWxsMSwgY2VsbDIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYzEgPSBjZWxsMSBpbnN0YW5jZW9mIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gY2VsbDIgaW5zdGFuY2VvZiBqb2ludC5zaGFwZXMuYmFzaWMuR2VuZXJpYyA/IDEgOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gYzIgLSBjMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfZ3JhcGguYWRkQ2VsbHMoY2VsbHMpO1xyXG5cclxuICAgICAgICBjZWxscy5mb3JFYWNoKGNlbGwgPT4gX3JlZnJlc2hSZWxhdGVkRWxlbWVudChjZWxsKSk7XHJcbiAgICAgICAgX3N1YnNjcmliZU9uRWxlbWVudHMoKTtcclxuICAgICAgICBfZG9MYXlvdXQoZGlhZ3JhbUluZm8pO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBfZG9MYXlvdXQoZGlhZ3JhbUluZm8pO1xyXG4gICAgICAgICAgICBzZWxmLnpvb20oKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgZ3JhcGggdG8gcG5nIG9yIHN2ZyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ge1xyXG4gICAgICogIG5hbWU/OiBzdHJpbmcgLSBmaWxlIG5hbWVcclxuICAgICAqICB0eXBlPzogc3RyaW5nIC0gKHBuZy9zdmcpXHJcbiAgICAgKiB9IG9wdGlvbnNcclxuICAgICovXHJcbiAgICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBvcHRpb25zLm5hbWUgfHxcclxuICAgICAgICAgICAgJ0RNX2xpbmVhZ2VfZGlhZ3JhbV9zbmFwc2hvdF8nICsgZGF0ZTJTdHJpbmcobmV3IERhdGUoKSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwbmcnKSB7XHJcbiAgICAgICAgICAgIHRvRGF0YVVSTChfcGFwZXIsIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRIdG1sOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS50aGVuKGJhc2U2NFVSTCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlRGF0YShiYXNlNjRVUkwsIGZpbGVOYW1lLCAncG5nJyk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSBhbGVydChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgY29udmVydEh0bWw6IHRydWUsXHJcbiAgICAgICAgICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVEYXRhKHN2Z1N0cmluZywgZmlsZU5hbWUsICdzdmcnKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2F2ZURhdGEgKGRhdGEsIGZpbGVOYW1lLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBibG9iO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHsgdHlwZTogdHlwZSB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncG5nJykge1xyXG4gICAgICAgICAgICAgICAgYmxvYiA9IHBuZzJCbG9iIChkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZU5hbWUgKyAnLicgKyB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgKi9cclxuICAgIHNlbGYucHJpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdG9EYXRhVVJMKF9wYXBlciwge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIHN2Z09wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogJycsXHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0SHRtbDogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oYmFzZTY0VVJMID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbignJywgdW5kZWZpbmVkLCAnd2lkdGg9MTI4MCxoZWlnaHQ9NzIwJyk7XHJcbiAgICAgICAgICAgIGlmIChwcmludFdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoYFxyXG4gICAgICAgICAgICAgICAgICAgIDxodG1sPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiJHtiYXNlNjRVUkx9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2JvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9odG1sPlxyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBwcmludFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KCdZb3Ugc2hvdWxkIHVuYmxvY2sgcG9wdXAgd2luZG93cyBmb3IgdGhlIGN1cnJlbnQgdXJsIHRvIGJlIGFibGUgdG8gcHJpbnQgdGhpcyBkaWFncmFtIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICBlbHNlIGFsZXJ0KCdUaGlzIHR5cGUgb2YgZXhwb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEludGVybmV0IEV4cGxvcmVyJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldFNlYXJjaEtleSA9IGZ1bmN0aW9uIChzZWFyY2hLZXkpIHtcclxuICAgICAgICBfZ3JhcGguZ2V0RWxlbWVudHMoKS5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnNldFNlYXJjaEtleShzZWFyY2hLZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfZG9MYXlvdXQgKGRpYWdyYW1JbmZvKSB7IC8vIHRvZG86IHJlZmFjdG9yIHRoaXMgYWxnb3JpdGhtXHJcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBkaWFncmFtSW5mbyA/IGRpYWdyYW1JbmZvLnNvdXJjZUlkIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZGlhZ3JhbUluZm8gPyBkaWFncmFtSW5mby50YXJnZXRJZCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBjZW50ZXJYID0gX3BhcGVyU2Nyb2xsZXIub3B0aW9ucy5iYXNlV2lkdGggLyAyO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBfcGFwZXJTY3JvbGxlci5vcHRpb25zLmJhc2VIZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGNvbnZlcnRETUVsZW1lbnRzVG9MYXlvdXRNb2RlbHMoX25vZGVzLCBfbGlua3MpO1xyXG4gICAgICAgIHJlbW92ZUN5Y2xlcyhlbGVtZW50cy5ub2RlcywgZWxlbWVudHMubGlua3MpO1xyXG4gICAgICAgIHRxU2Fua2V5TGF5b3V0KGVsZW1lbnRzLm5vZGVzLCBlbGVtZW50cy5saW5rcywgc291cmNlSWQsIHRhcmdldElkKTtcclxuXHJcbiAgICAgICAgY29uc3Qgam9pbnRFbGVtZW50cyA9IGNvbnZlcnRKb2ludEVsZW1lbnRzVG9MYXlvdXRNb2RlbHMoX2dyYXBoLmdldEVsZW1lbnRzKCksIF9ncmFwaC5nZXRMaW5rcygpKTtcclxuICAgICAgICByZW1vdmVDeWNsZXMoam9pbnRFbGVtZW50cy5ub2Rlcywgam9pbnRFbGVtZW50cy5saW5rcyk7XHJcbiAgICAgICAgdHFTYW5rZXlMYXlvdXQoam9pbnRFbGVtZW50cy5ub2Rlcywgam9pbnRFbGVtZW50cy5saW5rcywgc291cmNlSWQsIHRhcmdldElkKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBkZXB0aE1hcCA9IGFycmF5VG9NYXAoXHJcbiAgICAgICAgICAgIGpvaW50RWxlbWVudHMubm9kZXMubWFwKGplID0+ICh7IGlkOiBqZS5pZCwgZGVwdGg6IGplLnkgfSkpLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGxldCBtYXhDb2wgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgZWxlbWVudHMubm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgbWF4Q29sID0gTWF0aC5tYXgobi54LCBtYXhDb2wpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBwb3NzaWJsZVhlcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IG9yZGVyID0ge307XHJcbiAgICAgICAgZWxlbWVudHMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgcG9zc2libGVYZXNbbm9kZS54XSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcG9zc2libGVDb2x1bW5zTGlzdCA9IE9iamVjdC5rZXlzKHBvc3NpYmxlWGVzKS5tYXAocHggPT4gTWF0aC5yb3VuZCgrcHgpKTtcclxuICAgICAgICBwb3NzaWJsZUNvbHVtbnNMaXN0LnNvcnQoKHgxLCB4MikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoeDEgPiB4Mikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeDEgPCB4Mikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5mb3JFYWNoKCh4LCBpbmRleCkgPT4gb3JkZXJbeF0gPSBpbmRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0ZXBYID0gKFxyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHRFbGVtZW50V2lkdGggK1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmRlZmF1bHRMYXlvdXRTdGVwXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gY2VudGVyWCAtIHN0ZXBYICogKHBvc3NpYmxlQ29sdW1uc0xpc3QubGVuZ3RoICsgMSkgLyAyO1xyXG5cclxuICAgICAgICBjb25zdCBjb2x1bW5zID0ge307XHJcbiAgICAgICAgZWxlbWVudHMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gbm9kZS5vcmlnaW5hbE5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBzdGFydFBvc2l0aW9uICsgc3RlcFggKiBvcmRlcltNYXRoLnJvdW5kKG5vZGUueCldO1xyXG4gICAgICAgICAgICBpZiAoIWNvbHVtbnNbeF0pIGNvbHVtbnNbeF0gPSBbXTtcclxuICAgICAgICAgICAgY29sdW1uc1t4XS5wdXNoKG9yaWdpbmFsTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IEJPVFRPTV9NQVJHSU4gPSA1MDtcclxuICAgICAgICBPYmplY3Qua2V5cyhjb2x1bW5zKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNba2V5XTtcclxuICAgICAgICAgICAgbGV0IHRvdGFsSGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgY29sdW1uLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhlTGFzdCA9IGluZGV4ID09PSBjb2x1bW4ubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSAodGhlTGFzdCA/IDAgOiBCT1RUT01fTUFSR0lOKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IGVsLmdldCgnc2l6ZScpLmhlaWdodCArIHN0ZXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb2x1bW4uc29ydCgoZTEsIGUyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlMURlcHRoID0gKGRlcHRoTWFwW2UxLmlkXSA/IGRlcHRoTWFwW2UxLmlkXS5kZXB0aCA6IDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZTJEZXB0aCA9IChkZXB0aE1hcFtlMi5pZF0gPyBkZXB0aE1hcFtlMi5pZF0uZGVwdGggOiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZTFEZXB0aCA+IGUyRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZTFEZXB0aCA8IGUyRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gY2VudGVyWSAtIHRvdGFsSGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgY29uc3QgeCA9ICtrZXk7XHJcbiAgICAgICAgICAgIGxldCBjdXJZID0gMDtcclxuICAgICAgICAgICAgY29sdW1uLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPT09IGNvbHVtbi5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IChpc0xhc3QgPyAwIDogQk9UVE9NX01BUkdJTik7XHJcbiAgICAgICAgICAgICAgICBlbC5wb3NpdGlvbih4LCBzdGFydFkgKyBjdXJZKTtcclxuICAgICAgICAgICAgICAgIGN1clkgKz0gZWwuZ2V0KCdzaXplJykuaGVpZ2h0ICsgc3RlcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgX3BhcGVyU2Nyb2xsZXIuY2VudGVyKGNlbnRlclgsIGNlbnRlclkpO1xyXG5cclxuICAgICAgICAvLyBXZSBoaWRlIGR1YmxpY2F0aW9ucyB1c2luZyBoaWdobGlnaHRlci5cclxuICAgICAgICAvLyBUaGF0J3Mgd2h5IHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IG5vZGVzIGFyZVxyXG4gICAgICAgIC8vIG9uIHRoZSBwYWdlLCBzbyB3ZSB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIF9hbGlnbkNyb3NzTm9kZXMoKTtcclxuICAgICAgICAgICAgX2dyYXBoLmdldExpbmtzKCkuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIF9hZGp1c3RBbGxWZXJ0aWNlcyhsaW5rKTtcclxuICAgICAgICAgICAgfSk7ICAgIFxyXG4gICAgICAgICAgICBfaGlkZUR1YmxpY2F0aW9ucygpO1xyXG4gICAgICAgIH0sIDMwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0aW5nIHZlcnRpY2VzXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBfZ3JhcGgub24oJ2NoYW5nZTpzb3VyY2UgY2hhbmdlOnRhcmdldCB1cGRhdGUtdmVydGljZXMnLCBfYWRqdXN0VmVydGljZXMpO1xyXG4gICAgX3BhcGVyLm9uKCdjZWxsOnBvaW50ZXJ1cCcsIF9hZGp1c3RWZXJ0aWNlcyk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkanVzdEFsbFZlcnRpY2VzICgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgX2dyYXBoLmdldExpbmtzKCkuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKF9ncmFwaCwgbGluayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FkanVzdFZlcnRpY2VzIChjZWxsKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKF9ncmFwaCwgY2VsbCk7XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlT25FbGVtZW50cyAoKSB7XHJcbiAgICAgICAgX25vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGUub24oJ2VsZW1lbnQtc3RhdGUtY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9hZGp1c3RWZXJ0aWNlcyhub2RlLmdldFBvcnQoKS5wcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFJlbGF0ZWRFbGVtZW50IChjZWxsKSB7XHJcbiAgICAgICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBHcmFwaExpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNUb1VwZGF0ZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGNlbGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZTb3VyY2VEZXNjcmlwdG9yID0gbGluay5wcmV2aW91cygnc291cmNlJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZUYXJnZXREZXNjcmlwdG9yID0gbGluay5wcmV2aW91cygndGFyZ2V0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZTb3VyY2UgPSBwcmV2U291cmNlRGVzY3JpcHRvciA/IF9ncmFwaC5nZXRDZWxsKHByZXZTb3VyY2VEZXNjcmlwdG9yLmlkKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgcHJldlRhcmdldCA9IHByZXZUYXJnZXREZXNjcmlwdG9yID8gX2dyYXBoLmdldENlbGwocHJldlRhcmdldERlc2NyaXB0b3IuaWQpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlRGVzY3JpcHRvciA9IGxpbmsuZ2V0KCdzb3VyY2UnKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGVzY3JpcHRvciA9IGxpbmsuZ2V0KCd0YXJnZXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gX2dyYXBoLmdldENlbGwoc291cmNlRGVzY3JpcHRvci5pZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IF9ncmFwaC5nZXRDZWxsKHRhcmdldERlc2NyaXB0b3IuaWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByZXZTb3VyY2UgJiYgcHJldlNvdXJjZS5hY3RpdmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNUb1VwZGF0ZVtwcmV2U291cmNlLmlkXSA9IHByZXZTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0SWQgPSBwcmV2U291cmNlRGVzY3JpcHRvci5wb3J0O1xyXG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZS5hY3RpdmVQb3J0c1twb3J0SWRdID0gcHJldlNvdXJjZS5hY3RpdmVQb3J0c1twb3J0SWRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHByZXZTb3VyY2UuYWN0aXZlUG9ydHNbcG9ydElkXVtsaW5rLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldlRhcmdldCAmJiBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3ByZXZUYXJnZXQuaWRdID0gcHJldlRhcmdldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRJZCA9IHByZXZUYXJnZXREZXNjcmlwdG9yLnBvcnQ7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzW3BvcnRJZF0gPSBwcmV2VGFyZ2V0LmFjdGl2ZVBvcnRzW3BvcnRJZF0gfHwge307XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJldlRhcmdldC5hY3RpdmVQb3J0c1twb3J0SWRdW2xpbmsuaWRdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc291cmNlLmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3NvdXJjZS5pZF0gPSBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWN0aXZlUG9ydHNbc291cmNlRGVzY3JpcHRvci5wb3J0XSA9IHNvdXJjZS5hY3RpdmVQb3J0c1tzb3VyY2VEZXNjcmlwdG9yLnBvcnRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmFjdGl2ZVBvcnRzW3NvdXJjZURlc2NyaXB0b3IucG9ydF1bbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmFjdGl2ZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvVXBkYXRlW3RhcmdldC5pZF0gPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWN0aXZlUG9ydHNbdGFyZ2V0RGVzY3JpcHRvci5wb3J0XSA9IHRhcmdldC5hY3RpdmVQb3J0c1t0YXJnZXREZXNjcmlwdG9yLnBvcnRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFjdGl2ZVBvcnRzW3RhcmdldERlc2NyaXB0b3IucG9ydF1bbGluay5pZF0gPSBsaW5rO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbGVtZW50c1RvVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZWxJZCA9PiBlbGVtZW50c1RvVXBkYXRlW2VsSWRdLnJlZnJlc2goKSk7XHJcbiAgICAgICAgICAgIF9oaWRlRHVibGljYXRpb25zKCk7XHJcbiAgICAgICAgICAgIF9hbGlnbkNyb3NzTm9kZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2FsaWduQ3Jvc3NOb2RlcyAoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNyb3NzTGlua3MgPSBbXTtcclxuICAgICAgICBfbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY3Jvc3NOb2RlID0gbGluay5nZXRDcm9zc05vZGUoKTtcclxuICAgICAgICAgICAgaWYgKGNyb3NzTm9kZSAmJiAhdGVtcE1hcFtjcm9zc05vZGUuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wTWFwW2Nyb3NzTm9kZS5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlQ3Jvc3NMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVuaXF1ZUNyb3NzTGlua3MuZm9yRWFjaChsID0+IGwuYWxpZ25Dcm9zc05vZGUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpZGVEdWJsaWNhdGlvbnMgKCkge1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZU1hcCA9IHt9O1xyXG4gICAgICAgIF9saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlSWQgPSAvKmxpbmsudHlwZUlkIHx8Ki8gbGluay5sYWJlbDtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9ydElkID0gbGluay5zb3VyY2UuZ2V0UG9ydCgpLmlkO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3J0SWQgPSBsaW5rLnRhcmdldC5nZXRQb3J0KCkuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVGdW5jdGlvbiAodHlwZUlkLCBzb3VyY2VQb3J0SWQsIHRhcmdldFBvcnRJZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSGlnaGxpZ2h0ZWQgPSBsaW5rLmhpZ2hsaWdodGluZygpO1xyXG4gICAgICAgICAgICBpZiAoaXNIaWdobGlnaHRlZCB8fCAhdW5pcXVlTWFwW2NhY2hlS2V5XSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZU1hcFtjYWNoZUtleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVNYXBbY2FjaGVLZXldLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVuaXF1ZU1hcFtjYWNoZUtleV0gPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgbGluay5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWNoZUZ1bmN0aW9uIChsYWJlbCwgc291cmNlUG9ydElkLCB0YXJnZXRQb3J0SWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2xhYmVsfX4jdHFETUxpbmsjfiR7c291cmNlUG9ydElkfX4jdHFETUxpbmsjfiR7dGFyZ2V0UG9ydElkfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IE1hcExheW91dDtcclxuXHJcblxyXG5mdW5jdGlvbiB0cVNhbmtleUxheW91dCAobm9kZXMsIGxpbmtzLCBzb3VyY2VJZCwgdGFyZ2V0SWQsIHNhdmVPcmRlcikge1xyXG4gICAgY29uc3Qgc2Fua2V5TGF5b3V0ID0gU2Fua2V5KCkuc3RlcChbMTAsIDEwXSlcclxuICAgICAgICAuZ3JvdXBzKFt7XHJcbiAgICAgICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgICAgIH1dKVxyXG4gICAgICAgIC5ub2RlV2lkdGgoMSlcclxuICAgICAgICAubm9kZUhlaWdodCgxKVxyXG4gICAgICAgIC5ub2Rlcyhub2RlcylcclxuICAgICAgICAuc2F2ZU9yZGVyKHNhdmVPcmRlcilcclxuICAgICAgICAubGlua3MobGlua3MpO1xyXG4gICAgICAgIFxyXG4gICAgaWYgKHNvdXJjZUlkICYmIHRhcmdldElkKSB7XHJcbiAgICAgICAgc2Fua2V5TGF5b3V0LmNvbXB1dGVOb2RlQnJlYWR0aHMgPSBmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IG5vZGUub3JpZ2luYWxOb2RlLm1vZGVsLnJlc291cmNlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS54ID0gbm9kZUlkID09PSBzb3VyY2VJZCA/IDAgOiBub2RlSWQgPT09IHRhcmdldElkID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICBub2RlLmR4ID09PSAxO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2Fua2V5TGF5b3V0LmxheW91dCgyMDAwKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0UG9ydElkLFxyXG59IGZyb20gJy4vbWFwRWxlbWVudHMnO1xyXG5pbXBvcnQge1xyXG4gICAgb25EcmFnU3RhcnQsXHJcbn0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTm9kZVZpZXcgKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBNQVhfTk9ERV9IRUlHSFQgPSAyMDA7XHJcbmV4cG9ydCBjb25zdCBDU1NfQ0xBU1NfTlVNQkVSID0gMztcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuRWxlbWVudFZpZXcucHJvdG90eXBlKTtcclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3Byb2Nlc3NlZElkczsgLy8gcHJldmVudCBjeWNsZXNcclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3NjYWxlID0gMTsgLy8gZGVmYXVsdCBzY2FsZVxyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGpvaW50LmRpYS5FbGVtZW50Vmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgdGhpcy5fcHJvY2Vzc2VkSWRzID0ge307XHJcbiAgICB0aGlzLnBhcnRzID0ge307XHJcblxyXG4gICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICBib3guY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZSc7XHJcbiAgICBib3guaWQgPSB0aGlzLm1vZGVsLmlkO1xyXG4gICAgYm94Lm9ubW91c2Vkb3duID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgb25EcmFnU3RhcnQoZXZlbnQsIChkaWZmKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1clBvcyA9IHRoaXMubW9kZWwucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5wb3NpdGlvbihjdXJQb3MueCArIGRpZmYueCAvIHRoaXMuX3NjYWxlLCBjdXJQb3MueSArIGRpZmYueSAvIHRoaXMuX3NjYWxlKTtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmdyYXBoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5ncmFwaC50cmlnZ2VyKCd1cGRhdGUtdmVydGljZXMnLCBldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucGFydHNbJ2JveCddID0gYm94O1xyXG4gICAgXHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHRoaXMuX2NyZWF0ZVNjcm9sbGVyKCk7XHJcbiAgICBib3guYXBwZW5kQ2hpbGQoc2Nyb2xsZXIpO1xyXG4gICAgdGhpcy5wYXJ0c1snc2Nyb2xsZXInXSA9IHNjcm9sbGVyO1xyXG5cclxuICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuX2NyZWF0ZUhlYWRlcih0aGlzLm1vZGVsLm1vZGVsKTtcclxuICAgIGJveC5hcHBlbmRDaGlsZChoZWFkZXIpO1xyXG4gICAgdGhpcy5wYXJ0c1snaGVhZGVyJ10gPSBoZWFkZXI7XHJcblxyXG4gICAgY29uc3QgYm9keSA9IHRoaXMuX2NyZWF0ZUJvZHkodGhpcy5tb2RlbC5tb2RlbCk7XHJcbiAgICBib3guYXBwZW5kQ2hpbGQoYm9keSk7XHJcbiAgICB0aGlzLnBhcnRzWydib2R5J10gPSBib2R5O1xyXG4gICAgXHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUNvbGxhcHNlQnV0dG9uKCk7XHJcbiAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoY29sbGFwc2VCdXR0b24pO1xyXG4gICAgdGhpcy5wYXJ0c1snY29sbGFwc2VCdXR0b24nXSA9IGNvbGxhcHNlQnV0dG9uO1xyXG5cclxuICAgIHRoaXMubW9kZWwub24oJ2NoYW5nZScsIHRoaXMuX3VwZGF0ZUJveCwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdyZW1vdmUnLCB0aGlzLl9yZW1vdmVCb3gsIHRoaXMpO1xyXG4gICAgdGhpcy5tb2RlbC5vbigncmVkcmF3LXZpZXcnLCB0aGlzLmRlYm91bmNlZFJlbmRlciwgdGhpcyk7XHJcbiAgICB0aGlzLm1vZGVsLm9uKCdlbGVtZW50cy1zdGF0ZS1jaGFuZ2VkJywgdGhpcy5kZWJvdW5jZWRSZW5kZXIsIHRoaXMpO1xyXG4gICAgdGhpcy5tb2RlbC5vbigncG9ydHMtc3RhdGUtY2hhbmdlZCcsIHRoaXMuX3VwZGF0ZVBvcnRzLCB0aGlzKTtcclxuICAgIHRoaXMubW9kZWwub24oJ2NoYW5nZTpjb2xsYXBzZWQnLCB0aGlzLmRlYm91bmNlZFJlbmRlciwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5kZWJvdW5jZXI7XHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlZFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVib3VuY2VyKTtcclxuICAgIHRoaXMuZGVib3VuY2VyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLl9wcm9jZXNzZWRJZHMgPSB7fTtcclxuICAgIGpvaW50LmRpYS5FbGVtZW50Vmlldy5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBjb25zdCBib3ggPSB0aGlzLnBhcnRzWydib3gnXTtcclxuICAgIGlmICh0aGlzLnBhcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7ICAgICAgICBcclxuICAgICAgICB0aGlzLnBhcGVyLiRlbC5wcmVwZW5kKGJveCk7IFxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XHJcbiAgICB0aGlzLl91cGRhdGVCb2R5KCk7XHJcblxyXG4gICAgY29tcG9uZW50cyA9IGNvbXBvbmVudHMgfHwgdGhpcy5tb2RlbC5nZXRBbGxDaGlsZHJlbigpO1xyXG4gICAgY29tcG9uZW50cy5mb3JFYWNoKG1vZGVsID0+IHRoaXMuX3VwZGF0ZU1vZGVsKG1vZGVsKSk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlQ29sbGFwc2VCdXR0b24oKTtcclxuICAgIHRoaXMuX3VwZGF0ZUJveCgpO1xyXG4gICAgdGhpcy5fdXBkYXRlUG9ydHMoKTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBib3ggPSB0aGlzLnBhcnRzWydib3gnXTsgXHJcblxyXG4gICAgY29uc3QgZWxlbWVudEJCb3ggPSB0aGlzLm1vZGVsLmdldEJCb3goKTtcclxuICAgIGxldCBoZWlnaHQgPSBib3guZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC8gdGhpcy5fc2NhbGU7XHJcblxyXG4gICAgLy9GRiBpcyByZXR1cm5pbmcgMCAwIDAgMCBmb3IgZ2V0Qm91bmRuaW5nQ2xpZW50UmVjdCByZXN1bHRpbmcgaW4gYSAwIGhlaWdodFxyXG4gICAgLy9kb3duIHN0cmVhbSB0aGlzIHdpbGwgY2F1c2Ugc2NhbGluZyBhbmQgYWxpZ25tZW50IGlzc3VlcyBmb3IgdGhlIGluL291dCBwb3J0c1xyXG4gICAgaWYoaGVpZ2h0ID09IDApe1xyXG4gICAgICAgIGhlaWdodCA9IDE7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGJveC5zdHlsZS53aWR0aCA9IGVsZW1lbnRCQm94LndpZHRoICsgJ3B4JztcclxuICAgIHRoaXMubW9kZWwucmVzaXplKGVsZW1lbnRCQm94LndpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGNvbnN0IHhfZXJyb3IgPSBlbGVtZW50QkJveC53aWR0aCAvIDI7XHJcbiAgICBjb25zdCB5X2Vycm9yID0gaGVpZ2h0IC8gMjtcclxuICAgIGJveC5zdHlsZS5sZWZ0ID0gKChlbGVtZW50QkJveC54ICsgeF9lcnJvcikgKiB0aGlzLm1vZGVsLnNjYWxlKSAtIHhfZXJyb3IgKyAncHgnO1xyXG4gICAgYm94LnN0eWxlLnRvcCA9ICgoZWxlbWVudEJCb3gueSArIHlfZXJyb3IpICogdGhpcy5tb2RlbC5zY2FsZSkgLSB5X2Vycm9yICsgJ3B4JztcclxuXHJcbiAgICB0aGlzLl9zY2FsZSA9IHRoaXMubW9kZWwuc2NhbGU7XHJcbiAgICBib3guc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKCcgKyB0aGlzLl9zY2FsZSArICcpJztcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVQb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGJveCA9IHRoaXMucGFydHNbJ2JveCddOyBcclxuICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnRzWydib2R5J107XHJcbiAgICBjb25zdCBmcmVzaFBvcnRzID0ge307XHJcbiAgICBjb25zdCBzaXplID0gdGhpcy5tb2RlbC5nZXQoJ3NpemUnKTtcclxuICAgIHRoaXMubW9kZWwuZ2V0QWxsQ2hpbGRyZW4oKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluUG9ydElkID0gZ2V0UG9ydElkKGVsZW1lbnQuaWQsICdpbicpO1xyXG4gICAgICAgIGNvbnN0IG91dFBvcnRJZCA9IGdldFBvcnRJZChlbGVtZW50LmlkLCAnb3V0Jyk7XHJcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBib3gucXVlcnlTZWxlY3RvcignIycgKyBlbGVtZW50LmlkKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBoZWFkZXIgPSBodG1sRWxlbWVudCA/XHJcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kbi1ncm91cF9oZWFkZXInKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgcG9ydEh0bWxFbGVtZW50O1xyXG4gICAgICAgIGlmIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgcG9ydEh0bWxFbGVtZW50ID0gaGVhZGVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBvcnRIdG1sRWxlbWVudCA9IGh0bWxFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9ydEh0bWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGdldE9mZnNldFRvcChwb3J0SHRtbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBwb3J0SHRtbEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb1RvcCA9IGJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5ZID0gYm9keS5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFkgPSBib2R5LmNsaWVudEhlaWdodCArIG1pblk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZVBvaW50ID0gKC1zY3JvbGxUb1RvcCkgKyBvZmZzZXRUb3AgKyBjbGllbnRIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCByZWZZID0gTWF0aC5tYXgoTWF0aC5taW4obWlkZGxlUG9pbnQsIG1heFkpLCBtaW5ZKTtcclxuXHJcbiAgICAgICAgICAgIGZyZXNoUG9ydHNbJy4nICsgaW5Qb3J0SWRdID0ge1xyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogcmVmWSxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZyZXNoUG9ydHNbJy4nICsgb3V0UG9ydElkXSA9IHtcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IHJlZlksXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMubW9kZWwuYXR0cihmcmVzaFBvcnRzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRUb3AgKGVsZW1lbnQpIHtcclxuICAgICAgICBpZihlbGVtZW50LmNsYXNzTmFtZSAhPT0gJ2Rlcml2YXRpb24tbm9kZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5jbGllbnRUb3AgKyAoZWxlbWVudC5vZmZzZXRQYXJlbnQgPyBnZXRPZmZzZXRUb3AoZWxlbWVudC5vZmZzZXRQYXJlbnQpIDogMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX2NyZWF0ZVNjcm9sbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3Qgc2Nyb2xsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIHNjcm9sbGVyLmNsYXNzTmFtZSA9ICdkZXJpdmF0aW9uLW5vZGVfYm9keS1zY3JvbGxlcic7XHJcbiAgICBzY3JvbGxlci5vbnNjcm9sbCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnBhcnRzWydib2R5J10uc2Nyb2xsVG9wID0gdGhpcy5tb2RlbC5zY3RvbGxUb3AgPSBzY3JvbGxlci5zY3JvbGxUb3A7XHJcbiAgICAgICAgdGhpcy5tb2RlbC51cGRhdGVQb3J0cygpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJvZHlTaXplID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICBib2R5U2l6ZS5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2JvZHktc2Nyb2xsZXJfX3NpemUnO1xyXG4gICAgc2Nyb2xsZXIuYXBwZW5kQ2hpbGQoYm9keVNpemUpO1xyXG5cclxuICAgIHJldHVybiBzY3JvbGxlcjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVTY3JvbGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gdGhpcy5wYXJ0c1snc2Nyb2xsZXInXTtcclxuICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnRzWydib2R5J107XHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IHRoaXMucGFydHNbJ2NvbGxhcHNlQnV0dG9uJ107XHJcblxyXG4gICAgY29uc3QgYmJveCA9IGJvZHkuZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IGJvZHlIZWlnaHQgPSBiYm94LmhlaWdodCAvIHRoaXMuX3NjYWxlO1xyXG4gICAgY29uc3QgYm9keVdpZHRoID0gYmJveC53aWR0aCAvIHRoaXMuX3NjYWxlO1xyXG4gICAgaWYgKHNjcm9sbGVyLmZpcnN0Q2hpbGQpIHsgLy8gZm9yIElFMTFcclxuICAgICAgICBzY3JvbGxlci5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IGJvZHlIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgIHNjcm9sbGVyLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBib2R5V2lkdGggKyAncHgnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhjZWVkU2l6ZSA9IGJvZHlIZWlnaHQgPD0gTUFYX05PREVfSEVJR0hUO1xyXG4gICAgY29uc3QgaXNTY3JvbGxhYmxlID0gZXhjZWVkU2l6ZSB8fCAhdGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpO1xyXG4gICAgY29sbGFwc2VCdXR0b24uc3R5bGUuZGlzcGxheSA9IGV4Y2VlZFNpemUgPyAnbm9uZScgOiBudWxsO1xyXG4gICAgc2Nyb2xsZXIuc3R5bGUuZGlzcGxheSA9IGlzU2Nyb2xsYWJsZSA/ICdub25lJyA6IG51bGw7XHJcblxyXG4gICAgYm9keS5zY3JvbGxUb3AgPSB0aGlzLm1vZGVsLnNjdG9sbFRvcDtcclxuICAgIHNjcm9sbGVyLnNjcm9sbFRvcCA9IHRoaXMubW9kZWwuc2N0b2xsVG9wO1xyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3JlbW92ZUJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucGFydHNbJ2JveCddLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wYXJ0c1snYm94J10pO1xyXG4gICAgdGhpcy5wYXJ0cyA9IHt9O1xyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX2NyZWF0ZUJvZHkgPSBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgIGNvbnN0IGJvZHkgPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICBib2R5LmNsYXNzTmFtZSA9ICdkZXJpdmF0aW9uLW5vZGVfYm9keSc7XHJcbiAgICBjb25zdCByZW5kZXJlZE1vZGVsID0gdGhpcy5fY3JlYXRlTW9kZWwobW9kZWwsIDApO1xyXG4gICAgYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlZE1vZGVsKTtcclxuXHJcbiAgICByZXR1cm4gYm9keTtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgYm9keSA9ICB0aGlzLnBhcnRzWydib2R5J107XHJcbiAgICBcclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29sbGFwc2VkJykpIHtcclxuICAgICAgICBib2R5LnN0eWxlLm1heEhlaWdodCA9IE1BWF9OT0RFX0hFSUdIVCArICdweCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJvZHkuc3R5bGUubWF4SGVpZ2h0ID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVDb2xsYXBzZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICBjb2xsYXBzZUJ1dHRvbi5hbHQgPSBcImNvbGxhcHNlIGJ1dHRvblwiO1xyXG4gICAgY29sbGFwc2VCdXR0b24uY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZS1jb2xsYXBzZS1idXR0b24nO1xyXG4gICAgY29sbGFwc2VCdXR0b24ub25jbGljayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2NvbGxhcHNlZCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuX2V4cGFuZEVsZW1lbnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLl9jb2xsYXBzZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBjb2xsYXBzZUJ1dHRvbjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVDb2xsYXBzZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGNvbGxhcHNlQnV0dG9uID0gdGhpcy5wYXJ0c1snY29sbGFwc2VCdXR0b24nXTtcclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnY29sbGFwc2VkJykpIHtcclxuICAgICAgICBjb2xsYXBzZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sbGFwc2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlSGVhZGVyID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgIGhlYWRlci5jbGFzc05hbWUgPSAnZGVyaXZhdGlvbi1ub2RlX2hlYWRlcic7XHJcblxyXG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMQUJFTCcpO1xyXG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ2Rlcml2YXRpb24tbm9kZV9oZWFkZXJfX2xhYmVsJztcclxuICAgIGxhYmVsLmlubmVyVGV4dCA9IG1vZGVsLnRpdGxlIHx8ICcnO1xyXG5cclxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG4gICAgcmV0dXJuIGhlYWRlcjtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl9jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCwgZGVlcCkge1xyXG4gICAgaWYgKCF0aGlzLl9wcm9jZXNzZWRJZHNbbW9kZWwuaWRdKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkSWRzW21vZGVsLmlkXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGxldCBtb2RlbFZpZXc7XHJcbiAgICAgICAgaWYgKG1vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbW9kZWxWaWV3ID0gdGhpcy5fY3JlYXRlR3JvdXAobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGVsVmlldyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobW9kZWwsIGRlZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhcnRzW21vZGVsLmlkXSA9IG1vZGVsVmlldztcclxuICAgICAgICByZXR1cm4gbW9kZWxWaWV3O1xyXG4gICAgfVxyXG59O1xyXG5cclxuR3JhcGhOb2RlVmlldy5wcm90b3R5cGUuX3VwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICBpZiAobW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUdyb3VwKG1vZGVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRWxlbWVudChtb2RlbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAocm9vdE1vZGVsLCBkZWVwKSB7XHJcbiAgICBjb25zdCBpY29uID0gcm9vdE1vZGVsLmljb24gPyBgPHNwYW4gY2xhc3M9XCJkbi1oZWFkZXItaWNvblwiPjxpIGNsYXNzPVwiJHtyb290TW9kZWwuaWNvbn1cIj48L2k+PC9zcGFuPmAgOiAnJztcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3QgY3NzQ2xhc3MgPSAnZGVyaXZhdGlvbi1ub2RlX2dyb3VwXycgKyBkZWVwICUgKENTU19DTEFTU19OVU1CRVIgKyAxKTtcclxuICAgIGdyb3VwRWxlbWVudC5pZCA9IHJvb3RNb2RlbC5pZDtcclxuICAgIGdyb3VwRWxlbWVudC5jbGFzc05hbWUgPSBgJHtjc3NDbGFzc30gZG4tZ3JvdXBgO1xyXG4gICAgZ3JvdXBFbGVtZW50LmlubmVySFRNTCA9IGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tZ3JvdXBfaGVhZGVyXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX2luY29taW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8aW1nIGFsdD1cIkNvbGxhcHNlIEdyb3VwXCIgdGl0bGU9XCJDb2xsYXBzZSBHcm91cFwiLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWdyb3VwX2hlYWRlcl9fbGFiZWxcIiAgdGl0bGU9XCIke3Jvb3RNb2RlbC5lbmRwb2ludElkICsgJyh0eXBlOiAnICsgcm9vdE1vZGVsLnR5cGUgKyAnKSd9XCI+XHJcbiAgICAgICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgICAgICA8bGFiZWw+JHtyb290TW9kZWwubGFiZWx9PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG4tYXJyb3ctdHJpYW5nbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDx1bCBjbGFzcz1cImRlcml2YXRpb24tbm9kZV9saXN0LW9mLWVsZW1lbnRzXCI+PC91bD5cclxuICAgIGA7XHJcblxyXG4gICAgY29uc3QgYWN0aXZlSGVhZGVyQXJlYSA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyX19sYWJlbCcpO1xyXG4gICAgYWN0aXZlSGVhZGVyQXJlYS5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZ3JvdXBFbGVtZW50LmlkKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfbGlzdC1vZi1lbGVtZW50cycpO1xyXG4gICAgcm9vdE1vZGVsLmNoaWxkcmVuLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZWRNb2RlbCA9IHRoaXMuX2NyZWF0ZU1vZGVsKGVsZW1lbnQsIGRlZXAgKyAxKTtcclxuICAgICAgICBpZiAocmVuZGVyZWRNb2RlbCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmRDaGlsZChyZW5kZXJlZE1vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBjb2xsYXBzZUJ1dHRvbiA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXAgaW1nJyk7XHJcbiAgICBjb2xsYXBzZUJ1dHRvbi5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5vbkNsaWNrQ29sbGFwc2VCdXR0b24ocm9vdE1vZGVsLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGdyb3VwRWxlbWVudDtcclxufTtcclxuXHJcbkdyYXBoTm9kZVZpZXcucHJvdG90eXBlLl91cGRhdGVHcm91cCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IHRoaXMucGFydHNbcm9vdE1vZGVsLmlkXTtcclxuXHJcbiAgICBncm91cEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHJvb3RNb2RlbC5pbnZpc2libGUgPyAnbm9uZScgOiBudWxsO1xyXG4gICAgaWYgKHJvb3RNb2RlbC5pbnZpc2libGUpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBub1Zpc2libGVDaGlsZHJlbiA9ICghcm9vdE1vZGVsLmNoaWxkcmVuKSB8fCByb290TW9kZWwuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5pbnZpc2libGUpLmxlbmd0aCA9PT0gMDtcclxuICAgIGlmIChyb290TW9kZWwuY29sbGFwc2VkICYmIG5vVmlzaWJsZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgZ3JvdXBFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RuLWNvbGxhcHNlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJvb3RNb2RlbC5jb2xsYXBzZWQgJiYgbm9WaXNpYmxlQ2hpbGRyZW4pIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZG4tY29sbGFwc2VkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkbi1jb2xsYXBzZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGdyb3VwRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBncm91cEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBodG1sSW5Qb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX291dGdvaW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sT3V0VHJpYW5nZWwgPSBodG1sT3V0UG9ydHMucXVlcnlTZWxlY3RvcignLmRuLWFycm93LXRyaWFuZ2xlJyk7XHJcbiAgICBjb25zdCBvdXRQb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnb3V0Jyk7XHJcbiAgICBjb25zdCBvdXRnb2luZ0xpbmtzTWFwID0gdGhpcy5tb2RlbC5hY3RpdmVQb3J0c1tvdXRQb3J0SWRdIHx8IHt9O1xyXG4gICAgY29uc3QgYWN0aXZlT3V0TGlua3MgPSBPYmplY3Qua2V5cyhvdXRnb2luZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IG91dGdvaW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBuZWVkT3V0QXJyb3cgPSBhY3RpdmVPdXRMaW5rcyAmJiBjaGVja0Fycm93KHRoaXMubW9kZWwsIGFjdGl2ZU91dExpbmtzKTtcclxuICAgIGNvbnN0IG91dFBvcnRWaXNpYmxlID0gYWN0aXZlT3V0TGlua3MubGVuZ3RoID4gMCAmJiByb290TW9kZWwhPT0gdGhpcy5tb2RlbC5tb2RlbDtcclxuICAgIGh0bWxPdXRQb3J0cy5zdHlsZS5kaXNwbGF5ID0gb3V0UG9ydFZpc2libGUgPyBudWxsIDogJ25vbmUnO1xyXG4gICAgaHRtbE91dFRyaWFuZ2VsLnN0eWxlLmRpc3BsYXkgPSBuZWVkT3V0QXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGltZyA9IGdyb3VwRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZ3JvdXBfaGVhZGVyIGltZycpO1xyXG4gICAgaW1nLmNsYXNzTmFtZSA9IHJvb3RNb2RlbC5jb2xsYXBzZWQgPyAnZG4tY29sbGFwc2VkJyA6ICcnO1xyXG4gICAgaW1nLmFsdCA9IHJvb3RNb2RlbC5jb2xsYXBzZWQgPyAnRXhwYW5kIEdyb3VwJyA6ICdDb2xsYXBzZSBHcm91cCc7XHJcbiAgICBpbWcudGl0bGUgPSBpbWcuYWx0O1xyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXBFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kbi1ncm91cF9oZWFkZXJfX2xhYmVsIGxhYmVsJyk7XHJcbiAgICBsYWJlbC5pbm5lckhUTUwgPSBnZXRDb2xvcmVkTGFiZWwocm9vdE1vZGVsLmxhYmVsLCB0aGlzLm1vZGVsLnNlYXJjaEtleSk7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwsIGRlZXApIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IGljb24gPSByb290TW9kZWwuaWNvbiA/IGA8c3BhbiBjbGFzcz1cImRuLWhlYWRlci1pY29uXCI+PGkgY2xhc3M9XCIke3Jvb3RNb2RlbC5pY29ufVwiPjwvaT48L3NwYW4+YCA6ICcnO1xyXG5cclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYGRuLWVsZW1lbnQgZGVyaXZhdGlvbi1ub2RlX2VsZW1lbnRfJHtkZWVwfWA7XHJcbiAgICBlbGVtZW50LmlkID0gcm9vdE1vZGVsLmlkO1xyXG4gICAgZWxlbWVudC5vbmNsaWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5maXJlQ2xpY2tFdmVudChldmVudCwgZWxlbWVudC5pZCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkbi1hcnJvdyBkbl9faW5jb21pbmctYXJyb3dcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRuLWFycm93LXRyaWFuZ2xlXCI+PC9kaXY+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkbi1lbGVtZW50X2NlbnRlclwiPlxyXG4gICAgICAgICAgICAke2ljb259XHJcbiAgICAgICAgICAgIDxsYWJlbCB0aXRsZT1cIiR7cm9vdE1vZGVsLmVuZHBvaW50SWQgKyAnKHR5cGU6ICcgKyByb290TW9kZWwudHlwZSArICcpJ31cIj5cclxuICAgICAgICAgICAgICAgICR7cm9vdE1vZGVsLmxhYmVsfVxyXG4gICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZG4tYXJyb3cgZG5fX291dGdvaW5nLWFycm93XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkbi1hcnJvdy10cmlhbmdsZVwiPjwvZGl2PlxyXG4gICAgICAgIDwvc3Bhbj5cclxuICAgIGA7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG5HcmFwaE5vZGVWaWV3LnByb3RvdHlwZS5fdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290TW9kZWwpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnBhcnRzW3Jvb3RNb2RlbC5pZF07XHJcblxyXG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gcm9vdE1vZGVsLmludmlzaWJsZSA/ICdub25lJyA6IG51bGw7XHJcbiAgICBpZiAocm9vdE1vZGVsLmludmlzaWJsZSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGh0bWxJblBvcnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tYXJyb3cuZG5fX2luY29taW5nLWFycm93Jyk7XHJcbiAgICBjb25zdCBodG1sSW5UcmlhbmdlbCA9IGh0bWxJblBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3QgaW5Qb3J0SWQgPSBnZXRQb3J0SWQocm9vdE1vZGVsLmlkLCAnaW4nKTtcclxuICAgIGNvbnN0IGluY29taW5nTGlua3NNYXAgPSB0aGlzLm1vZGVsLmFjdGl2ZVBvcnRzW2luUG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZUluTGlua3MgPSBPYmplY3Qua2V5cyhpbmNvbWluZ0xpbmtzTWFwKS5tYXAoa2V5ID0+IGluY29taW5nTGlua3NNYXBba2V5XSk7XHJcbiAgICBjb25zdCBpblBvcnRWaXNpYmxlID0gYWN0aXZlSW5MaW5rcy5sZW5ndGggPiAwICYmIHJvb3RNb2RlbCE9PSB0aGlzLm1vZGVsLm1vZGVsO1xyXG4gICAgY29uc3QgbmVlZEluQXJyb3cgPSBhY3RpdmVJbkxpbmtzICYmIGNoZWNrQXJyb3codGhpcy5tb2RlbCwgYWN0aXZlSW5MaW5rcyk7XHJcbiAgICBodG1sSW5Qb3J0cy5zdHlsZS5kaXNwbGF5ID0gaW5Qb3J0VmlzaWJsZSA/IG51bGwgOiAnbm9uZSc7XHJcbiAgICBodG1sSW5UcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZEluQXJyb3cgPyBudWxsIDogJ25vbmUnO1xyXG5cclxuICAgIGNvbnN0IGh0bWxPdXRQb3J0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRuLWFycm93LmRuX19vdXRnb2luZy1hcnJvdycpO1xyXG4gICAgY29uc3QgaHRtbE91dFRyaWFuZ2VsID0gaHRtbE91dFBvcnRzLnF1ZXJ5U2VsZWN0b3IoJy5kbi1hcnJvdy10cmlhbmdsZScpO1xyXG4gICAgY29uc3Qgb3V0UG9ydElkID0gZ2V0UG9ydElkKHJvb3RNb2RlbC5pZCwgJ291dCcpO1xyXG4gICAgY29uc3Qgb3V0Z29pbmdMaW5rc01hcCA9IHRoaXMubW9kZWwuYWN0aXZlUG9ydHNbb3V0UG9ydElkXSB8fCB7fTtcclxuICAgIGNvbnN0IGFjdGl2ZU91dExpbmtzID0gT2JqZWN0LmtleXMob3V0Z29pbmdMaW5rc01hcCkubWFwKGtleSA9PiBvdXRnb2luZ0xpbmtzTWFwW2tleV0pO1xyXG4gICAgY29uc3QgbmVlZE91dEFycm93ID0gYWN0aXZlT3V0TGlua3MgJiYgY2hlY2tBcnJvdyh0aGlzLm1vZGVsLCBhY3RpdmVPdXRMaW5rcyk7XHJcbiAgICBjb25zdCBvdXRQb3J0VmlzaWJsZSA9IGFjdGl2ZU91dExpbmtzLmxlbmd0aCA+IDAgJiYgcm9vdE1vZGVsIT09IHRoaXMubW9kZWwubW9kZWw7XHJcbiAgICBodG1sT3V0UG9ydHMuc3R5bGUuZGlzcGxheSA9IG91dFBvcnRWaXNpYmxlID8gbnVsbCA6ICdub25lJztcclxuICAgIGh0bWxPdXRUcmlhbmdlbC5zdHlsZS5kaXNwbGF5ID0gbmVlZE91dEFycm93ID8gbnVsbCA6ICdub25lJztcclxuXHJcbiAgICBjb25zdCBpc0hpZ2hsaWdodGVkID0gdGhpcy5tb2RlbC5oaWdobGlnaHRlZElkID09PSByb290TW9kZWwuaWQ7XHJcbiAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndHEtZG0taGlnaGxpZ2h0ZWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCd0cS1kbS1oaWdobGlnaHRlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxhYmVsID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZG4tZWxlbWVudF9jZW50ZXIgbGFiZWwnKTtcclxuICAgIGxhYmVsLmlubmVySFRNTCA9IGdldENvbG9yZWRMYWJlbChyb290TW9kZWwubGFiZWwsIHRoaXMubW9kZWwuc2VhcmNoS2V5KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldENvbG9yZWRMYWJlbCAobGFiZWwsIGtleSkge1xyXG4gICAgaWYgKCFrZXkpIHJldHVybiBsYWJlbDtcclxuICAgIGNvbnN0IGxvd2VyQ2FzZUxhYmVsID0gbGFiZWwudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGtleUluZGV4ID0gbG93ZXJDYXNlTGFiZWwuaW5kZXhPZihrZXkpO1xyXG5cclxuICAgIGlmIChrZXlJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleS5sZW5ndGgpOyBcclxuICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKGtleS5sZW5ndGgsIGxhYmVsLmxlbmd0aCk7IFxyXG4gICAgICAgIHJldHVybiBgPGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke2ZpcnN0UGFydH08L2k+JHtzZWNvbmRQYXJ0fWA7XHJcbiAgICB9IGVsc2UgaWYgKGtleUluZGV4ICsga2V5Lmxlbmd0aCA9PT0gbGFiZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwgbGFiZWwubGVuZ3RoKTsgXHJcbiAgICAgICAgcmV0dXJuIGAke2ZpcnN0UGFydH08aSBjbGFzcz1cInRxLWRtLWhpZ2hsaWdodGVkLWtleVwiPiR7c2Vjb25kUGFydH08L2k+YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gbGFiZWwuc3Vic3RyaW5nKDAsIGtleUluZGV4KTsgXHJcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGxhYmVsLnN1YnN0cmluZyhrZXlJbmRleCwga2V5SW5kZXggKyBrZXkubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB0aGlyZFBhcnQgPSBsYWJlbC5zdWJzdHJpbmcoa2V5SW5kZXggKyBrZXkubGVuZ3RoLCBsYWJlbC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBgJHtmaXJzdFBhcnR9PGkgY2xhc3M9XCJ0cS1kbS1oaWdobGlnaHRlZC1rZXlcIj4ke3NlY29uZFBhcnR9PC9pPiR7dGhpcmRQYXJ0fWA7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgR3JhcGhMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTGlua1ZpZXcgKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5HcmFwaExpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2U6aGlnaGxpZ2h0ZWQgY2hhbmdlOmJsdXJlZCB1cGRhdGUtc3RhdGUnLCBvbkV2ZW50KTtcclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgJ3VwZGF0ZU1hcmtlcnMnLCB0aGlzLnVwZGF0ZU1hcmtlcnMpO1xyXG59O1xyXG5cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUudXBkYXRlTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX21hcmtlckNhY2hlID0ge307XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG59O1xyXG5cclxuR3JhcGhMaW5rVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElHSExJR0hURVIgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1kbS1oaWdobGlnaHRlZCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RNX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0tYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IExHX0RNX0NFTExfSElEREVOID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtZG0taGlkZGVuJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIG9uRXZlbnQgKCkge1xyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWdobGlnaHRlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9ISUdITElHSFRFUik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHQobnVsbCwgTEdfRE1fQ0VMTF9CTFVSRVIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfQkxVUkVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmhpZGRlbikge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0RNX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19ETV9DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrQXJyb3cgKHNlbGYsIGxpbmtzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsaW5rLmdldCgndGFyZ2V0JykuaWQgPT09IHNlbGYuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEFzcGVjdExpbmtNb2RlbCAtIGRhdGEgbW9kZWwgb2YgYW4gQXNwZWN0TGluayBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gQXNwZWN0TGlua01vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZSB8IFRlcm1pbmF0aW9uTm9kZX0gdGFyZ2V0IC0gVGFyZ2V0IE5vZGVcclxuICogQHByb3BlcnR5IHtOb2RlIHwgVGVybWluYXRpb25Ob2RlfSBzb3VyY2UgLSBTb3VyY2UgTm9kZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBncmFwaCBMaW5rIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rXHJcbiAqIEBwYXJhbSB7QXNwZWN0TGlua01vZGVsfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBAcHJvcGVydHkge1NpbXBsZUxpbmtNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsIFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gQXNwZWN0TGluayAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IHsgaWQ6IG9wdGlvbnMuc291cmNlLmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0geyBpZDogb3B0aW9ucy50YXJnZXQuaWQsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH07XHJcblxyXG4gICAgY29uc3QgbGlua0NvbG9yID0gX3Jlcy5nZXRDb2xvcignYXNwZWN0TGluaycpO1xyXG5cclxuICAgIGpvaW50LmRpYS5MaW5rLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXHJcbiAgICAgICAgdHlwZTogJ2FzcGVjdC1saW5rJyxcclxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICB6OiBaX0lOREVYRVMuQVNQRUNUX0xJTkssXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJy5jb25uZWN0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcxMCwgMTAnLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICc1cHgnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci1zb3VyY2UnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci10YXJnZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIGQ6ICdNMCwzYTMsMyAwIDEsMCA2LDBhMywzIDAgMSwwIC02LDAnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gdmFyaWFudHMgZm9yIHRoZSBleHBlcmltZW50aW5nXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVycyB0aGUgQXNwZWN0TGluay5cclxuICAgICAqIEBtZW1iZXJvZiBBc3BlY3RMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIEFzcGVjdExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgQXNwZWN0TGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBBc3BlY3RMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIEFzcGVjdExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5tb2RlbCA9IHsgc291cmNlOiBvcHRpb25zLnNvdXJjZS5pZCwgdGFyZ2V0OiBvcHRpb25zLnRhcmdldC5pZCB9O1xyXG59XHJcbkFzcGVjdExpbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShqb2ludC5kaWEuTGluay5wcm90b3R5cGUpO1xyXG5cclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vbm9kZSc7XHJcbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL2xpbmsnO1xyXG5pbXBvcnQgeyBUZXJtaW5hdGlvbkxpbmsgfSBmcm9tICcuL3Rlcm1pbmF0aW9uTGluayc7XHJcbmltcG9ydCB7IFRlcm1pbmF0aW9uTm9kZSB9IGZyb20gJy4vdGVybWluYXRpb25Ob2RlJztcclxuaW1wb3J0IHsgQXNwZWN0TGluayB9IGZyb20gJy4vYXNwZWN0TGluayc7XHJcblxyXG5leHBvcnQgeyBOb2RlLCBMaW5rLCBUZXJtaW5hdGlvbk5vZGUsIFRlcm1pbmF0aW9uTGluaywgQXNwZWN0TGluayB9O1xyXG5cclxuY29uc3QgViA9IGpvaW50LlY7XHJcbmNvbnN0IGcgPSBqb2ludC5nO1xyXG5cclxuZXhwb3J0IGNvbnN0IFpfSU5ERVhFUyA9IHtcclxuICAgIEFTUEVDVF9MSU5LOiAyNSxcclxuICAgIFRFUk1JTkFUSU9OX0VMRU1FTlQ6IDI1LFxyXG4gICAgU0VMRUNURURfRUxFTUVOVDogMzAsXHJcbiAgICBOT0RFOiAyMCxcclxuICAgIExJTks6IDE1LFxyXG4gICAgQkxVUkVEX05PREU6IDEwLFxyXG4gICAgQkxVUkVEX0xJTks6IDUsXHJcbiAgICBWSUVXX0ZSQU1FOiAxLFxyXG59O1xyXG5cclxuY29uc3QgTEdfQ0VMTF9ISUdITElHSFRFUiA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWhpZ2hsaWdodGVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfQ0VMTF9ISURERU4gPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1oaWRkZW4tZWxlbWVudCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0NFTExfQkxVUkVSID0ge1xyXG4gICAgaGlnaGxpZ2h0ZXI6IHtcclxuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAndHEtbGctYmx1cmVkJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgTEdfU0hPUlRfTEFCRUwgPSB7XHJcbiAgICBoaWdobGlnaHRlcjoge1xyXG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICd0cS1sZy1zaG9ydC1sYWJlbCdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IExHX0RSQUdHRURfTk9ERSA9IHtcclxuICAgIGhpZ2hsaWdodGVyOiB7XHJcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RxLWxnLWRyYWdnZWQtbm9kZSdcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRDbGFzcyAoKSB7XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ2hpZ2hsaWdodGVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJR0hMSUdIVEVSKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vZGVsLmdldCgnYmx1cmVkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0JMVVJFUik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfQ0VMTF9CTFVSRVIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdoaWRkZW4nKSkge1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0KG51bGwsIExHX0NFTExfSElEREVOKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodChudWxsLCBMR19DRUxMX0hJRERFTik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb2RlbC5nZXQoJ3Nob3J0LWxhYmVsJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19TSE9SVF9MQUJFTCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudW5oaWdobGlnaHQobnVsbCwgTEdfU0hPUlRfTEFCRUwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubW9kZWwuZ2V0KCdkcmFnZ2VkJykpIHtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodChudWxsLCBMR19EUkFHR0VEX05PREUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0KG51bGwsIExHX0RSQUdHRURfTk9ERSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgTGlua1ZpZXcgY2xhc3MuIE1haW5seSBpbiBjaGFyZ2Ugb2Ygbm9kZSBoaWdobGlnaHRpbmcuXHJcbiAqIExpc3RlbiB0byBldmVudHMgYW5kIGFwcGx5IGhpZ2hsaWdodGVycy5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBqb2ludC5kaWEuTGlua1ZpZXdcclxuICogQHBhcmFtIHtOb2RlTW9kZWx9IGRhdGFNb2RlbCAtIE1vZGVsIG9mIGdyYXBoIG5vZGVcclxuICogQHBhcmFtIHt2ZXJ9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE5vZGVWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5FbGVtZW50Vmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbk5vZGVWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZSk7XHJcbk5vZGVWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgam9pbnQuZGlhLkVsZW1lbnRWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmRyYWdnZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6aGlnaGxpZ2h0ZWQnLFxyXG4gICAgICAgICdjaGFuZ2U6Ymx1cmVkJyxcclxuICAgICAgICAnY2hhbmdlOmhpZGRlbicsXHJcbiAgICAgICAgJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJyxcclxuICAgICAgICAnY2hhbmdlOnNob3J0LWxhYmVsJ1xyXG4gICAgXS5qb2luKCcgJyksIHRoaXMuZGVib3VuY2VkSGlnaGxpZ2h0aW5nKTtcclxufTtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlcjtcclxuTm9kZVZpZXcucHJvdG90eXBlLmRlYm91bmNlZEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVib3VuY2VyKTtcclxuICAgIHRoaXMuZGVib3VuY2VyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBnZXRDbGFzcy5jYWxsKHRoaXMpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRoZSBMaW5rVmlldyBjbGFzcy4gTWFpbmx5IGluIGNoYXJnZSBvZiBsaW5rIGhpZ2hsaWdodGluZy5cclxuICogTGlzdGVuIHRvIGV2ZW50cyBhbmQgYXBwbHkgaGlnaGxpZ2h0ZXJzLlxyXG4gKiBAY2xhc3NcclxuICogQGF1Z21lbnRzIGpvaW50LmRpYS5MaW5rVmlld1xyXG4gKiBAcGFyYW0ge05vZGVNb2RlbH0gZGF0YU1vZGVsIC0gTW9kZWwgb2YgZ3JhcGggbm9kZVxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSBUaGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmtWaWV3ICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBqb2ludC5kaWEuTGlua1ZpZXcucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUpO1xyXG5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGpvaW50LmRpYS5MaW5rVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFtcclxuICAgICAgICAnY2hhbmdlOmhpZ2hsaWdodGVkJyxcclxuICAgICAgICAnY2hhbmdlOmJsdXJlZCcsXHJcbiAgICAgICAgJ2NoYW5nZTpoaWRkZW4nLFxyXG4gICAgICAgICdyZWZyZXNoLWhpZ2hsaWdodGluZycsXHJcbiAgICBdLmpvaW4oJyAnKSwgdGhpcy5kZWJvdW5jZWRIaWdobGlnaHRpbmcpO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUuZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fVi5jb25uZWN0aW9uLm5vZGUuZ2V0UG9pbnRBdExlbmd0aCh0aGlzLl9WLmNvbm5lY3Rpb24ubm9kZS5nZXRUb3RhbExlbmd0aCgpICogayk7XHJcbn07XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZXI7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5kZWJvdW5jZWRIaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlYm91bmNlcik7XHJcbiAgICB0aGlzLmRlYm91bmNlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgZ2V0Q2xhc3MuY2FsbCh0aGlzKTtcclxuICAgIH0pO1xyXG59O1xyXG5MaW5rVmlldy5wcm90b3R5cGUudXBkYXRlVG9vbHNQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBNb3ZlIHRoZSB0b29scyBhIGJpdCB0byB0aGUgdGFyZ2V0IHBvc2l0aW9uIGJ1dCBkb24ndCBjb3ZlciB0aGUgYHNvdXJjZUFycm93aGVhZGAgbWFya2VyLlxyXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBvZmZzZXQgaXMgaGFyZGNvZGVkIGhlcmUuIFRoZSBvZmZzZXQgc2hvdWxkIGJlIGFsd2F5c1xyXG4gICAgLy8gbW9yZSB0aGFuIHRoZSBgdGhpcy4kKCcubWFya2VyLWFycm93aGVhZFtlbmQ9XCJzb3VyY2VcIl0nKVswXS5iYm94KCkud2lkdGhgIGJ1dCBsb29raW5nXHJcbiAgICAvLyB0aGlzIHVwIGFsbCB0aGUgdGltZSB3b3VsZCBiZSBzbG93LlxyXG5cclxuICAgIGxldCBzY2FsZSA9ICcnO1xyXG4gICAgY29uc3QgY29ubmVjdGlvbkxlbmd0aCA9IHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpO1xyXG5cclxuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBjb25uZWN0aW9uTGVuZ3RoPU5hTiBpbiBvZGQgY2FzZXMgKGZvciBiZXppZXIgY3VydmVzKS5cclxuICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB3b24ndCB1cGRhdGUgdG9vbHMgcG9zaXRpb24gYXQgYWxsLlxyXG4gICAgaWYgKCFfLmlzTmFOKGNvbm5lY3Rpb25MZW5ndGgpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBsaW5rIGlzIHRvbyBzaG9ydCwgbWFrZSB0aGUgdG9vbHMgaGFsZiB0aGUgc2l6ZSBhbmQgdGhlIG9mZnNldCB0d2ljZSBhcyBsb3cuXHJcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25MZW5ndGggPCB0aGlzLm9wdGlvbnMuc2hvcnRMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gJ3NjYWxlKC41KSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90b29sQ2FjaGUuZm9yRWFjaCgodG9vbCwgaW5kZXgsIGFycikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gYXJyLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGsgPSBpIC8gbDtcclxuICAgICAgICAgICAgY29uc3QgdG9vbFBvc2l0aW9uID0gdGhpcy5nZXRQb2ludEF0TGVuZ3RoKGspO1xyXG4gICAgICAgICAgICBpZiAodG9vbC5ub2RlIGluc3RhbmNlb2YgU1ZHR0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRvb2wuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgdG9vbFBvc2l0aW9uLnggKyAnLCAnICsgdG9vbFBvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG91YmxlTGlua1Rvb2xzICYmIGNvbm5lY3Rpb25MZW5ndGggPj0gdGhpcy5vcHRpb25zLmxvbmdMaW5rTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmdldFBvaW50QXRMZW5ndGgoayAvKmNvbm5lY3Rpb25MZW5ndGggLSBkb3VibGVMaW5rVG9vbHNPZmZzZXQqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbDJDYWNoZS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBuZXdQb3NpdGlvbi54ICsgJywgJyArIG5ld1Bvc2l0aW9uLnkgKyAnKSAnICsgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2wyQ2FjaGUuYXR0cigndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kb3VibGVMaW5rVG9vbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sMkNhY2hlLmF0dHIoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkxpbmtWaWV3LnByb3RvdHlwZS5yZW5kZXJUb29scyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuX1YubGlua1Rvb2xzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBUb29scyBhcmUgYSBncm91cCBvZiBjbGlja2FibGUgZWxlbWVudHMgdGhhdCBtYW5pcHVsYXRlIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gQSBnb29kIGV4YW1wbGUgb2YgdGhpcyBpcyB0aGUgcmVtb3ZlIHRvb2wgdGhhdCByZW1vdmVzIHRoZSB3aG9sZSBsaW5rLlxyXG4gICAgLy8gVG9vbHMgYXBwZWFyIGFmdGVyIGhvdmVyaW5nIHRoZSBsaW5rIGNsb3NlIHRvIHRoZSBgc291cmNlYCBlbGVtZW50L3BvaW50IG9mIHRoZSBsaW5rXHJcbiAgICAvLyBidXQgYXJlIG9mZnNldCBhIGJpdCBzbyB0aGF0IHRoZXkgZG9uJ3QgY292ZXIgdGhlIGBtYXJrZXItYXJyb3doZWFkYC5cclxuXHJcbiAgICB2YXIgaHRtbFRvb2xzID0gdGhpcy5fVi5saW5rVG9vbHMubm9kZTtcclxuICAgIHZhciB0b29sVGVtcGxhdGUgPSBqb2ludC51dGlsLnRlbXBsYXRlKHRoaXMubW9kZWwuZ2V0KCd0b29sTWFya3VwJykgfHwgdGhpcy5tb2RlbC50b29sTWFya3VwKTtcclxuICAgIHZhciB2VG9vbHMgPSBWKHRvb2xUZW1wbGF0ZSgpKTtcclxuXHJcbiAgICB2YXIgdG9vbHM7XHJcbiAgICBpZiAodlRvb2xzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICB0b29scyA9IHZUb29scztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9vbHMgPSBbdlRvb2xzXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHtcclxuICAgICAgICBodG1sVG9vbHMuYXBwZW5kQ2hpbGQodG9vbC5ub2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhY2hlIHRoZSB0b29sIG5vZGUgc28gdGhhdCB0aGUgYHVwZGF0ZVRvb2xzUG9zaXRpb24oKWAgY2FuIHVwZGF0ZSB0aGUgdG9vbCBwb3NpdGlvbiBxdWlja2x5LlxyXG4gICAgdGhpcy5fdG9vbENhY2hlID0gdG9vbHM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5jb25zdCBvdmVycmlkZWRGdW5jdGlvbiA9IExpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQ7XHJcbkxpbmtWaWV3LnByb3RvdHlwZS5nZXRDb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiAoZW5kLCBzZWxlY3Rvck9yUG9pbnQsIHJlZmVyZW5jZVNlbGVjdG9yT3JQb2ludCkge1xyXG4gICAgbGV0IGNvbm5lY3Rpb25Qb2ludCA9IG92ZXJyaWRlZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgbGV0IGxpbWl0Qm94O1xyXG4gICAgXy5pc0VtcHR5KHNlbGVjdG9yT3JQb2ludCkgJiYgKHNlbGVjdG9yT3JQb2ludCA9IHsgeDogMCwgeTogMCB9KTtcclxuICAgIF8uaXNFbXB0eShyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpICYmIChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQgPSB7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG4gICAgaWYgKCFzZWxlY3Rvck9yUG9pbnQuaWQpIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGcucG9pbnQoc2VsZWN0b3JPclBvaW50KTtcclxuICAgICAgICBsaW1pdEJveCA9IHtcclxuICAgICAgICAgICAgeDogcG9pbnQueCxcclxuICAgICAgICAgICAgeTogcG9pbnQueSxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgY2VudGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsaW1pdEJveCA9IChlbmQgPT09ICdzb3VyY2UnID8gdGhpcy5zb3VyY2VCQm94IDogdGhpcy50YXJnZXRCQm94KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpbWl0Q2V0ZXIgPSBsaW1pdEJveC5jZW50ZXIoKTtcclxuXHJcbiAgICBjb25zdCByaWdodEJvcmRlciA9IE1hdGgucm91bmQobGltaXRDZXRlci54ICsgbGltaXRCb3gud2lkdGggLyAyKTtcclxuICAgIGNvbnN0IGxlZnRCb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueCAtIGxpbWl0Qm94LndpZHRoIC8gMik7XHJcbiAgICBjb25zdCBib3R0b21Cb3JkZXIgPSBNYXRoLnJvdW5kKGxpbWl0Q2V0ZXIueSArIGxpbWl0Qm94LmhlaWdodCAvIDIpO1xyXG4gICAgY29uc3QgdG9wQm9yZGVyID0gTWF0aC5yb3VuZChsaW1pdENldGVyLnkgLSBsaW1pdEJveC5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICBjb25zdCB4SW5zaWRlID0gbGVmdEJvcmRlciA8IGNvbm5lY3Rpb25Qb2ludC54ICYmIGNvbm5lY3Rpb25Qb2ludC54IDwgcmlnaHRCb3JkZXI7XHJcbiAgICBjb25zdCB5SW5zaWRlID0gdG9wQm9yZGVyIDwgY29ubmVjdGlvblBvaW50LnkgJiYgY29ubmVjdGlvblBvaW50LnkgPCBib3R0b21Cb3JkZXI7XHJcbiAgICBjb25zdCBpc0luVGhlQm9keSA9IHhJbnNpZGUgJiYgeUluc2lkZTtcclxuXHJcbiAgICBpZiAoaXNJblRoZUJvZHkpIHtcclxuICAgICAgICBjb25zdCByaWdodERpc3QgPSByaWdodEJvcmRlciAtIGNvbm5lY3Rpb25Qb2ludC54O1xyXG4gICAgICAgIGNvbnN0IGxlZnREaXN0ID0gY29ubmVjdGlvblBvaW50LnggLSBsZWZ0Qm9yZGVyO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbURpc3QgPSBib3R0b21Cb3JkZXIgLSBjb25uZWN0aW9uUG9pbnQueTtcclxuICAgICAgICBjb25zdCB0b3BEaXN0ID0gY29ubmVjdGlvblBvaW50LnkgLSB0b3BCb3JkZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IG1pbkRpc3QgPSBNYXRoLm1pbihyaWdodERpc3QsIGxlZnREaXN0LCBib3R0b21EaXN0LCB0b3BEaXN0KTtcclxuXHJcbiAgICAgICAgaWYgKHJpZ2h0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KHJpZ2h0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0RGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KC1sZWZ0RGlzdCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0b3BEaXN0ID09PSBtaW5EaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQoMCwgLXRvcERpc3QpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRGlzdCA9PT0gbWluRGlzdCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uUG9pbnQub2Zmc2V0KDAsIGJvdHRvbURpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVmZXJlbmNlO1xyXG4gICAgdmFyIHNwb3RCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMuc291cmNlQkJveCA6IHRoaXMudGFyZ2V0QkJveDtcclxuICAgIGlmICghcmVmZXJlbmNlU2VsZWN0b3JPclBvaW50LmlkKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5wb2ludChyZWZlcmVuY2VTZWxlY3Rvck9yUG9pbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCByZWZlcmVuY2VCYm94ID0gZW5kID09PSAnc291cmNlJyA/IHRoaXMudGFyZ2V0QkJveCA6IHRoaXMuc291cmNlQkJveDtcclxuXHJcbiAgICAgICAgcmVmZXJlbmNlID0gZy5yZWN0KHJlZmVyZW5jZUJib3gpLmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQoZy5yZWN0KHNwb3RCYm94KS5jZW50ZXIoKSk7XHJcbiAgICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlIHx8IGcucmVjdChyZWZlcmVuY2VCYm94KS5jZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbGlnblggPSBNYXRoLmFicyhyZWZlcmVuY2UueCAtIGNvbm5lY3Rpb25Qb2ludC54KTtcclxuICAgIGNvbnN0IGFsaWduWSA9IE1hdGguYWJzKHJlZmVyZW5jZS55IC0gY29ubmVjdGlvblBvaW50LnkpO1xyXG5cclxuICAgIGNvbnN0IHJvdXRlcklkID0gdGhpcy5tb2RlbC5nZXQoJ3JvdXRlcicpICYmIHRoaXMubW9kZWwuZ2V0KCdyb3V0ZXInKS5uYW1lO1xyXG4gICAgY29uc3Qgc3BlY2lhbFJvdXRlciA9IHJvdXRlcklkICYmIChyb3V0ZXJJZCA9PT0gJ2xncm91dGVyJyB8fCByb3V0ZXJJZCA9PT0gJ21ldHJvJyk7XHJcbiAgICBpZiAodGhpcy5tb2RlbCBpbnN0YW5jZW9mIExpbmsgJiYgc3BlY2lhbFJvdXRlcikge1xyXG4gICAgICAgIGlmIChhbGlnblggPD0gYWxpZ25ZKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludC5vZmZzZXQocmVmZXJlbmNlLnggLSBjb25uZWN0aW9uUG9pbnQueCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Lm9mZnNldCgwLCByZWZlcmVuY2UueSAtIGNvbm5lY3Rpb25Qb2ludC55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdGlvblBvaW50ID0gZy5wb2ludCh7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueCksIHJpZ2h0Qm9yZGVyKSwgbGVmdEJvcmRlciksXHJcbiAgICAgICAgeTogTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5yb3VuZChjb25uZWN0aW9uUG9pbnQueSksIGJvdHRvbUJvcmRlciksIHRvcEJvcmRlciksXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29ubmVjdGlvblBvaW50O1xyXG59OyIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9kYXRhL3Jlc291cmNlUHJvdmlkZXInO1xyXG5pbXBvcnQgeyBaX0lOREVYRVMgfSBmcm9tICcuL2VsZW1lbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0xJTktfVFlQRSA9ICdsaW5lYWdlLWdyYW0tbGluayc7XHJcbmV4cG9ydCBjb25zdCBBTFdBWVNfVklTSUJMRV9UT09MX0JVVFRPTlM9ICdsZy12aXNpYmxlLXRvb2wtYnV0dG9ucyc7XHJcblxyXG4vKipcclxuICogTGlua01vZGVsIC0gZGF0YSBtb2RlbCBmb3IgYSB7QGxpbmsgTGlua30gb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBMaW5rIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIFRhcmdldCBOb2RlIGlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2UgLSBTb3VyY2UgTm9kZSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGlua3R5cGUgLSBUeXBlIG9mIHRoZSBMaW5rXHJcbiovXHJcblxyXG4vKipcclxuICogVGhlIGdyYXBoIExpbmsgY2xhc3Mgd2hpY2ggaXMgIGJhc2VkIG9uIGpvaW50LmRpYS5MaW5rLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyByZWxhdGlvbiBvZiB0aGUgcGFydHMgb2YgdGhlIGRhdGFzZXQuICBIYXMgc3BlY2lmaWMgdHlwZSBhbmQgaWQuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAYXVnbWVudHMgam9pbnQuZGlhLkxpbmtcclxuICogXHJcbiAqIEBwYXJhbSB7TGlua01vZGVsfSBkYXRhTW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtMaW5rTW9kZWx9IG1vZGVsIC0gRGF0YSBtb2RlbFxyXG4gKiBAcHJvcGVydHkge1Rlcm1pbmF0aW9uTGlua30gdGVybWluYXRpb25MaW5rIC0gVGVybWluYXRpb24gbGluayB3aGljaFxyXG4gKiByZXByZXNlbnRzIHRoaXMgbGluaywgd2hlbiB0aGUgbm9kZSBpcyBvdXQgb2YgdGhlIHZpZXdGcmFtZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnYmx1cmVkJykpXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBMaW5rIChkYXRhTW9kZWwsIHBhcmFtZXRlcnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MgPSBbXTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuYmx1cmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIGxldCBfbGlua1N0eWxlO1xyXG4gICAgbGV0IF90b29sTWFya3VwO1xyXG4gICAgaWYgKGRhdGFNb2RlbC5ncm91cCkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZWRUeXBlSWRzID0gW107XHJcbiAgICAgICAgY29uc3QgZ3JvdXBUb29scyA9IGRhdGFNb2RlbC5ncm91cFxyXG4gICAgICAgICAgICAuZmlsdGVyKG1vZGVsID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gZXhpc3RlZFR5cGVJZHMuaW5kZXhPZihtb2RlbC5saW5rVHlwZSkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RlZFR5cGVJZHMucHVzaChtb2RlbC5saW5rVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XHJcbiAgICAgICAgICAgIH0pLm1hcChtb2RlbCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbGlua1R5cGU6IG1vZGVsLmxpbmtUeXBlLFxyXG4gICAgICAgICAgICAgICAgbGlua1N0eWxlOiBfcmVzLmdldExpbmtTdHlsZShtb2RlbC5saW5rVHlwZSksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKGdyb3VwVG9vbHMubGVuZ3RoID09PSAxKSBfbGlua1N0eWxlID0gZ3JvdXBUb29sc1swXS5saW5rU3R5bGU7XHJcbiAgICAgICAgZWxzZSBfbGlua1N0eWxlID0gX3Jlcy5nZXRMaW5rU3R5bGUoZGF0YU1vZGVsLmxpbmtUeXBlKTsgXHJcbiAgICAgICAgX3Rvb2xNYXJrdXAgPSBfZ2V0VG9vbE1hcmt1cChncm91cFRvb2xzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2xpbmtTdHlsZSA9IF9yZXMuZ2V0TGlua1N0eWxlKGRhdGFNb2RlbC5saW5rVHlwZSk7IFxyXG4gICAgICAgIF90b29sTWFya3VwID0gX2dldFRvb2xNYXJrdXAoW3tcclxuICAgICAgICAgICAgbGlua1R5cGU6IGRhdGFNb2RlbC5saW5rVHlwZSxcclxuICAgICAgICAgICAgbGlua1N0eWxlOiBfbGlua1N0eWxlLFxyXG4gICAgICAgIH1dKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdHlwZXMgPSBbREVGQVVMVF9MSU5LX1RZUEVdO1xyXG4gICAgaWYgKF9saW5rU3R5bGUuY3NzQ2xhc3MgJiYgX2xpbmtTdHlsZS5jc3NDbGFzcyAhPT0gREVGQVVMVF9MSU5LX1RZUEUpIHtcclxuICAgICAgICB0eXBlcy5wdXNoKF9saW5rU3R5bGUuY3NzQ2xhc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfbGlua1N0eWxlLnRvb2xCdXR0b24uYWx3YXlzVmlzaWJsZSkge1xyXG4gICAgICAgIHR5cGVzLnB1c2goQUxXQVlTX1ZJU0lCTEVfVE9PTF9CVVRUT05TKTtcclxuICAgIH1cclxuXHJcbiAgICBqb2ludC5kaWEuTGluay5hcHBseShzZWxmLCBbe1xyXG4gICAgICAgIHR5cGU6IHR5cGVzLmpvaW4oJyAnKSxcclxuICAgICAgICBzb3VyY2U6IHsgaWQ6IGRhdGFNb2RlbC5zb3VyY2UsIHBvcnQ6ICdjbGlwUmVjdFBvcnQnIH0sXHJcbiAgICAgICAgdGFyZ2V0OiB7IGlkOiBkYXRhTW9kZWwudGFyZ2V0LCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5MSU5LLFxyXG4gICAgICAgIGF0dHJzOiBfZ2V0TGlua0F0dHJpYnV0ZXMoX2xpbmtTdHlsZSksXHJcbiAgICAgICAgY29ubmVjdG9yOiB7bmFtZTogJ3JvdW5kZWQnIH0sXHJcbiAgICAgICAgLy8gY29ubmVjdG9yOiB7IG5hbWU6ICdqdW1wb3ZlcicsIGFyZ3M6IHsgdHlwZTogJ2dhcCcgfX0sXHJcbiAgICAgICAgcm91dGVyOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRhdGFNb2RlbC5yb3V0aW5nLFxyXG4gICAgICAgICAgICBhcmdzOiB7XHJcbiAgICAgICAgICAgICAgICBleGNsdWRlVHlwZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAndmlld0ZyYW1lJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25MaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAndGVybWluYXRpb25Ob2RlJyxcclxuICAgICAgICAgICAgICAgICAgICAndmlldy1mcmFtZS1zcGxpdHRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZpZXctZnJhbWUtc3BsaXR0ZXItdmVydGljYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICdhc3BlY3RMaW5rJyxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtTG9vcHM6IDMwMDAsXHJcbiAgICAgICAgICAgICAgICBtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlOiAzMDAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9vbE1hcmt1cDogX3Rvb2xNYXJrdXAsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldExpbmtBdHRyaWJ1dGVzIChsaW5rU3R5bGUpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgYXR0cmlidXRlc1snLmNvbm5lY3Rpb24nXSA9IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IGxpbmtTdHlsZS5saW5lVHlwZSA9PT0gJ3NvbGlkJyA/IHVuZGVmaW5lZCA6ICc1LDUnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxpbmtTdHlsZS5oYXNBcnJvdykge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXNvdXJjZSddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTTAsM2EzLDMgMCAxLDAgNiwwYTMsMyAwIDEsMCAtNiwwJyxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBsaW5rU3R5bGUudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWycubWFya2VyLXRhcmdldCddID0ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogbGlua1N0eWxlLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5rU3R5bGUuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbGlua1N0eWxlLnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldFRvb2xNYXJrdXAgKGxpbmtUb29scykge1xyXG4gICAgICAgIHJldHVybiBsaW5rVG9vbHMubWFwKGxpbmtUb29sID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlua1R5cGVJZCA9IGxpbmtUb29sLmxpbmtUeXBlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sID0gbGlua1Rvb2wubGlua1N0eWxlLnRvb2xCdXR0b247XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdG9vbC53aWR0aCB8fCAzMDtcclxuICAgICAgICAgICAgY29uc3QgaGllZ2h0ID0gdG9vbC5oaWVnaHQgfHwgMzA7XHJcbiAgICAgICAgICAgIHJldHVybiBgPGcgY2xhc3M9XCJsaW5rLXRvb2xcIj5cclxuICAgICAgICAgICAgICAgIDxnIGNsYXNzPVwidG9vbC1vcHRpb25zXCIgZXZlbnQ9XCJsaW5rOm9wdGlvbnNcIiBsaW5rVHlwZT1cIiR7bGlua1R5cGVJZH1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke3dpZHRofVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7aGllZ2h0fVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg9XCItJHt3aWR0aC8yfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk9XCItJHtoaWVnaHQvMn1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bGluazpocmVmPVwiJHt0b29sLmltYWdlfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3I9XCJ0aGlzLnNldEF0dHJpYnV0ZSggJ3hsaW5rOmhyZWYnLCAnJHtfcmVzLmdldEltYWdlKCdkZWZhdWx0LWxpbmstb3B0aW9ucycpfScgKTtcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRpdGxlPk9wZW4gZGVyaXZhdGlvbiBtYXAke2xpbmtUeXBlSWQgPyAnIGZvciAnICsgbGlua1R5cGVJZCA6ICcnfTwvdGl0bGU+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgIDwvZz5gO1xyXG4gICAgICAgIH0pLmpvaW4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlIGxpbmsgaXMgY3VycmVudGx5XHJcbiAgICAgKiBvbiB0aGUgZ3JhcGggKGluIHRoZSBhbnkgb2YgdmlldyBmcmFtZXMpIG9yIG5vdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlbmF9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuaXNPblRoZUdyYXBoID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoc2VsZi5ncmFwaCA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2JsdXJlZCcpKSBzZWxmLnVuYmx1cmUoKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGRlbicpKSBzZWxmLnNob3coKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuYmx1cmUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5CTFVSRURfTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIExpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRlcm1pbmF0aW9uTGlua3MuZm9yRWFjaCh0bCA9PiB0bC51bmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuTElOSyB9KTtcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBMaW5rLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbkxpbmtzLmZvckVhY2godGwgPT4gdGwuaGlkZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgTGluay5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25MaW5rcy5mb3JFYWNoKHRsID0+IHRsLnNob3codHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbn1cclxuTGluay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LmRpYS5MaW5rLnByb3RvdHlwZSk7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IExBQkVMX0xFRlRfUklHSFRfUEFERElORyA9IDU7XHJcbmV4cG9ydCBjb25zdCBMQUJFTF9UT1BfQk9UVE9NX1BBRERJTkcgPSAxMDtcclxuZXhwb3J0IGNvbnN0IExBQkVMX0xJTkVfSEVJR0hUID0gMjA7XHJcbmV4cG9ydCBjb25zdCBCT0RZX1BBRERJTkcgPSAyNTtcclxuZXhwb3J0IGNvbnN0IElNR19QQURESU5HID0gMTA7XHJcbmV4cG9ydCBjb25zdCBGT05UX1NJWkUgPSAxNjtcclxuZXhwb3J0IGNvbnN0IEVYUEFOREVEX05PREVfR1JPV0lORyA9IDEuNTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlTW9kZWwgLSBkYXRhIG1vZGVsIGZvciBhIHtAbGluayBOb2RlfSBvYmplY3RcclxuICogQHR5cGVkZWYge09iamVjdH0gTm9kZU1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZCAtIE5vZGUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBUaXRsZSBvZiB0aGUgTm9kZSxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpZXdGcmFtZSAtIElkIG9mIFZpZXdGcmFtZSB3aWNoIHdpbGwgaW5jbHVkZSB0aGlzIG5vZGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVJZCAtIFR5cGUgaWRlbnRpZnllclxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBncmFwaCBOb2RlIGNsYXNzIHdoaWNoIGlzIGJhc2VkIG9uIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljLiBJcyB0aGUgb25lIG9mIHRoZSBtYWluIGVsZW1lbnRzIG9mIHRoZSBMaW5lYWdlRnJhbS5cclxuICogUmVwcmVzZW50cyBleGlzdGluZyBwYXJ0IG9mIHRoZSBkYXRhc2V0IHdpdGggc3BlY2lmaWVkIGltYWdlLCBjb2xvciwgdHlwZSBhbmQgaWQgYW5kIHBsYWNlZCBpbiBzZXBhcmF0ZWQgVmlld0ZyYW1lLlxyXG4gKiBAY2xhc3NcclxuICogQHByaXZhdGVcclxuICogQGF1Z21lbnRzIGpvaW50LnNoYXBlcy5iYXNpYy5HZW5lcmljXHJcbiAqIEBwYXJhbSB7Tm9kZU1vZGVsfSBkYXRhTW9kZWwgLSBNb2RlbCBvZiBncmFwaCBub2RlXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBcclxuICogQHByb3BlcnR5IHtOb2RlW119IGFzcGVjdHMgLSBDb3BpZXMgb2YgdGhpcyBub2RlIGluIG90aGVyIGZyYW1lc1xyXG4gKiBAcHJvcGVydHkge05vZGVNb2RlbH0gbW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7VGVybWluYXRpb25Ob2RlW119IHRlcm1pbmF0aW9uTm9kZXMgLSBUZXJtaW5hdGlvbiBub2RlcyB3aGljaCBleGlzdHMgb24gaW4gdGhlIGZyYW1lXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlnaGxpZ2h0ZWQgLSBUZWxscyB3aGV0ZXIgaGlnaGxpZ2h0ZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdoaWdobGlnaHRlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJsdXJlZCAtIFRlbGxzIHdoZXRlciBibHVyZWQgbm9kZSBvciBub3QgKHVzZSBtZXRob2QgZ2V0IHRvIGdldCB0aGlzIHByb3BlcnR5LCBlLmcuIG5vZGUuZ2V0KCdibHVyZWQnKSlcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWV9IHZpZXdGcmFtZU93bmVySWQgLSBFeGlzdHMgb25seSBpZiBlbGVtZW50IHdhcyBkcmFnZ2VkIGZyb20gb25lIHRvIGFub3RoZXIgZnJhbWVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBkcmFnZ2VkIC0gSWYgc29tZWJvZHkgaXMgZHJhZ2dpbmcgdGhpcyBOb2RlIG5vdywgdGhlbiB0cnVlLlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gTm9kZSAoZGF0YU1vZGVsLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IF9zaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGNvbnN0IF9yZXMgPSBuZXcgUmVzb3VyY2VQcm92aWRlcihwYXJhbWV0ZXJzKTtcclxuICAgIFxyXG4gICAgbGV0IF9pc1ZlcnRpY2FsT3JpZW50ZWQgPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJyB8fFxyXG4gICAgICAgIHBhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG5cclxuICAgIHNlbGYubW9kZWwgPSBkYXRhTW9kZWw7XHJcbiAgICBzZWxmLnRlcm1pbmF0aW9uTm9kZXMgPSBbXTtcclxuICAgIHNlbGYuYXNwZWN0cyA9IFtdO1xyXG4gICAgc2VsZi52aWV3RnJhbWVPd25lcklkID0gbnVsbDtcclxuICAgIHNlbGYuZHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuc2l6ZSA9IHsgd2lkdGg6IF9zaXplLndpZHRoLCBoZWlnaHQ6IF9zaXplLmhlaWdodCwgbWF4V2lkdGg6IF9zaXplLndpZHRoLCBtYXhIZWlnaHQ6IF9zaXplLmhlaWdodCB9O1xyXG4gICAgc2VsZi5jb2xsYXBzZWRTaXplID0gc2VsZi5zaXplO1xyXG5cclxuICAgIFxyXG4gICAgXHJcbiAgICBjb25zdCBpbWFnZSA9IF9yZXMuZ2V0SW1hZ2UoZGF0YU1vZGVsLnR5cGVJZCk7XHJcblxyXG4gICAgY29uc3QgSUQgPSB1bmlxdWVJZCgnTm9kZScpO1xyXG4gICAgam9pbnQuc2hhcGVzLmJhc2ljLkdlbmVyaWMuYXBwbHkoc2VsZiwgW3tcclxuICAgICAgICB0eXBlOiAnbGluZWFnZS1ncmFtLW5vZGUnLFxyXG4gICAgICAgIGlkOiBJRCxcclxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICAgICAgbWFya3VwOiBgPGcgY2xhc3M9XCJyb3RhdGFibGVcIiBjbGlwLXBhdGg9XCJ1cmwoJHsnIycgKyBJRCArICdfY2xpcFBhdGgnfSlcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZyBjbGFzcz1cInNjYWxhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJ0cS1sZy1ib2R5XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbWFnZSBjbGFzcz1cInNjYWxhYmxlXCIgb25lcnJvcj1cInRoaXMuc2V0QXR0cmlidXRlKCAneGxpbms6aHJlZicsICcke19yZXMuZ2V0SW1hZ2UoKX0nICk7XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwibGFiZWxcIi8+XHJcbiAgICAgICAgICAgICAgICA8L2c+XHJcbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICAgICAgPGNsaXBQYXRoIGlkPVwiJHtJRCArICdfY2xpcFBhdGgnfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImNsaXBSZWN0XCI+PC9yZWN0PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvY2xpcFBhdGg+XHJcbiAgICAgICAgICAgICAgICA8L2RlZnM+YCxcclxuICAgICAgICBzaXplOiBzZWxmLnNpemUsXHJcbiAgICAgICAgYXR0cnM6IHtcclxuICAgICAgICAgICAgJ2NpcmNsZSc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICByOiAxLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLmNsaXBSZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgcG9ydDogJ2NsaXBSZWN0UG9ydCcsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcuYm9keSc6IHtcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIHJ4OiA1LFxyXG4gICAgICAgICAgICAgICAgcnk6IDUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubGFiZWwnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBfcmVzLmdldENvbG9yKCd0ZXh0JyksXHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogRk9OVF9TSVpFLFxyXG4gICAgICAgICAgICAgICAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdoYW5naW5nJyxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHNlbGYubW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLnRxLWxnLWJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiAuNSxcclxuICAgICAgICAgICAgICAgICd4LWFsaWdubWVudCc6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICByeDogNSxcclxuICAgICAgICAgICAgICAgIHJ5OiA1LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBfcmVzLmdldENvbG9yKGRhdGFNb2RlbC50eXBlSWQpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbWFnZToge1xyXG4gICAgICAgICAgICAgICAgJ3hsaW5rOmhyZWYnOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICdyZWYteCc6IC41LFxyXG4gICAgICAgICAgICAgICAgcmVmOiAnLmJvZHknLFxyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICAneS1hbGlnbm1lbnQnOiAndG9wJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy5sYWJlbCB0c3Bhbic6IHtcclxuICAgICAgICAgICAgICAgIGR5OiBMQUJFTF9MSU5FX0hFSUdIVCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLk5PREUsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8vdHJpZ2dlciBleHBhbmRlZCBiZWZvcmUgYXR0YWNoaW5nIHRoZSBldmVudHNcclxuICAgIHNlbGYuc2V0KCdleHBhbmRlZCcsIHRydWUpO1xyXG5cclxuICAgIGxldCBfYmxvY2tTdWJzY3JpcHRpb24gPSBmYWxzZTtcclxuICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gc2VsZi5wb3NpdGlvbjtcclxuXHJcbiAgICBzZWxmLnBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICBfYmxvY2tTdWJzY3JpcHRpb24gPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9sZFBvc2l0aW9uLmNhbGwoc2VsZiwgeCwgeSk7XHJcbiAgICAgICAgX2Jsb2NrU3Vic2NyaXB0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5vbignY2hhbmdlOnBvc2l0aW9uJywgKCkgPT4ge1xyXG4gICAgICAgIGlmIChfYmxvY2tTdWJzY3JpcHRpb24pIHJldHVybjtcclxuICAgICAgICBzZWxmLnNldENsaXBwaW5nKHVuZGVmaW5lZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6c2l6ZScsIChjZWxsLCBzaXplKSA9PiB7XHJcbiAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgJy5jbGlwUmVjdCc6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgc2VsZi5vbignY2hhbmdlOmV4cGFuZGVkJywgKCkgPT4ge1xyXG4gICAgICAgIF9yZWZyZXNoU2l6ZShzZWxmLmNvbGxhcHNlZFNpemUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIF9yZWZyZXNoU2l6ZShzZWxmLnNpemUpO1xyXG5cclxuICAgIHNlbGYuc2V0U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBzZWxmLmNvbGxhcHNlZFNpemUud2lkdGggIT09IHNpemUud2lkdGggfHxcclxuICAgICAgICAgICAgc2VsZi5jb2xsYXBzZWRTaXplLmhlaWdodCAhPT0gc2l6ZS5oZWlnaHQgfHxcclxuICAgICAgICAgICAgc2VsZi5zaXplLm1heFdpZHRoICE9PSBzaXplLm1heFdpZHRoIHx8XHJcbiAgICAgICAgICAgIHNlbGYuc2l6ZS5tYXhIZWlnaHQgIT09IHNpemUubWF4SGVpZ2h0XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIF9yZWZyZXNoU2l6ZShzaXplKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICBfaXNWZXJ0aWNhbE9yaWVudGVkID0gb3JpZW50YXRpb24gPT09ICd0b3AtdG8tYm90dG9tJyB8fCBvcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlIG5vZGUgaXMgY3VycmVudGx5XHJcbiAgICAgKiBvbiB0aGUgZ3JhcGggKGluIHRoZSBhbnkgb2YgdmlldyBmcmFtZXMpIG9yIG5vdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlbmF9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuaXNPblRoZUdyYXBoID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoc2VsZi5ncmFwaCA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgY29uc3QgY2FsY3VsYXRpb25zID0gX2NhbGN1bGF0ZU5vZGUoc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2lkdGg6IGNhbGN1bGF0aW9ucy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBjYWxjdWxhdGlvbnMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogY2FsY3VsYXRpb25zLm1heFdpZHRoLFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IGNhbGN1bGF0aW9ucy5tYXhIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZ2hsaWdodHMgdGhlIE5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBOb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25Ob2Rlcy5mb3JFYWNoKHRuID0+IHRuLnNlbGVjdCh0cnVlKSk7XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLmFzcGVjdHMuZm9yRWFjaChhID0+IGEuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2JsdXJlZCcpKSBzZWxmLnVuYmx1cmUoKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGRlbicpKSBzZWxmLnNob3coKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBOb2RlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25Ob2Rlcy5mb3JFYWNoKHRuID0+IHRuLnVuc2VsZWN0KHRydWUpKTtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYuYXNwZWN0cy5mb3JFYWNoKGEgPT4gYS51bnNlbGVjdCh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLk5PREUgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJsdXJzIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmJsdXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlnaGxpZ2h0ZWQnKSkgcmV0dXJuO1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25Ob2Rlcy5mb3JFYWNoKHRuID0+IHRuLmJsdXJlKHRydWUpKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX05PREUgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYmx1ciBmcm9tIHRoZSBOb2RlLlxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuYmx1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi50ZXJtaW5hdGlvbk5vZGVzLmZvckVhY2godG4gPT4gdG4udW5ibHVyZSh0cnVlKSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLk5PREUgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgTm9kZS5cclxuICAgICAqIEBtZW1iZXJvZiBOb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25Ob2Rlcy5mb3JFYWNoKHRuID0+IHRuLmhpZGUodHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgTm9kZS5cclxuICAgICAqIEBtZW1iZXJvZiBOb2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudGVybWluYXRpb25Ob2Rlcy5mb3JFYWNoKHRuID0+IHRuLnNob3codHJ1ZSkpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3JlZnJlc2gtaGlnaGxpZ2h0aW5nJywgc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvZmZzZXQgYW5kIHNpemUgb2YgY2xpcHBpbmcgcmVjdGFuZ2xlLlxyXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBPZmZzZXQgb2YgdGhlIGNsaXBwaW5nIHJlY3RhbmdsZVxyXG4gICAgICogQG1lbWJlcm9mIE5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNldENsaXBwaW5nID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgeCA9IChwb2ludC54ID4gMCA/IHBvaW50LnggOiAwKTtcclxuICAgICAgICBjb25zdCB5ID0gKHBvaW50LnkgPiAwID8gcG9pbnQueSA6IDApO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gc2VsZi5zaXplLndpZHRoIC0gTWF0aC5hYnMocG9pbnQueCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc2VsZi5zaXplLmhlaWdodCAtIE1hdGguYWJzKHBvaW50LnkpO1xyXG5cclxuICAgICAgICBzZWxmLmF0dHIoe1xyXG4gICAgICAgICAgICAnLmNsaXBSZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPiAwID8gd2lkdGggOiAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPiAwID8gaGVpZ2h0IDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX3JlZnJlc2hTaXplIChzaXplKSB7XHJcbiAgICAgICAgLy8gc2VsZi5jb2xsYXBzZWRTaXplID0gc2l6ZTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FsY3VsYXRpb25zID0gX2NhbGN1bGF0ZU5vZGUoc2l6ZSk7XHJcbiAgICAgICAgc2VsZi5zaXplID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogY2FsY3VsYXRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0aW9ucy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiBjYWxjdWxhdGlvbnMubWF4V2lkdGgsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogY2FsY3VsYXRpb25zLm1heEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBjYWxjdWxhdGlvbnMuc2NhbGU7XHJcbiAgICAgICAgY29uc3QgYm9keVBhZGRpbmcgPSBCT0RZX1BBRERJTkcgKiBzY2FsZTtcclxuICAgICAgICBjb25zdCB0b3BCb3R0b21QYWRkaW5nID0gTEFCRUxfVE9QX0JPVFRPTV9QQURESU5HICogc2NhbGU7XHJcbiAgICAgICAgY29uc3QgbGFiZWxMaW5lSGVpZ2h0ID0gTEFCRUxfTElORV9IRUlHSFQgKiBzY2FsZTtcclxuXHJcbiAgICAgICAgc2VsZi5hdHRyKHtcclxuICAgICAgICAgICAgJy50cS1sZy1ib2R5Jzoge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNhbGN1bGF0aW9ucy5yZWN0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0aW9ucy5yZWN0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgJ3JlZi15JzogYm9keVBhZGRpbmcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGltYWdlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoMCwgY2FsY3VsYXRpb25zLnJlY3RXaWR0aCAtIElNR19QQURESU5HICogMiksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGNhbGN1bGF0aW9ucy5yZWN0SGVpZ2h0IC0gSU1HX1BBRERJTkcgKiAyKSxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IGJvZHlQYWRkaW5nICsgSU1HX1BBRERJTkcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubGFiZWwnOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYWxjdWxhdGlvbnMubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiBib2R5UGFkZGluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wQm90dG9tUGFkZGluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLnJlY3RIZWlnaHQgK1xyXG4gICAgICAgICAgICAgICAgICAgIEZPTlRfU0laRSAqIHNjYWxlIC1cclxuICAgICAgICAgICAgICAgICAgICBsYWJlbExpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubGFiZWwgdHNwYW4nOiB7XHJcbiAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogRk9OVF9TSVpFICogc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBkeTogbGFiZWxMaW5lSGVpZ2h0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnJlc2l6ZShzZWxmLnNpemUud2lkdGgsIHNlbGYuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIHNlbGYuc2V0KCdzaG9ydC1sYWJlbCcsIGNhbGN1bGF0aW9ucy5zaG9ydExhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgX2NhdGNoZWRSZXN1bHQgPSBudWxsO1xyXG4gICAgZnVuY3Rpb24gX2NhbGN1bGF0ZU5vZGUgKHNpemUpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0ICYmXHJcbiAgICAgICAgICAgIF9jYXRjaGVkUmVzdWx0LmluU2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5pblNpemUuaGVpZ2h0ID09PSBzaXplLmhlaWdodCAmJlxyXG4gICAgICAgICAgICBfY2F0Y2hlZFJlc3VsdC5pblNpemUubWF4V2lkdGggPT09IHNpemUubWF4V2lkdGggJiZcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQuaW5TaXplLm1heEhlaWdodCA9PT0gc2l6ZS5tYXhIZWlnaHQgJiZcclxuICAgICAgICAgICAgX2NhdGNoZWRSZXN1bHQuZXhwYW5kZWQgPT09IHNlbGYuZ2V0KCdleHBhbmRlZCcpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfY2F0Y2hlZFJlc3VsdC5vdXRTaXplO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHdpZHRoO1xyXG4gICAgICAgIGxldCBoZWlnaHQ7XHJcbiAgICAgICAgaWYgKCFzZWxmLmdldCgnZXhwYW5kZWQnKSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oc2l6ZS5tYXhXaWR0aCwgc2l6ZS53aWR0aCAqIEVYUEFOREVEX05PREVfR1JPV0lORyk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKHNpemUubWF4SGVpZ2h0LCBzaXplLmhlaWdodCAqIEVYUEFOREVEX05PREVfR1JPV0lORyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4U2NhbGUgPSBzaXplLndpZHRoIC8gcGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aDsgXHJcbiAgICAgICAgY29uc3QgeVNjYWxlID0gc2l6ZS5oZWlnaHQgLyBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodDsgXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbih4U2NhbGUsIHlTY2FsZSk7XHJcbiAgICAgICAgY29uc3QgYm9keVBhZGRpbmcgPSBCT0RZX1BBRERJTkcgKiBzY2FsZTtcclxuICAgICAgICBjb25zdCBsYWJlbExpbmVIZWlnaHQgPSBMQUJFTF9MSU5FX0hFSUdIVCAqIHNjYWxlO1xyXG5cclxuICAgICAgICBsZXQgY2FsY3VsYXRpb25zID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogc2l6ZS5tYXhXaWR0aCxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBzaXplLm1heEhlaWdodCxcclxuICAgICAgICAgICAgcmVjdFdpZHRoOiB3aWR0aCAtIGJvZHlQYWRkaW5nICogMixcclxuICAgICAgICAgICAgcmVjdEhlaWdodDogaGVpZ2h0IC0gYm9keVBhZGRpbmcgKiAyLFxyXG4gICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgIHNob3J0TGFiZWw6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChzZWxmLm1vZGVsLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5oZWlnaHQgLT0gYm9keVBhZGRpbmc7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IEZPTlRfU0laRSAqIHNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0UmlnaHRQYWRkaW5nID0gTEFCRUxfTEVGVF9SSUdIVF9QQURESU5HICogc2NhbGUgKiAyO1xyXG4gICAgICAgICAgICBjb25zdCB0b3BCb3R0b21QYWRkaW5nID0gTEFCRUxfVE9QX0JPVFRPTV9QQURESU5HICogc2NhbGUgKiAyO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxhYmVsID0gX2JyZWFrVGV4dEJ5TGluZXMoXHJcbiAgICAgICAgICAgICAgICBzZWxmLm1vZGVsLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGggLSBsZWZ0UmlnaHRQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsYWJlbEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBzdWJzdHJpbmdzID0gbGFiZWwuc3BsaXQoJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN1YnN0cmluZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1heFJvd0NvdW50ID0gKF9pc1ZlcnRpY2FsT3JpZW50ZWQgPyAyIDogMykgKyAoc2VsZi5nZXQoJ2V4cGFuZGVkJykgPyAxIDogMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN1YnN0cmluZ3MubGVuZ3RoID4gbWF4Um93Q291bnQpIGNhbGN1bGF0aW9ucy5zaG9ydExhYmVsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzdWJzdHJpbmdzID0gc3Vic3RyaW5ncy5zbGljZSgwLCBtYXhSb3dDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChfaXNWZXJ0aWNhbE9yaWVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxMYWJlbCA9IHN1YnN0cmluZ3Muam9pbignICcpICsgKGNhbGN1bGF0aW9ucy5zaG9ydExhYmVsID8gJy4uLicgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IF9nZXRUZXh0V2lkdGgoZmluYWxMYWJlbCwgZm9udFNpemUgKyAncHggc2Fucy1zZXJpZicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW9ucy53aWR0aCA9IGxhYmVsV2lkdGggKyBsZWZ0UmlnaHRQYWRkaW5nICogc3Vic3RyaW5ncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLmxhYmVsID0gZmluYWxMYWJlbDtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEhlaWdodCA9IGZvbnRTaXplICsgdG9wQm90dG9tUGFkZGluZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIGR5IHByb3BlcnR5IGZvciBlYWNoIGxpbmUgdGhhdCdzIHdoeSBmb250LXNpemUgZ29lcyBvbmx5IG9uZSB0aW1lIGludG8gYWNvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgZHggaXMgZGlzdGFuY2UgYmV0d2VlbiB0b3AgbGluZXMgb2YgZWFjaCB0ZXh0IGxpbmUuIEFuZCBmb3IgYSBmdWxsIHRleHQgaGVpZ2h0IHdlIGFkZCBmb250IHNpemUgb2YgbHVzdCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gKGZvbnRTaXplKSArIHRvcEJvdHRvbVBhZGRpbmcgKyAoc3Vic3RyaW5ncy5sZW5ndGggLSAxKSAqIChsYWJlbExpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5sYWJlbCA9IHN1YnN0cmluZ3Muam9pbignXFxuJykgKyAoY2FsY3VsYXRpb25zLnNob3J0TGFiZWwgPyAnLi4uJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gKGZvbnRTaXplKSArIHRvcEJvdHRvbVBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbnMubGFiZWwgPSBzZWxmLm1vZGVsLmxhYmVsO1xyXG4gICAgICAgICAgICB9IFxyXG5cclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmhlaWdodCArPSBsYWJlbEhlaWdodDtcclxuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmxhYmVsSGVpZ2h0ID0gbGFiZWxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5leHBhbmRlZCA9IHNlbGYuZ2V0KCdleHBhbmRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfY2F0Y2hlZFJlc3VsdCA9IHtcclxuICAgICAgICAgICAgaW5TaXplOiBzaXplLFxyXG4gICAgICAgICAgICBvdXRTaXplOiBjYWxjdWxhdGlvbnMsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBjYWxjdWxhdGlvbnMuZXhwYW5kZWQsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfYnJlYWtUZXh0QnlMaW5lcyAoXHJcbiAgICAgICAgbGFiZWwsIHdpZHRoLCBmb250U2l6ZSxcclxuICAgICkge1xyXG4gICAgICAgIGNvbnN0IGJyb2tlblRleHQgPSBqb2ludC51dGlsLmJyZWFrVGV4dChsYWJlbCwge1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgfSwgeyAnZm9udC1zaXplJzogZm9udFNpemUgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gYnJva2VuVGV4dC5zcGxpdCgnXFxuJyk7XHJcblxyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBNSU5fQ0hBUkFDVEVSX05VTUJFUiA9IDQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkLmxlbmd0aCA8IE1JTl9DSEFSQUNURVJfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gTUlOX0NIQVJBQ1RFUl9OVU1CRVIgLSBsYXN0Q2hpbGQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkID0gbGluZXMubGVuZ3RoIC0gKGRpZmYgKyAxKTtcclxuICAgICAgICAgICAgICAgIC8vIG1heCBlcnJvciBpcyAzIGV4dHJhIGxldHRlcnMsIHNvIEkgaG9wZSBpdCdzIE9LLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZTdGVhbGVkTm9kZXMgPSBNYXRoLnJvdW5kKGRpZmYgLyBNYXRoLm1pbihkaWZmLCBsaW5lcy5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBwcmV2UmVzdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lcyA9IGxpbmVzLm1hcCgobGluZSwgaW5kZXgsIGFycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMYXN0TGluZSA9IGluZGV4ID09PSAoYXJyLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGluZSA9IHByZXZSZXN0ICsgbGluZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG51bWJlck9mU3RlYWxlZE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYXN0TGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlJlc3QgPSBmdWxsTGluZS5zdWJzdHJpbmcoZnVsbExpbmUubGVuZ3RoIC0gb2Zmc2V0LCBmdWxsTGluZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxMaW5lLnN1YnN0cmluZygwLCBmdWxsTGluZS5sZW5ndGggLSBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0xpbmVzLmpvaW4oJ1xcbicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb2tlblRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIFVwZGF0ZSBzaXplIG9mIGVsZW1lbnQuIFRha2VzIGNvbGxhcHNlZCBzaXplLFxyXG4gICAgICogYW5kIGlmIGVsZW1lbnQgYXJlIGV4cGFuZGVkIHRyeWluZyB0byBzZXQgYSB0d2lzZSBzaXplLlxyXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplIFxyXG4gICAgKi9cclxuICAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFRleHRXaWR0aCAodGV4dCwgZm9udCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IF9nZXRUZXh0V2lkdGguY2FudmFzIHx8IChfZ2V0VGV4dFdpZHRoLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xyXG4gICAgICAgIHJldHVybiBtZXRyaWNzLndpZHRoO1xyXG4gICAgfVxyXG59XHJcblxyXG5Ob2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuc2hhcGVzLmRldnMuTW9kZWwucHJvdG90eXBlKTtcclxuIiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuaW1wb3J0IHsgUmVzb3VyY2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZWxlbWVudHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFRlcm1pbmF0aW9uTGlua09wdGlvbnMgLSBvcHRpb25zIGZvciBUZXJtaW5hdGlvbkxpbmsgb2JqZWN0XHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRlcm1pbmF0aW9uTGlua09wdGlvbnNcclxuICogQHByb3BlcnR5IHtMaW5rfSBsaW5rIC0gT3JpZ2luYWwgbGlua1xyXG4gKiBAcHJvcGVydHkge05vZGV9IHRhcmdldCAtIFRhcmdldCBOb2RlXHJcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gc291cmNlIC0gU291cmNlIE5vZGVcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBTaW1wbGVMaW5rTW9kZWwgLSBkYXRhIG1vZGVsIG9mIGEgVGVybWluYXRpb25MaW5rIG9iamVjdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW1wbGVMaW5rTW9kZWwgLSBEYXRhIG1vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXQgLSBUYXJnZXQgTm9kZSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIC0gU291cmNlIE5vZGUgaWRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBUaGUgZ3JhcGggTGluayBiYXNlZCBvbiBqb2ludC5kaWEuTGluay5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBqb2ludC5kaWEuTGlua1xyXG4gKiBcclxuICogQHBhcmFtIHtUZXJtaW5hdGlvbkxpbmtPcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgVGVybWluYXRpb25MaW5rIG9iamVjdFxyXG4gKiBAcGFyYW0ge1BhcmFtZXRlcnN9IHBhcmFtZXRlcnMgLSB0aGUgc2V0IG9mIHBhcmFtZXRlcnNcclxuICogXHJcbiAqIEBwcm9wZXJ0eSB7TGlua30gb3JpZ2luYWxMaW5rIC0gT3JpZ2luYWwgTGluayAtIHRoZSBsaW5rIHRvIGEgbm9kZSB3aGljaCBpcyBvdXQgb2YgdGhlIFZpZXdGcm1hZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpZ2hsaWdodGVkIC0gVGVsbHMgd2hldGVyIGhpZ2hsaWdodGVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnaGlnaGxpZ2h0ZWQnKSlcclxuICogQHByb3BlcnR5IHtib29sZWFufSBibHVyZWQgLSBUZWxscyB3aGV0ZXIgYmx1cmVkIGxpbmsgb3Igbm90ICh1c2UgbWV0aG9kIGdldCB0byBnZXQgdGhpcyBwcm9wZXJ0eSwgZS5nLiBsaW5rLmdldCgnYmx1cmVkJykpXHJcbiAqIEBwcm9wZXJ0eSB7U2ltcGxlTGlua01vZGVsfSBtb2RlbCAtIERhdGEgbW9kZWwgXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBUZXJtaW5hdGlvbkxpbmsgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHNlbGYub3JpZ2luYWxMaW5rID0gb3B0aW9ucy5saW5rO1xyXG4gICAgc2VsZi5oaWdobGlnaHRlZCA9IGZhbHNlO1xyXG4gICAgc2VsZi5ibHVyZWQgPSBmYWxzZTtcclxuICAgIHNlbGYub3JpZ2luYWxMaW5rLnRlcm1pbmF0aW9uTGlua3MucHVzaChzZWxmKTtcclxuXHJcbiAgICBjb25zdCBzb3VyY2UgPSB7IGlkOiBvcHRpb25zLnNvdXJjZS5pZCwgcG9ydDogJ2NsaXBSZWN0UG9ydCcgfTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHsgaWQ6IG9wdGlvbnMudGFyZ2V0LmlkLCBwb3J0OiAnY2xpcFJlY3RQb3J0JyB9O1xyXG5cclxuICAgIGNvbnN0IGxpbmtDb2xvciA9IF9yZXMuZ2V0Q29sb3IoJ3Rlcm1pbmF0aW9uTGluaycpO1xyXG5cclxuICAgIGpvaW50LmRpYS5MaW5rLmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgdHlwZTogJ3Rlcm1pbmF0aW9uLWxpbmsnLFxyXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgIHo6IFpfSU5ERVhFUy5URVJNSU5BVElPTl9FTEVNRU5ULFxyXG4gICAgICAgIGF0dHJzOiB7XHJcbiAgICAgICAgICAgICcuY29ubmVjdGlvbic6IHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMubGlua1RoaWNrbmVzcyAqICgxICsgKHNlbGYub3JpZ2luYWxMaW5rLm1vZGVsLnRoaWNrbmVzcyB8fCAwKSksXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICc1LDUnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLm1hcmtlci1zb3VyY2UnOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBsaW5rQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBwYXJhbWV0ZXJzLmxpbmtUaGlja25lc3MgKiAoMSArIChzZWxmLm9yaWdpbmFsTGluay5tb2RlbC50aGlja25lc3MgfHwgMCkpLFxyXG4gICAgICAgICAgICAgICAgZDogJ00wLDNhMywzIDAgMSwwIDYsMGEzLDMgMCAxLDAgLTYsMCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubWFya2VyLXRhcmdldCc6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IGxpbmtDb2xvcixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGlua0NvbG9yLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMubGlua1RoaWNrbmVzcyAqICgxICsgKHNlbGYub3JpZ2luYWxMaW5rLm1vZGVsLnRoaWNrbmVzcyB8fCAwKSksXHJcbiAgICAgICAgICAgICAgICBkOiAnTSAxMCAwIEwgMCA1IEwgMTAgMTAgeicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb25uZWN0b3I6IHtuYW1lOiAncm91bmRlZCcgfSxcclxuICAgIH1dKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZ2hsaWdodHMgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuc2VsZWN0ID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYub3JpZ2luYWxMaW5rLnNlbGVjdCh0cnVlKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2JsdXJlZCcpKSBzZWxmLnVuYmx1cmUoKTtcclxuICAgICAgICBpZiAoc2VsZi5nZXQoJ2hpZGRlbicpKSBzZWxmLnNob3coKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuU0VMRUNURURfRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBoaWdobGlnaHRpbmcgZnJvbSB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bnNlbGVjdCA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKCFvbmNlKSBzZWxmLm9yaWdpbmFsTGluay51bnNlbGVjdCh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuVEVSTUlOQVRJT05fRUxFTUVOVCB9KTtcclxuICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmx1cnMgdGhlIFRlcm1pbmF0aW9uTGluay5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuYmx1cmUgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlnaGxpZ2h0ZWQnKSkgcmV0dXJuO1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuYmx1cmUodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLkJMVVJFRF9MSU5LIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGJsdXIgZnJvbSB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi51bmJsdXJlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYub3JpZ2luYWxMaW5rLnVuYmx1cmUodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5wcm9wKHsgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQgfSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgVGVybWluYXRpb25MaW5rLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoIW9uY2UpIHNlbGYub3JpZ2luYWxMaW5rLmhpZGUodHJ1ZSk7XHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmICghb25jZSkgc2VsZi5vcmlnaW5hbExpbmsuc2hvdyh0cnVlKTtcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBoaWdobGlnaHRlcnMgb2YgdGhlIHZpZXcgb2YgdGhpcyBlbGVtZW50LlxyXG4gICAgICogQG1lbWJlcm9mIExpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnJlZnJlc2hIaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N5bmNocm9uaXplV2l0aE9yaWdpbigpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVmcmVzaC1oaWdobGlnaHRpbmcnLCBzZWxmKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCBoaWdobGlnaHRpbmcgZm9yIHRoZSBUZXJtaW5hdGlvbkxpbmsuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25MaW5rXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3N5bmNocm9uaXplV2l0aE9yaWdpbiAoKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxMaW5rLmdldCgnaGlnaGxpZ2h0ZWQnKSkge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnaGlnaGxpZ2h0ZWQnLCBmYWxzZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTGluay5nZXQoJ2JsdXJlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2V0KCdibHVyZWQnLCB0cnVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgZmFsc2UsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZWxmLm1vZGVsID0geyBzb3VyY2U6IG9wdGlvbnMuc291cmNlLmlkLCB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LmlkIH07XHJcbiAgICBzZWxmLnJlZnJlc2hIaWdobGlnaHRpbmcoKTtcclxuXHJcbiAgICBjb25zdCBvblJlbW92ZSA9IHNlbGYucmVtb3ZlO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbGluayBmcm9tIHRoZSBwYXBlci5cclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbkxpbmtcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGYub3JpZ2luYWxMaW5rLnRlcm1pbmF0aW9uTGlua3MuaW5kZXhPZihzZWxmKTtcclxuICAgICAgICBzZWxmLm9yaWdpbmFsTGluay50ZXJtaW5hdGlvbkxpbmtzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgb25SZW1vdmUuY2FsbChzZWxmKTtcclxuICAgIH07XHJcbn1cclxuVGVybWluYXRpb25MaW5rLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoam9pbnQuZGlhLkxpbmsucHJvdG90eXBlKTtcclxuXHJcblxyXG4iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgeyBSZXNvdXJjZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vZGF0YS9yZXNvdXJjZVByb3ZpZGVyJztcclxuaW1wb3J0IHsgWl9JTkRFWEVTIH0gZnJvbSAnLi9lbGVtZW50cyc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogVGVybWluYXRpb25Ob2RlTW9kZWwgLSBkYXRhIG1vZGVsIG9mIGEgVGVybWluYXRpb25Ob2RlIG9iamVjdFxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXJtaW5hdGlvbk5vZGVNb2RlbFxyXG4gKiBAcHJvcGVydHkge1BvaW50fSBwb3NpdGlvbiAtIE5vZGUgaWRlbnRpZnllclxyXG4gKiBAcHJvcGVydHkge05vZGV9IG5vZGUgLSBPcmlnaW5hbCBub2RlXHJcbiovXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogVGhlIGdyYXBoIFRlcm1pbmF0aW9uTm9kZSBiYXNlZCBvbiBqb2ludC5zaGFwZXMuYmFzaWMuUmVjdC5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBqb2ludC5zaGFwZXMuYmFzaWMuUmVjdFxyXG4gKiBcclxuICogQHBhcmFtIHtUZXJtaW5hdGlvbk5vZGVNb2RlbH0gb3B0aW9ucyAtIERhdGEgbW9kZWxcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gVGhlIHNldCBvZiBwYXJhbWV0ZXJzXHJcbiAqIFxyXG4gKiBAcHJvcGVydHkge05vZGV9IG9yaWdpbmFsTm9kZSAtIFRoZSBvcmlnaW5hbCBub2RlLFxyXG4gKiB3aGljaCBpcyBvdXQgb2YgdGhlIHZpZXdGcmFtZSBzbyB3ZSB1c2UgdGVybWluYXRpb24gaW5zdGVhZFxyXG4gKiBAcHJvcGVydHkge05vZGVbXX0gcmVsYXRlZCAtIExpc3Qgb2YgdGhlIG5vZGVzIHJlbGF0ZWQgd2l0aCB0aGlzIG5vZGVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBoaWdobGlnaHRlZCAtIFRlbGxzIHdoZXRlciBoaWdobGlnaHRlZCBub2RlIG9yIG5vdCAodXNlIG1ldGhvZCBnZXQgdG8gZ2V0IHRoaXMgcHJvcGVydHksIGUuZy4gbm9kZS5nZXQoJ2hpZ2hsaWdodGVkJykpXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYmx1cmVkIC0gVGVsbHMgd2hldGVyIGJsdXJlZCBub2RlIG9yIG5vdCAodXNlIG1ldGhvZCBnZXQgdG8gZ2V0IHRoaXMgcHJvcGVydHksIGUuZy4gbm9kZS5nZXQoJ2JsdXJlZCcpKVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbW92ZWQgLSBJcyB0aGUgbm9kZSByZW1vdmVkIGZyb20gdGhlIHBhcGVyXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBUZXJtaW5hdGlvbk5vZGUgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX3JlcyA9IG5ldyBSZXNvdXJjZVByb3ZpZGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgXHJcbiAgICBzZWxmLm9yaWdpbmFsTm9kZSA9IG9wdGlvbnMubm9kZTtcclxuICAgIHNlbGYuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcclxuICAgIHNlbGYuYmx1cmVkID0gZmFsc2U7XHJcbiAgICBzZWxmLnJlbGF0ZWQgPSBbXTtcclxuICAgIHNlbGYuc2l6ZSA9IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZTtcclxuICAgIFxyXG4gICAgb3B0aW9ucy5ub2RlLnRlcm1pbmF0aW9uTm9kZXMucHVzaChzZWxmKTtcclxuXHJcbiAgICBqb2ludC5zaGFwZXMuYmFzaWMuR2VuZXJpYy5hcHBseShzZWxmLCBbe1xyXG4gICAgICAgIG1hcmt1cDogYDxnIGNsYXNzPVwicm90YXRhYmxlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGcgY2xhc3M9XCJzY2FsYWJsZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImJvZHlcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwidHEtbGctYm9keVwiLz5cclxuICAgICAgICAgICAgICAgICAgICA8dGV4dC8+XHJcbiAgICAgICAgICAgICAgICA8L2c+YCxcclxuICAgICAgICB0eXBlOiAndGVybWluYXRpb24tbm9kZScsXHJcbiAgICAgICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgc2l6ZTogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLFxyXG4gICAgICAgIGF0dHJzOiB7IFxyXG4gICAgICAgICAgICAnLmJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICBwb3J0OiAnY2xpcFJlY3RQb3J0JyxcclxuICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMCxcclxuICAgICAgICAgICAgICAgIHJ4OiAxMCxcclxuICAgICAgICAgICAgICAgIHJ5OiAxMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJy50cS1sZy1ib2R5Jzoge1xyXG4gICAgICAgICAgICAgICAgJ3JlZi14JzogLjUsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiAuNSxcclxuICAgICAgICAgICAgICAgICd4LWFsaWdubWVudCc6ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICAgICAgJ3ktYWxpZ25tZW50JzogJ21pZGRsZScsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyYW1ldGVycy50ZXJtaW5hdGlvbk5vZGVTaXplLndpZHRoIC0gMTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZS5oZWlnaHQgLSAxMCxcclxuICAgICAgICAgICAgICAgIHJlZjogJy5ib2R5JyxcclxuICAgICAgICAgICAgICAgIHJ4OiAyLFxyXG4gICAgICAgICAgICAgICAgcnk6IDIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IF9yZXMuZ2V0Q29sb3Iob3B0aW9ucy5ub2RlLm1vZGVsLnR5cGVJZCksXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgcG9ydDogJ2NsaXBSZWN0UG9ydCcsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6ICfQoScsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBfcmVzLmdldENvbG9yKG9wdGlvbnMubm9kZS5tb2RlbC50eXBlSWQpLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBfcmVzLmdldENvbG9yKG9wdGlvbnMubm9kZS5tb2RlbC50eXBlSWQpLFxyXG4gICAgICAgICAgICAgICAgJ3JlZi14JzogLjUsXHJcbiAgICAgICAgICAgICAgICAncmVmLXknOiAuNTUsXHJcbiAgICAgICAgICAgICAgICByZWY6ICcuYm9keScsXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBzZWxmLm9yaWdpbmFsTm9kZS5tb2RlbC5sYWJlbCAvLyBzZWUgdGhlIGxpbmUgMjIxIGF0IGxpbmVhZ2VHcmFtLmpzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgejogWl9JTkRFWEVTLlRFUk1JTkFUSU9OX0VMRU1FTlQsXHJcbiAgICB9XSk7XHJcblxyXG4gICAgbGV0IF9pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gc2VsZi5wb3NpdGlvbjtcclxuICAgIHNlbGYucG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgIF9pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb2xkUG9zaXRpb24uY2FsbChzZWxmLCB4LCB5KTtcclxuICAgICAgICBfaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6cG9zaXRpb24nLCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKF9pc0RyYWdnaW5nKSBzZWxmLnNldCgnZHJhZ2dlZCcsIF9pc0RyYWdnaW5nKTtcclxuICAgIH0pO1xyXG4gICAgc2VsZi5vbignY2hhbmdlOmRyYWdnZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHNlbGYuc2l6ZTtcclxuICAgICAgICBjb25zdCBvbGRQb3MgPSBzZWxmLnBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmdldCgnZHJhZ2dlZCcpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzZWxmLm9yaWdpbmFsTm9kZS5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAgc2VsZi5vcmlnaW5hbE5vZGUuc2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJysnLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZWYteSc6IC41MSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnLmJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcng6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcnk6IDAsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VsZi5yZXNpemUoc2VsZi5zaXplLndpZHRoLCBzZWxmLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihcclxuICAgICAgICAgICAgICAgIG9sZFBvcy54IC0gKHNlbGYuc2l6ZS53aWR0aCAtIG9sZFNpemUud2lkdGgpIC8gMixcclxuICAgICAgICAgICAgICAgIG9sZFBvcy55IC0gKHNlbGYuc2l6ZS5oZWlnaHQgLSBvbGRTaXplLmhlaWdodCkgLyAyLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcmFtZXRlcnMudGVybWluYXRpb25Ob2RlU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNlbGYuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ0MnLFxyXG4gICAgICAgICAgICAgICAgICAgICdyZWYteSc6IC41NSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnLmJvZHknOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcng6IDEwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ5OiAxMCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZWxmLnJlc2l6ZShzZWxmLnNpemUud2lkdGgsIHNlbGYuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihcclxuICAgICAgICAgICAgICAgIG9sZFBvcy54ICsgKHNlbGYuc2l6ZS53aWR0aCAtIG9sZFNpemUud2lkdGgpIC8gMixcclxuICAgICAgICAgICAgICAgIG9sZFBvcy55ICsgKHNlbGYuc2l6ZS5oZWlnaHQgLSBvbGRTaXplLmhlaWdodCkgLyAyLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgVGVybWluYXRpb25Ob2RlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvbmNlIC0gQm9vbGVhbiBmbGFnIHRvIHByb3RlY3QgY29kZSBmcm9tIHJlY3Vyc2lvbiAob3B0aW9uYWwpXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25Ob2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZWxlY3QgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnYmx1cmVkJykpIHNlbGYudW5ibHVyZSgpO1xyXG4gICAgICAgIGlmIChzZWxmLmdldCgnaGlkZGVuJykpIHNlbGYuc2hvdygpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5TRUxFQ1RFRF9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGhpZ2hsaWdodGluZyBmcm9tIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnVuc2VsZWN0ID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLnVuc2VsZWN0KHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5URVJNSU5BVElPTl9FTEVNRU5UIH0pO1xyXG4gICAgICAgIHNlbGYuc2V0KCdoaWdobGlnaHRlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAvKipcclxuICAgICAqIEJsdXJzIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovICAgIFxyXG4gICAgc2VsZi5ibHVyZSA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuZ2V0KCdoaWdobGlnaHRlZCcpKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS5ibHVyZSh0cnVlKTtcclxuICAgICAgICBzZWxmLnByb3AoeyB6OiBaX0lOREVYRVMuQkxVUkVEX05PREUgfSk7ICAgICAgICBcclxuICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBibHVyIGZyb20gdGhlIFRlcm1pbmF0aW9uTm9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb25jZSAtIEJvb2xlYW4gZmxhZyB0byBwcm90ZWN0IGNvZGUgZnJvbSByZWN1cnNpb24gKG9wdGlvbmFsKVxyXG4gICAgICogQG1lbWJlcm9mIFRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYudW5ibHVyZSA9IGZ1bmN0aW9uIChvbmNlKSB7XHJcbiAgICAgICAgaWYgKHNlbGYub3JpZ2luYWxOb2RlICYmICFvbmNlKSBzZWxmLm9yaWdpbmFsTm9kZS51bmJsdXJlKHRydWUpO1xyXG4gICAgICAgIHNlbGYucHJvcCh7IHo6IFpfSU5ERVhFUy5URVJNSU5BVElPTl9FTEVNRU5UIH0pOyAgICAgICAgXHJcbiAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAvKipcclxuICAgICAqIEJsdXJzIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovICAgIFxyXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKG9uY2UpIHtcclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUgJiYgIW9uY2UpIHNlbGYub3JpZ2luYWxOb2RlLmhpZGUodHJ1ZSk7ICAgICBcclxuICAgICAgICBzZWxmLnNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYmx1ciBmcm9tIHRoZSBUZXJtaW5hdGlvbk5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uY2UgLSBCb29sZWFuIGZsYWcgdG8gcHJvdGVjdCBjb2RlIGZyb20gcmVjdXJzaW9uIChvcHRpb25hbClcclxuICAgICAqIEBtZW1iZXJvZiBUZXJtaW5hdGlvbk5vZGVcclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbiAob25jZSkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZSAmJiAhb25jZSkgc2VsZi5vcmlnaW5hbE5vZGUuc2hvdyh0cnVlKTsgICAgXHJcbiAgICAgICAgc2VsZi5zZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIGhpZ2hsaWdodGVycyBvZiB0aGUgdmlldyBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlua1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3luY2hyb25pemVXaXRoT3JpZ2luKCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZWZyZXNoLWhpZ2hsaWdodGluZycsIHNlbGYpOyAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9zeW5jaHJvbml6ZVdpdGhPcmlnaW4gKCkge1xyXG4gICAgICAgIGlmIChzZWxmLm9yaWdpbmFsTm9kZS5nZXQoJ2hpZ2hsaWdodGVkJykpIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgdHJ1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2hpZ2hsaWdodGVkJywgZmFsc2UsIHsgc2lsZW50OiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZi5vcmlnaW5hbE5vZGUuZ2V0KCdibHVyZWQnKSkge1xyXG4gICAgICAgICAgICBzZWxmLnNldCgnYmx1cmVkJywgdHJ1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zZXQoJ2JsdXJlZCcsIGZhbHNlLCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25SZW1vdmUgPSBzZWxmLnJlbW92ZTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG5vZGUgZnJvbSB0aGUgcGFwZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGVybWluYXRpb25Ob2RlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBzZWxmLm9yaWdpbmFsTm9kZS50ZXJtaW5hdGlvbk5vZGVzLmluZGV4T2Yoc2VsZik7XHJcbiAgICAgICAgc2VsZi5vcmlnaW5hbE5vZGUudGVybWluYXRpb25Ob2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIG9uUmVtb3ZlLmNhbGwoc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVmcmVzaEhpZ2hsaWdodGluZygpO1xyXG59XHJcblRlcm1pbmF0aW9uTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LnByb3RvdHlwZSk7IiwiaW1wb3J0ICogYXMgam9pbnQgZnJvbSBcInJhcHBpZFwiO1xyXG5pbXBvcnQgc2F2ZUFzIGZyb20gXCJmaWxlLXNhdmVyanNcIjtcclxuaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XHJcblxyXG5pbXBvcnQge1xyXG4gIFZpZXdNYW5hZ2VyLFxyXG4gIEZSQU1FX09VVF9NQVJHSU4sXHJcbiAgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVNcclxufSBmcm9tIFwiLi92aWV3TWFuYWdlclwiO1xyXG5pbXBvcnQgeyBSb3V0aW5nTWFuYWdlciB9IGZyb20gXCIuL2xpbmtSb3V0aW5nTWFuYWdlci9yb3V0aW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBWaWV3RnJhbWUgfSBmcm9tIFwiLi92aWV3RnJhbWVcIjtcclxuaW1wb3J0IHtcclxuICBOb2RlLFxyXG4gIExpbmssXHJcbiAgVGVybWluYXRpb25Ob2RlLFxyXG4gIE5vZGVWaWV3LFxyXG4gIExpbmtWaWV3LFxyXG4gIEFzcGVjdExpbmtcclxufSBmcm9tIFwiLi9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzXCI7XHJcbmltcG9ydCBWaWV3RnJhbWVzVUkgZnJvbSBcIi4uL2h0bWxVSS92aWV3RnJhbWVzVUlcIjtcclxuaW1wb3J0IFN1YnNjcmliYWJsZSBmcm9tIFwiLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjtcclxuaW1wb3J0IHsgZXhwb3J0VG9TVkcsIHRvRGF0YVVSTCB9IGZyb20gXCIuL3RvU3ZnXCI7XHJcbmltcG9ydCB7IGNvbWJpbmVPcGVyYXRpb24gfSBmcm9tIFwiLi4vbGF5b3V0L2xheW91dFwiO1xyXG5pbXBvcnQgeyBkYXRlMlN0cmluZywgcG5nMkJsb2IsIGdldEJhc2VFbGVtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2RhdGFVdGlsc1wiO1xyXG5pbXBvcnQge1xyXG4gIGxpbWl0UG9pbnRQb3NpdGlvbixcclxuICBnZXREaXN0LFxyXG4gIGdldERpZmYsXHJcbiAgbG9jYWxUb0dsb2JhbFBvaW50LFxyXG4gIGdldEdsb2JhbE5vZGVQb3NpdGlvbixcclxuICBnZXRHbG9iYWxOb2RlU2l6ZSxcclxuICBnbG9iYWxUb1NjYWxlZFNpemUsXHJcbiAgc2NhbGVkVG9HbG9iYWxTaXplXHJcbn0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XHJcbmltcG9ydCB7IGdldFBhdGgsIGdldFZpZXdGcmFtZUlkRm9yTm9kZSB9IGZyb20gXCIuLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzXCI7XHJcblxyXG5jb25zdCBESVJFQ1RJT04gPSB7XHJcbiAgVVA6IDM4LFxyXG4gIERPV046IDQwLFxyXG4gIExFRlQ6IDM3LFxyXG4gIFJJR0hUOiAzOVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjbGFzc1xyXG4gKiBNYW5hZ2VzIHRoZSBtYWluIHZpZXcgb2YgYXBwbGljYXRpb24gKFZpZXctMilcclxuICogQWxsIGNoYW5nZXMgZ29lcyB0aHJvdWdoIHRoZSByZW5kZXIgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQHBhcmFtIHtcclxuICogIGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXJcclxuICogIGdyYXBoUGxhY2U6IEhUTUxFbGVtZW50XHJcbiAqICB2aWV3RnJhbWVzOiBWaWV3RnJhbWVNb2RlbHNcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqXHJcbiAqIFB1YmxpYyBwcm9wZXJ0aWVzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHNlbGVjdGVkRWxlbWVudDogTm9kZXxMaW5rXHJcbiAqXHJcbiAqIFB1YmxpYyBtZXRob2RzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIHJlZHJhdzogKG9wdGlvbnM6IHtcclxuICAgIHZpZXdGcmFtZXM6IFZpZXdGcmFtZVB1YmxpY01vZGVsW107XHJcbiAgICBzZWxlY3RlZEVsZW1lbnQ6IChOb2RlfExpbmspO1xyXG4gICAgcGF0aDogeyBbaWQ6IHN0cmluZ106IChOb2RlfExpbmspIH07XHJcbiAgICBxdWlja1VwZGF0ZTogYm9vbGVhbjtcclxuICAgIHVwZGF0ZUJvdW5kczogYm9vbGVhbjtcclxuICAgIHBhcGVyT3B0aW9uczoge1xyXG4gICAgICAgIG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcclxuICAgICAgICB3aWR0aDogbnVtYmVyO1xyXG4gICAgICAgIGhlaWdodDpudW1iZXI7XHJcbiAgICAgICAgc2NhbGU6IFBvaW50O1xyXG4gICAgfTtcclxuICAgIGVsZW1lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgZWxlbWVudFNpemU6IEVsZW1lbnRTaXplO1xyXG4gKiB9KSA9PiB2b2lkO1xyXG4gKiBkZWxheWVkUmVkcmF3OiAob3B0aW9uczogeyAuLi4gc2VlIHJlZHJhd30pID0+IHZvaWQ7XHJcbiAqIG9wZW5WaWV3RnJhbWU6IChpZDpzdHJpbmcpID0+IHZvaWQ7XHJcbiAqIGNsb3NlVmlld0ZyYW1lOiAoaWQ6c3RyaW5nKSA9PiB2b2lkO1xyXG4gKiBvcGVuT3ZlclZpZXdGcmFtZTogKCkgPT4gdm9pZDtcclxuICogY2xvc2VPdmVyVmlld0ZyYW1lOiAoKSA9PiB2b2lkO1xyXG4gKiB1cGRhdGVOb2Rlc1Bvc2l0aW9uczogKG5vZGVzOiBOb2RlW10pID0+IHZvaWQ7XHJcbiAqIGNvbWJpbmU6ICgpID0+IHZvaWQ7XHJcbiAqIHJlc2V0TGF5b3V0OiAoKSA9PiB2b2lkO1xyXG4gKiByZWZyZXNoOiAoKSA9PiB2b2lkO1xyXG4gKiBnZXRTZWxlY3RlZEVsZW1lbnQ6ICgpID0+IChOb2RlfExpbmspO1xyXG4gKiBnZXRWaXNpYmxlQ2VsbHM6ICgpID0+IChOb2RlfExpbmt8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZXxUZXJtaW5hdGlvbkxpbmspO1xyXG4gKiBnZXRWaXNpYmxlTm9kZXM6ICgpID0+IChOb2RlfFZpZXdGcmFtZXxUZXJtaW5hdGlvbk5vZGUpO1xyXG4gKiBnZXRWaXNpYmxlTGlua3M6ICgpID0+IChMaW5rfFRlcm1pbmF0aW9uTGluayk7XHJcbiAqIHNldFNlbGVjdGVkRWxlbWVudDogKGVsZW1lbnQ6IChOb2RlfExpbmt8dW5kZWZpbmVkKSwgZm9jdXNPbjogYm9vbGVhbikgPT4gdm9pZDtcclxuICogcG9zaXRpb25WaWV3UG9ydDogKHZmOiBWaWV3RnJhbWVQdWJsaWNNb2RlbCwgcG9pbnQ6IFBvaW50LCBhbmltYXRpb246IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAqIGV4cG9ydDogKCkgPT4gdm9pZDtcclxuICogcHJpbnQ6ICgpID0+IHZvaWQ7XHJcbiAqIHNldERhdGE6IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzOiBWaWV3RnJhbWVEZWZpbml0aW9uW10pID0+IHZvaWQ7XHJcbiAqIHNjYWxlOiAoc2NhbGU6IFBvaW50KSA9PiB2b2lkOyAtIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgb2YgdGhlIGdyYXBoXHJcbiAqIHpvb21JbjogKCkgPT4gdm9pZDtcclxuICogem9vbU91dDogKCkgPT4gdm9pZDtcclxuICogem9vbVRvRml0OiAoKSA9PiB2b2lkO1xyXG4gKiBzZXRPcmllbnRhdGlvbjogKG9yaWVudGF0aW9uOiBPcmllbnRhdGlvbikgPT4gdm9pZDsgVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICogZ2V0Vmlld0ZyYW1lczogKCkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWxbXTtcclxuICogdHJhbnNsYXRlVmlld1BvcnQgKHZmOiBWaWV3RnJhbWUsIGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbjogYm9vbGVhbilcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBvbiAoZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IGZ1bmN0aW9uKSA9PiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pID0+IHZvaWRcclxuICogdHJpZ2dlciAoZXZlbnQ6IHN0cmluZywgcGFyYW1ldGVyczogYW55KSA9PiB2b2lkXHJcbiAqXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkIChOb2RlfExpbmspXHJcbiAqIEBmaXJlcyBzY2FsZS1jaGFuZ2VkIChzY2FsZSlcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWQgKFZpZXdGcmFtZSwgYm9vbGVhbilcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZCAoVmlld0ZyYW1lLCBib29sZWFuKVxyXG4gKiBAZmlyZXMgY2VsbC1kb3VibGUtY2xpY2sgKGNlbGwpXHJcbiAqIEBmaXJlcyBjZWxsLXNpbmdsZS1jbGljayAoY2VsbClcclxuICogQGZpcmVzIGxpbmstb3B0aW9ucy1jbGljayAoTGluaylcclxuICogQGZpcmVzIG5vZGVzLXBvc2l0aW9uLWNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExpbmVhZ2VEaWFncmFtKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAvLyBJbml0XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7IC8vIG1ha2UgdGhpcyBjbGFzcyBTdWJzY3JpYmFibGVcclxuXHJcbiAgY29uc3QgX2Jhc2UgPSBfY3JlYXRlQmFzZShvcHRpb25zLmdyYXBoUGxhY2UpO1xyXG5cclxuICAvLyBDcmVhdGluZyBhIGpvaW50IGdyYXBoIGFuZCBqb2ludCBwYXBlclxyXG4gIGNvbnN0IF9ncmFwaCA9IG5ldyBqb2ludC5kaWEuR3JhcGgoKTtcclxuICBjb25zdCBfcGFwZXIgPSBuZXcgam9pbnQuZGlhLlBhcGVyKHtcclxuICAgIGVsOiBfYmFzZS5kaWFncmFtLFxyXG4gICAgbW9kZWw6IF9ncmFwaCxcclxuICAgIGVsZW1lbnRWaWV3OiBOb2RlVmlldyxcclxuICAgIGxpbmtWaWV3OiBMaW5rVmlldyxcclxuICAgIGdyaWRTaXplOiAxLFxyXG4gICAgaW50ZXJhY3RpdmU6ICgpID0+IHtcclxuICAgICAgcmV0dXJuIHsgdmVydGV4QWRkOiBmYWxzZSB9O1xyXG4gICAgfSxcclxuICAgIHByZXZlbnRDb250ZXh0TWVudTogZmFsc2UsXHJcbiAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICBoZWlnaHQ6IFwiMTAwJVwiXHJcbiAgfSk7XHJcblxyXG4gIGxldCBfc2NhbGUgPSBwYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZTtcclxuICBsZXQgX2RhdGFDb250YWluZXI7XHJcblxyXG4gIGxldCBfb3JpZW50YXRpb24gPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb247XHJcbiAgbGV0IF9mdWxsU2NyZWVuTW9kZSA9IHBhcmFtZXRlcnMuZnVsbFNjcmVlbk1vZGU7XHJcbiAgbGV0IF9wYXRoID0gbnVsbDsgLy8gaGlnaGxpZ2h0aW5nIHBhdGhcclxuICBsZXQgX21hc2sgPSBwYXJhbWV0ZXJzLm1hc2s7IC8vIGhpZ2hsaWdodGluZyBwYXRoXHJcbiAgbGV0IF9zZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG4gIGxldCBfcm91dGluZ01hbmFnZXI7XHJcbiAgbGV0IF92aWV3RnJhbWVzVUk7XHJcbiAgbGV0IF92aWV3TWFuYWdlcjtcclxuXHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgY29uc3QgX2tleWJvYXJkID0gbmV3IGpvaW50LnVpLktleWJvYXJkKCk7XHJcbiAgY29uc3QgX3NjYWxlQm91bmRzID0gXy5jbG9uZShwYXJhbWV0ZXJzLnNjYWxlQm91bmRzKTtcclxuICBjb25zdCBfb3ZlclZpZXdTY2FsZUJvdW5kcyA9IF8uY2xvbmUocGFyYW1ldGVycy5vdmVyVmlld1NjYWxlQm91bmRzKTtcclxuICBjb25zdCBfc2NhbGVTdGVwID0gcGFyYW1ldGVycy5zY2FsZVN0ZXA7XHJcblxyXG4gIF9zZXREYXRhKG9wdGlvbnMuZGF0YUNvbnRhaW5lciwgb3B0aW9ucy52aWV3RnJhbWVzKTtcclxuICBfc3Vic2NyaWJlT25FdmVudHMoKTtcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAvKipcclxuICAgKiBEcmF3aW5nIG9wdGlvbnMgKGRlcHJlY2F0ZWQpXHJcbiAgICogQHR5cGVkZWYge09iamVjdH0gRHJhd2luZ09wdGlvbnNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrVXBkYXRlIC0gZG9uJ3QgdXBkYXRlcyBsaW5rcyBhbmQgcmVtb3ZlIHRoZW0uXHJcbiAgICogQHBhcmFtIHtBcnJheSBvZiBWaWV3RnJhbWV9IHZpZXdGcmFtZXMgLSB1cGRhdGUgb25seSBsaW1pdHRlZCBudW1iZXIgb2Ygdmlld0ZyYW1lcy5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBVcGRhdGVzIHRoZSBncmFwaCdzIHN0YXRlLCAtIEFkZC9yZW1vdmVcclxuICAgKiB2aXNpYmxlIE5vZGVzIGFuZCBUZXJtaW5hdGlvbk5vZGVzXHJcbiAgICogQHBhcmFtIHtEcmF3aW5nT3B0aW9uc30gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHNlbGYucmVkcmF3ID0gX3JlZHJhdztcclxuICAvKipcclxuICAgKiBTYW1lIGFzIHJlZHJhdyBidXQgaXQncyBxdWljayB1cGRhdGVcclxuICAgKiB3aXRoIGRlbGF5ZWQgZnVsbCByZWRyYXcgKGRlYm91bmNlcikuXHJcbiAgICovXHJcbiAgc2VsZi5kZWxheWVkUmVkcmF3ID0gX2RlbGF5ZWRSZWRyYXc7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wZW5zIFZpZXdGcmFtZSB3aXRoIHNwZWNpZmllZCBpZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAqL1xyXG4gIHNlbGYub3BlblZpZXdGcmFtZSA9IF9vcGVuVmlld0ZyYW1lO1xyXG5cclxuICAvKipcclxuICAgKiBDbG9zZXMgVmlld0ZyYW1lIHdpdGggc3BlY2lmaWVkIGlkXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkXHJcbiAgICovXHJcbiAgc2VsZi5jbG9zZVZpZXdGcmFtZSA9IF9jbG9zZVZpZXdGcmFtZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlcyBtb2RlIGZ1bGxTY3JlZW4vdmlld0ZyYW1lLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKi9cclxuICBzZWxmLnNldEZ1bGxTY3JlZW5Nb2RlID0gX3NldEZ1bGxTY3JlZW5Nb2RlO1xyXG5cclxuICAvKipcclxuICAgKiBPcGVucyBPdmVyVmlld0ZyYW1lXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkXHJcbiAgICovXHJcbiAgc2VsZi5vcGVuT3ZlclZpZXdGcmFtZSA9ICgpID0+XHJcbiAgICBfb3BlblZpZXdGcmFtZShfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpLmlkKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvc2VzIE92ZXJWaWV3RnJhbWVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWRcclxuICAgKi9cclxuICBzZWxmLmNsb3NlT3ZlclZpZXdGcmFtZSA9ICgpID0+XHJcbiAgICBfY2xvc2VWaWV3RnJhbWUoX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKS5pZCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgbGF5b3V0IHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgdXNpbmcgcGFwZXIgcG9zaXRpb25zXHJcbiAgICogQHBhcmFtIHtOb2RlW119IG5vZGVzXHJcbiAgICovXHJcbiAgc2VsZi51cGRhdGVOb2Rlc1Bvc2l0aW9ucyA9IF91cGRhdGVOb2Rlc1Bvc2l0aW9ucztcclxuXHJcbiAgLyoqXHJcbiAgICogR3JvdXBzIG5vZGVzIGFyb3VuZCBzZWxlY3RlZFxyXG4gICAqIGFuZCBoaWdobGlnaHRzIG5laWdoYm91cnNcclxuICAgKi9cclxuICBzZWxmLmNvbWJpbmUgPSBfY29tYmluZTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdG9yZSBub2RlcyBwb3NpdGlvbnNcclxuICAgKi9cclxuICBzZWxmLnJlc2V0TGF5b3V0ID0gX3Jlc2V0TGF5b3V0O1xyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoZXMgYWxsIHZpZXdGcmFtZXMgYm91bmRzLlxyXG4gICAqL1xyXG4gIHNlbGYucmVmcmVzaCA9IF9yZWZyZXNoO1xyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Tm9kZXxMaW5rfS5cclxuICAgKi9cclxuICBzZWxmLmdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgeyhOb2RlfExpbmt8Vmlld0ZyYW1lfFRlcm1pbmF0aW9uTm9kZXxUZXJtaW5hdGlvbkxpbmspfS5cclxuICAgKi9cclxuICBzZWxmLmdldFZpc2libGVDZWxscyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIF9ncmFwaC5nZXRDZWxscygpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHsoTm9kZXxWaWV3RnJhbWV8VGVybWluYXRpb25Ob2RlKX0uXHJcbiAgICovXHJcbiAgc2VsZi5nZXRWaXNpYmxlTm9kZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfZ3JhcGguZ2V0RWxlbWVudHMoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyB7KExpbmt8VGVybWluYXRpb25MaW5rKX0uXHJcbiAgICovXHJcbiAgc2VsZi5nZXRWaXNpYmxlTGlua3MgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfZ3JhcGguZ2V0TGlua3MoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHNlbGVjdGVkIGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge05vZGV8TGlua3x1bmRlZmluZWR9LlxyXG4gICAqL1xyXG4gIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgZm9jdXNPbikge1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgX3NlbGVjdChlbGVtZW50LCBmb2N1c09uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF91bnNlbGVjdCgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0IHNldHMgb2Zmc2V0IGZvciBhbGwgZWxlbWVudHMgaW50byB0aGUgdmlld1BvcnQuXHJcbiAgICogQHBhcmFtIHtWaWV3RnJhbWV9IHZpZXdGcmFtZVxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRpb24gLSBpdCdzIG9wdGlvbmFsXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpdCdzIGNhbGxlZCBhZnRlciBmb2N1c1xyXG4gICAqIEBmaXJlcyB2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWRcclxuICAgKi9cclxuICBzZWxmLnBvc2l0aW9uVmlld1BvcnQgPSBmdW5jdGlvbihcclxuICAgIHZpZXdGcmFtZVB1YmxpY01vZGVsLFxyXG4gICAgcG9pbnQsXHJcbiAgICBhbmltYXRpb24sXHJcbiAgICBjYWxsYmFja1xyXG4gICkge1xyXG4gICAgY29uc3QgcmVsZXZhbnRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZChcclxuICAgICAgdmlld0ZyYW1lUHVibGljTW9kZWwuaWRcclxuICAgICk7XHJcbiAgICBfcG9zaXRpb25WaWV3UG9ydChyZWxldmFudFZpZXdGcmFtZSwgcG9pbnQsIGFuaW1hdGlvbiwgKCkgPT4ge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQoXHJcbiAgICAgICAgdmlld0ZyYW1lUHVibGljTW9kZWwuaWRcclxuICAgICAgKTtcclxuICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtcclxuICAgICAgICBbY2hhbmdlZFZpZXdGcmFtZV1cclxuICAgICAgXSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeHBvcnRzIGdyYXBoIHRvIHBuZyBvciBzdmcgZmlsZS5cclxuICAgKiBAcGFyYW0ge1xyXG4gICAqICBuYW1lPzogc3RyaW5nIC0gZmlsZSBuYW1lXHJcbiAgICogIHR5cGU/OiBzdHJpbmcgLSAocG5nL3N2ZylcclxuICAgKiB9IG9wdGlvbnNcclxuICAgKi9cclxuICBzZWxmLmV4cG9ydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG4gICAgY29uc3QgZmlsZU5hbWUgPVxyXG4gICAgICBvcHRpb25zLm5hbWUgfHwgXCJMR19saW5lYWdlX2RpYWdyYW1fc25hcHNob3RfXCIgKyBkYXRlMlN0cmluZyhuZXcgRGF0ZSgpKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy50eXBlID09PSBcInBuZ1wiKSB7XHJcbiAgICAgIHRvRGF0YVVSTChfcGFwZXIsIHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIixcclxuICAgICAgICBzdmdPcHRpb25zOiB7XHJcbiAgICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6IFwiXCIsXHJcbiAgICAgICAgICBjb252ZXJ0SW1hZ2VzVG9EYXRhVXJpczogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgICAudGhlbihiYXNlNjRVUkwgPT4ge1xyXG4gICAgICAgICAgc2F2ZURhdGEoYmFzZTY0VVJMLCBmaWxlTmFtZSwgXCJwbmdcIik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBhbGVydChcclxuICAgICAgICAgICAgICBcIlRoaXMgdHlwZSBvZiBleHBvcnQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgSW50ZXJuZXQgRXhwbG9yZXJcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBleHBvcnRUb1NWRyhfcGFwZXIsIHtcclxuICAgICAgICBlbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3I6IFwiXCIsXHJcbiAgICAgICAgY29udmVydEltYWdlc1RvRGF0YVVyaXM6IHRydWVcclxuICAgICAgfSlcclxuICAgICAgICAudGhlbihzdmdTdHJpbmcgPT4ge1xyXG4gICAgICAgICAgc2F2ZURhdGEoc3ZnU3RyaW5nLCBmaWxlTmFtZSwgXCJzdmdcIik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2F2ZURhdGEoZGF0YSwgZmlsZU5hbWUsIHR5cGUpIHtcclxuICAgICAgbGV0IGJsb2I7XHJcbiAgICAgIGlmICh0eXBlID09PSBcInN2Z1wiKSB7XHJcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiB0eXBlIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicG5nXCIpIHtcclxuICAgICAgICBibG9iID0gcG5nMkJsb2IoZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgc2F2ZUFzKGJsb2IsIGZpbGVOYW1lICsgXCIuXCIgKyB0eXBlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTaG93cyBwcmludCBkaWFsb2cuXHJcbiAgICovXHJcbiAgc2VsZi5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZXhwb3J0VG9TVkcoX3BhcGVyLCB7XHJcbiAgICAgIHByZXNlcnZlRGltZW5zaW9uczogZmFsc2UsXHJcbiAgICAgIGVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvcjogXCJcIixcclxuICAgICAgY29udmVydEltYWdlc1RvRGF0YVVyaXM6IHRydWUsXHJcbiAgICAgIHBkZk1vZGU6IHRydWVcclxuICAgIH0pLnRoZW4oc3ZnU3RyaW5nID0+IHtcclxuICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbihcIlwiLCB1bmRlZmluZWQsIFwid2lkdGg9MTI4MCxoZWlnaHQ9NzIwXCIpO1xyXG4gICAgICBpZiAocHJpbnRXaW5kb3cpIHtcclxuICAgICAgICBwcmludFdpbmRvdy5kb2N1bWVudC53cml0ZShzdmdTdHJpbmcpO1xyXG4gICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgcHJpbnRXaW5kb3cucHJpbnQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhbGVydChcclxuICAgICAgICAgIFwiWW91IHNob3VsZCB1bmJsb2NrIHBvcHVwIHdpbmRvd3MgZm9yIHRoZSBjdXJyZW50IHVybCB0byBiZSBhYmxlIHRvIHByaW50IHRoaXMgZGlhZ3JhbSFcIlxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZSBkYXRhIGNvbnRhaW5lciB3aXRoIG5vZGVzIGFuZCBsaW5rcyBmb3IgdGhlIEpvaW50anMgdmlldyAodmlldy0yKVxyXG4gICAqIGFuZCBwYXRoIGl0IHRvIHRoZSBmb3Jtc1xyXG4gICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lciAtIGRhdGEgZm9yIHRoZSBncmFwaFxyXG4gICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gdmlld0ZyYW1lcyAtIHZpZXcgZnJhbWVzXHJcbiAgICovXHJcbiAgc2VsZi5zZXREYXRhID0gX3NldERhdGE7XHJcblxyXG4gIHNlbGYuc2V0Um91dGluZyA9IGZ1bmN0aW9uKHJvdXRpbmdJZCkge1xyXG4gICAgX3JvdXRpbmdNYW5hZ2VyLnNldFJvdXRpbmcocm91dGluZ0lkKTtcclxuICB9O1xyXG5cclxuICBzZWxmLmdldFJvdXRpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfcm91dGluZ01hbmFnZXIuZ2V0Um91dGluZygpO1xyXG4gIH07XHJcblxyXG4gIHNlbGYuc2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG4gICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgIF91cGRhdGVTY2FsZShzY2FsZSk7XHJcbiAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9zY2FsZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbmNyZWFzZXMgc2NhbGUgb2YgdGhlIGdyYXBoLlxyXG4gICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgKi9cclxuICBzZWxmLnpvb21JbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX3VwZGF0ZVNjYWxlKHtcclxuICAgICAgeDogX3NjYWxlLnggKyBfc2NhbGVTdGVwLFxyXG4gICAgICB5OiBfc2NhbGUueSArIF9zY2FsZVN0ZXBcclxuICAgIH0pO1xyXG4gICAgX2RlbGF5ZWRSZWRyYXcodW5kZWZpbmVkLCAoKSA9PiB7XHJcbiAgICAgIF9saW1pdFZpZXdQb3J0c1Bvc3Rpb25zKF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkpO1xyXG4gICAgICBzZWxmLnRyaWdnZXIoXCJzY2FsZS1jaGFuZ2VkXCIsIF9zY2FsZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEZWNyZWFzZXMgc2NhbGUgb2YgdGhlIGdyYXBoLlxyXG4gICAqIEFuZCByZWRyYXcgaXQgYWZ0ZXIgdGhhdC5cclxuICAgKi9cclxuICBzZWxmLnpvb21PdXQgPSBmdW5jdGlvbigpIHtcclxuICAgIF91cGRhdGVTY2FsZSh7XHJcbiAgICAgIHg6IF9zY2FsZS54IC0gX3NjYWxlU3RlcCxcclxuICAgICAgeTogX3NjYWxlLnkgLSBfc2NhbGVTdGVwXHJcbiAgICB9KTtcclxuICAgIF9kZWxheWVkUmVkcmF3KHVuZGVmaW5lZCwgKCkgPT4ge1xyXG4gICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgICAgc2VsZi50cmlnZ2VyKFwic2NhbGUtY2hhbmdlZFwiLCBfc2NhbGUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVhc2VzIHNjYWxlIG9mIHRoZSBncmFwaC5cclxuICAgKiBBbmQgcmVkcmF3IGl0IGFmdGVyIHRoYXQuXHJcbiAgICovXHJcbiAgc2VsZi56b29tVG9GaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgY29uc3Qgbm9kZUJvdW5kcyA9IG92ZXJWaWV3RnJhbWUubm9kZUJvdW5kcztcclxuICAgIGNvbnN0IHdpZHRoID0gX3BhcGVyLmVsLmNsaWVudFdpZHRoIC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBfcGFwZXIuZWwuY2xpZW50SGVpZ2h0IC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcblxyXG4gICAgY29uc3Qgc2NhbGUgPSBvdmVyVmlld0ZyYW1lLnNjYWxlO1xyXG4gICAgY29uc3QgbmVjZXNzYXJ5U2l6ZSA9IGdsb2JhbFRvU2NhbGVkU2l6ZShcclxuICAgICAge1xyXG4gICAgICAgIHdpZHRoOiBub2RlQm91bmRzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogbm9kZUJvdW5kcy5oZWlnaHRcclxuICAgICAgfSxcclxuICAgICAgc2NhbGVcclxuICAgICk7XHJcbiAgICBjb25zdCB4UmF0aW8gPVxyXG4gICAgICB3aWR0aCAvIChuZWNlc3NhcnlTaXplLndpZHRoICsgcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueCAqIDIpO1xyXG4gICAgY29uc3QgeVJhdGlvID1cclxuICAgICAgaGVpZ2h0IC8gKG5lY2Vzc2FyeVNpemUuaGVpZ2h0ICsgcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueSAqIDIpO1xyXG4gICAgY29uc3QgbWluUmF0aW8gPSBNYXRoLm1pbih4UmF0aW8sIHlSYXRpbyk7XHJcbiAgICBfdXBkYXRlU2NhbGUoe1xyXG4gICAgICB4OiBfc2NhbGUueCAqIG1pblJhdGlvLFxyXG4gICAgICB5OiBfc2NhbGUueSAqIG1pblJhdGlvXHJcbiAgICB9KTtcclxuICAgIF9kZWxheWVkUmVkcmF3KHVuZGVmaW5lZCwgKCkgPT4ge1xyXG4gICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgICAgc2VsZi50cmlnZ2VyKFwic2NhbGUtY2hhbmdlZFwiLCBfc2NhbGUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSXQgY2hhbmdlcyBvcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGguXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIC0gVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgKiBAbWV0aG9kXHJcbiAgICovXHJcbiAgc2VsZi5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XHJcbiAgICBfb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgIF9yZWRyYXcoKTtcclxuICAgIF92aWV3RnJhbWVzVUkuc2V0T3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIFZpZXdGcmFtZXNcclxuICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119XHJcbiAgICovXHJcbiAgc2VsZi5nZXRWaWV3RnJhbWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9uZSBWaWV3RnJhbWUgYnkgaWRcclxuICAgKiBAbWVtYmVyb2YgTGluZWFnZURpYWdyYW1cclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkXHJcbiAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAqL1xyXG4gIHNlbGYuZ2V0Vmlld0ZyYW1lQnlJZCA9IGZ1bmN0aW9uKHZpZXdGcmFtZUlkKSB7XHJcbiAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgb25lIFZpZXdGcmFtZSBieSBpZFxyXG4gICAqIEBtZW1iZXJvZiBMaW5lYWdlRGlhZ3JhbVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICovXHJcbiAgc2VsZi5nZXRPdmVyVmlld0ZyYW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuICB9O1xyXG5cclxuICBzZWxmLnNldE1hc2sgPSBmdW5jdGlvbihtYXNrKSB7XHJcbiAgICBfbWFzayA9IG1hc2s7XHJcbiAgICBfcmVkcmF3KCk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5nZXRNYXNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX21hc2s7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5pc0Z1bGxTY3JlZW5Nb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gX3ZpZXdNYW5hZ2VyLmlzRnVsbFNjcmVlbk1vZGUoKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBfcmVkcmF3KG9wdGlvbnMpIHtcclxuICAgIF9yb3V0aW5nTWFuYWdlci5yZXNldFJvdXRpbmcoKTtcclxuICAgIF9yb3V0aW5nTWFuYWdlci5zZXRCb3VuZHMoe1xyXG4gICAgICB4OiBGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoLFxyXG4gICAgICB5OiBGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoLFxyXG4gICAgICB3aWR0aDpcclxuICAgICAgICBfcGFwZXIuZWwuY2xpZW50V2lkdGggLVxyXG4gICAgICAgIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgIGhlaWdodDpcclxuICAgICAgICBfcGFwZXIuZWwuY2xpZW50SGVpZ2h0IC1cclxuICAgICAgICAoRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCkgKiAyXHJcbiAgICB9KTtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB7XHJcbiAgICAgIHZpZXdGcmFtZXM6IG9wdGlvbnMudmlld0ZyYW1lcyxcclxuICAgICAgZnVsbFNjcmVlbk1vZGU6IG9wdGlvbnMuZnVsbFNjcmVlbk1vZGUsXHJcbiAgICAgIHNlbGVjdGVkRWxlbWVudDogX3NlbGVjdGVkRWxlbWVudCxcclxuICAgICAgcGF0aDogX3BhdGgsXHJcbiAgICAgIG1hc2s6IF9tYXNrLFxyXG4gICAgICBxdWlja1VwZGF0ZTogb3B0aW9ucy5xdWlja1VwZGF0ZSxcclxuICAgICAgdXBkYXRlQm91bmRzOiBvcHRpb25zLnVwZGF0ZUJvdW5kcyxcclxuICAgICAgcGFwZXJPcHRpb25zOiB7XHJcbiAgICAgICAgb3JpZW50YXRpb246IF9vcmllbnRhdGlvbixcclxuICAgICAgICB3aWR0aDogX3BhcGVyLmVsLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogX3BhcGVyLmVsLmNsaWVudEhlaWdodCxcclxuICAgICAgICBzY2FsZTogX3NjYWxlXHJcbiAgICAgIH0sXHJcbiAgICAgIGVsZW1lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgZWxlbWVudFNpemU6IG9wdGlvbnMuZWxlbWVudFNpemVcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUpIGNsZWFyVGltZW91dChfdGltZW91dFJlZik7XHJcblxyXG4gICAgX2dyYXBoLnN0YXJ0QmF0Y2goXCJyZW1vdmVcIik7XHJcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSkgX2dyYXBoLnJlbW92ZUNlbGxzKF9ncmFwaC5nZXRMaW5rcygpKTtcclxuXHJcbiAgICBsZXQgcmVuZGVyRGF0YSA9IF92aWV3TWFuYWdlci5wcmVwYXJlUmVuZGVyRGF0YShyZW5kZXJPcHRpb25zKTtcclxuXHJcbiAgICByZW5kZXJEYXRhID0gX3JlbW92ZURlcHJlY2F0ZWRBbmRFeGlzdGluZ0NlbGxzKHJlbmRlckRhdGEpO1xyXG4gICAgX2dyYXBoLnN0b3BCYXRjaChcInJlbW92ZVwiKTtcclxuXHJcbiAgICBfZ3JhcGguc3RhcnRCYXRjaChcImFkZFwiKTtcclxuICAgIF9ncmFwaC5hZGRDZWxscyhyZW5kZXJEYXRhKTtcclxuICAgIF9ncmFwaC5zdG9wQmF0Y2goXCJhZGRcIik7XHJcblxyXG4gICAgX3VwZGF0ZUhpZ2hsaWdodGluZyhyZW5kZXJEYXRhKTtcclxuICAgIF92aWV3RnJhbWVzVUkucmVmcmVzaCgpO1xyXG4gICAgLy8gY29uc29sZS5sb2coJ1JlZHJhdycgKyAocmVuZGVyT3B0aW9ucy5xdWlja1VwZGF0ZSA/ICcgKHF1aWNrKScgOiAnJykpO1xyXG4gIH1cclxuXHJcbiAgbGV0IF90aW1lb3V0UmVmID0gMDtcclxuICBsZXQgX2Jsb2NrTXVsdGlwbGVRdWVyaWVzID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gX2RlbGF5ZWRSZWRyYXcob3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIGlmIChfYmxvY2tNdWx0aXBsZVF1ZXJpZXMpIHJldHVybjtcclxuICAgIGNsZWFyVGltZW91dChfdGltZW91dFJlZik7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBjb25zdCBxdWlja09wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcclxuICAgIHF1aWNrT3B0aW9ucy5xdWlja1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgX2Jsb2NrTXVsdGlwbGVRdWVyaWVzID0gdHJ1ZTtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIF9ibG9ja011bHRpcGxlUXVlcmllcyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgICBfcmVkcmF3KHF1aWNrT3B0aW9ucyk7XHJcblxyXG4gICAgX3RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgb3B0aW9ucy5xdWlja1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhgUmVkcmF3IChkZWxheTpzdGFydC0ke190aW1lb3V0UmVmfSkgPT4gYCk7XHJcbiAgICAgIF9yZWRyYXcob3B0aW9ucyk7XHJcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgIH0sIDE1MCk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhgUmVkcmF3IChkZWxheTp3YWl0LSR7X3RpbWVvdXRSZWZ9KWApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3JlbW92ZURlcHJlY2F0ZWRBbmRFeGlzdGluZ0NlbGxzKG5ld0NlbGxzKSB7XHJcbiAgICBjb25zdCBvbGRDZWxscyA9IF9ncmFwaC5nZXRDZWxscygpO1xyXG4gICAgY29uc3QgY2VsbE1hcCA9IHt9O1xyXG5cclxuICAgIG5ld0NlbGxzLmZvckVhY2goY2VsbCA9PiB7XHJcbiAgICAgIGNlbGxNYXBbY2VsbC5pZF0gPSBjZWxsO1xyXG4gICAgfSk7XHJcbiAgICBvbGRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xyXG4gICAgICBpZiAoIWNlbGxNYXBbY2VsbC5pZF0pIHtcclxuICAgICAgICBjZWxsLnJlbW92ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGV0ZSBjZWxsTWFwW2NlbGwuaWRdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY2VsbE1hcCkubWFwKGtleSA9PiBjZWxsTWFwW2tleV0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3VwZGF0ZUhpZ2hsaWdodGluZyhjZWxscykge1xyXG4gICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IHtcclxuICAgICAgaWYgKGNlbGwucmVmcmVzaEhpZ2hsaWdodGluZykge1xyXG4gICAgICAgIGNlbGwucmVmcmVzaEhpZ2hsaWdodGluZygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9jb21iaW5lKCkge1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50SXNOb2RlID0gX3NlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIE5vZGU7XHJcbiAgICBpZiAoc2VsZWN0ZWRFbGVtZW50SXNOb2RlKSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IF9zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMuc291cmNlTWFwO1xyXG4gICAgICBjb25zdCB0YXJnZXRNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLnRhcmdldE1hcDtcclxuXHJcbiAgICAgIGNvbnN0IHJlbGF0aXZlTGlua3MgPSAoc291cmNlTWFwW3NlbGVjdGVkTm9kZS5pZF0gfHwgW10pLmNvbmNhdChcclxuICAgICAgICB0YXJnZXRNYXBbc2VsZWN0ZWROb2RlLmlkXSB8fCBbXVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCByZWxhdGl2ZU5vZGVzID0gcmVsYXRpdmVMaW5rcy5tYXAobCA9PiB7XHJcbiAgICAgICAgaWYgKGwubW9kZWwuc291cmNlICE9PSBzZWxlY3RlZE5vZGUuaWQpIHJldHVybiBub2RlTWFwW2wubW9kZWwuc291cmNlXTtcclxuICAgICAgICBlbHNlIGlmIChsLm1vZGVsLnRhcmdldCAhPT0gc2VsZWN0ZWROb2RlLmlkKVxyXG4gICAgICAgICAgcmV0dXJuIG5vZGVNYXBbbC5tb2RlbC50YXJnZXRdO1xyXG4gICAgICAgIGVsc2UgaWYgKGwubW9kZWwuc291cmNlID09PSBsLm1vZGVsLnRhcmdldClcclxuICAgICAgICAgIHJldHVybiBub2RlTWFwW2wubW9kZWwuc291cmNlXTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBuZXdQb3NpdGlvbnMgPSBjb21iaW5lT3BlcmF0aW9uKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHNlbGVjdGVkTm9kZTogc2VsZWN0ZWROb2RlLFxyXG4gICAgICAgICAgcmVsYXRpdmVMaW5rczogcmVsYXRpdmVMaW5rcyxcclxuICAgICAgICAgIHJlbGF0aXZlTm9kZXM6IHJlbGF0aXZlTm9kZXMsXHJcbiAgICAgICAgICBzY2FsZTogX3NjYWxlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJhbWV0ZXJzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWVJZCA9IGdldFZpZXdGcmFtZUlkRm9yTm9kZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgICBjb25zdCBuZXdQYXRoID0ge307XHJcbiAgICAgIGNvbnN0IGFmZmVjdGVkVmlld0ZyYW1lc01hcCA9IHt9O1xyXG4gICAgICByZWxhdGl2ZU5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VyUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgbm9kZS5tb2RlbC5wb3NpdGlvbiA9IG5ld1Bvc2l0aW9uc1tub2RlLmlkXTtcclxuICAgICAgICBfZGF0YUNvbnRhaW5lci51cGRhdGVab25lc0Zvck5vZGUobm9kZSwgY3VyUG9zaXRpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlKTtcclxuICAgICAgICBhZmZlY3RlZFZpZXdGcmFtZXNNYXBbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZTtcclxuICAgICAgICBub2RlLnZpZXdGcmFtZU93bmVySWQgPSB0YXJnZXRWaWV3RnJhbWVJZDtcclxuICAgICAgICBuZXdQYXRoW25vZGUuaWRdID0gbm9kZTtcclxuICAgICAgfSk7XHJcbiAgICAgIG5ld1BhdGhbc2VsZWN0ZWROb2RlLmlkXSA9IHNlbGVjdGVkTm9kZTtcclxuXHJcbiAgICAgIHJlbGF0aXZlTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICBuZXdQYXRoW2xpbmsuaWRdID0gbGluaztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBfcGF0aCA9IG5ld1BhdGg7XHJcblxyXG4gICAgICBjb25zdCBhZmZlY3RlZFZpZXdGcmFtZXMgPSBPYmplY3Qua2V5cyhhZmZlY3RlZFZpZXdGcmFtZXNNYXApLm1hcChcclxuICAgICAgICBrZXkgPT4gYWZmZWN0ZWRWaWV3RnJhbWVzTWFwW2tleV1cclxuICAgICAgKTtcclxuICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IGFmZmVjdGVkVmlld0ZyYW1lcywgdXBkYXRlQm91bmRzOiB0cnVlIH0pO1xyXG4gICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhhZmZlY3RlZFZpZXdGcmFtZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgZnJvbSB0aGUgcGFwZXIgYmVzaWRlcyB2aWV3RnJhbWVzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9jbGVhcigpIHtcclxuICAgIF91bnNlbGVjdCgpO1xyXG4gICAgX2dyYXBoLmNsZWFyKCk7XHJcbiAgICBfdmlld01hbmFnZXIgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWZpbmUgZGF0YSBjb250YWluZXIgd2l0aCBub2RlcyBhbmQgbGlua3MgZm9yIHRoZSBKb2ludGpzIHZpZXcgKHZpZXctMilcclxuICAgKiBhbmQgcGF0aCBpdCB0byB0aGUgZm9ybXNcclxuICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXIgLSBkYXRhIGZvciB0aGUgZ3JhcGhcclxuICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXMgLSB2aWV3IGZyYW1lc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9zZXREYXRhKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpIHtcclxuICAgIF9jbGVhcigpO1xyXG5cclxuICAgIF9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcclxuICAgIF9yb3V0aW5nTWFuYWdlciA9IG5ldyBSb3V0aW5nTWFuYWdlcihcclxuICAgICAge1xyXG4gICAgICAgIGxpbmtzOiBfZGF0YUNvbnRhaW5lci5saW5rcyxcclxuICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgIHg6IEZSQU1FX09VVF9NQVJHSU4gKyBwYXJhbWV0ZXJzLmZyYW1lQm9yZGVyV2lkdGgsXHJcbiAgICAgICAgICB5OiBGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgd2lkdGg6XHJcbiAgICAgICAgICAgIF9wYXBlci5lbC5jbGllbnRXaWR0aCAtXHJcbiAgICAgICAgICAgIChGUkFNRV9PVVRfTUFSR0lOICsgcGFyYW1ldGVycy5mcmFtZUJvcmRlcldpZHRoKSAqIDIsXHJcbiAgICAgICAgICBoZWlnaHQ6XHJcbiAgICAgICAgICAgIF9wYXBlci5lbC5jbGllbnRIZWlnaHQgLVxyXG4gICAgICAgICAgICAoRlJBTUVfT1VUX01BUkdJTiArIHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCkgKiAyXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBwYXJhbWV0ZXJzXHJcbiAgICApO1xyXG4gICAgX3ZpZXdNYW5hZ2VyID0gbmV3IFZpZXdNYW5hZ2VyKFxyXG4gICAgICB7XHJcbiAgICAgICAgZGF0YUNvbnRhaW5lcjogZGF0YUNvbnRhaW5lcixcclxuICAgICAgICB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzLFxyXG4gICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiBfZnVsbFNjcmVlbk1vZGVcclxuICAgICAgfSxcclxuICAgICAgcGFyYW1ldGVyc1xyXG4gICAgKTtcclxuXHJcbiAgICBfdmlld0ZyYW1lc1VJID0gX2NyZWF0ZVZpZXdGcmFtZXNVSShfdmlld01hbmFnZXIpO1xyXG5cclxuICAgIF92aWV3TWFuYWdlci5vbihcImNoYW5nZS12aWV3LXBvcnQtcG9zaXRpb25cIiwgdmlld0ZyYW1lID0+IHtcclxuICAgICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdLCBxdWlja1VwZGF0ZTogdHJ1ZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9jb3JyZWN0U2NhbGUoKTtcclxuICAgIF9yZWRyYXcoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZFxyXG4gICAqIEBmaXJlcyB2aWV3LWZyYW1lcy1zaXplLW9yLXBvc2l0aW9uLWNoYW5nZWRcclxuICAgKi9cclxuICBmdW5jdGlvbiBfb3BlblZpZXdGcmFtZSh2aWV3RnJhbWVJZCkge1xyXG4gICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgaWYgKCF2aWV3RnJhbWUpIHJldHVybjtcclxuXHJcbiAgICB2aWV3RnJhbWUuZXhwYW5kZWQgPSB0cnVlO1xyXG4gICAgY29uc3Qgdmlld0ZyYW1lcyA9IFt2aWV3RnJhbWVdO1xyXG5cclxuICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG5cclxuICAgIHNlbGYudHJpZ2dlcihcInZpZXctZnJhbWVzLXN0YXRlLWNoYW5nZWRcIiwgW3ZpZXdGcmFtZXNdKTtcclxuXHJcbiAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhcclxuICAgICAgX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKS5maWx0ZXIodmYgPT4gdmYuYWN0aXZlKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9jbG9zZVZpZXdGcmFtZSh2aWV3RnJhbWVJZCkge1xyXG4gICAgY29uc3Qgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lSWQpO1xyXG4gICAgaWYgKCF2aWV3RnJhbWUpIHJldHVybjtcclxuXHJcbiAgICB2aWV3RnJhbWUuZXhwYW5kZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBbdmlld0ZyYW1lXTtcclxuXHJcbiAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogdmlld0ZyYW1lcyB9KTtcclxuXHJcbiAgICBzZWxmLnRyaWdnZXIoXCJ2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkXCIsIFt2aWV3RnJhbWVzXSk7XHJcblxyXG4gICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoXHJcbiAgICAgIF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCkuZmlsdGVyKHZmID0+IHZmLmFjdGl2ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2V0RnVsbFNjcmVlbk1vZGUodmFsdWUpIHtcclxuICAgIF9mdWxsU2NyZWVuTW9kZSA9IHZhbHVlO1xyXG5cclxuICAgIGlmICghX2Z1bGxTY3JlZW5Nb2RlKSB7XHJcbiAgICAgIF9zY2FsZSA9IHtcclxuICAgICAgICB4OiBNYXRoLm1heChNYXRoLm1pbihfc2NhbGUueCwgX3NjYWxlQm91bmRzLm1heCksIF9zY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgIHk6IE1hdGgubWF4KE1hdGgubWluKF9zY2FsZS55LCBfc2NhbGVCb3VuZHMubWF4KSwgX3NjYWxlQm91bmRzLm1pbilcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBfcmVkcmF3KHsgZnVsbFNjcmVlbk1vZGU6IHZhbHVlIH0pO1xyXG5cclxuICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lcygpO1xyXG4gICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc3RhdGUtY2hhbmdlZFwiLCBbdmlld0ZyYW1lc10pO1xyXG5cclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICBjb25zdCBvdmVyVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKTtcclxuICAgICAgX2xpbWl0Vmlld1BvcnRQb3N0aW9uKG92ZXJWaWV3RnJhbWUsICgpID0+IHtcclxuICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtbb3ZlclZpZXdGcmFtZV1dKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyh2aWV3RnJhbWVzLmZpbHRlcih2ZiA9PiB2Zi5hY3RpdmUpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYW5kIGxpbWl0cyB2YWx1ZSBvZiB0aGUgc2NhbGUgb2YgdGhlIGdyYXBoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICogPT09PT09PT09PT09PT09PT1cclxuICAgKiBAZmlyZXMgc2NhbGUtY2hhbmdlZFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF91cGRhdGVTY2FsZShzY2FsZSkge1xyXG4gICAgY29uc3QgZnVsbFNjcmVlbiA9IF92aWV3TWFuYWdlci5pc0Z1bGxTY3JlZW5Nb2RlKCk7XHJcblxyXG4gICAgc2NhbGUgPSBzY2FsZSB8fCBfc2NhbGU7XHJcbiAgICBpZiAoZnVsbFNjcmVlbikge1xyXG4gICAgICBfc2NhbGUgPSB7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoXHJcbiAgICAgICAgICBNYXRoLm1pbihzY2FsZS54LCBfb3ZlclZpZXdTY2FsZUJvdW5kcy5tYXgpLFxyXG4gICAgICAgICAgX292ZXJWaWV3U2NhbGVCb3VuZHMubWluXHJcbiAgICAgICAgKSxcclxuICAgICAgICB5OiBNYXRoLm1heChcclxuICAgICAgICAgIE1hdGgubWluKHNjYWxlLnksIF9vdmVyVmlld1NjYWxlQm91bmRzLm1heCksXHJcbiAgICAgICAgICBfb3ZlclZpZXdTY2FsZUJvdW5kcy5taW5cclxuICAgICAgICApXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfc2NhbGUgPSB7XHJcbiAgICAgICAgeDogTWF0aC5tYXgoTWF0aC5taW4oc2NhbGUueCwgX3NjYWxlQm91bmRzLm1heCksIF9zY2FsZUJvdW5kcy5taW4pLFxyXG4gICAgICAgIHk6IE1hdGgubWF4KE1hdGgubWluKHNjYWxlLnksIF9zY2FsZUJvdW5kcy5tYXgpLCBfc2NhbGVCb3VuZHMubWluKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9zY2FsZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9jb3JyZWN0U2NhbGUoKSB7XHJcbiAgICBjb25zdCB2aWV3RnJhbWVzTnVtYmVyID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKS5sZW5ndGg7XHJcbiAgICBjb25zdCB3aWR0aCA9IF9wYXBlci5lbC5jbGllbnRXaWR0aCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gX3BhcGVyLmVsLmNsaWVudEhlaWdodCAtIEZSQU1FX09VVF9NQVJHSU4gKiAyO1xyXG5cclxuICAgIGNvbnN0IGN1dGVkV2lkdGggPSB3aWR0aCAtIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTICogKHZpZXdGcmFtZXNOdW1iZXIgLSAxKTtcclxuICAgIGNvbnN0IGN1dGVkSGVpZ2h0ID1cclxuICAgICAgaGVpZ2h0IC0gRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgKiAodmlld0ZyYW1lc051bWJlciAtIDEpO1xyXG5cclxuICAgIGNvbnN0IG1pbkhvck51bSA9IDQ7IC8vIGl0J3MgZm9yIG1heCBzY2FsZSBiZWNhdXNlIHdoZW4gd2UgaGF2ZSBtYXggc2NhbGUgd2UgYWxzbyBoYXZlIG1pbmltdW0gbm9kZSBudW1iZXJcclxuICAgIGNvbnN0IG1pblZlcnROdW0gPSAzO1xyXG5cclxuICAgIGNvbnN0IG1heEhvck51bSA9IDg7IC8vIGl0J3MgZm9yIG1pbiBzY2FsZSBiZWNhdXNlIHdoZW4gd2UgaGF2ZSBtaW4gc2NhbGUgd2UgYWxzbyBoYXZlIG1heGltdW0gbm9kZSBudW1iZXJcclxuICAgIGNvbnN0IG1heFZlcnROdW0gPSA3O1xyXG5cclxuICAgIGNvbnN0IG5vZGVTaXplID0ge1xyXG4gICAgICB3aWR0aDogcGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCxcclxuICAgICAgaGVpZ2h0OiBwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLmhlaWdodFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHN0ZXAgPSB7XHJcbiAgICAgIHg6IHBhcmFtZXRlcnMubGF5b3V0U3RlcC54LFxyXG4gICAgICB5OiBwYXJhbWV0ZXJzLmxheW91dFN0ZXAueVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtaW5TY2FsZSA9IGdldFNjYWxlRm9yTm9kZU51bWJlcihtYXhIb3JOdW0sIG1heFZlcnROdW0pO1xyXG4gICAgY29uc3QgbWF4U2NhbGUgPSBnZXRTY2FsZUZvck5vZGVOdW1iZXIobWluSG9yTnVtLCBtaW5WZXJ0TnVtKTtcclxuXHJcbiAgICAvLyBwYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSA9IHNjYWxlO1xyXG4gICAgX3NjYWxlQm91bmRzLm1pbiA9IE1hdGgubWF4KG1pblNjYWxlLngsIG1pblNjYWxlLnkpO1xyXG4gICAgX3NjYWxlQm91bmRzLm1heCA9IE1hdGgubWluKG1heFNjYWxlLngsIG1heFNjYWxlLnkpO1xyXG4gICAgLy8gX3NldFNjYWxlKHNjYWxlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTY2FsZUZvck5vZGVOdW1iZXIoaG9yTnVtLCB2ZXJ0TnVtKSB7XHJcbiAgICAgIGNvbnN0IGN1clhWYWx1ZSA9IGhvck51bSAqIG5vZGVTaXplLndpZHRoICsgKGhvck51bSAtIDEpICogc3RlcC54O1xyXG4gICAgICBjb25zdCBjdXJZVmFsdWUgPSB2ZXJ0TnVtICogbm9kZVNpemUuaGVpZ2h0ICsgKGhvck51bSAtIDEpICogc3RlcC55O1xyXG5cclxuICAgICAgbGV0IHNjYWxlO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgTWF0aC5hYnMoY3V0ZWRXaWR0aCAtIGN1clhWYWx1ZSkgPj0gTWF0aC5hYnMoY3V0ZWRIZWlnaHQgLSBjdXJZVmFsdWUpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHNjYWxlID0ge1xyXG4gICAgICAgICAgeDogY3V0ZWRXaWR0aCAvIGN1clhWYWx1ZSxcclxuICAgICAgICAgIHk6IGN1dGVkV2lkdGggLyBjdXJYVmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjYWxlID0ge1xyXG4gICAgICAgICAgeDogY3V0ZWRIZWlnaHQgLyBjdXJZVmFsdWUsXHJcbiAgICAgICAgICB5OiBjdXRlZEhlaWdodCAvIGN1cllWYWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzY2FsZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9maW5kTmV4dE5vZGUoZGlyZWN0aW9uKSB7XHJcbiAgICBpZiAoIV9zZWxlY3RlZEVsZW1lbnQpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBsZXQgY3VyUG9zO1xyXG4gICAgaWYgKF9zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgIGN1clBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihfc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHNvdXJjZSA9IF9kYXRhQ29udGFpbmVyLm1hcHMubm9kZU1hcFtfc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnNvdXJjZV07XHJcbiAgICAgIGNvbnN0IHNvdXJjZVBvcyA9IHNvdXJjZS5tb2RlbC5wb3NpdGlvbjtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW19zZWxlY3RlZEVsZW1lbnQubW9kZWwudGFyZ2V0XTtcclxuICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGFyZ2V0Lm1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uVVApIHtcclxuICAgICAgICBpZiAoc291cmNlLm1vZGVsLnkgPCB0YXJnZXQubW9kZWwueSkge1xyXG4gICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRE9XTikge1xyXG4gICAgICAgIGlmIChzb3VyY2UubW9kZWwueSA+IHRhcmdldC5tb2RlbC55KSB7XHJcbiAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZVBvcy54IDwgdGFyZ2V0UG9zLngpIHtcclxuICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlJJR0hUKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZVBvcy54ID4gdGFyZ2V0UG9zLngpIHtcclxuICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByZXZOb2RlcyA9IFtdOyAvLyB0byBicmVhayBjeWNsaW5nXHJcbiAgICByZXR1cm4gZ2V0TmV4dE5vZGUoY3VyUG9zKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXROZXh0Tm9kZShjdXJQb3MpIHtcclxuICAgICAgZnVuY3Rpb24gZGlmZlRvTm9kZShub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB4OiBjdXJQb3MueCAtIG5vZGVQb3NpdGlvbi54LFxyXG4gICAgICAgICAgeTogY3VyUG9zLnkgLSBub2RlUG9zaXRpb24ueVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IFhfU1RFUCA9IHBhcmFtZXRlcnMuZGF0YVpvbmVTaXplLndpZHRoO1xyXG4gICAgICBjb25zdCBZX1NURVAgPSBwYXJhbWV0ZXJzLmRhdGFab25lU2l6ZS5oZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSB7XHJcbiAgICAgICAgeDogY3VyUG9zLnggLSBYX1NURVAgLyAyLFxyXG4gICAgICAgIHk6IGN1clBvcy55IC0gWV9TVEVQIC8gMixcclxuICAgICAgICB3aWR0aDogWF9TVEVQLFxyXG4gICAgICAgIGhlaWdodDogWV9TVEVQXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBub2RlcyA9IF9kYXRhQ29udGFpbmVyXHJcbiAgICAgICAgLmdldEVsZW1lbnRzRm9yUmVjdGFuZ2xlKHJlY3QpXHJcbiAgICAgICAgLm5vZGVzLmZpbHRlcihuID0+IHByZXZOb2Rlcy5pbmRleE9mKG4pID09PSAtMSk7XHJcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBfc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICBwcmV2Tm9kZXMgPSBub2RlcztcclxuXHJcbiAgICAgIGxldCBuZXh0RWxlbWVudHM7XHJcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5VUCkge1xyXG4gICAgICAgIG5leHRFbGVtZW50cyA9IG5vZGVzLmZpbHRlcihuID0+IHtcclxuICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaWZmVG9Ob2RlKG4pO1xyXG4gICAgICAgICAgcmV0dXJuIGRpc3QueSA+IDAgJiYgTWF0aC5hYnMoZGlzdC55KSA+IE1hdGguYWJzKGRpc3QueCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG5leHRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiBnZXROZXh0Tm9kZSh7XHJcbiAgICAgICAgICAgIHg6IGN1clBvcy54LFxyXG4gICAgICAgICAgICB5OiBjdXJQb3MueSAtIFlfU1RFUFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkRPV04pIHtcclxuICAgICAgICBuZXh0RWxlbWVudHMgPSBub2Rlcy5maWx0ZXIobiA9PiB7XHJcbiAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgIHJldHVybiBkaXN0LnkgPCAwICYmIE1hdGguYWJzKGRpc3QueSkgPiBNYXRoLmFicyhkaXN0LngpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2V0TmV4dE5vZGUoe1xyXG4gICAgICAgICAgICB4OiBjdXJQb3MueCxcclxuICAgICAgICAgICAgeTogY3VyUG9zLnkgKyBZX1NURVBcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XHJcbiAgICAgICAgbmV4dEVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKG4gPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGlzdCA9IGRpZmZUb05vZGUobik7XHJcbiAgICAgICAgICByZXR1cm4gZGlzdC54ID4gMCAmJiBNYXRoLmFicyhkaXN0LnkpIDwgTWF0aC5hYnMoZGlzdC54KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmV4dEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdldE5leHROb2RlKHtcclxuICAgICAgICAgICAgeDogY3VyUG9zLnggLSBYX1NURVAsXHJcbiAgICAgICAgICAgIHk6IGN1clBvcy55XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUklHSFQpIHtcclxuICAgICAgICBuZXh0RWxlbWVudHMgPSBub2Rlcy5maWx0ZXIobiA9PiB7XHJcbiAgICAgICAgICBjb25zdCBkaXN0ID0gZGlmZlRvTm9kZShuKTtcclxuICAgICAgICAgIHJldHVybiBkaXN0LnggPCAwICYmIE1hdGguYWJzKGRpc3QueSkgPCBNYXRoLmFicyhkaXN0LngpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChuZXh0RWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2V0TmV4dE5vZGUoe1xyXG4gICAgICAgICAgICB4OiBjdXJQb3MueCArIFhfU1RFUCxcclxuICAgICAgICAgICAgeTogY3VyUG9zLnlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBuZXh0RWxlbWVudHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFQb3MgPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24oYSk7XHJcbiAgICAgICAgY29uc3QgYlBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihiKTtcclxuICAgICAgICBjb25zdCBhRGlzdCA9IGdldERpc3QoYVBvcywgY3VyUG9zKTtcclxuICAgICAgICBjb25zdCBiRGlzdCA9IGdldERpc3QoYlBvcywgY3VyUG9zKTtcclxuXHJcbiAgICAgICAgaWYgKGFEaXN0ID4gYkRpc3QpIHtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYURpc3QgPCBiRGlzdCkge1xyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbmV4dEVsZW1lbnRzWzBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlcyBvbiBwYXBlciBhbmQgS2V5Ym9hcmQgZXZlbnRzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9zdWJzY3JpYmVPbkV2ZW50cygpIHtcclxuICAgIGxldCBxdWVyeUFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgIF9wYXBlci5vbihcImxpbms6b3B0aW9uc1wiLCAoY2VsbFZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpbmtUeXBlID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKFwibGlua1R5cGVcIik7XHJcbiAgICAgIHNlbGYudHJpZ2dlcihcImxpbmstb3B0aW9ucy1jbGlja1wiLCB7XHJcbiAgICAgICAgbGluazogY2VsbFZpZXcubW9kZWwsXHJcbiAgICAgICAgbGlua1R5cGU6IGxpbmtUeXBlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX2tleWJvYXJkLm9uKHtcclxuICAgICAgXCJ1cCBkb3duIGxlZnQgcmlnaHRcIjogZXZ0ID0+IHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShxdWVyeUFuaW1hdGlvbkZyYW1lKTtcclxuICAgICAgICBxdWVyeUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgIF9zZWxlY3QoX2ZpbmROZXh0Tm9kZShldnQua2V5Q29kZSksIHRydWUpO1xyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX2NsaWNrQ291bnRlciA9IDA7XHJcbiAgICBfcGFwZXIub24oXCJjZWxsOnBvaW50ZXJ1cFwiLCAoY2VsbFZpZXcsIGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGlzVmlld0ZyYW1lID0gY2VsbFZpZXcubW9kZWwgaW5zdGFuY2VvZiBWaWV3RnJhbWU7XHJcbiAgICAgIGlmIChpc1ZpZXdGcmFtZSkge1xyXG4gICAgICAgIG9uU2luZ2xlQ2xpY2soY2VsbFZpZXcsIGV2ZW50KTtcclxuICAgICAgICBfY2xpY2tDb3VudGVyID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2NsaWNrQ291bnRlciA+IDEpIHtcclxuICAgICAgICAgIG9uRG91YmxlQ2xpY2soY2VsbFZpZXcsIGV2ZW50KTtcclxuICAgICAgICAgIF9jbGlja0NvdW50ZXIgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9jbGlja0NvdW50ZXIgPT09IDEpIG9uU2luZ2xlQ2xpY2soY2VsbFZpZXcsIGV2ZW50KTtcclxuICAgICAgICAgICAgX2NsaWNrQ291bnRlciA9IDA7XHJcbiAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25TaW5nbGVDbGljayhjZWxsVmlldywgZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBpc0RyYWdnaW5nID1cclxuICAgICAgICAgIE1hdGguYWJzKF9tb3VzZURvd25Qb3NpdGlvbi54IC0gZXZlbnQucGFnZVgpID4gNSB8fFxyXG4gICAgICAgICAgTWF0aC5hYnMoX21vdXNlRG93blBvc2l0aW9uLnkgLSBldmVudC5wYWdlWSk7XHJcbiAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxWaWV3Lm1vZGVsO1xyXG4gICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgVmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZChjZWxsLmlkKTtcclxuICAgICAgICAgIC8vIFZpZXdGcmFtZSBjbGlja1xyXG4gICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgIGlmICghaXNEcmFnZ2luZykgX3Vuc2VsZWN0KCk7XHJcbiAgICAgICAgICBfbGltaXRWaWV3UG9ydFBvc3Rpb24odmlld0ZyYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIF9yZWRyYXcoKTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtcclxuICAgICAgICAgICAgICBbX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQoY2VsbC5pZCldXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBOb2RlL0xpbmsgY2xpY2tcclxuICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICBjb25zdCBkcmFnZ2luZ05vZGUgPVxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nICYmXHJcbiAgICAgICAgICAgIChjZWxsIGluc3RhbmNlb2YgTm9kZSB8fCBjZWxsIGluc3RhbmNlb2YgVGVybWluYXRpb25Ob2RlKTtcclxuICAgICAgICAgIGNvbnN0IGNsaWNrVGVybWluYXRpb25Ob2RlID0gY2VsbCBpbnN0YW5jZW9mIFRlcm1pbmF0aW9uTm9kZTtcclxuICAgICAgICAgIGNvbnN0IGNsaWNrT25Ob2RlT3JMaW5rID0gIShjZWxsIGluc3RhbmNlb2YgQXNwZWN0TGluayk7IC8vIEV4Y2x1ZGUgQXNwZWN0TGlua1xyXG4gICAgICAgICAgaWYgKGRyYWdnaW5nTm9kZSkge1xyXG4gICAgICAgICAgICBfdXBkYXRlTm9kZXNQb3NpdGlvbnMoW2NlbGxdKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpY2tUZXJtaW5hdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgX3NlbGVjdChjZWxsLCB0cnVlKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpY2tPbk5vZGVPckxpbmspIHtcclxuICAgICAgICAgICAgX3NlbGVjdChjZWxsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGYudHJpZ2dlcihcImNlbGwtc2luZ2xlLWNsaWNrXCIsIGNlbGxWaWV3Lm1vZGVsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25Eb3VibGVDbGljayhjZWxsVmlldykge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjZWxsVmlldy5tb2RlbDtcclxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgIGVsZW1lbnQuc2V0KFwiZXhwYW5kZWRcIiwgIWNlbGxWaWV3Lm1vZGVsLmdldChcImV4cGFuZGVkXCIpKTtcclxuICAgICAgICAgIF91cGRhdGVOb2Rlc1Bvc2l0aW9ucyhbZWxlbWVudF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJjZWxsLWRvdWJsZS1jbGlja1wiLCBjZWxsVmlldy5tb2RlbCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBfbW91c2VEb3duUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgIF9wYXBlci5vbihcImNlbGw6cG9pbnRlcmRvd25cIiwgKGNlbGwsIGV2ZW50KSA9PiB7XHJcbiAgICAgIF9tb3VzZURvd25Qb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XHJcbiAgICAgIF9jbGlja0NvdW50ZXIrKztcclxuICAgIH0pO1xyXG5cclxuICAgIF9wYXBlci5vbihcImNlbGw6bW91c2V3aGVlbFwiLCAoY2VsbCwgZXZ0LCB4LCB5LCBkZWx0YSkgPT4ge1xyXG4gICAgICBjb25zdCBTQ1JPTExfU1RFUCA9IDEwMDtcclxuICAgICAgbGV0IHZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWVGcmFtZUJ5U2NyZWVuUG9pbnQoeyB4OiB4LCB5OiB5IH0pO1xyXG5cclxuICAgICAgaWYgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGlmIChldnQuc2hpZnRLZXkpIHtcclxuICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnggKz0gKGRlbHRhIDwgMCA/IDEgOiAtMSkgKiBTQ1JPTExfU1RFUDtcclxuICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uID0gbGltaXRQb2ludFBvc2l0aW9uKFxyXG4gICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbixcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBfZGVsYXllZFJlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdIH0sICgpID0+IHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtbdmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQuY3RybEtleSkge1xyXG4gICAgICAgICAgY29uc3QgZGlmZiA9IGRlbHRhID4gMCA/IF9zY2FsZVN0ZXAgOiAtX3NjYWxlU3RlcDtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlID0ge1xyXG4gICAgICAgICAgICB4OiBfc2NhbGUueCArIGRpZmYsXHJcbiAgICAgICAgICAgIHk6IF9zY2FsZS55ICsgZGlmZlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIF91cGRhdGVTY2FsZShzY2FsZSk7XHJcbiAgICAgICAgICBfZGVsYXllZFJlZHJhdyh1bmRlZmluZWQsICgpID0+IHtcclxuICAgICAgICAgICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZXMoKSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcInNjYWxlLWNoYW5nZWRcIiwgc2NhbGUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnkgKz0gKGRlbHRhIDwgMCA/IDEgOiAtMSkgKiBTQ1JPTExfU1RFUDtcclxuICAgICAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uID0gbGltaXRQb2ludFBvc2l0aW9uKFxyXG4gICAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbixcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHNcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBfZGVsYXllZFJlZHJhdyh7IHZpZXdGcmFtZXM6IFt2aWV3RnJhbWVdIH0sICgpID0+IHtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtbdmlld0ZyYW1lXV0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB3aW5kb3cub25yZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIF9jb3JyZWN0U2NhbGUoKTtcclxuICAgICAgX2RlbGF5ZWRSZWRyYXcodW5kZWZpbmVkLCAoKSA9PiB7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwic2NhbGUtY2hhbmdlZFwiKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3VwZGF0ZU5vZGVzUG9zaXRpb25zKG5vZGVzKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lcyA9IFtdO1xyXG4gICAgY29uc3Qgb3ZlclZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcblxyXG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcclxuICAgICAgY29uc3Qgbm9kZSA9IGdldEJhc2VFbGVtZW50KG4pO1xyXG4gICAgICBjb25zdCBpc1Rlcm1pbmF0aW9uTm9kZSA9IG4gaW5zdGFuY2VvZiBUZXJtaW5hdGlvbk5vZGU7XHJcbiAgICAgIGNvbnN0IHZpZXdGcmFtZUJ5UG9zaXRpb24gPSBfdmlld01hbmFnZXIuZ2V0VmllRnJhbWVGb3JOb2RlQnlQb3NpdGlvbihuKTtcclxuXHJcbiAgICAgIGxldCBwcmV2T3duZXJGcmFtZSA9XHJcbiAgICAgICAgX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZU93bmVyKG5vZGUpIHx8IG92ZXJWaWV3RnJhbWU7XHJcbiAgICAgIGxldCB2aWV3RnJhbWU7XHJcblxyXG4gICAgICB2aWV3RnJhbWUgPSB2aWV3RnJhbWVCeVBvc2l0aW9uIHx8IHByZXZPd25lckZyYW1lO1xyXG4gICAgICBjb25zdCBkcmFnZ2VkRWxlbWVudFBvc2l0aW9uID0gbi5wb3NpdGlvbigpOyAvLyBjb3VsZCBiZSB0ZXJtaW5hdGlvbiBub2RlXHJcblxyXG4gICAgICBpZiAoaXNUZXJtaW5hdGlvbk5vZGUpIHtcclxuICAgICAgICBkcmFnZ2VkRWxlbWVudFBvc2l0aW9uLnggLT0gKG5vZGUuc2l6ZS53aWR0aCAtIG4uc2l6ZS53aWR0aCkgLyAyO1xyXG4gICAgICAgIGRyYWdnZWRFbGVtZW50UG9zaXRpb24ueSAtPSAobm9kZS5zaXplLmhlaWdodCAtIG4uc2l6ZS5oZWlnaHQpIC8gMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmV3R2xvYmFsUG9zaXRpb24gPSBsb2NhbFRvR2xvYmFsUG9pbnQoXHJcbiAgICAgICAgZHJhZ2dlZEVsZW1lbnRQb3NpdGlvbixcclxuICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPyBvdmVyVmlld0ZyYW1lLnNjYWxlIDogdmlld0ZyYW1lLnNjYWxlLFxyXG4gICAgICAgIF9mdWxsU2NyZWVuTW9kZSA/IG92ZXJWaWV3RnJhbWUgOiB2aWV3RnJhbWVcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgb2xkR2xvYmFsUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcblxyXG4gICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gbmV3R2xvYmFsUG9zaXRpb247XHJcbiAgICAgIG5vZGUudmlld0ZyYW1lT3duZXJJZCA9IHZpZXdGcmFtZS5pZDtcclxuXHJcbiAgICAgIF9kYXRhQ29udGFpbmVyLnVwZGF0ZVpvbmVzRm9yTm9kZShub2RlLCBvbGRHbG9iYWxQb3NpdGlvbik7XHJcblxyXG4gICAgICBjb25zdCBhZGRlZEZyYW1lSWRzID0gY2hhbmdlZFZpZXdGcmFtZXMubWFwKHZmID0+IHZmLmlkKTtcclxuICAgICAgY29uc3QgcHJldk93bmVyTm90QWRkZWRJbkxpc3QgPVxyXG4gICAgICAgIGFkZGVkRnJhbWVJZHMuaW5kZXhPZihwcmV2T3duZXJGcmFtZS5pZCkgPT09IC0xO1xyXG4gICAgICBjb25zdCB2aWV3RnJhbWVOb3RBZGRlZEluTGlzdCA9XHJcbiAgICAgICAgYWRkZWRGcmFtZUlkcy5pbmRleE9mKHZpZXdGcmFtZS5pZCkgPT09IC0xO1xyXG4gICAgICBpZiAocHJldk93bmVyTm90QWRkZWRJbkxpc3QgJiYgcHJldk93bmVyRnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgcHJldk93bmVyRnJhbWUudXBkYXRlQm91bmRzID0gdHJ1ZTtcclxuICAgICAgICBjaGFuZ2VkVmlld0ZyYW1lcy5wdXNoKHByZXZPd25lckZyYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmlld0ZyYW1lTm90QWRkZWRJbkxpc3QgJiYgdmlld0ZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgIHZpZXdGcmFtZS51cGRhdGVCb3VuZHMgPSB0cnVlO1xyXG4gICAgICAgIGNoYW5nZWRWaWV3RnJhbWVzLnB1c2godmlld0ZyYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKF9mdWxsU2NyZWVuTW9kZSkge1xyXG4gICAgICBvdmVyVmlld0ZyYW1lLnVwZGF0ZUJvdW5kcyA9IHRydWU7XHJcbiAgICAgIGNoYW5nZWRWaWV3RnJhbWVzLnB1c2gob3ZlclZpZXdGcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3JlZHJhdyh7IHZpZXdGcmFtZXM6IGNoYW5nZWRWaWV3RnJhbWVzIH0pO1xyXG4gICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnMoY2hhbmdlZFZpZXdGcmFtZXMsICgpID0+IHtcclxuICAgICAgc2VsZi50cmlnZ2VyKFwibm9kZXMtcG9zaXRpb24tY2hhbmdlZFwiLCBbbm9kZXNdKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyB1aSBmb3IgVmlld0ZyYW1lcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfY3JlYXRlVmlld0ZyYW1lc1VJKHZpZXdNYW5hZ2VyKSB7XHJcbiAgICBpZiAoX2Jhc2UudWkpIHtcclxuICAgICAgY29uc3Qgdmlld0ZyYW1lc1VJID0gbmV3IFZpZXdGcmFtZXNVSShcclxuICAgICAgICB7XHJcbiAgICAgICAgICByb290RWw6IF9iYXNlLnVpLFxyXG4gICAgICAgICAgdmlld01hbmFnZXI6IHZpZXdNYW5hZ2VyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJhbWV0ZXJzXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB2aWV3RnJhbWVzVUkub24oXCJzcGxpdHRlci1wb3NpdGlvbi1jaGFuZ2VkXCIsIChzLCBkaWZmT2JqKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsT3JpZW50YXRlZCA9XHJcbiAgICAgICAgICBfb3JpZW50YXRpb24gPT09IFwibGVmdC10by1yaWdodFwiIHx8IF9vcmllbnRhdGlvbiA9PT0gXCJyaWdodC10by1sZWZ0XCI7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZPYmouZGlmZjtcclxuICAgICAgICBjb25zdCB2ZkEgPSBzLm1vZGVsLnZpZXdGcmFtZUE7XHJcbiAgICAgICAgY29uc3QgdmZCID0gcy5tb2RlbC52aWV3RnJhbWVCO1xyXG4gICAgICAgIGNvbnN0IHRoZXJlSXNEaWZmZXJlbmNlID0gZGlmZiAhPT0gdW5kZWZpbmVkICYmIGRpZmYgIT09IG51bGw7XHJcbiAgICAgICAgaWYgKHRoZXJlSXNEaWZmZXJlbmNlKSB7XHJcbiAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JpZW50YXRlZCkge1xyXG4gICAgICAgICAgICB2ZkEuc2l6ZS53aWR0aCArPSBkaWZmO1xyXG4gICAgICAgICAgICB2ZkIuc2l6ZS53aWR0aCAtPSBkaWZmO1xyXG4gICAgICAgICAgICB2ZkIucG9zaXRpb24ueCArPSBkaWZmO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmZBLnNpemUuaGVpZ2h0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIHZmQi5zaXplLmhlaWdodCAtPSBkaWZmO1xyXG4gICAgICAgICAgICB2ZkIucG9zaXRpb24ueSArPSBkaWZmO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmZBLmN1c3RvbWVTaXplZDtcclxuICAgICAgICAgIHZmQi5jdXN0b21lU2l6ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaWZmT2JqLmxhc3RDaGFuZ2UpIHtcclxuICAgICAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmZBLCB2ZkJdLCBxdWlja1VwZGF0ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICBfbGltaXRWaWV3UG9ydHNQb3N0aW9ucyhbdmZBLCB2ZkJdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoZXJlSXNEaWZmZXJlbmNlKSB7XHJcbiAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZmQSwgdmZCXSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZpZXdGcmFtZXNVSS5vbihcInZpZXctcG9ydC1wb3NpdGlvbi1jaGFuZ2VkXCIsIHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVsZXZhbnRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICAgIF9wb3NpdGlvblZpZXdQb3J0KFxyXG4gICAgICAgICAgcmVsZXZhbnRWaWV3RnJhbWUsXHJcbiAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbixcclxuICAgICAgICAgIHBhcmFtZXRlcnMuYW5pbWF0aW9uLFxyXG4gICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQoXHJcbiAgICAgICAgICAgICAgdmlld0ZyYW1lLmlkXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcInZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZFwiLCBbXHJcbiAgICAgICAgICAgICAgW2NoYW5nZWRWaWV3RnJhbWVdXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmlld0ZyYW1lc1VJLm9uKFwidmlldy1mcmFtZS1jb2xsYXBzZWRcIiwgdmlld0ZyYW1lID0+IHtcclxuICAgICAgICB2aWV3RnJhbWUuZXhwYW5kZWQgPSBmYWxzZTtcclxuICAgICAgICBfY2xvc2VWaWV3RnJhbWUodmlld0ZyYW1lLmlkKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdmlld0ZyYW1lc1VJO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBodG1sIGJhc2UgZm9yIGRpYWdyYW0uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2NyZWF0ZUJhc2UoYmFzZURpdikge1xyXG4gICAgYmFzZURpdi5pbm5lckhUTUwgPSBcIlwiO1xyXG5cclxuICAgIGNvbnN0IGRpYWdyYW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xyXG4gICAgZGlhZ3JhbS5jbGFzc05hbWUgPSBcInRxLWxnLWxpbmVhZ2UtZGlhZ3JhbVwiO1xyXG4gICAgZGlhZ3JhbS5pZCA9IFwidHFfbGctbGluZWFnZS1ncmFwaFwiO1xyXG4gICAgYmFzZURpdi5hcHBlbmRDaGlsZChkaWFncmFtKTtcclxuXHJcbiAgICBjb25zdCB1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XHJcbiAgICB1aS5jbGFzc05hbWUgPSBcInRxLWxnLWxpbmVhZ2UtdWlcIjtcclxuICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQodWkpO1xyXG5cclxuICAgIHJldHVybiB7IHVpLCBkaWFncmFtIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhcnMgc2VsZWN0ZWQgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gYmxvY2tzIHRocm93aW5nIG9mIGV2ZW50XHJcbiAgICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF91bnNlbGVjdChzaWxlbnQpIHtcclxuICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgIF9wYXRoID0gbnVsbDtcclxuICAgICAgX3NlbGVjdGVkRWxlbWVudC51bnNlbGVjdCgpO1xyXG4gICAgICBfc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgICAgX3JlZHJhdygpO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcihcInNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFwiLCBudWxsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzZWxlY3RlZCBvYmplY3QgYW5kIGNoYW5nZXMgdmlld1BvcnQgcG9zaXRpb24gaWYgaXQncyBuZWVkZWQuXHJcbiAgICogQHBhcmFtIHtOb2RlfExpbmt9IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzT25cclxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3NlbGVjdChlbGVtZW50LCBmb2N1c09uKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICBpZiAoc2VsZWN0ZWRFbGVtZW50ICE9PSBfc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgIGlmIChfc2VsZWN0ZWRFbGVtZW50KSBfc2VsZWN0ZWRFbGVtZW50LnVuc2VsZWN0KCk7XHJcbiAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgIF9zZWxlY3RlZEVsZW1lbnQuc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZvY3VzT24pIHtcclxuICAgICAgX2ZvY3VzT25FbGVtZW50KF9zZWxlY3RlZEVsZW1lbnQsICgpID0+IHtcclxuICAgICAgICBfcGF0aCA9IGdldFBhdGgoX3NlbGVjdGVkRWxlbWVudCwgX2RhdGFDb250YWluZXIpO1xyXG4gICAgICAgIF9yZWRyYXcoKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcIiwgZWxlbWVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgX3BhdGggPSBnZXRQYXRoKF9zZWxlY3RlZEVsZW1lbnQsIF9kYXRhQ29udGFpbmVyKTtcclxuICAgICAgICBfcmVkcmF3KCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwic2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXCIsIGVsZW1lbnQpO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0IG1vdmVzIHBvc2l0aW9uIG9mIHRoZSB2aWV3UG9ydCBzbyB0aGF0XHJcbiAgICogdGhlIHNlbGVjdGVkIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgc2VudGVyIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBfZm9jdXNPbkVsZW1lbnQgY2FuIGJlIGFzeW5jaHJvbm91cyBkZXBlbmRzIG9uIGFuaW1hdGlvbiBtb2RlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2ZvY3VzT25FbGVtZW50KGVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBsZXQgZm9jdXNOb2RlID0gbnVsbDtcclxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTGluaykge1xyXG4gICAgICBmb2N1c05vZGUgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXBbZWxlbWVudC5tb2RlbC5zb3VyY2VdO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICBmb2N1c05vZGUgPSBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGZvY3VzTm9kZSkge1xyXG4gICAgICBsZXQgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUZvck5vZGUoZm9jdXNOb2RlKTtcclxuICAgICAgaWYgKCF2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgX3JlZHJhdyh7XHJcbiAgICAgICAgICB2aWV3RnJhbWVzOiBbeyBpZDogdmlld0ZyYW1lLmlkLCBleHBhbmRlZDogdHJ1ZSB9XSxcclxuICAgICAgICAgIHF1aWNrVXBkYXRlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJ2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkXCIsIFtbdmlld0ZyYW1lXV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG5vZGVTaXplID0gZ2V0R2xvYmFsTm9kZVNpemUoZm9jdXNOb2RlLCB2aWV3RnJhbWUuc2NhbGUpO1xyXG4gICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24oZm9jdXNOb2RlKTtcclxuICAgICAgY29uc3Qgdmlld1BvcnRTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHZpZXdGcmFtZS5zaXplLCB2aWV3RnJhbWUuc2NhbGUpO1xyXG5cclxuICAgICAgbGV0IHRhcmdldFBvc2l0aW9uID0ge1xyXG4gICAgICAgIC8vIEdsb2JhbFxyXG4gICAgICAgIHg6IG5vZGVQb3NpdGlvbi54ICsgKG5vZGVTaXplLndpZHRoIC0gdmlld1BvcnRTaXplLndpZHRoKSAvIDIsXHJcbiAgICAgICAgeTogbm9kZVBvc2l0aW9uLnkgKyAobm9kZVNpemUuaGVpZ2h0IC0gdmlld1BvcnRTaXplLmhlaWdodCkgLyAyXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBfcG9zaXRpb25WaWV3UG9ydCh2aWV3RnJhbWUsIHRhcmdldFBvc2l0aW9uLCBwYXJhbWV0ZXJzLmFuaW1hdGlvbiwgKCkgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZFZpZXdGcmFtZSA9IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKFwidmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkXCIsIFtcclxuICAgICAgICAgIFtjaGFuZ2VkVmlld0ZyYW1lXVxyXG4gICAgICAgIF0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbCB2aWV3UG9ydCBwb3NpdGlvbiBjaGFuZ2VzIHNob3VsZCBiZSBwZXJmb3JtZWQgdGhyb3VnaCB0aGlzIG1ldGhvZHMuXHJcbiAgICogX3Bvc2l0aW9uVmlld1BvcnQgKGV4Y2x1ZGUgc2NhbGUpXHJcbiAgICogSXQncyBuZWVkZWQgdG8gc3RvcCBhbmltYXRpb24gaW4gY2FzZSBvZiBhbmltYXRpb24gaGF2ZW4ndCBiZWVuIGRvbmUuXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEl0IHNldHMgb2Zmc2V0IGZvciBhbGwgZWxlbWVudHMgaW50byB0aGUgdmlld1BvcnQuXHJcbiAgICogQHBhcmFtIHtWaWV3RnJhbWV9IHZpZXdGcmFtZVxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBhbmltYXRpb24gLSBpdCdzIG9wdGlvbmFsXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBpdCdzIGNhbGxlZCBhZnRlciBmb2N1c1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9wb3NpdGlvblZpZXdQb3J0KHZpZXdGcmFtZSwgcG9pbnQsIGFuaW1hdGlvbiwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHJlbGV2YXRuVmlld0ZyYW1lID0gX3ZpZXdNYW5hZ2VyLmdldFZpZXdGcmFtZUJ5SWQodmlld0ZyYW1lLmlkKTtcclxuICAgIGNvbnN0IHRhcmdldFBvcyA9IGxpbWl0UG9pbnRQb3NpdGlvbihcclxuICAgICAgcG9pbnQsXHJcbiAgICAgIHJlbGV2YXRuVmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHNcclxuICAgICk7XHJcbiAgICBjb25zdCB2aWV3UG9ydFBvc2l0aW9uID0gcmVsZXZhdG5WaWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuICAgIGNvbnN0IHRhcmdldElzUmVhY2hlZCA9XHJcbiAgICAgIHZpZXdQb3J0UG9zaXRpb24ueCA9PT0gdGFyZ2V0UG9zLnggJiYgdmlld1BvcnRQb3NpdGlvbi55ID09PSB0YXJnZXRQb3MueTtcclxuXHJcbiAgICBpZiAoIWFuaW1hdGlvbiB8fCB0YXJnZXRJc1JlYWNoZWQgfHwgIXZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX2FuaW1hdGlvbklkKTtcclxuICAgICAgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24gPSB0YXJnZXRQb3M7XHJcbiAgICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiBbdmlld0ZyYW1lXSwgcXVpY2tVcGRhdGU6IHRydWUgfSk7XHJcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF9hbmltYXRlZFZpZXdQb3J0Q2hhbmdpbmcocmVsZXZhdG5WaWV3RnJhbWUsIHRhcmdldFBvcywgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnModmlld0ZyYW1lcywgY2FsbGJhY2spIHtcclxuICAgIHJlY3Vyc2l2ZUNhbGwoMCk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlQ2FsbChpbmRleCkge1xyXG4gICAgICBjb25zdCB2aWV3RnJhbWUgPSB2aWV3RnJhbWVzW2luZGV4XTtcclxuICAgICAgaWYgKCF2aWV3RnJhbWUpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWUgPSBfdmlld01hbmFnZXIuZ2V0Vmlld0ZyYW1lQnlJZCh2aWV3RnJhbWUuaWQpO1xyXG4gICAgICBpZiAoIXRhcmdldFZpZXdGcmFtZSkge1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9saW1pdFZpZXdQb3J0UG9zdGlvbih0YXJnZXRWaWV3RnJhbWUsICgpID0+IHtcclxuICAgICAgICBpZiAoaW5kZXggPCB2aWV3RnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmVjdXJzaXZlQ2FsbChpbmRleCArIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkVmlld0ZyYW1lc01vZGVscyA9IHZpZXdGcmFtZXMubWFwKHZmID0+XHJcbiAgICAgICAgICAgIF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVCeUlkKHZmLmlkKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHNlbGYudHJpZ2dlcihcInZpZXctZnJhbWVzLXNpemUtb3ItcG9zaXRpb24tY2hhbmdlZFwiLCBbXHJcbiAgICAgICAgICAgIGNoYW5nZWRWaWV3RnJhbWVzTW9kZWxzXHJcbiAgICAgICAgICBdKTtcclxuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRQb3N0aW9uKHZpZXdGcmFtZSwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IGxpbWl0dGVkUG9zaXRpb24gPSBsaW1pdFBvaW50UG9zaXRpb24oXHJcbiAgICAgIHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLFxyXG4gICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kc1xyXG4gICAgKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uSXNJbmNvcnJlY3QgPVxyXG4gICAgICBsaW1pdHRlZFBvc2l0aW9uLnggIT09IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uLnggfHxcclxuICAgICAgbGltaXR0ZWRQb3NpdGlvbi55ICE9PSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbi55O1xyXG4gICAgaWYgKHBvc2l0aW9uSXNJbmNvcnJlY3QpIHtcclxuICAgICAgX3Bvc2l0aW9uVmlld1BvcnQoXHJcbiAgICAgICAgdmlld0ZyYW1lLFxyXG4gICAgICAgIGxpbWl0dGVkUG9zaXRpb24sXHJcbiAgICAgICAgcGFyYW1ldGVycy5hbmltYXRpb24sXHJcbiAgICAgICAgY2FsbGJhY2tcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYWdlcyB2aWV3UG9ydCBwb3NpdGlvbiBzbW9vdGhseSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gdG8gdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2ZlxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHRhcmdldFBvc1xyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgbGV0IF9hbmltYXRpb25JZCA9IHVuZGVmaW5lZDtcclxuICBmdW5jdGlvbiBfYW5pbWF0ZWRWaWV3UG9ydENoYW5naW5nKHZpZXdGcmFtZSwgdGFyZ2V0UG9zLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3Qgc3RhcnRQb3MgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuXHJcbiAgICBjb25zdCBkaWZmWCA9IGdldERpZmYoc3RhcnRQb3MueCwgdGFyZ2V0UG9zLngpO1xyXG4gICAgY29uc3QgZGlmZlkgPSBnZXREaWZmKHN0YXJ0UG9zLnksIHRhcmdldFBvcy55KTtcclxuICAgIGNvbnN0IHNjYWxlID0gdmlld0ZyYW1lLnNjYWxlIHx8IF9zY2FsZTtcclxuICAgIGNvbnN0IGRlZmF1bHRTdGVwWCA9IHBhcmFtZXRlcnMuYW5pbWF0aW9uU3RlcCAvIHNjYWxlLng7XHJcbiAgICBjb25zdCBkZWZhdWx0U3RlcFkgPSBwYXJhbWV0ZXJzLmFuaW1hdGlvblN0ZXAgLyBzY2FsZS55O1xyXG5cclxuICAgIGxldCBzdGVwWCwgc3RlcFk7XHJcbiAgICBpZiAoZGlmZlggPiBkaWZmWSkge1xyXG4gICAgICBzdGVwWCA9IGRlZmF1bHRTdGVwWDtcclxuICAgICAgc3RlcFkgPSBkZWZhdWx0U3RlcFggKiAoZGlmZlkgLyBkaWZmWCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGVwWCA9IGRlZmF1bHRTdGVwWSAqIChkaWZmWCAvIGRpZmZZKTtcclxuICAgICAgc3RlcFkgPSBkZWZhdWx0U3RlcFk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhcnREaXN0YW5jZSA9IGdldERpc3Qodmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24sIHRhcmdldFBvcyk7XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX2FuaW1hdGlvbklkKTtcclxuXHJcbiAgICBsZXQgdGltZTtcclxuICAgIHJlcXVyc2l2ZUFuaW1hdGlvbigpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcXVyc2l2ZUFuaW1hdGlvbihvbGRQb3MpIHtcclxuICAgICAgX2FuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBjb25zdCB0aW1lUmF0ZSA9IDEwMDAgLyAobm93IC0gdGltZSkgfHwgcGFyYW1ldGVycy5taW5GcmFtZVJhdGU7XHJcblxyXG4gICAgICAgIGxldCB0TW9kaWZpZXIgPSAxO1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLm1pbkZyYW1lUmF0ZSA+IHRpbWVSYXRlKSB7XHJcbiAgICAgICAgICB0TW9kaWZpZXIgPSBwYXJhbWV0ZXJzLm1pbkZyYW1lUmF0ZSAvIHRpbWVSYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZVJhdGUgPiBwYXJhbWV0ZXJzLm1heEZyYW1lUmF0ZSkge1xyXG4gICAgICAgICAgdE1vZGlmaWVyID0gcGFyYW1ldGVycy5tYXhGcmFtZVJhdGUgLyB0aW1lUmF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZSA9IG5vdztcclxuXHJcbiAgICAgICAgY29uc3QgY3VyUG9zID0gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNSZWFjaGVkID1cclxuICAgICAgICAgIGN1clBvcy54ID09PSB0YXJnZXRQb3MueCAmJiBjdXJQb3MueSA9PT0gdGFyZ2V0UG9zLnk7XHJcbiAgICAgICAgY29uc3Qgd2VBcmVOb3RNb3ZpbmcgPVxyXG4gICAgICAgICAgb2xkUG9zICYmIGN1clBvcy54ID09PSBvbGRQb3MueCAmJiBjdXJQb3MueSA9PT0gb2xkUG9zLnk7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXRJc1JlYWNoZWQgfHwgd2VBcmVOb3RNb3ZpbmcpIHtcclxuICAgICAgICAgIF9kZWxheWVkUmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0gfSk7XHJcbiAgICAgICAgICAvLyBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0sIHF1aWNrVXBkYXRlOiBmYWxzZSB9KTtcclxuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9hbmltYXRpb25JZCk7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGRpZmZYID0gZ2V0RGlmZihjdXJQb3MueCwgdGFyZ2V0UG9zLngpO1xyXG4gICAgICAgICAgY29uc3QgZGlmZlkgPSBnZXREaWZmKGN1clBvcy55LCB0YXJnZXRQb3MueSk7XHJcblxyXG4gICAgICAgICAgY29uc3QgbmV3UG9zID0geyB4OiBjdXJQb3MueCwgeTogY3VyUG9zLnkgfTtcclxuXHJcbiAgICAgICAgICBjb25zdCBjdXJEaXN0YW5jZSA9IGdldERpc3QoY3VyUG9zLCB0YXJnZXRQb3MpO1xyXG4gICAgICAgICAgY29uc3QgayA9XHJcbiAgICAgICAgICAgIDEgLVxyXG4gICAgICAgICAgICBNYXRoLmNvcyhcclxuICAgICAgICAgICAgICAoTWF0aC5QSSAqIChzdGFydERpc3RhbmNlIC0gY3VyRGlzdGFuY2UpKSAvIHN0YXJ0RGlzdGFuY2VcclxuICAgICAgICAgICAgKSAqXHJcbiAgICAgICAgICAgICAgMC4zO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGZpbmFsU3RlcFggPSBzdGVwWDtcclxuICAgICAgICAgIGNvbnN0IGZpbmFsU3RlcFkgPSBzdGVwWTtcclxuXHJcbiAgICAgICAgICBpZiAobmV3UG9zLnggIT09IHRhcmdldFBvcy54KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLm1pbihkaWZmWCwgZmluYWxTdGVwWCAqIGsgKiB0TW9kaWZpZXIpO1xyXG4gICAgICAgICAgICBuZXdQb3MueCArPSBjdXJQb3MueCA8IHRhcmdldFBvcy54ID8gZCA6IC1kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG5ld1Bvcy55ICE9PSB0YXJnZXRQb3MueSkge1xyXG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5taW4oTWF0aC5hYnMoZGlmZlkpLCBmaW5hbFN0ZXBZICogayAqIHRNb2RpZmllcik7XHJcbiAgICAgICAgICAgIG5ld1Bvcy55ICs9IGN1clBvcy55IDwgdGFyZ2V0UG9zLnkgPyBkIDogLWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbiA9IG5ld1BvcztcclxuXHJcbiAgICAgICAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogW3ZpZXdGcmFtZV0sIHF1aWNrVXBkYXRlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAgIHJlcXVyc2l2ZUFuaW1hdGlvbihjdXJQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoZXMgYWxsIHZpZXdGcmFtZXMgYm91bmRzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9yZWZyZXNoKHZpZXdGcmFtZXMpIHtcclxuICAgIHZpZXdGcmFtZXMgPSB2aWV3RnJhbWVzIHx8IF92aWV3TWFuYWdlci5nZXRWaWV3RnJhbWVzKCk7XHJcbiAgICBfcmVkcmF3KHsgdmlld0ZyYW1lczogdmlld0ZyYW1lcywgdXBkYXRlQm91bmRzOiB0cnVlIH0pO1xyXG4gICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnModmlld0ZyYW1lcyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfcmVzZXRMYXlvdXQoKSB7XHJcbiAgICBjb25zdCB2aWV3RnJhbWVBZmZlY3RlZElkcyA9IHt9O1xyXG4gICAgY29uc3Qgb3ZlclZpZXdGcmFtZUlkID0gX3ZpZXdNYW5hZ2VyLmdldE92ZXJWaWV3RnJhbWUoKS5pZDtcclxuXHJcbiAgICBfZGF0YUNvbnRhaW5lci5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICBpZiAobm9kZS5tb2RlbC5kZWZhdWx0UG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCBjdXJQb3MgPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgbm9kZS5tb2RlbC5wb3NpdGlvbiA9IG5vZGUubW9kZWwuZGVmYXVsdFBvc2l0aW9uO1xyXG4gICAgICAgIF9kYXRhQ29udGFpbmVyLnVwZGF0ZVpvbmVzRm9yTm9kZShub2RlLCBjdXJQb3MpO1xyXG4gICAgICAgIGlmIChub2RlLnZpZXdGcmFtZU93bmVySWQpXHJcbiAgICAgICAgICB2aWV3RnJhbWVBZmZlY3RlZElkc1tub2RlLnZpZXdGcmFtZU93bmVySWRdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNGdWxsU2NyZWVuTW9kZSA9IF92aWV3TWFuYWdlci5pc0Z1bGxTY3JlZW5Nb2RlKCk7XHJcbiAgICAgICAgdmlld0ZyYW1lQWZmZWN0ZWRJZHNbXHJcbiAgICAgICAgICBpc0Z1bGxTY3JlZW5Nb2RlID8gb3ZlclZpZXdGcmFtZUlkIDogbm9kZS5tb2RlbC52aWV3RnJhbWVcclxuICAgICAgICBdID0gdHJ1ZTtcclxuICAgICAgICBkZWxldGUgbm9kZS52aWV3RnJhbWVPd25lcklkO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBPYmplY3Qua2V5cyh2aWV3RnJhbWVBZmZlY3RlZElkcykubWFwKGtleSA9PiAoe1xyXG4gICAgICBpZDoga2V5LFxyXG4gICAgICB1cGRhdGVCb3VuZHM6IHRydWVcclxuICAgIH0pKTtcclxuICAgIF9yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgX2xpbWl0Vmlld1BvcnRzUG9zdGlvbnModmlld0ZyYW1lcyk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuXHJcbmNvbnN0IGcgPSBqb2ludC5nO1xyXG5jb25zdCBMSU5LX09GRlNFVCA9IDc7XHJcblxyXG5leHBvcnQgY29uc3QgRU5BQkxFX1JPVVRJTkdTID0gWyAnbWV0cm8nLCAnbm9ybWFsJywgJ21hbmhhdHRhbicsICdvcnRob2dvbmFsJywgJ2xncm91dGVyJyBdO1xyXG5cclxuLyoqXHJcbiAqIFJvdXRpbmdNYW5hZ2VyXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7bGlua1JvdXRpbmcsIGxpbmtzLCBib3VuZHN9IG9wdGlvbnMgXHJcbiAqIEBwYXJhbSB7Kn0gcGFyYW1ldGVycyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBSb3V0aW5nTWFuYWdlciAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgbGV0IF9saW5rcztcclxuICAgIGxldCBfcm91dGluZyA9IG9wdGlvbnMubGlua1JvdXRpbmcgfHwgcGFyYW1ldGVycy5saW5rUm91dGluZztcclxuXHJcbiAgICBsZXQgX3ZlcnRleE1hcCA9IHt9O1xyXG4gICAgbGV0IF9pZFRvVmVydGV4ID0ge307XHJcbiAgICBsZXQgX2JvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xyXG5cclxuICAgIHNlbGYuc2V0RGF0YSA9IF9zZXREYXRhO1xyXG4gICAgc2VsZi5zZXRSb3V0aW5nID0gX3NldFJvdXRpbmc7XHJcbiAgICBzZWxmLnJlc2V0Um91dGluZyA9IF9yZXNldFJvdXRpbmc7XHJcbiAgICBzZWxmLnNldEJvdW5kcyA9IF9zZXRCb3VuZHM7XHJcblxyXG4gICAgc2VsZi5nZXRSb3V0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcm91dGluZztcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX2luaXQgKCkge1xyXG4gICAgICAgIF9zZXREYXRhKG9wdGlvbnMubGlua3MpO1xyXG4gICAgICAgIGpvaW50LnJvdXRlcnMubGdyb3V0ZXIgPSBsZ3JvdXRlcjtcclxuICAgICAgICBqb2ludC5yb3V0ZXJzLm1ldHJvID0gbmV3TWV0cm87XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3NldEJvdW5kcyAoYm91bmRzKSB7XHJcbiAgICAgICAgX2JvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0RGF0YSAobGlua3MpIHtcclxuICAgICAgICBfbGlua3MgPSBsaW5rcztcclxuICAgICAgICBfdXBkYXRlTGlua1JvdXRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfc2V0Um91dGluZyAocm91dGluZykge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93blJvdXRpbmdJZCA9IEVOQUJMRV9ST1VUSU5HUy5pbmRleE9mKHJvdXRpbmcpID09PSAtMTtcclxuICAgICAgICBpZiAoaXNVbmtub3duUm91dGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHJvdXRpbmcgPSAnbWV0cm8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91dGluZyAhPT0gX3JvdXRpbmcpIHtcclxuICAgICAgICAgICAgX3JvdXRpbmcgPSByb3V0aW5nO1xyXG4gICAgICAgICAgICBfdXBkYXRlTGlua1JvdXRpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUxpbmtSb3V0aW5nICgpIHtcclxuICAgICAgICBfdmVydGV4TWFwID0ge307XHJcbiAgICAgICAgX2lkVG9WZXJ0ZXggPSB7fTtcclxuICAgICAgICBfbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgcm91dGVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogX3JvdXRpbmcsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBsaW5rLmdldCgncm91dGVyJykuYXJncyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGluay5zZXQoJ3JvdXRlcicsIHJvdXRlciwgbGluay5pc09uVGhlR3JhcGgoKSA/IHt9IDogeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3Jlc2V0Um91dGluZyAoKSB7XHJcbiAgICAgICAgX3ZlcnRleE1hcCA9IHt9O1xyXG4gICAgICAgIF9pZFRvVmVydGV4ID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUm91dGVyc1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICBjb25zdCBsZ3JvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYW51YWxWZXJ0aWNlcywgb3B0cywgbGlua1ZpZXcpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgc3RlcDogMTAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0aWNlcyA9IGpvaW50LnJvdXRlcnMubWFuaGF0dGFuKG1hbnVhbFZlcnRpY2VzLCBfLmV4dGVuZCh7fSwgZGVmYXVsdENvZmlnLCBvcHRzKSwgbGlua1ZpZXcpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZmluZENvbm5lY3Rpb25Qb2ludHModmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYWxsVmVydGljZXMgPSBmaW5kSW50ZXJtZWRpYXRlVmVydGljZXMoXHJcbiAgICAgICAgICAgICAgICBbdGhpcy5zb3VyY2VQb2ludF0uY29uY2F0KHZlcnRpY2VzKS5jb25jYXQoW3RoaXMudGFyZ2V0UG9pbnRdKSxcclxuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2VzLmxlbmd0aCA+IDAgPyB2ZXJ0aWNlcyA6IFt0aGlzLnNvdXJjZUJCb3guY2VudGVyKCksIHRoaXMudGFyZ2V0QkJveC5jZW50ZXIoKV0sXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29maWcuc3RlcCxcclxuICAgICAgICAgICAgKTtcclxuICAgIFxyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkVmVydGljZXMgPSBbXTtcclxuICAgICAgICAgICAgY2xlYXJWZXJ0aWNlcyhsaW5rVmlldyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgbWF4T2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsVmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZWZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWZXJ0ZXggPSBhbGxWZXJ0aWNlc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgudHlwZSA9IGdldFBvc2l0aW9uVHlwZShwcmV2VmVydGV4LCB2ZXJ0ZXgsIG5leHRWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0ID0gZ2V0T2Zmc2V0KHZlcnRleCwgbWF4T2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGFsbFZlcnRpY2VzLmZvckVhY2godmVydGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZlcnRleCA9IHN0b3JlVmVlcnRleCh2ZXJ0ZXgsIG1heE9mZnNldCwgbGlua1ZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzLmluZGV4T2YodmVydGV4KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkVmVydGljZXMucHVzaChuZXdWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZFZlcnRpY2VzLm1hcCh2ZXJ0ZXggPT4gKHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKE1hdGgubWF4KHZlcnRleC54LCBfYm91bmRzLnggKSwgX2JvdW5kcy54ICsgX2JvdW5kcy53aWR0aCksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihNYXRoLm1heCh2ZXJ0ZXgueSwgX2JvdW5kcy55ICksIF9ib3VuZHMueSArIF9ib3VuZHMuaGVpZ2h0KSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGNvbnN0IG5ld01ldHJvID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAvLyBjb3N0IG9mIGEgZGlhZ29uYWwgc3RlcCAoY2FsY3VsYXRlZCBpZiBub3QgZGVmaW5lZCkuXHJcbiAgICAgICAgICAgIGRpYWdvbmFsQ29zdDogbnVsbCxcclxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgZGlyZWN0aW9ucyB0byBmaW5kIG5leHQgcG9pbnRzIG9uIHRoZSByb3V0ZVxyXG4gICAgICAgICAgICBkaXJlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbENvc3QgPSB0aGlzLmRpYWdvbmFsQ29zdCB8fCBNYXRoLmNlaWwoTWF0aC5zcXJ0KHN0ZXAgKiBzdGVwIDw8IDEpKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAgICwgb2Zmc2V0WTogMCAgICAgLCBjb3N0OiBzdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwICAsIG9mZnNldFk6IHN0ZXAgICwgY29zdDogZGlhZ29uYWxDb3N0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiAwICAgICAsIG9mZnNldFk6IHN0ZXAgICwgY29zdDogc3RlcCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAgLCBvZmZzZXRZOiBzdGVwICAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAgLCBvZmZzZXRZOiAwICAgICAsIGNvc3Q6IHN0ZXAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwICwgb2Zmc2V0WTogLXN0ZXAgLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcclxuICAgICAgICAgICAgICAgICAgICB7IG9mZnNldFg6IDAgICAgICwgb2Zmc2V0WTogLXN0ZXAgLCBjb3N0OiBzdGVwIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwICAsIG9mZnNldFk6IC1zdGVwICwgY29zdDogZGlhZ29uYWxDb3N0IH1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2U6IDQ1LFxyXG4gICAgICAgICAgICAvLyBhIHNpbXBsZSByb3V0ZSB1c2VkIGluIHNpdHVhdGlvbnMsIHdoZW4gbWFpbiByb3V0aW5nIG1ldGhvZCBmYWlsc1xyXG4gICAgICAgICAgICAvLyAoZXhjZWVkIGxvb3BzLCBpbmFjY2Vzc2libGUpLlxyXG4gICAgICAgICAgICBmYWxsYmFja1JvdXRlOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYSByb3V0ZSB3aGljaCBicmVha3MgYnkgNDUgZGVncmVlcyBpZ25vcmluZyBhbGwgb2JzdGFjbGVzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGhldGEgPSBmcm9tLnRoZXRhKHRvKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSB7IHg6IHRvLngsIHk6IGZyb20ueSB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSB7IHg6IGZyb20ueCwgeTogdG8ueSB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhldGEgJSAxODAgPiA5MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBiID0gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcDEgPSAodGhldGEgJSA5MCkgPCA0NSA/IGEgOiBiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBnLmxpbmUoZnJvbSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSA5MCAqIE1hdGguY2VpbCh0aGV0YSAvIDkwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gZy5wb2ludC5mcm9tUG9sYXIobDEuc3F1YXJlZExlbmd0aCgpLCBnLnRvUmFkKGFscGhhICsgMTM1KSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBnLmxpbmUodG8sIHAyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbDEuaW50ZXJzZWN0aW9uKGwyKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50ID8gW3BvaW50LnJvdW5kKCksIHRvXSA6IFt0b107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgLy8gcHVibGljIGZ1bmN0aW9uXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2ZXJ0aWNlcywgb3B0cywgbGlua1ZpZXcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxncm91dGVyLmNhbGwodGhpcywgdmVydGljZXMsIF8uZXh0ZW5kKHt9LCBjb25maWcsIG9wdHMpLCBsaW5rVmlldyk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbiAgICBcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25UeXBlIChwcmV2VmVydGV4LCB2ZXJ0ZXgsIG5leHRWZXJ0ZXgpIHtcclxuICAgICAgICBpZiAocHJldlZlcnRleCB8fCBuZXh0VmVydGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHZlcnRleC54KTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQodmVydGV4LnkpO1xyXG4gICAgICAgICAgICBjb25zdCBlcXVhbFggPSAoKCFwcmV2VmVydGV4KSB8fCBNYXRoLnJvdW5kKHByZXZWZXJ0ZXgueCkgPT09IHgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgoIW5leHRWZXJ0ZXgpIHx8IE1hdGgucm91bmQobmV4dFZlcnRleC54KSA9PT0geCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVxdWFsWSA9ICgoIXByZXZWZXJ0ZXgpIHx8IE1hdGgucm91bmQocHJldlZlcnRleC55KSA9PT0geSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCghbmV4dFZlcnRleCkgfHwgTWF0aC5yb3VuZChuZXh0VmVydGV4LnkpID09PSB5KTtcclxuICAgICAgICAgICAgaWYgKGVxdWFsWCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXF1YWxZKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdwb2ludCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BvaW50JztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlPZmZzZXQgKHZlcnRleCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdmVydGV4LnR5cGUgPT09ICdob3Jpem9udGFsJzsgXHJcbiAgICAgICAgY29uc3QgaXNWZXJpY2FsID0gdmVydGV4LnR5cGUgPT09ICd2ZXJ0aWNhbCc7IFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHZlcnRleC54ICsgKGlzSG9yaXpvbnRhbCA/IDAgOiBvZmZzZXQueCksXHJcbiAgICAgICAgICAgIHk6IHZlcnRleC55ICsgKGlzVmVyaWNhbCA/IDA6IG9mZnNldC55KSxcclxuICAgICAgICAgICAgdHlwZTogdmVydGV4LnR5cGUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJZCAodmVydGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmVydGV4LngpICsgJ0AnICsgTWF0aC5yb3VuZCh2ZXJ0ZXgueSkgKyAnOicgKyB2ZXJ0ZXgudHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmdW5jdGlvbiBnZXRPZmZzZXQgKHZlcnRleCwgZGVmYXVsdE9mZnNldCkge1xyXG4gICAgLy8gICAgIGNvbnN0IGN1clZlcnRleCA9IGFwcGx5T2Zmc2V0KHZlcnRleCwgZGVmYXVsdE9mZnNldCk7XHJcbiAgICAvLyAgICAgY29uc3QgdklkID0gZ2V0SWQoY3VyVmVydGV4KTtcclxuXHJcbiAgICAvLyAgICAgaWYgKF92ZXJ0ZXhNYXBbdklkXSkge1xyXG4gICAgLy8gICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB2ZXJ0ZXgudHlwZSA9PT0gJ2hvcml6b250YWwnOyBcclxuICAgIC8vICAgICAgICAgY29uc3QgaXNWZXJpY2FsID0gdmVydGV4LnR5cGUgPT09ICd2ZXJ0aWNhbCc7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBnZXRPZmZzZXQgKHZlcnRleCwge1xyXG4gICAgLy8gICAgICAgICAgICAgeDogZGVmYXVsdE9mZnNldC54ICsgKGlzSG9yaXpvbnRhbCA/IDAgOiAtTElOS19PRkZTRVQpLFxyXG4gICAgLy8gICAgICAgICAgICAgeTogZGVmYXVsdE9mZnNldC55ICsgKGlzVmVyaWNhbCA/IDAgOiBMSU5LX09GRlNFVCksXHJcbiAgICAvLyAgICAgICAgIH0pO1xyXG4gICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBkZWZhdWx0T2Zmc2V0O1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXQgKHZlcnRleCwgZGVmYXVsdE9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHZlcnRleC50eXBlID09PSAnaG9yaXpvbnRhbCc7IFxyXG4gICAgICAgIGNvbnN0IGlzVmVyaWNhbCA9IHZlcnRleC50eXBlID09PSAndmVydGljYWwnO1xyXG5cclxuICAgICAgICBsZXQgY3VyT2Zmc2V0ID0gZGVmYXVsdE9mZnNldDtcclxuICAgICAgICBsZXQgY3VyVmVydGV4ID0gYXBwbHlPZmZzZXQodmVydGV4LCBkZWZhdWx0T2Zmc2V0KTtcclxuICAgICAgICBsZXQgY3VySWQgPSBnZXRJZChjdXJWZXJ0ZXgpO1xyXG5cclxuICAgICAgICBjb25zdCB4VHlwZSA9IGRlZmF1bHRPZmZzZXQueCA9PT0gMCA/ICd0cmlnZ2VyJyA6IGRlZmF1bHRPZmZzZXQueCA+IDAgPyAncmlzZScgOiAnZmFsbCc7XHJcbiAgICAgICAgY29uc3QgeVR5cGUgPSBkZWZhdWx0T2Zmc2V0LnkgPT09IDAgPyAndHJpZ2dlcicgOiBkZWZhdWx0T2Zmc2V0LnkgPiAwID8gJ3Jpc2UnIDogJ2ZhbGwnO1xyXG4gICAgICAgIGxldCB4VHJpZ2dlciA9IDE7XHJcbiAgICAgICAgbGV0IHlUcmlnZ2VyID0gMTtcclxuICAgICAgICBsZXQgeFN0ZXAgPSAwO1xyXG4gICAgICAgIGxldCB5U3RlcCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKF92ZXJ0ZXhNYXBbY3VySWRdKSB7XHJcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IHsgeDogZGVmYXVsdE9mZnNldC54LCB5OiBkZWZhdWx0T2Zmc2V0LnkgfTtcclxuICAgICAgICAgICAgaWYgKHhUeXBlID09PSAndHJpZ2dlcicpIHtcclxuICAgICAgICAgICAgICAgIHhUcmlnZ2VyID0gLXhUcmlnZ2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhUcmlnZ2VyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhTdGVwKys7XHJcbiAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhUeXBlID09PSAncmlzZScpIHtcclxuICAgICAgICAgICAgICAgIHhTdGVwKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4U3RlcC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5VHlwZSA9PT0gJ3RyaWdnZXInKSB7XHJcbiAgICAgICAgICAgICAgICB5VHJpZ2dlciA9IC15VHJpZ2dlcjtcclxuICAgICAgICAgICAgICAgIGlmICh5VHJpZ2dlciA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB5U3RlcCsrO1xyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh5VHlwZSA9PT0gJ3Jpc2UnKSB7XHJcbiAgICAgICAgICAgICAgICB5U3RlcCsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeVN0ZXAtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBkZWZhdWx0T2Zmc2V0LnggKyAoaXNIb3Jpem9udGFsID8gMCA6IHhTdGVwICogTElOS19PRkZTRVQgKiB4VHJpZ2dlciksXHJcbiAgICAgICAgICAgICAgICB5OiBkZWZhdWx0T2Zmc2V0LnkgKyAoaXNWZXJpY2FsID8gMCA6IHlTdGVwICogTElOS19PRkZTRVQgKiB5VHJpZ2dlciksXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjdXJWZXJ0ZXggPSBhcHBseU9mZnNldCh2ZXJ0ZXgsIGN1ck9mZnNldCk7XHJcbiAgICAgICAgICAgIGN1cklkID0gZ2V0SWQoY3VyVmVydGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjdXJPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNsZWFyVmVydGljZXMgKGxpbmtWaWV3KSB7XHJcbiAgICAgICAgaWYgKF9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXSkge1xyXG4gICAgICAgICAgICBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF0uZm9yRWFjaCh2ZXJ0ZXhJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgX3ZlcnRleE1hcFt2ZXJ0ZXhJZF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWxldGUgX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gc3RvcmVWZWVydGV4ICh2ZXJ0ZXgsIG9mZnNldCwgbGlua1ZpZXcsKSB7XHJcbiAgICAgICAgY29uc3QgbmV3VmVydGV4ID0gYXBwbHlPZmZzZXQodmVydGV4LCBvZmZzZXQpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZCA9IGdldElkKG5ld1ZlcnRleCk7XHJcbiAgICAgICAgX3ZlcnRleE1hcFt2ZXJ0ZXhJZF0gPSBuZXdWZXJ0ZXg7XHJcbiAgICBcclxuICAgICAgICBpZiAoIV9pZFRvVmVydGV4W2xpbmtWaWV3Lm1vZGVsLmlkXSkge1xyXG4gICAgICAgICAgICBfaWRUb1ZlcnRleFtsaW5rVmlldy5tb2RlbC5pZF0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lkVG9WZXJ0ZXhbbGlua1ZpZXcubW9kZWwuaWRdLnB1c2godmVydGV4SWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdWZXJ0ZXg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGZpbmRJbnRlcm1lZGlhdGVWZXJ0aWNlcyAodmVydGljZXMsIHN0ZXApIHtcclxuICAgICAgICBjb25zdCBhbGxWZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIGxldCBwcmV2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZlcnRpY2VzLmZvckVhY2godmVydGV4ID0+IHtcclxuICAgICAgICAgICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IHByZXYueCA9PT0gdmVydGV4Lng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBwcmV2LnkgPT09IHZlcnRleC55O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LnkgPCB2ZXJ0ZXgueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gcHJldi55ICsgc3RlcDsgeSA8IHZlcnRleC55OyB5ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2goeyB4OiB2ZXJ0ZXgueCwgeTogeSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBwcmV2LnkgLSBzdGVwOyB5ID4gdmVydGV4Lnk7IHkgLT0gc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVmVydGljZXMucHVzaCh7IHg6IHZlcnRleC54LCB5OiB5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi54IDwgdmVydGV4LngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHByZXYueCArIHN0ZXA7IHggPCB2ZXJ0ZXgueDsgeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxWZXJ0aWNlcy5wdXNoKHsgeDogeCwgeTogdmVydGV4LnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gcHJldi54IC0gc3RlcDsgeCA+IHZlcnRleC54OyB4IC09IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFZlcnRpY2VzLnB1c2goeyB4OiB4LCB5OiB2ZXJ0ZXgueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbGxWZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgICAgIHByZXYgPSB2ZXJ0ZXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gYWxsVmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgX2luaXQoKTtcclxufSIsImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0ICogYXMgam9pbnQgZnJvbSAncmFwcGlkJztcclxuXHJcbmltcG9ydCB7IExBQkVMX0xFRlRfUklHSFRfUEFERElORyB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG5leHBvcnQgY29uc3QgRk9SRUlHTl9PQkpFQ1RfUEFERElORyA9IDI7IC8vIGluIHB4XHJcbmV4cG9ydCBjb25zdCBQTkdfQ09OVEVOVF9QQURESU5HID0gMTsgLy8gaW4gcHhcclxuZXhwb3J0IGNvbnN0IEVYQ0xVREVEX0VMRU1FTlRTID0gW1xyXG4gICAgJy5kbi1hcnJvdycsXHJcbiAgICAnaW1nJyxcclxuICAgICcuZGVyaXZhdGlvbi1ub2RlX2JvZHktc2Nyb2xsZXInLFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydFRvU1ZHIChwYXBlciwgcHJvcHMpIHtcclxuICAgIHByb3BzID0gcHJvcHMgfHwge307XHJcblxyXG4gICAgY29uc3QgdnBUcmFuc2Zvcm0gPSBwYXBlci52aWV3cG9ydC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgcGFwZXIudmlld3BvcnQucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuXHJcbiAgICAvLyBjb25zdCBwYXBlckJvdW5kaW5nQm94ID0gcGFwZXIudmlld3BvcnQuZ2V0QkJveCgpO1xyXG4gICAgY29uc3QgcGFwZXJCb3VuZGluZ0JveCA9IHBhcGVyLmdldENvbnRlbnRCQm94KCk7XHJcbiAgICBjb25zdCBzdmdDb3B5ID0gcHJvcHMuY29udmVydEh0bWwgPyBjcmVhdGVTVkdDb3B5KHBhcGVyKSA6IHNpbXBsZUNsb25lKHBhcGVyKTtcclxuXHJcbiAgICBwYXBlci52aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHZwVHJhbnNmb3JtIHx8ICcnKTtcclxuXHJcbiAgICBpZiAocHJvcHMucGRmTW9kZSkge1xyXG4gICAgICAgIHN2Z0NvcHkucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcclxuICAgICAgICBzdmdDb3B5LnJlbW92ZUF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XHJcbiAgICAgICAgaWYgKHByb3BzLnByZXNlcnZlRGltZW5zaW9ucykge1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBwYXBlckJvdW5kaW5nQm94LndpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBQQURESU5HID0gNDA7XHJcbiAgICAgICAgc3ZnQ29weS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCAtIFBBRERJTkcsXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueSAtIFBBRERJTkcsXHJcbiAgICAgICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCArIHBhcGVyQm91bmRpbmdCb3gud2lkdGggKyBQQURESU5HLFxyXG4gICAgICAgICAgICBwYXBlckJvdW5kaW5nQm94LnkgKyBwYXBlckJvdW5kaW5nQm94LmhlaWdodCArIFBBRERJTkcsXHJcbiAgICAgICAgXS5qb2luKCcgJykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzdmdDb3B5LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICBpZiAocHJvcHMucHJlc2VydmVEaW1lbnNpb25zKSB7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHBhcGVyQm91bmRpbmdCb3gud2lkdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwYXBlckJvdW5kaW5nQm94LmhlaWdodC50b1N0cmluZygpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xyXG4gICAgICAgICAgICBzdmdDb3B5LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN2Z0NvcHkuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJycgK1xyXG4gICAgICAgIHBhcGVyQm91bmRpbmdCb3gueCArICcgJyArXHJcbiAgICAgICAgcGFwZXJCb3VuZGluZ0JveC55ICsgJyAnICtcclxuICAgICAgICBwYXBlckJvdW5kaW5nQm94LndpZHRoICsgJyAnICtcclxuICAgICAgICBwYXBlckJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBjb25zdCBpc0lFID0gISh3aW5kb3cuQWN0aXZlWE9iamVjdCkgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbiAgICBpZihpc0lFKXtcclxuICAgICAgYWxpZ25UZXh0KHN2Z0NvcHkucXVlcnlTZWxlY3RvckFsbCgndGV4dCcpKTtcclxuXHJcbiAgICAgIC8vU2hpbSBTVkdFbGVtZW50IGNsYXNzTGlzdFxyXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU1ZHRWxlbWVudC5wcm90b3R5cGUsJ2NsYXNzTGlzdCcpKXtcclxuICAgICAgICAgIGlmIChIVE1MRWxlbWVudCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwnY2xhc3NMaXN0Jykpe1xyXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnY2xhc3NMaXN0Jyk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTVkdFbGVtZW50LnByb3RvdHlwZSwnY2xhc3NMaXN0JywgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd29ya2Fyb3VuZCB0byBpbmNsdWRlIG9ubHkgb250b2RpYS1yZWxhdGVkIHN0eWxlc2hlZXRzXHJcbiAgICBjb25zdCBjc3NTdHJpbmdzID0gZXh0cmFjdENTU0Zyb21QYXBlcihzdmdDb3B5KTtcclxuXHJcbiAgICBjb25zdCBkZWZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdkZWZzJyk7XHJcbiAgICBkZWZzLmlkID0gJ2V4dHJhY3RlZC1zdHlsZXMnOyAvLyBGb3IgSUUtRURHRVxyXG4gICAgY3NzU3RyaW5ncy5mb3JFYWNoKChjc3NTdHJpbmcsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW9jRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgbW9jRGl2LmlkID0gJ2V4dHJhY3RlZC1maWxlLScgKyBpbmRleDtcclxuICAgICAgICBtb2NEaXYuaW5uZXJIVE1MID0gJzxzdHlsZT4nICsgY3NzU3RyaW5ncyArICc8L3N0eWxlPic7XHJcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtb2NEaXYuZmlyc3RDaGlsZCk7XHJcbiAgICB9KTtcclxuICAgIHN2Z0NvcHkuaW5zZXJ0QmVmb3JlKGRlZnMsIHN2Z0NvcHkuZmlyc3RDaGlsZCk7XHJcblxyXG5cclxuICAgIGlmIChwcm9wcy5lbGVtZW50c1RvUmVtb3ZlU2VsZWN0b3IpIHtcclxuICAgICAgICBwcm9jZXNzTm9kZXMoc3ZnQ29weS5xdWVyeVNlbGVjdG9yQWxsKHByb3BzLmVsZW1lbnRzVG9SZW1vdmVTZWxlY3RvciksXHJcbiAgICAgICAgICAgIG5vZGUgPT4gbm9kZS5yZW1vdmUoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udmVydEltYWdlcyhzdmdDb3B5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltYWdlJykpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Z0NvcHkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsaWduVGV4dCAodGV4dEJsb2Nrcykge1xyXG4gICAgcHJvY2Vzc05vZGVzKHRleHRCbG9ja3MsICh0ZXh0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xyXG4gICAgICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnICYmIHRyYW5zZm9ybS5pbmRleE9mKCd0cmFuc2xhdGUnKSkge1xyXG4gICAgICAgICAgICB0ZXh0LnJlbW92ZUF0dHJpYnV0ZSgndGV4dC1hbmNob3InKTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IHRyYW5zZm9ybS5tYXRjaCgvLChbXFxkLC5dKylcXCkvKVsxXTtcclxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtMQUJFTF9MRUZUX1JJR0hUX1BBRERJTkd9LCAke3l9KWApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29udmVydEltYWdlcyAoaW1hZ2VzKSB7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgcHJvY2Vzc05vZGVzKGltYWdlcywgKGltYWdlKSA9PiB7XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWltYWdlKSByZXNvbHZlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlZm94IHVzZXMgYGhyZWZgLCBhbGwgdGhlIG90aGVycyAneGxpbms6aHJlZidcclxuICAgICAgICAgICAgdmFyIHVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpIHx8IGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xyXG5cclxuICAgICAgICAgICAgam9pbnQudXRpbC5pbWFnZVRvRGF0YVVyaSh1cmwsIChlcnIsIGRhdGFVcmkpID0+IHtcclxuICAgICAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsIGRhdGFVcmkpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbn1cclxuXHJcbmNvbnN0IEVYQ0xVREVEX1NFTEVDVE9SUyA9IFsgJ2JvZHknIF07XHJcbmZ1bmN0aW9uIGV4dHJhY3RDU1NGcm9tUGFwZXIgKHBhcGVyKSB7XHJcbiAgICBjb25zdCBjc3NUZXh0cyA9IFtdO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSBwYXBlci5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XHJcblxyXG4gICAgY29uc3QgYWxsb3dlZENzc0NsYXNzZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gYWxsRWxlbWVudHNbaV07XHJcblxyXG4gICAgICAgIGNvbnN0IGNsYXNzZXNMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjbGFzc2VzTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBhbGxvd2VkQ3NzQ2xhc3Nlcy5wdXNoKGNsYXNzZXNMaXN0W2pdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY3NzQ2xhc3NlcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjc3NGaWxlID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XHJcbiAgICAgICAgICAgIGNzc0NsYXNzZXMgPSBjc3NGaWxlLmNzc1J1bGVzIHx8IGNzc0ZpbGUucnVsZXM7XHJcbiAgICAgICAgICAgIGlmICghY3NzQ2xhc3NlcykgeyBjb250aW51ZTsgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgY29uc3QgY3NzQ2xhc3NUZXh0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3NzQ2xhc3Nlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gY3NzQ2xhc3Nlc1tqXTtcclxuICAgICAgICAgICAgY29uc3QgZG9lc0NvbnRhaW5BbGxvd2VkQ2xhc3MgPSBjb250YWluc0FsbG93ZWRDbGFzcyhydWxlLnNlbGVjdG9yVGV4dCwgYWxsb3dlZENzc0NsYXNzZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBhbGxvd2VkU2VsZWN0b3IgPSBFWENMVURFRF9TRUxFQ1RPUlMuaW5kZXhPZihydWxlLnNlbGVjdG9yVGV4dCkgPT09IC0xICYmIGRvZXNDb250YWluQWxsb3dlZENsYXNzO1xyXG4gICAgICAgICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIENTU1N0eWxlUnVsZSAmJiBhbGxvd2VkU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNzc0NsYXNzVGV4dC5wdXNoKHJ1bGUuY3NzVGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNzc1RleHRzLnB1c2goY3NzQ2xhc3NUZXh0LmpvaW4oJ1xcbicpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWluc0FsbG93ZWRDbGFzcyAoY3NzU2VsZWN0b3IsIGFsbG93ZWRDc3NDbGFzc2VzKSB7XHJcbiAgICAgICAgaWYgKCFjc3NTZWxlY3RvcikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxvd2VkQ3NzQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY3NzU2VsZWN0b3IuaW5kZXhPZihhbGxvd2VkQ3NzQ2xhc3Nlc1tpXSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNzc1RleHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaW1wbGVDbG9uZSAocGFwZXIpIHtcclxuICAgIGNvbnN0IHN2Z0Nsb25lID0gcGFwZXIuc3ZnLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIHJldHVybiBzdmdDbG9uZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU1ZHQ29weSAocGFwZXIpIHtcclxuICAgIGNvbnN0IHN2Z0Nsb25lID0gcGFwZXIuc3ZnLmNsb25lTm9kZSh0cnVlKTtcclxuICAgIGNvbnN0IGNlbGxzID0gcGFwZXIubW9kZWwuZ2V0KCdjZWxscycpO1xyXG4gICAgcHJvY2Vzc05vZGVzKHN2Z0Nsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2cuZWxlbWVudCcpLCBjZWxsVmlldyA9PiB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBjZWxsVmlldy5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJyk7XHJcbiAgICAgICAgY29uc3QgaHRtbFZpZXcgPSBwYXBlci5lbC5xdWVyeVNlbGVjdG9yKGAuZGVyaXZhdGlvbi1ub2RlW2lkPScke2lkfSddYCk7XHJcbiAgICAgICAgaWYgKCFodG1sVmlldykgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgbGV0IGNvbnRlbnQ7XHJcbiAgICAgICAgY29uc3QgaXNJdElFMTEgPSBCb29sZWFuKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQuKnJ2XFw6MTFcXC4vKSk7XHJcbiAgICAgICAgaWYgKGlzSXRJRTExKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwcm9jZXNzSFRNTChodG1sVmlldywgRVhDTFVERURfRUxFTUVOVFMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2ZvcmVpZ25PYmplY3QnKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzLmdldChpZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTaXplID0gY2VsbC5nZXQoJ3NpemUnKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGNlbGxTaXplLndpZHRoICsgRk9SRUlHTl9PQkpFQ1RfUEFERElORyk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBjZWxsU2l6ZS5oZWlnaHQgKyBGT1JFSUdOX09CSkVDVF9QQURESU5HKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGh0bWxDb250ZW50ID0gaHRtbFZpZXcuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICBodG1sQ29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYm9keSA9IGh0bWxWaWV3LnF1ZXJ5U2VsZWN0b3IoJy5kZXJpdmF0aW9uLW5vZGVfYm9keScpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdCb2RpZXMgPSBodG1sQ29udGVudC5xdWVyeVNlbGVjdG9yKCcuZGVyaXZhdGlvbi1ub2RlX2JvZHknKTtcclxuICAgICAgICAgICAgaWYgKGJvZHkuc2Nyb2xsVG9wICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdCb2RpZXMuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSAoLWJvZHkuc2Nyb2xsVG9wKSArICdweCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChodG1sQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjZWxsVmlldy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2VsbFZpZXcuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcclxuXHJcbiAgICAgICAgY29uc3QgYW5jaG9yID0gY2VsbFZpZXcucXVlcnlTZWxlY3RvcignLmV4cG9ydC1hbmNob3InKTtcclxuICAgICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IGNlbGxWaWV3LnF1ZXJ5U2VsZWN0b3IoJy5ib2R5Jyk7XHJcbiAgICAgICAgYW5jaG9yLnJlbW92ZUNoaWxkKHJvb3QpO1xyXG4gICAgICAgIGFuY2hvci5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzdmdDbG9uZTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzSFRNTCAoaHRtbFZpZXcsIGV4Y2x1ZGVkRWxlbWVudHMpIHtcclxuICAgIGNvbnN0IGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2cnKTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWN1cnNpb24gKGh0bWxSb290KSB7XHJcbiAgICAgICAgaWYgKGh0bWxSb290IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrRWxlbWVudChodG1sUm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3JlY3QnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGdldE9mZnNldFRvcChodG1sUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gZ2V0T2Zmc2V0TGVmdChodG1sUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGh0bWxSb290KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzdmdSZWN0LnNldEF0dHJpYnV0ZSgnY2xhc3NOYW1lJywgaHRtbFJvb3QuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgc3R5bGUuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCBzdHlsZS5ib3JkZXJDb2xvcik7XHJcbiAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgc3R5bGUuYm9yZGVyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCBvZmZzZXRMZWZ0KTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd5Jywgb2Zmc2V0VG9wKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHN0eWxlLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdHlsZS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQocmVjdCk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzTm9kZXMoaHRtbFJvb3QuY2hpbGROb2RlcywgY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbihjaGlsZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaHRtbFJvb3QgaW5zdGFuY2VvZiBUZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gaHRtbFJvb3QudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAodGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICd0ZXh0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGh0bWxSb290LnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSBnZXRPZmZzZXRUb3AocGFyZW50KTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IGdldE9mZnNldExlZnQocGFyZW50KTtcclxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xyXG5cclxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBzdHlsZS5jb2xvcik7XHJcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnaGFuZ2luZycpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneCcsIG9mZnNldExlZnQpO1xyXG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneScsIG9mZnNldFRvcCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYXhDaGFyTnVtYmVyID0gZ2V0TWF4Q2hhck51bWJlcihcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgK3N0eWxlLndpZHRoLnN1YnN0cmluZygwLCBzdHlsZS53aWR0aC5sZW5ndGggLSAyKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlLmZvbnRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG1heENoYXJOdW1iZXIgPT09IHRleHRDb250ZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgRUxJUFNJU19MRU5HVEggPSAyO1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnN1YnN0cmluZygwLCBtYXhDaGFyTnVtYmVyIC0gRUxJUFNJU19MRU5HVEgpICsgJy4uLic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrRWxlbWVudCAoZWxlbWVudCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhjbHVkZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBJRTExIGZpeFxyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZWxlbWVudC5tYXRjaGVzID8gZWxlbWVudC5tYXRjaGVzIDogZWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcjtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMuYXBwbHkoZWxlbWVudCwgW2V4Y2x1ZGVkRWxlbWVudHNbaV1dKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9mZnNldFRvcCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmKGVsZW1lbnQuY2xhc3NOYW1lICE9PSAnZGVyaXZhdGlvbi1ub2RlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50LmNsaWVudFRvcCArIChlbGVtZW50Lm9mZnNldFBhcmVudCA/IGdldE9mZnNldFRvcChlbGVtZW50Lm9mZnNldFBhcmVudCkgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0TGVmdCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmKGVsZW1lbnQuY2xhc3NOYW1lICE9PSAnZGVyaXZhdGlvbi1ub2RlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRMZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0ICsgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID8gZ2V0T2Zmc2V0TGVmdChlbGVtZW50Lm9mZnNldFBhcmVudCkgOiAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TWF4Q2hhck51bWJlciAodGV4dCwgbWF4V2lkdGgsIGZvbnQpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGN0eC5mb250ID0gZm9udDtcclxuXHJcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xyXG4gICAgICAgIGlmICh0ZXh0V2lkdGggPD0gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IEZJVF9DT1JSRUNUSU9OID0gMC44NTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiAobWF4V2lkdGggLyB0ZXh0V2lkdGgpICogRklUX0NPUlJFQ1RJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWN1cnNpb24oaHRtbFZpZXcpO1xyXG5cclxuICAgIHJldHVybiBnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzTm9kZXMgKG5vZGVzLCBjYWxsYmFjaykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhbGxiYWNrKG5vZGVzW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0YVVSTCAocGFwZXIsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN2Z09wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnMuc3ZnT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9sZFRvU3ZnID0gcGFwZXIudG9TVkc7XHJcbiAgICAgICAgcGFwZXIudG9TVkcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgZXhwb3J0VG9TVkcgKHBhcGVyLCBzdmdPcHRpb25zKS50aGVuKChzdmdTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN2Z1N0cmluZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcGFwZXIudG9QTkcoZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoaW1hZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhcGVyLnRvU1ZHID0gb2xkVG9Tdmc7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZpdFJlY3RLZWVwaW5nQXNwZWN0UmF0aW8gKHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcclxuICAgIGlmICghdGFyZ2V0V2lkdGggJiYgIXRhcmdldEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBzb3VyY2VXaWR0aCwgaGVpZ2h0OiBzb3VyY2VIZWlnaHQgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdGlvID0gc291cmNlV2lkdGggLyBzb3VyY2VIZWlnaHQ7XHJcbiAgICB0YXJnZXRXaWR0aCA9IHRhcmdldFdpZHRoIHx8ICh0YXJnZXRIZWlnaHQgKiByYXRpbyk7XHJcbiAgICB0YXJnZXRIZWlnaHQgPSB0YXJnZXRIZWlnaHQgfHwgKHRhcmdldFdpZHRoIC8gcmF0aW8pO1xyXG5cclxuICAgIGlmICh0YXJnZXRIZWlnaHQgKiByYXRpbyA8PSB0YXJnZXRXaWR0aCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB0YXJnZXRIZWlnaHQgKiByYXRpbywgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldFdpZHRoIC8gcmF0aW8gfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0VG9TVkc7XHJcbiIsImltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCB7XHJcbiAgICBsaW1pdFBvaW50UG9zaXRpb24sXHJcbiAgICBleHRlbmRCb3VuZHMsXHJcbiAgICBnbG9iYWxUb1NjYWxlZEJvdW5kcyxcclxuICAgIGdsb2JhbFRvU2NhbGVkU2l6ZSxcclxuICAgIHNjYWxlZFRvR2xvYmFsU2l6ZSxcclxuICAgIGdldEdsb2JhbE5vZGVQb3NpdGlvbixcclxuICAgIGdldFNjYWxlZE5vZGVQb3NpdGlvbixcclxuICAgIGdldExvY2FsTm9kZVBvc2l0aW9uLFxyXG4gICAgc2NhbGVkVG9HbG9iYWxQb2ludCxcclxuICAgIGdsb2JhbFRvU2NhbGVkUG9pbnQsXHJcbiAgICBsb2NhbFRvR2xvYmFsUG9pbnQsXHJcbiAgICBnZXRFbGVtZW50U2l6ZSxcclxufSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IFpfSU5ERVhFUyB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG5jb25zdCBIT1JfTEFCRUxfUEFERElORyA9IDg7XHJcbmNvbnN0IFZFUlRfTEFCRUxfUEFERElORyA9IDY7XHJcbmNvbnN0IEZPTlRfU0laRSA9IDExO1xyXG5jb25zdCBERUZBVUxUX0ZSQU1FX1NJWkUgPSB7IHdpZHRoOiA1MCwgaGVpZ2h0OiA1MCB9O1xyXG5cclxuLyoqXHJcbiAqIEJvdW5kc1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCb3VuZHNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFlcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbllcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogVmlld0ZyYW1lIG9mIHRoZSBtYWluIHZpZXcgKFZpZXctMikuXHJcbiAqIFByb3ZpZGVzIHZpc2libGUgZWxlbWVudHMgdG8gdGhlIExpbmVhZ2VEaWFncmFtLlxyXG4gKiBCYXNlZCBvbiBqb2ludC5zaGFwZXMuYmFzaWMuUmVjdC5cclxuICpcclxuICogQ29uc3RydWN0b3IgcGFyYW1ldGVyczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAcGFyYW0ge1xyXG4gKiAgZGF0YUNvbnRhaW5lcjogRGF0YUNvbnRhaW5lclxyXG4gKiAgaWQ6IHN0cmluZ1xyXG4gKiAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcclxuICogIGJvcmRlckNvbG9yOiBzdHJpbmdcclxuICogIHNwYWNlU2hhcmU6IG51bWJlclxyXG4gKiB9IG9wdGlvbnNcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICpcclxuICogUHVibGljIHByb3BlcnRpZXM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogaWQ6IHN0cmluZ1xyXG4gKiBtb2RlbDogQHBhcmFtIG9wdGlvbnNcclxuICogY29uc3RQb3NpdGlvbjogUG9pbnRcclxuICogc2l6ZTogU2l6ZSAod2lkdGgsIGhlaWdodClcclxuICogbW92aW5nQnlJdHNlbGY6IGJvb2xlbmEgLSBpdCdzIGZsYWcgdG8gYmxvY2sgYSBtb3ZpbmdcclxuICpcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogcmVmcmVzaE5vZGVTdGF0ZTogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XHJcbiAqIGdldE5vZGVzOiAoKSA9PiBOb2RlW107XHJcbiAqIHVwZGF0ZUJvdW5kczogKCkgPT4gdm9pZDtcclxuICogY2xlYXI6ICgpID0+IHZvaWQ7XHJcbiAqIGdldE5vZGVCb3VuZHM6ICgpID0+IEJvdW5kcztcclxuICogZ2V0Vmlld1BvcnRCb3VuZHM6ICgpID0+IEJvdW5kcztcclxuICogc2V0RGF0YTogKGRhdGFDb250YWluZXI6IERhdGFDb250YWluZXIpID0+IHZvaWRcclxuICogZ2V0VmlzaWJsZUNlbGxzOiAoKSA9PiB7IG5vZGVzOiBOb2RlW10sIGxpbms6IExpbmtbXSB9O1xyXG4gKiBjYWxjdWxhdGVWaXNpYmxlQ2VsbHM6ICgpID0+IHZvaWQ7XHJcbiAqIHNldFBvc2l0aW9uOiAocG9zOiBQb2ludCkgPT4gdm9pZDtcclxuICogc2V0U2l6ZTogKHNpemU6IFNpemUpID0+IHZvaWQ7XHJcbiAqIHBvc2l0aW9uVmlld1BvcnQ6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gUG9pbnQ7XHJcbiAqIHJlc2V0U2l6ZTogKCkgPT4gdm9pZDtcclxuICogaGl0U2NhbGVkUG9pbnRUZXN0IChwb2ludDogUG9pbnQpID0+IGJvb2xlYW47XHJcbiAqIGhpdFRlc3QgKG5vZGU6IE5vZGUsIHBhcnRpYWxIaXQ6IGJvb2xlYW4pID0+IGJvb2xlYW47XHJcbiAqIG93bmVyVGVzdCAobm9kZTogTm9kZSkgPT4gYm9vbGVhbjtcclxuICogc2V0U2NhbGU6IChzY2FsZTogUG9pbnQpID0+IHZvaWQ7XHJcbiAqIGdldFNjYWxlOiAoKSA9PiBQb2ludDtcclxuICogc2V0RWxlbWVudFNpemU6IChzaXplOiBFbGVtZW50U2l6ZSkgPT4gdm9pZDtcclxuICogZ2V0RWxlbWVudFNpemU6ICgpID0+IEVsZW1lbnRTaXplO1xyXG4gKiBsaW1pdE5vZGVQb3NpdGlvbjogKG5vZGU6IE5vZGUpID0+IHZvaWQ7XHJcbiAqXHJcbiAqIEV2ZW50c1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBmaXJlcyBjaGFuZ2U6Y29ycmVjdFBvc3Rpb24gKGxpbWl0dGVkUG9pbnQ6IFBvaW50KVxyXG4gKiBAZmlyZXMgY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbiAobmV3UG9zaXRpb246IFBvaW50KVxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFZpZXdGcmFtZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgLy8gSW5pdFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgc2VsZi5pZCA9IG9wdGlvbnMuaWQ7XHJcbiAgICBzZWxmLm1vZGVsID0gb3B0aW9ucztcclxuICAgIHNlbGYuY29uc3RQb3NpdGlvbiA9IHsgeDogMCwgeTogMH07XHJcblxyXG4gICAgc2VsZi5zaXplID0gREVGQVVMVF9GUkFNRV9TSVpFO1xyXG4gICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnNpbmdsZU1vZGUpIHtcclxuICAgICAgICBvcHRpb25zLmRhdGFDb250YWluZXIubm9kZXMuZm9yRWFjaChuID0+IG4udmlld0ZyYW1lT3duZXJJZCA9IHNlbGYuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50O1xyXG5cclxuICAgIGxldCBfY2FjaGVkUmVzdWx0O1xyXG4gICAgbGV0IF9ub2RlQm91bmRzO1xyXG4gICAgbGV0IF92aWV3UG9ydFBvc2l0aW9uQm91bmRzO1xyXG4gICAgbGV0IF9kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgbGV0IF9zY2FsZTtcclxuICAgIGxldCBfdmlld1BvcnRQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9OyAvLyBnbG9iYWwgY29vcmRpbmF0ZXNcclxuICAgIGxldCBfZGVmYXVsdEVsZW1lbnRTaXplID0gcGFyYW1ldGVycy5lbGVtZW50U2l6ZTtcclxuICAgIGxldCBfcmVmZXJlbmNlU2l6ZSA9IF9kZWZhdWx0RWxlbWVudFNpemU7XHJcbiAgICBsZXQgX3ZpZXdQb3J0Qm91bmRzO1xyXG5cclxuICAgIGNvbnN0IF9mcmFtZVBhZGRpbmcgPSBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZztcclxuICAgIGNvbnN0IGxhYmVsID0gam9pbnQudXRpbC5icmVha1RleHQob3B0aW9ucy5sYWJlbCwge1xyXG4gICAgICAgIHdpZHRoOiBzZWxmLnNpemUud2lkdGggLSBIT1JfTEFCRUxfUEFERElORyAqIDJcclxuICAgIH0pO1xyXG5cclxuICAgIGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LmFwcGx5KHNlbGYsIFt7XHJcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXHJcbiAgICAgICAgdHlwZTogJ3ZpZXdGcmFtZScsXHJcbiAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgICAgIHNpemU6IHNlbGYuc2l6ZSxcclxuICAgICAgICBhdHRyczoge1xyXG4gICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBjbGFzczogJ2JvZHkgdmlldy1mcmFtZScsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc2VsZi5zaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzZWxmLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHBhcmFtZXRlcnMuZnJhbWVCb3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgJ3gtYWxpZ25tZW50JzogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ2JvbGQnLFxyXG4gICAgICAgICAgICAgICAgcmVmOiAncmVjdCcsXHJcbiAgICAgICAgICAgICAgICAncmVmLXgnOiBIT1JfTEFCRUxfUEFERElORyxcclxuICAgICAgICAgICAgICAgICdyZWYteSc6IFZFUlRfTEFCRUxfUEFERElORyArIEZPTlRfU0laRSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLmluZGV4T2YoJ1xcbicpID09PSAtMSA/IGxhYmVsIDogbGFiZWwuc3Vic3RyaW5nKDAsIGxhYmVsLmluZGV4T2YoJ1xcbicpKSArICcuLi4nLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogb3B0aW9ucy5ib3JkZXJDb2xvclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB6OiBaX0lOREVYRVMuVklFV19GUkFNRSxcclxuICAgIH1dKTtcclxuXHJcbiAgICBpZiAoc2VsZi5tb2RlbC53aWR0aCkgc2VsZi5tb2RlbC53aWR0aCA9IE1hdGguYWJzKE1hdGgubWF4KHNlbGYubW9kZWwud2lkdGgsIHBhcmFtZXRlcnMuZnJhbWVQYWRkaW5nLnggKiAyICsgMSkpO1xyXG4gICAgaWYgKHNlbGYubW9kZWwuaGVpZ2h0KSBzZWxmLm1vZGVsLmhlaWdodCA9IE1hdGguYWJzKE1hdGgubWF4KHNlbGYubW9kZWwuaGVpZ2h0LCBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy55ICogMiArIDEpKTtcclxuXHJcbiAgICBzZWxmLm9uKCdjaGFuZ2U6cG9zaXRpb24nLCAoY2VsbCwgcG9zaXRpb24pID0+IHtcclxuICAgICAgICBpZiAoIXNlbGYubW92aW5nQnlJdHNlbGYpIHtcclxuICAgICAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYucG9zaXRpb24oc2VsZi5jb25zdFBvc2l0aW9uLngsIHNlbGYuY29uc3RQb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVkT2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogc2VsZi5jb25zdFBvc2l0aW9uLnggLSBwb3NpdGlvbi54LFxyXG4gICAgICAgICAgICAgICAgeTogc2VsZi5jb25zdFBvc2l0aW9uLnkgLSBwb3NpdGlvbi55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxPZmZzZXQgPSBzY2FsZWRUb0dsb2JhbFBvaW50KHNjYWxlZE9mZnNldCwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXdQb3J0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBfdmlld1BvcnRQb3NpdGlvbi54ICsgZ2xvYmFsT2Zmc2V0LngsXHJcbiAgICAgICAgICAgICAgICB5OiBfdmlld1BvcnRQb3NpdGlvbi55ICsgZ2xvYmFsT2Zmc2V0LnksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvbicsIG5ld1ZpZXdQb3J0UG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIF9pbml0KG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHNlbGYuc2V0KCdjb3JyZWN0UG9zdGlvbicsIG51bGwpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIFxyXG4gICAgLy8gQ2FsbEJhY2sgdG8gb3ZlcnJpZGVcclxuICAgIC8vIHNlbGYuX29uQ2hhbmdlQm91bmRzID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAqL1xyXG4gICAgc2VsZi5yZWZyZXNoTm9kZVN0YXRlID0gX3JlZnJlc2hOb2RlU3RhdGU7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaXN0IG9mIG5vZGVzIHdoaWNoIHZpZXdGcmFtZSBvd25zLlxyXG4gICAgICogQHJldHVybnMge0FycmF5IG9mIE5vZGV9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXROb2RlcyA9IF9nZXROb2RlczsgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhY2x1bGF0ZSB2aWV3UG9ydCBib3VuZHNcclxuICAgICovXHJcbiAgICBzZWxmLnVwZGF0ZUJvdW5kcyA9IF91cGRhdGVCb3VuZHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBjYWNoZXMuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5jbGVhciA9IF9jbGVhcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdGcmFtZSBwdWJsaWMgbW9kZWxcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEJvdW5kc1xyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblhcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhYXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluWVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFlcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYm91bmRzIG9mIHZpZXdGcmFtZSBpbiBwYXBlciBjb29yZGluYXRlcyB3aXRob3V0IHBhZGRpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm91bmRzfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Tm9kZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX25vZGVCb3VuZHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2Ygdmlld0ZyYW1lIGluIHBhcGVyIGNvb3JkaW5hdGVzLlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0Vmlld1BvcnRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF92aWV3UG9ydEJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvdW5kcyBvZiB2aWV3RnJhbWUgaW4gcGFwZXIgY29vcmRpbmF0ZXMuXHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3UG9ydFBvc2l0aW9uQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld1BvcnRQb3NpdGlvbkJvdW5kcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB2aXNpYmxlIGluIHRoaXMgdmlld3BvcnQgY2VsbHMgKExpbmtzfE5vZGVzIGUudC5jLilcclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBub2RlczogTm9kZVtdLFxyXG4gICAgICogIGxpbmtzOiBMaW5rW10sXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0VmlzaWJsZUNlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX2NhY2hlZFJlc3VsdCkgc2VsZi5jYWxjdWxhdGVWaXNpYmxlQ2VsbHMoKTtcclxuICAgICAgICByZXR1cm4gX2NhY2hlZFJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgbGlzdCBvZiBhbGwgdmlzaWJsZSBpbiB0aGlzIHZpZXdwb3J0IGNlbGxzXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVJlbmRlck9wdGlvbnN9IG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2VsZi5jYWxjdWxhdGVWaXNpYmxlQ2VsbHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIF9yZWZlcmVuY2VTaXplID0gX2NhbGN1bGF0ZVJlZmVyZW5jZU5vZGVTaXplKG9wdGlvbnMuZWxlbWVudFNpemUgfHwgX2RlZmF1bHRFbGVtZW50U2l6ZSk7XHJcbiAgICAgICAgX3ZpZXdQb3J0Qm91bmRzID0gX2dldFZpZXdQb3J0Qm91bmRzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsb2JhbFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2VsZi5zaXplLCBfc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbFJlY3RhbmdsZSA9IHtcclxuICAgICAgICAgICAgeDogX3ZpZXdQb3J0UG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogX3ZpZXdQb3J0UG9zaXRpb24ueSxcclxuICAgICAgICAgICAgd2lkdGg6IGdsb2JhbFNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogZ2xvYmFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IF9kYXRhQ29udGFpbmVyLmdldEVsZW1lbnRzRm9yUmVjdGFuZ2xlKGdsb2JhbFJlY3RhbmdsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU5vZGVzID0gYWN0aXZlRWxlbWVudHMubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc05vZGVWaXNpYmxlID0gX293bmVyVGVzdChub2RlKSAmJiBfaGl0VGVzdEJ5R2xvYmFsUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05vZGVWaXNpYmxlKSB2aXNpYmxlTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05vZGVWaXNpYmxlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2aXNpYmxlTm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgX3JlZnJlc2hOb2RlU3RhdGUobm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9jYWNoZWRSZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpYmxlTm9kZXMsXHJcbiAgICAgICAgICAgIGxpbmtzOiBhY3RpdmVFbGVtZW50cy5saW5rcyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgcG9zaXRpb24gb2YgdGhlIHZpZXdGcmFtZSBvbiB0aGUgcGFwZXJcclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBub2RlczogTm9kZVtdLFxyXG4gICAgICogIGxpbmtzOiBMaW5rW10sXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcbiAgICAgICAgc2VsZi5jb25zdFBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgIHNlbGYucG9zaXRpb24oc2VsZi5jb25zdFBvc2l0aW9uLngsIHNlbGYuY29uc3RQb3NpdGlvbi55KTtcclxuICAgICAgICBzZWxmLm1vdmluZ0J5SXRzZWxmID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBzaXplIG9mIHRoZSB2aWV3LXBvcnQtam9pbnRqcyBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbWVtYmVyXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0U2l6ZSA9IF9zZXRTaXplO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgc2V0cyBvZmZzZXQgZm9yIGFsbCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3UG9ydC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIGRpc2FibGVzIHRoZSBsaW1pdFxyXG4gICAgICogQHJldHVybnMge1BvaW50fVxyXG4gICAgICovXHJcbiAgICBzZWxmLnBvc2l0aW9uVmlld1BvcnQgPSBfcG9zaXRpb25WaWV3UG9ydDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBzaXplLlxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLm1vZGVsLndpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHNlbGYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgdGhlXHJcbiAgICAgKiBwb2ludCBpcyBpbiB0aGUgdmlld1BvcnQgb2YgVmlld0ZyYW1lIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICBzZWxmLmhpdFNjYWxlZFBvaW50VGVzdCA9IF9oaXRTY2FsZWRQb2ludFRlc3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIHRoZVxyXG4gICAgICogbm9kZSBpcyBpbiB0aGUgdmlld1BvcnQgb2YgVmlld0ZyYW1lIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICBzZWxmLmhpdFRlc3RCeVNjYWxlZFBvc2l0aW9uID0gX2hpdFRlc3RCeVNjYWxlZFBvc2l0aW9uO1xyXG5cclxuICAgIHNlbGYuaGl0VGVzdEJ5R2xvYmFsUG9zaXRpb24gPSBfaGl0QXJlYVRlc3RCeUdsb2JhbFBvc2l0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdXMgd2hldGhlciB0aGVcclxuICAgICAqIFZpZXdGcmFtZSBpcyBvd25lciBvZiB0aGUgcGFzc2VkIG5vZGUgb3Igbm90XHJcbiAgICAgKiBmdW5jdGlvbiBmb3Igb3ZlcnJpZGluZ1xyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICovXHJcbiAgICAvLyBzZWxmLl9vd25lclRlc3QgLSB0byBvdmVycmlkZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NhbGUgb2YgdGhlIHZpZXdGcmFtZS5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHNjYWxlXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRTY2FsZSA9IF9zZXRTY2FsZTtcclxuICAgIC8vIHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQ7IC0gdG8gb3ZlcnJpZGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0U2NhbGUgPSBfZ2V0U2NhbGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGVsZW1lbnQgc2l6ZS5cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChlbGVtZW50U2l6ZSkge1xyXG4gICAgICAgIF9kZWZhdWx0RWxlbWVudFNpemUgPSBlbGVtZW50U2l6ZTtcclxuICAgICAgICBfdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgX2xpbWl0Vmlld1BvcnRQb3NpdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgZWxlbWVudCBzaXplLlxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0RWxlbWVudFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0RWxlbWVudFNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubGltaXROb2RlUG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTsgLy8gc2NhbGVkXHJcbiAgICAgICAgY29uc3Qgc2NhbGVkVmlld1BvcnRCb3VuZHMgPSBnbG9iYWxUb1NjYWxlZEJvdW5kcyhfdmlld1BvcnRQb3NpdGlvbkJvdW5kcyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1pblNjYWxlZFBvc2l0aW9uID0gZ2V0U2NhbGVkTm9kZVBvc2l0aW9uKG5vZGUsIF9zY2FsZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbGltaXRCeU1pbiA9IGxpbWl0UG9pbnRQb3NpdGlvbihub2RlTWluU2NhbGVkUG9zaXRpb24sIHNjYWxlZFZpZXdQb3J0Qm91bmRzKTtcclxuICAgICAgICBjb25zdCBub2RlTWF4U2NhbGVkUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IGxpbWl0QnlNaW4ueCArIG5vZGVTY2FsZWRTaXplLndpZHRoLFxyXG4gICAgICAgICAgICB5OiBsaW1pdEJ5TWluLnkgKyBub2RlU2NhbGVkU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBsaW1pdEJ5TWF4ID0gbGltaXRQb2ludFBvc2l0aW9uKG5vZGVNYXhTY2FsZWRQb3NpdGlvbiwgc2NhbGVkVmlld1BvcnRCb3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc2NhbGVkVG9HbG9iYWxQb2ludChsaW1pdEJ5TWF4LCBfc2NhbGUpO1xyXG5cclxuICAgICAgICBub2RlLm1vZGVsLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0IChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUpIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gb3B0aW9ucy5zY2FsZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQpIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gc2VsZi5fc2NhbGVXaWxsQXBwbGllZChwYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3NjYWxlID0gcGFyYW1ldGVycy5kZWZhdWx0U2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgX25vZGVCb3VuZHMgPSBvcHRpb25zLm5vZGVCb3VuZHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX25vZGVCb3VuZHMgPSBfY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdQb3J0UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb24gPSBvcHRpb25zLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMpIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBvcHRpb25zLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdmlld1BvcnRCb3VuZHMgPSBfZ2V0Vmlld1BvcnRCb3VuZHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzY2FsZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRTY2FsZSAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2VsZi5fc2NhbGVXaWxsQXBwbGllZCkge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBzZWxmLl9zY2FsZVdpbGxBcHBsaWVkKHNjYWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc2NhbGUgPSBzY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3VwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIF9saW1pdFZpZXdQb3J0UG9zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIG9mIHRoZSB2aWV3RnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRTY2FsZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfY2xlYXIgKCkge1xyXG4gICAgICAgIF9jYWNoZWRSZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBzZXRzIG9mZnNldCBmb3IgYWxsIGVsZW1lbnRzIGludG8gdGhlIHZpZXdQb3J0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gZGlzYWJsZXMgdGhlIGxpbWl0XHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9wb3NpdGlvblZpZXdQb3J0ICh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkgX3ZpZXdQb3J0UG9zaXRpb24ueCA9IHg7XHJcbiAgICAgICAgaWYgKHkgIT09IHVuZGVmaW5lZCkgX3ZpZXdQb3J0UG9zaXRpb24ueSA9IHk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHg6IF92aWV3UG9ydFBvc2l0aW9uLngsIHk6IF92aWV3UG9ydFBvc2l0aW9uLnkgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbGlzdCBvZiBub2RlcyB3aGljaCB2aWV3RnJhbWUgb3ducy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheSBvZiBOb2RlfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXROb2RlcyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhQ29udGFpbmVyLm5vZGVzLmZpbHRlcihuID0+IF9vd25lclRlc3QobikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBzaXplIG9mIHRoZSB2aWV3LXBvcnQtam9pbnRqcyBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtTaXplfSBzaXplXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbWVtYmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zZXRTaXplIChzaXplKSB7XHJcbiAgICAgICAgc2VsZi5tb3ZpbmdCeUl0c2VsZiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGl0J3MgYmVzdCBzb2x1dGlvbiB0byBmaXggdGhlIHN2ZyBleHBvcnRpbmdcclxuICAgICAgICAvLyBhbmQgZm9yIGJldHRlciBjb21wYXRpYmlsaXR5IElFMTFcclxuICAgICAgICBzZWxmLmF0dHIoe1xyXG4gICAgICAgICAgICAncmVjdCc6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIHNlbGYucmVzaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcclxuICAgICAgICBzZWxmLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHNlbGYubW9kZWwud2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgICAgIHNlbGYubW9kZWwuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHNlbGYubW92aW5nQnlJdHNlbGYgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBqb2ludC51dGlsLmJyZWFrVGV4dChvcHRpb25zLmxhYmVsLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiBzZWxmLnNpemUud2lkdGggLSBIT1JfTEFCRUxfUEFERElORyAqIDJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZUxhYmVsID0gbGFiZWwuaW5kZXhPZignXFxuJykgPT09IC0xID8gbGFiZWwgOiBsYWJlbC5zdWJzdHJpbmcoMCwgbGFiZWwuaW5kZXhPZignXFxuJykpICsgJy4uLic7XHJcbiAgICAgICAgc2VsZi5hdHRyKCd0ZXh0L3RleHQnLCBjb21wbGV0ZUxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgbm9kZS5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaE5vZGVTdGF0ZSAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGdldExvY2FsTm9kZVBvc2l0aW9uKG5vZGUsIF9zY2FsZSwgc2VsZik7XHJcbiAgICAgICAgbm9kZS5wb3NpdGlvbihub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnkpO1xyXG4gICAgICAgIG5vZGUuc2V0U2l6ZShfcmVmZXJlbmNlU2l6ZSk7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMuY2xpcE5vZGVzKSB7XHJcbiAgICAgICAgICAgIF9jbGlwTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUJvdW5kcyAoKSB7XHJcbiAgICAgICAgX25vZGVCb3VuZHMgPSBfY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjYWxjdWxhdGUgYm91bmRzIG9mIHZpZXcgcG9ydC5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlQm91bmRzICgpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pblg6IEluZmluaXR5LFxyXG4gICAgICAgICAgICBtYXhYOiAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIG1pblk6IEluZmluaXR5LFxyXG4gICAgICAgICAgICBtYXhZOiAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGhlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gX2dldE5vZGVzKCk7XHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUobm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3VuZHMubWluWCA9IE1hdGgubWluKGJvdW5kcy5taW5YLCBwb3MueCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1pblggPT09IHBvcy54KSBib3VuZHMubWluWE5vZGUgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXhYID0gIE1hdGgubWF4KGJvdW5kcy5tYXhYLCBwb3MueCArIHNpemUud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kcy5tYXhYID09PSBwb3MueCArIHNpemUud2lkdGgpIGJvdW5kcy5tYXhYTm9kZSA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1pblkgPSBNYXRoLm1pbihib3VuZHMubWluWSwgcG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kcy5taW5ZID09PSBwb3MueSkgYm91bmRzLm1pbllOb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYm91bmRzLm1heFkgPSBNYXRoLm1heChib3VuZHMubWF4WSwgcG9zLnkgKyBzaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzLm1heFkgPT09IHBvcy55ICsgc2l6ZS5oZWlnaHQpIGJvdW5kcy5tYXhZTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBib3VuZHMud2lkdGggPSBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YO1xyXG4gICAgICAgICAgICBib3VuZHMuaGVpZ2h0ID0gYm91bmRzLm1heFkgLSBib3VuZHMubWluWTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZHMubWluWCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5taW5ZID0gMDtcclxuICAgICAgICAgICAgYm91bmRzLm1heFggPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMubWF4WSA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYm91bmRzIG9mIHZpZXcgcG9ydC5cclxuICAgICAqIEByZXR1cm5zIHtcclxuICAgICAqICBtYXhYOiBudW1iZXJcclxuICAgICAqICBtaW5YOiBudW1iZXJcclxuICAgICAqICBtYXhZOiBudW1iZXJcclxuICAgICAqICBtaW5ZOiBudW1iZXJcclxuICAgICAqIH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlVmlld1BvcnRQb3NpdGlvbkJvdW5kcyAoKSB7XHJcbiAgICAgICAgaWYgKCFfbm9kZUJvdW5kcykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gX2JvdW5kcyAtIGdsb2JhbCBjb29yZFxyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZUdsb2JhbFNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUoc2VsZi5zaXplLCBfc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kc1dpdGhQYWRkaW5nID0gZXh0ZW5kQm91bmRzKF9ub2RlQm91bmRzLCBfZnJhbWVQYWRkaW5nKTtcclxuXHJcbiAgICAgICAgY29uc3Qgdmlld1BvcnRCb3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pblg6IGJvdW5kc1dpdGhQYWRkaW5nLm1pblgsXHJcbiAgICAgICAgICAgIG1heFg6IGJvdW5kc1dpdGhQYWRkaW5nLm1heFggLSB2aWV3RnJhbWVHbG9iYWxTaXplLndpZHRoLFxyXG4gICAgICAgICAgICBtaW5ZOiBib3VuZHNXaXRoUGFkZGluZy5taW5ZLFxyXG4gICAgICAgICAgICBtYXhZOiBib3VuZHNXaXRoUGFkZGluZy5tYXhZIC0gdmlld0ZyYW1lR2xvYmFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZHNXaXRoUGFkZGluZy5tYXhYIC0gdmlld0ZyYW1lR2xvYmFsU2l6ZS53aWR0aCAtIGJvdW5kc1dpdGhQYWRkaW5nLm1pblgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzV2l0aFBhZGRpbmcubWF4WSAtIHZpZXdGcmFtZUdsb2JhbFNpemUuaGVpZ2h0IC0gYm91bmRzV2l0aFBhZGRpbmcubWluWSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAodmlld1BvcnRCb3VuZHMud2lkdGggPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZmZYID0gKHZpZXdGcmFtZUdsb2JhbFNpemUud2lkdGggLSBib3VuZHNXaXRoUGFkZGluZy53aWR0aCkgLyAyO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5taW5YID0gYm91bmRzV2l0aFBhZGRpbmcubWluWCAtIGRpZmZYO1xyXG4gICAgICAgICAgICB2aWV3UG9ydEJvdW5kcy5tYXhYID0gdmlld1BvcnRCb3VuZHMubWluWDtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMud2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZpZXdQb3J0Qm91bmRzLmhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZlkgPSAodmlld0ZyYW1lR2xvYmFsU2l6ZS5oZWlnaHQgLSBib3VuZHNXaXRoUGFkZGluZy5oZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMubWluWSA9IGJvdW5kc1dpdGhQYWRkaW5nLm1pblkgLSBkaWZmWTtcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHMubWF4WSA9IHZpZXdQb3J0Qm91bmRzLm1pblk7XHJcbiAgICAgICAgICAgIHZpZXdQb3J0Qm91bmRzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmlld1BvcnRCb3VuZHM7XHJcbiAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBib3VuZHMgb2YgdmlldyBwb3J0LlxyXG4gICAgICogQHJldHVybnMge1xyXG4gICAgICogIG1heFg6IG51bWJlclxyXG4gICAgICogIG1pblg6IG51bWJlclxyXG4gICAgICogIG1heFk6IG51bWJlclxyXG4gICAgICogIG1pblk6IG51bWJlclxyXG4gICAgICogfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRWaWV3UG9ydEJvdW5kcyAoKSB7XHJcbiAgICAgICAgY29uc3QgZ2xvYmFsVmlld1BvcnRTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHNlbGYuc2l6ZSwgX3NjYWxlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW5YOiBfdmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICBtYXhYOiBfdmlld1BvcnRQb3NpdGlvbi54ICsgZ2xvYmFsVmlld1BvcnRTaXplLndpZHRoLFxyXG4gICAgICAgICAgICBtaW5ZOiBfdmlld1BvcnRQb3NpdGlvbi55LFxyXG4gICAgICAgICAgICBtYXhZOiBfdmlld1BvcnRQb3NpdGlvbi55ICsgZ2xvYmFsVmlld1BvcnRTaXplLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IF92aWV3UG9ydFBvc2l0aW9uLnggKyBnbG9iYWxWaWV3UG9ydFNpemUud2lkdGggLSBfdmlld1BvcnRQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IF92aWV3UG9ydFBvc2l0aW9uLnkgKyBnbG9iYWxWaWV3UG9ydFNpemUuaGVpZ2h0IC0gX3ZpZXdQb3J0UG9zaXRpb24ueSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGltaXRzIHBvc2l0aW9uIG9mIHRoZSB2aWV3IHBvcnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2xpbWl0Vmlld1BvcnRQb3NpdGlvbiAoKSB7XHJcbiAgICAgICAgX3ZpZXdQb3J0UG9zaXRpb24gPSBsaW1pdFBvaW50UG9zaXRpb24oX3ZpZXdQb3J0UG9zaXRpb24sIF92aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHVzIHdoZXRoZXIgYSBOb2RlIGZhbGwgaW50byB0aGUgdmlld3BvcnQgb3Igbm8uXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFydGlhbEhpdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2hpdFRlc3RCeUdsb2JhbFBvc2l0aW9uIChub2RlLCBwYXJ0aWFsSGl0KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG5cclxuICAgICAgICBjb25zdCBub2RlU2NhbGVkU2l6ZSA9IG5vZGUuY2FsY3VsYXRlU2l6ZShfcmVmZXJlbmNlU2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUobm9kZVNjYWxlZFNpemUsIF9zY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHAxID0gbm9kZVBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSB9O1xyXG4gICAgICAgIGNvbnN0IHAzID0geyB4OiBub2RlUG9zaXRpb24ueCwgeTogbm9kZVBvc2l0aW9uLnkgKyBub2RlU2l6ZS5oZWlnaHQgfTtcclxuICAgICAgICBjb25zdCBwNCA9IHsgeDogbm9kZVBvc2l0aW9uLnggKyBub2RlU2l6ZS53aWR0aCwgeTogbm9kZVBvc2l0aW9uLnkgKyBub2RlU2l6ZS5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaGl0UDEgPSBfaGl0R2xvYmFsUG9pbnRUZXN0KHAxKTtcclxuICAgICAgICBjb25zdCBoaXRQMiA9IF9oaXRHbG9iYWxQb2ludFRlc3QocDIpO1xyXG4gICAgICAgIGNvbnN0IGhpdFAzID0gX2hpdEdsb2JhbFBvaW50VGVzdChwMyk7XHJcbiAgICAgICAgY29uc3QgaGl0UDQgPSBfaGl0R2xvYmFsUG9pbnRUZXN0KHA0KTtcclxuXHJcbiAgICAgICAgY29uc3QgZnVsbEhpdCA9IGhpdFAxICYmIGhpdFAyICYmIGhpdFAzICYmIGhpdFA0O1xyXG4gICAgICAgIGNvbnN0IGJvcmRlckhpdCA9IGhpdFAxIHx8IGhpdFAyIHx8IGhpdFAzIHx8IGhpdFA0O1xyXG5cclxuICAgICAgICBpZiAocGFyYW1ldGVycy5jbGlwTm9kZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvcmRlckhpdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKHBhcnRpYWxIaXQgJiYgYm9yZGVySGl0KSB8fCAoIXBhcnRpYWxIaXQgJiYgZnVsbEhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oaXRBcmVhVGVzdEJ5R2xvYmFsUG9zaXRpb24gKG5vZGUsIHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHNjYWxlZFBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVQb3NpdGlvbiA9IGxvY2FsVG9HbG9iYWxQb2ludChzY2FsZWRQb3NpdGlvbiwgX3NjYWxlLCB2aWV3RnJhbWUgfHwgc2VsZik7XHJcblxyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlU2NhbGVkU2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICBjb25zdCBoaXRQMSA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAxKTtcclxuICAgICAgICBjb25zdCBoaXRQMiA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAyKTtcclxuICAgICAgICBjb25zdCBoaXRQMyA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHAzKTtcclxuICAgICAgICBjb25zdCBoaXRQNCA9IF9oaXRBcmVhR2xvYmFsUG9pbnRUZXN0KHA0KTtcclxuXHJcbiAgICAgICAgY29uc3QgYm9yZGVySGl0ID0gaGl0UDEgfHwgaGl0UDIgfHwgaGl0UDMgfHwgaGl0UDQ7XHJcblxyXG4gICAgICAgIHJldHVybiBib3JkZXJIaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdFRlc3RCeVNjYWxlZFBvc2l0aW9uIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVkUG9zaXRpb24gPSBub2RlLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcDEgPSBzY2FsZWRQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBwMiA9IHsgeDogc2NhbGVkUG9zaXRpb24ueCArbm9kZS5zaXplLndpZHRoLCB5OiBzY2FsZWRQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IHNjYWxlZFBvc2l0aW9uLngsIHk6IHNjYWxlZFBvc2l0aW9uLnkgKyBub2RlLnNpemUuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3QgcDQgPSB7IHg6IHNjYWxlZFBvc2l0aW9uLnggKyBub2RlLnNpemUud2lkdGgsIHk6IHNjYWxlZFBvc2l0aW9uLnkgKyBub2RlLnNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGhpdFAxID0gX2hpdFNjYWxlZFBvaW50VGVzdChwMSk7XHJcbiAgICAgICAgY29uc3QgaGl0UDIgPSBfaGl0U2NhbGVkUG9pbnRUZXN0KHAyKTtcclxuICAgICAgICBjb25zdCBoaXRQMyA9IF9oaXRTY2FsZWRQb2ludFRlc3QocDMpO1xyXG4gICAgICAgIGNvbnN0IGhpdFA0ID0gX2hpdFNjYWxlZFBvaW50VGVzdChwNCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoaGl0UDEgfHwgaGl0UDIgfHwgaGl0UDMgfHwgaGl0UDQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9oaXRHbG9iYWxQb2ludFRlc3QgKHApIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdQb3J0Qm91bmRzLm1pblggPD0gcC54ICYmIHAueCA8PSBfdmlld1BvcnRCb3VuZHMubWF4WCAgJiZcclxuICAgICAgICAgICAgICAgX3ZpZXdQb3J0Qm91bmRzLm1pblkgPD0gcC55ICYmIHAueSA8PSBfdmlld1BvcnRCb3VuZHMubWF4WTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfaGl0QXJlYUdsb2JhbFBvaW50VGVzdCAocCkge1xyXG4gICAgICAgIHJldHVybiBfbm9kZUJvdW5kcy5taW5YIDw9IHAueCAmJiBwLnggPD0gX25vZGVCb3VuZHMubWF4WCAgJiZcclxuICAgICAgICAgICAgICAgX25vZGVCb3VuZHMubWluWSA8PSBwLnkgJiYgcC55IDw9IF9ub2RlQm91bmRzLm1heFk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2hpdFNjYWxlZFBvaW50VGVzdCAocCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmNvbnN0UG9zaXRpb24ueCA8PSBwLnggJiZcclxuICAgICAgICAgICAgc2VsZi5jb25zdFBvc2l0aW9uLnggKyBzZWxmLnNpemUud2lkdGggPj0gcC54ICYmXHJcbiAgICAgICAgICAgIHNlbGYuY29uc3RQb3NpdGlvbi55IDw9IHAueSAmJlxyXG4gICAgICAgICAgICBzZWxmLmNvbnN0UG9zaXRpb24ueSArIHNlbGYuc2l6ZS5oZWlnaHQgPj0gcC55O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9vd25lclRlc3QgKG5vZGUpIHtcclxuICAgICAgICBpZiAoc2VsZi5fb3duZXJUZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9vd25lclRlc3Qobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1c3RvbWVPd25lciA9IG5vZGUudmlld0ZyYW1lT3duZXJJZDtcclxuICAgICAgICBjb25zdCBvd25lcklzTWUgPSBub2RlLnZpZXdGcmFtZU93bmVySWQgPT09IHNlbGYuaWQ7XHJcbiAgICAgICAgY29uc3QgbWVJc05hdGl2ZU93bmVyID0gc2VsZi5pZCA9PT0gbm9kZS5tb2RlbC52aWV3RnJhbWU7XHJcbiAgICAgICAgcmV0dXJuIChjdXN0b21lT3duZXIgJiYgb3duZXJJc01lKSB8fCAobWVJc05hdGl2ZU93bmVyICYmICFjdXN0b21lT3duZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjbGlwIHBvaW50LCB3aGljaFxyXG4gICAgICogdGVsbHMgdXMgaG93IGZhciB0aGUgbm9kZSBnbyBvdXQgb2YgdGhlIGJvcmRlciBvZiB2aWV3RnJhbWUuXHJcbiAgICAgKiBBbmQgYWZ0ZXIgY2FsY3VsYXRpb24gdGhlIGZ1bmN0aW9uIHBhc3MgdGhpcyBwb2ludCBpbnRvIHRoZSBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NsaXBOb2RlIChub2RlKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVTY2FsZWRTaXplID0gbm9kZS5jYWxjdWxhdGVTaXplKF9yZWZlcmVuY2VTaXplKTtcclxuICAgICAgICBjb25zdCBub2RlU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShub2RlU2NhbGVkU2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBub2RlUG9zaXRpb247XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IG5vZGVQb3NpdGlvbi54ICsgbm9kZVNpemUud2lkdGgsIHk6IG5vZGVQb3NpdGlvbi55IH07XHJcbiAgICAgICAgY29uc3QgcDMgPSB7IHg6IG5vZGVQb3NpdGlvbi54LCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IHA0ID0geyB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoLCB5OiBub2RlUG9zaXRpb24ueSArIG5vZGVTaXplLmhlaWdodCB9O1xyXG5cclxuICAgICAgICBjb25zdCBnbG9iYWxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgbGV0IG8gPSBnZXRQb2ludE9mZnNldChwMSk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwMik7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwMyk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIG8gPSBnZXRQb2ludE9mZnNldChwNCk7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnggPSBNYXRoLmFicyhvLngpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LngpID8gby54IDogZ2xvYmFsT2Zmc2V0Lng7XHJcbiAgICAgICAgZ2xvYmFsT2Zmc2V0LnkgPSBNYXRoLmFicyhvLnkpID4gTWF0aC5hYnMoZ2xvYmFsT2Zmc2V0LnkpID8gby55IDogZ2xvYmFsT2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IGdsb2JhbFRvU2NhbGVkUG9pbnQoZ2xvYmFsT2Zmc2V0LCBfc2NhbGUpO1xyXG4gICAgICAgIG5vZGUuc2V0Q2xpcHBpbmcoc2NhbGVkT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRPZmZzZXQgKHApIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICAgICAgICAgIGlmIChfdmlld1BvcnRCb3VuZHMubWluWCA+IHAueCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnggPSBfdmlld1BvcnRCb3VuZHMubWluWCAtIHAueDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChfdmlld1BvcnRCb3VuZHMubWF4WCA8IHAueCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnggPSBfdmlld1BvcnRCb3VuZHMubWF4WCAtIHAueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3ZpZXdQb3J0Qm91bmRzLm1pblkgPiBwLnkpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldC55ID0gX3ZpZXdQb3J0Qm91bmRzLm1pblkgLSBwLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3ZpZXdQb3J0Qm91bmRzLm1heFkgPCBwLnkpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldC55ID0gX3ZpZXdQb3J0Qm91bmRzLm1heFkgLSBwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgc2l6ZSBmb3Igbm9kZSB3aXRoIGNvbnNpZGVyaW5nIHNjYWxlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7U2l6ZX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlUmVmZXJlbmNlTm9kZVNpemUgKGVsZW1lbnRTaXplKSB7XHJcbiAgICAgICAgY29uc3QgbWluU2NhbGUgPSBNYXRoLm1pbihfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlZEVsZW1lbnRTaXplID0gZ2xvYmFsVG9TY2FsZWRTaXplKGVsZW1lbnRTaXplLCB7XHJcbiAgICAgICAgICAgIHg6IG1pblNjYWxlLCB5OiBtaW5TY2FsZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjb25zdCBzY2FsZWRFbGVtZW50U2l6ZSA9IGdsb2JhbFRvU2NhbGVkU2l6ZShlbGVtZW50U2l6ZSwgX3NjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Qm91bmRlZFdpZHRoID0gc2VsZi5zaXplLndpZHRoIC0gcGFyYW1ldGVycy5mcmFtZVBhZGRpbmcueDtcclxuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IChtYXhCb3VuZGVkV2lkdGggPj0gZWxlbWVudFNpemUubWluV2lkdGggLyAzID8gbWF4Qm91bmRlZFdpZHRoIDogc2VsZi5zaXplLndpZHRoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Qm91bmRlZEhlaWdodCA9IHNlbGYuc2l6ZS5oZWlnaHQgLSBwYXJhbWV0ZXJzLmZyYW1lUGFkZGluZy55O1xyXG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IChtYXhCb3VuZGVkSGVpZ2h0ID49IGVsZW1lbnRTaXplLm1pbkhlaWdodCA/IG1heEJvdW5kZWRIZWlnaHQgOiBzZWxmLnNpemUuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemUubWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oc2NhbGVkRWxlbWVudFNpemUud2lkdGgsIGVsZW1lbnRTaXplLm1heFdpZHRoKSxcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplLm1pbkhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzY2FsZWRFbGVtZW50U2l6ZS5oZWlnaHQsIGVsZW1lbnRTaXplLm1heEhlaWdodCksXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGgsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VTaXplO1xyXG4gICAgfVxyXG59XHJcblZpZXdGcmFtZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGpvaW50LnNoYXBlcy5iYXNpYy5SZWN0LnByb3RvdHlwZSk7XHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdGcmFtZTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogSXQncyBzcGVjaWFsIHZpZXdGcmFtZSB0byBzaG93IGFsbCBOb2RlcyBzZWxlY3RlZCBub2Rlcy5cclxuICogQWxsIG5vZGVzIGFyZSBwYXNzZWQgd2l0aCBvcHRpb25zIGZvciBwYXJlbnQgY2xhc3MuXHJcbiAqIEBhdWdtZW50cyBWaWV3RnJhbWUuXHJcbiAqIEFuZCB0aGlzIGNsYXNzIGhhcyB0aGUgc2FtZSBtZXRob2RzLCBmaWVsZHMgYW5kIHBhcmFtZXRlcnMgYXMgVmlld0ZyYW1lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE92ZXJWaWV3RnJhbWUgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgbGV0IF9yYXRpb01vZGlmeWVyID0gMTtcclxuXHJcbiAgICBzZWxmLl9vd25lclRlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuX3NjYWxlV2lsbEFwcGxpZWQgPSBmdW5jdGlvbiAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoX3JhdGlvTW9kaWZ5ZXIgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzY2FsZS54LFxyXG4gICAgICAgICAgICAgICAgeTogc2NhbGUueCAqIF9yYXRpb01vZGlmeWVyLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzY2FsZS55IC8gX3JhdGlvTW9kaWZ5ZXIsXHJcbiAgICAgICAgICAgICAgICB5OiBzY2FsZS55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVmlld0ZyYW1lLmFwcGx5KHNlbGYsIFtvcHRpb25zLCBwYXJhbWV0ZXJzXSk7XHJcbiAgICBfaW5pdCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIF9pbml0ICgpIHtcclxuICAgICAgICBjb25zdCBwYXBlclNpemUgPSBnZXRFbGVtZW50U2l6ZShwYXJhbWV0ZXJzLmdyYXBoUGxhY2UpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSBzZWxmLmdldE5vZGVCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGhJc1NjYWxhYmxlID0gbm9kZUJvdW5kcy53aWR0aCAmJiBub2RlQm91bmRzLm1pblhOb2RlICE9PSBub2RlQm91bmRzLm1heFhOb2RlO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodElzU2NhbGFibGUgPSBub2RlQm91bmRzLmhlaWdodCAmJiBub2RlQm91bmRzLm1pbllOb2RlICE9PSBub2RlQm91bmRzLm1heFlOb2RlO1xyXG4gICAgICAgIGlmICh3aWR0aElzU2NhbGFibGUgJiYgaGVpZ2h0SXNTY2FsYWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCB4UmF0aW8gPSBwYXBlclNpemUud2lkdGggLyAobm9kZUJvdW5kcy53aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHlSYXRpbyA9IHBhcGVyU2l6ZS5oZWlnaHQgLyAobm9kZUJvdW5kcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHhSYXRpbyAhPT0geVJhdGlvKSB7XHJcbiAgICAgICAgICAgICAgICBfcmF0aW9Nb2RpZnllciA9IHlSYXRpbyAvIHhSYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PdmVyVmlld0ZyYW1lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVmlld0ZyYW1lLnByb3RvdHlwZSk7IiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuaW1wb3J0IHsgVmlld0ZyYW1lLCBPdmVyVmlld0ZyYW1lIH0gZnJvbSAnLi92aWV3RnJhbWUnO1xyXG5pbXBvcnQgeyBOb2RlLCBUZXJtaW5hdGlvbk5vZGUsIFRlcm1pbmF0aW9uTGluaywgQXNwZWN0TGluaywgTGluayB9IGZyb20gJy4vZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0Q3Jvc1BvaW50LCBnZXRWaWV3RnJhbWVJZEZvck5vZGUsXHJcbn0gZnJvbSAnLi4vdXRpbHMvbGluZWFnZURpYWdyYW1VdGlscyc7XHJcbmltcG9ydCB7IGFycmF5VG9NYXAsIGxpbWl0UG9pbnRQb3NpdGlvbiwgZ2V0U2NhbGVkTm9kZVBvc2l0aW9uLCBnZXRMb2NhbE5vZGVQb3NpdGlvbiwgc2NhbGVkVG9HbG9iYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgeyBnZXRCYXNlRWxlbWVudCB9IGZyb20gJy4uL3V0aWxzL2RhdGFVdGlscyc7XHJcblxyXG5leHBvcnQgY29uc3QgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgPSAyMDtcclxuZXhwb3J0IGNvbnN0IEZSQU1FX09VVF9NQVJHSU4gPSAyMDtcclxuXHJcbi8qKlxyXG4gKiBWaWV3TWFuYWdlciBvcHRpb25zLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3TWFuZ2VyT3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXJcclxuICogQHByb3BlcnR5IHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiovXHJcblxyXG4vKipcclxuICogTWFuYWdlIFZpZXdGcmFtZXMgYW5kIGNvbGxlY3QgZGF0YVxyXG4gKiBmcm9tIHRoZW0gdG8gcmV0dXJuIHRvIHRoZSBsaW5lYWdlRGlhZ3JhbSByZW5kZXJcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtWaWV3TWFuZ2VyT3B0aW9uc30gb3B0aW9ucyBcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIFxyXG4gKiBAZmlyZXMgY2hhbmdlLXZpZXctcG9ydC1wb3NpdGlvblxyXG4gKiBQdWJsaWMgbWV0aG9kczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBwcmVwYXJlUmVuZGVyRGF0YTogKHJlbmRlck9wdGlvbnMpID0+IChOb2RlfExpbmt8Vmlld0ZyYW1lKVtdXHJcbiAqIGdldFZpZXdGcmFtZUZvck5vZGU6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsO1xyXG4gKiBnZXRWaWVGcmFtZUZvck5vZGVCeVBvc2l0aW9uOiAobm9kZSkgPT4gVmlld0ZyYW1lUHVibGljTW9kZWw7XHJcbiAqIGdldFZpZXdGcmFtZUJ5SWQ6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsO1xyXG4gKiBnZXRPdmVyVmlld0ZyYW1lOiAoKSA9PiBWaWV3RnJhbWVQdWJsaWNNb2RlbDtcclxuICogZnVsbFNjcmVlbk1vZGU6ICgpID0+IGJvb2xlYW47XHJcbiAqIGdldFZpZXdGcmFtZXM6ICgpID0+IFZpZXdGcmFtZVB1YmxpY01vZGVsW107XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gVmlld01hbmFnZXIgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIFxyXG4gICAgY29uc3QgX3Rlcm1pbmF0aW9uTm9kZVNpemUgPSBwYXJhbWV0ZXJzLnRlcm1pbmF0aW9uTm9kZVNpemU7XHJcblxyXG4gICAgbGV0IF90ZXJtaW5hdGlvbkNlbGxDYWNoZSA9IHt9O1xyXG4gICAgbGV0IF9hc3BlY3RMaW5rc0NhaGUgPSB7fTtcclxuICAgIGxldCBfcmVuZGVyT3B0aW9ucyA9IHt9O1xyXG4gICAgbGV0IF92aWV3RnJhbWVzTWFwID0ge307XHJcbiAgICBsZXQgX3N0YXRlID0ge307XHJcbiAgICBsZXQgX2RhdGFDb250YWluZXI7XHJcbiAgICBsZXQgX292ZXJWaWV3RnJhbWU7XHJcbiAgICBsZXQgX3ZpZXdGcmFtZXM7XHJcbiAgICBsZXQgX2FsbEZyYW1lcztcclxuXHJcbiAgICBsZXQgX2Z1bGxTY3JlZW5Nb2RlOyAgLy8gY2hhbmdlYWJsZVxyXG5cclxuICAgIF9pbml0KG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG4gICAgXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXBlciByZW5kZXIgb3B0aW9ucy5cclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcGVyUmVuZGVyT3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IG9yaWVudGF0aW9uOiBfb3JpZW50YXRpb24sXHJcbiAgICAgKiBAcHJvcGVydHkgd2lkdGg6IF9wYXBlci5lbC5jbGllbnRXaWR0aCxcclxuICAgICAqIEBwcm9wZXJ0eSBoZWlnaHQ6IF9wYXBlci5lbC5jbGllbnRIZWlnaHQsXHJcbiAgICAgKiBAcHJvcGVydHkgc2NhbGU6IF9zY2FsZSxcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbGVtZW50IHJlbmRlciBvcHRpb25zLlxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRWxlbWVudFJlbmRlck9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIG9wdGlvbnMuXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBSZW5kZXJPcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZnVsbFNjcmVlbk1vZGVcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIChOb2RlfExpbmspPn0gcGF0aFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgKE5vZGV8TGluayk+fSBtYXNrXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHVwZGF0ZUJvdW5kc1xyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBxdWlja1VwZGF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtQYXBlclJlbmRlck9wdGlvbnN9IHBhcGVyT3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50UmVuZGVyT3B0aW9uc30gZWxlbWVudE9wdGlvbnNcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAxLiBUYWtlcyByZW5kZXIgZGF0YSBmcm9tIHRoZSBWaWV3RnJhbWVzLFxyXG4gICAgICogMi4gVXBkYXRlcyBWaWV3RnJhbWVzIHN0YXRlXHJcbiAgICAgKiAzLiBDaGFuZ2VzIHNpemUgYW5kIHNjYWxlIG9mIHZpZXdGcmFtZXNcclxuICAgICAqIDQuIFVwZGF0ZXMgaGlnaGxpZ2h0aW5nXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHsoTm9kZXxMaW5rfFZpZXdGcmFtZSlbXX1cclxuICAgICAqL1xyXG4gICAgc2VsZi5wcmVwYXJlUmVuZGVyRGF0YSA9IGZ1bmN0aW9uIChyZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgX3VwZGF0ZVZpZXdGcmFtZXMocmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZVZpZXdGcmFtZXMgPSBfZ2V0VmlzaWJsZVZpZXdGcmFtZXMoKTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVSZXN1bHRzID0gdmlzaWJsZVZpZXdGcmFtZXMubWFwKHZmID0+IHZmLmdldFZpc2libGVDZWxscygpKTtcclxuICAgICAgICBjb25zdCByZW5kZXJSZXN1bHRzID0gX2NhbGN1bGF0ZVJlbmRlckRhdGEodmlld0ZyYW1lUmVzdWx0cywgcmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgX3NldEhpZ2hsaWdodGluZyhyZW5kZXJSZXN1bHRzLCByZW5kZXJPcHRpb25zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVWaWV3RnJhbWVzLmNvbmNhdChyZW5kZXJSZXN1bHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSBmb3IgdGhlIG5vZGUgd2hpY2ggY3VycmVudGx5IHJlbmRlcnMgdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3RnJhbWVGb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF9nZXRWaWV3RnJhbWVGb3JOb2RlKG5vZGUpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFZpZXdGcmFtZSB3aGljaCBjdXJyZW50bHkgb3ducyB0aGlzIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZU93bmVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVJZCA9IGdldFZpZXdGcmFtZUlkRm9yTm9kZShub2RlKTtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF92aWV3RnJhbWVzTWFwW3ZpZXdGcmFtZUlkXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBWaWV3RnJhbWUgZm9yIHRoZSBub2RlIGJ5IGhpcyBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsIHwgdW5kZWZpbmVkfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmllRnJhbWVGb3JOb2RlQnlQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKF9mdWxsU2NyZWVuTW9kZSkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZUZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZiA9IHZpc2libGVGcmFtZXNbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodmYuaGl0VGVzdEJ5U2NhbGVkUG9zaXRpb24obm9kZSkpIHJldHVybiBfZ2V0Vmlld0ZyYW1lUHVibGljTW9kZWwodmYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgVmlld0ZyYW1lIGZvciB0aGUgbm9kZSBieSBoaXMgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0VmllRnJhbWVCeVNjcmVlblBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZUZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZiA9IHZpc2libGVGcmFtZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh2Zi5oaXRTY2FsZWRQb2ludFRlc3QocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIGRlZmF1bHQgc2l6ZSBvZiBWaWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVzZXRGcmFtZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfdmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgdmYucmVzZXRTaXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBWaWV3RnJhbWUgYnkgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsIHwgdW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZUJ5SWQgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF92aWV3RnJhbWVzTWFwW3ZpZXdGcmFtZUlkXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBPdmVyVmlld0ZyYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWx9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0T3ZlclZpZXdGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKF9vdmVyVmlld0ZyYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB1cyB3aGV0aGVyIG92ZXJWaWV3IGlzIGFjdGl2ZSBvciBub3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzZWxmLmlzRnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9mdWxsU2NyZWVuTW9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBWaWV3RnJhbWVzXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hbGxGcmFtZXMubWFwKHZmID0+IF9nZXRWaWV3RnJhbWVQdWJsaWNNb2RlbCh2ZikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpZXdGcmFtZSBwdWJsaWMgbW9kZWxcclxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdGcmFtZVB1YmxpY01vZGVsXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBJZGVudGlmeWVyXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgLSBMYWJlbCBpbiB0aGUgdG9wLXJpZ2h0IGNvcm5lclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIEJhY2dyb3VuZCBjb2xvclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQm9yZGVyIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFjdGl2ZSAtIElzIG9uIHRoZSBzY3JlZW5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXhwYW5kZWQgLSBJcyBleHBhbmRlZFxyXG4gICAgICogQHByb3BlcnR5IHtQb2ludH0gcG9zaXRpb24gLSBSZWFsIHBvc2l0aW9uIG9uIHRoZSBwYXBlclxyXG4gICAgICogQHByb3BlcnR5IHtQb2ludH0gdmlld1BvcnRQb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAgICogQHByb3BlcnR5IHtCb3VuZHN9IGJvdW5kcyAtIFJlYWwgdmlzdWFsIGJvdW5kcyBvZiBhY3RpdmUgem9uZSBvZiB2aWV3RnJhbWUgKFpvbmUgYXJvdW5kIG5vZGVzKVxyXG4gICAgICogQHByb3BlcnR5IHtTaXplfSBzaXplIC0gUmVhbCBzaXplIG9mIHZpZXdGcmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBjdXN0b21lU2l6ZWQgLSBUZWxscyB1cyB3aGV0aGVyIHNpemUgd2FzIGNoYW5nZWQgYnkgdXNlciBvciBub3RcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm91bmRzfSB2aWV3UG9ydFBvc2l0aW9uQm91bmRzIC0gTWluIG1heCB2YWx1ZXMgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3UG9ydFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNwYWNlU2hhcmUgLSByZWxhdGl2ZSBzaXplIG9mIHZpZXcgZnJhbWUgKGhvcml6b250YWwvdmVydGljYWwgZGVwZW5kcyBvbiBvcmllbnRhdGlvbilcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXBkYXRlQm91bmRzIC0gRmxhZyB0byBwYXNzIGludG8gdGhlIHJlbmRlciBwaXBsaW5lXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lfSB2aWV3RnJhbWVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBpZiAoIXZpZXdGcmFtZSkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbWVTaXplZCA9IHZpZXdGcmFtZS5tb2RlbC53aWR0aCB8fCB2aWV3RnJhbWUubW9kZWwuaGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUgP1xyXG4gICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgOiBfZnVsbFNjcmVlbk1vZGUgP1xyXG4gICAgICAgICAgICBmYWxzZSA6IF9zdGF0ZVt2aWV3RnJhbWUubW9kZWwuaWRdO1xyXG5cclxuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gdmlld0ZyYW1lID09PSBfb3ZlclZpZXdGcmFtZSA/XHJcbiAgICAgICAgICAgIF9mdWxsU2NyZWVuTW9kZSA6IF9zdGF0ZVt2aWV3RnJhbWUubW9kZWwuaWRdO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLm1vZGVsLmlkLFxyXG4gICAgICAgICAgICBsYWJlbDogdmlld0ZyYW1lLm1vZGVsLmxhYmVsLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHZpZXdGcmFtZS5tb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB2aWV3RnJhbWUubW9kZWwuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBpc0V4cGFuZGVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdmlld0ZyYW1lLnBvc2l0aW9uKCksIC8vIGxvY2FsXHJcbiAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KCksIC8vIGdsb2JhbFxyXG4gICAgICAgICAgICB2aWV3UG9ydFBvc2l0aW9uQm91bmRzOiB2aWV3RnJhbWUuZ2V0Vmlld1BvcnRQb3NpdGlvbkJvdW5kcygpLCAvLyBnbG9iYWxcclxuICAgICAgICAgICAgdmlld1BvcnRCb3VuZHM6IHZpZXdGcmFtZS5nZXRWaWV3UG9ydEJvdW5kcygpLCAvLyBnbG9iYWxcclxuICAgICAgICAgICAgbm9kZUJvdW5kczogdmlld0ZyYW1lLmdldE5vZGVCb3VuZHMoKSwgLy8gZ2xvYmFsXHJcbiAgICAgICAgICAgIHNpemU6IHsgd2lkdGg6IHZpZXdGcmFtZS5zaXplLndpZHRoLCBoZWlnaHQ6IHZpZXdGcmFtZS5zaXplLmhlaWdodCB9LCAvLyBsb2NhbFxyXG4gICAgICAgICAgICBjdXN0b21lU2l6ZWQ6IGN1c3RvbWVTaXplZCxcclxuICAgICAgICAgICAgc3BhY2VTaGFyZTogdmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUsXHJcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kczogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzT3ZlclZpZXc6IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUsXHJcbiAgICAgICAgICAgIHNjYWxlOiB2aWV3RnJhbWUuZ2V0U2NhbGUoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBkYXRhIG1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge0RhdGFDb250YWluZXJ9IGRhdGFDb250YWluZXIgLSBkYXRhIGZvciB0aGUgZ3JhcGhcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfaW5pdCAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG4gICAgICAgIF9kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBPdmVyVmlldyBmcmFtZVxyXG4gICAgICAgIF9vdmVyVmlld0ZyYW1lID0gbmV3IE92ZXJWaWV3RnJhbWUoe1xyXG4gICAgICAgICAgICBpZDogJ292ZXJWaWV3RnJhbWUnLFxyXG4gICAgICAgICAgICBsYWJlbDogJ092ZXJ2aWV3JyxcclxuICAgICAgICAgICAgZGF0YUNvbnRhaW5lcjogX2RhdGFDb250YWluZXIsXHJcbiAgICAgICAgICAgIHJlc3VycmVjdEVsZW1lbnRzOiB0cnVlLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMyM2IwZjQnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjRmNGZmJyxcclxuICAgICAgICAgICAgc3BhY2VTaGFyZTogMSxcclxuICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICBtYXBbX292ZXJWaWV3RnJhbWUuaWRdID0gX292ZXJWaWV3RnJhbWU7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBsaXN0IG9mIFZpZXdGcmFtZXNcclxuICAgICAgICBfdmlld0ZyYW1lcyA9IG9wdGlvbnMudmlld0ZyYW1lcy5tYXAobW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBzdGF0ZVttb2RlbC5pZF0gPSBtb2RlbC5leHBhbmRlZDtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lT3B0aW9ucyA9IF8uY2xvbmVEZWVwKG1vZGVsKTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lT3B0aW9ucy5kYXRhQ29udGFpbmVyID0gb3B0aW9ucy5kYXRhQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWUgPSBuZXcgVmlld0ZyYW1lKHZpZXdGcmFtZU9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICBtYXBbdmlld0ZyYW1lLmlkXSA9IHZpZXdGcmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdGcmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfYWxsRnJhbWVzID0gX3ZpZXdGcmFtZXMuY29uY2F0KF9vdmVyVmlld0ZyYW1lKTtcclxuXHJcbiAgICAgICAgX3N0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXNNYXAgPSBtYXA7XHJcbiAgICAgICAgX2Z1bGxTY3JlZW5Nb2RlID0gb3B0aW9ucy5mdWxsU2NyZWVuTW9kZTtcclxuXHJcbiAgICAgICAgX3N1YnNjcmliZU9uVmlld0ZyYW1lRXZlbnRzKF9hbGxGcmFtZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBzdGF0ZXMgb2Ygdmlld0ZyYW1lcyB1c2luZyByZW5kZXJPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlVmlld0ZyYW1lcyAocmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMucGFwZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzUGFwZXJPcHRpb25zID0gX3JlbmRlck9wdGlvbnMucGFwZXJPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZU9wdGlvbnMgPSBhcnJheVRvTWFwKHJlbmRlck9wdGlvbnMudmlld0ZyYW1lcyB8fCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzU2NhbGVDaGFuZ2VkID0gKCFwcmV2aW91c1BhcGVyT3B0aW9ucy5zY2FsZSkgfHwgcHJldmlvdXNQYXBlck9wdGlvbnMuc2NhbGUueCAhPT0gbmV3UGFwZXJPcHRpb25zLnNjYWxlLnggfHxcclxuICAgICAgICAgICAgcHJldmlvdXNQYXBlck9wdGlvbnMuc2NhbGUueSAhPT0gbmV3UGFwZXJPcHRpb25zLnNjYWxlLnk7XHJcbiAgICAgICAgY29uc3QgaXNQYXBlclNpemVDaGFuZ2VkID0gcHJldmlvdXNQYXBlck9wdGlvbnMud2lkdGggIT09IG5ld1BhcGVyT3B0aW9ucy53aWR0aCB8fFxyXG4gICAgICAgICAgICBwcmV2aW91c1BhcGVyT3B0aW9ucy5oZWlnaHQgIT09IG5ld1BhcGVyT3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgaXNPcmllbnRhdGlvbkNoYW5nZWQgPSBwcmV2aW91c1BhcGVyT3B0aW9ucy5vcmllbnRhdGlvbiAhPT0gbmV3UGFwZXJPcHRpb25zLm9yaWVudGF0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG9sZEVsZW1lbnRTaXplID0gKF9yZW5kZXJPcHRpb25zLmVsZW1lbnRPcHRpb25zIHx8IHt9KS5lbGVtZW50U2l6ZTtcclxuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHJlbmRlck9wdGlvbnMuZWxlbWVudE9wdGlvbnMuZWxlbWVudFNpemU7XHJcbiAgICAgICAgY29uc3QgaXNFbGVtZW50U2l6ZUNoYW5nZWQgPSBlbGVtZW50U2l6ZSAmJiAoXHJcbiAgICAgICAgICAgICghb2xkRWxlbWVudFNpemUpIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLndpZHRoICE9PSBvbGRFbGVtZW50U2l6ZS53aWR0aCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5oZWlnaHQgIT09IG9sZEVsZW1lbnRTaXplLmhlaWdodCB8fFxyXG4gICAgICAgICAgICBlbGVtZW50U2l6ZS5taW5XaWR0aCAhPT0gb2xkRWxlbWVudFNpemUubWluV2lkdGggfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUubWluSGVpZ2h0ICE9PSBvbGRFbGVtZW50U2l6ZS5taW5IZWlnaHQgfHxcclxuICAgICAgICAgICAgZWxlbWVudFNpemUubWF4V2lkdGggIT09IG9sZEVsZW1lbnRTaXplLm1heFdpZHRoIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnRTaXplLm1heEhlaWdodCAhPT0gb2xkRWxlbWVudFNpemUubWF4SGVpZ2h0XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgZnVsbFNjcmVlbk1vZGVDaGFuZ2VkID0gcmVuZGVyT3B0aW9ucy5mdWxsU2NyZWVuTW9kZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy5mdWxsU2NyZWVuTW9kZSAhPT0gX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXNTdGF0ZUNoYW5nZWQgPSBfdXBkYXRlVmlld0ZyYW1lVmlzaWJpbGl0eSh2aWV3RnJhbWVPcHRpb25zKSAmJiAoIV9mdWxsU2NyZWVuTW9kZSkgfHwgZnVsbFNjcmVlbk1vZGVDaGFuZ2VkO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW5Nb2RlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBfZnVsbFNjcmVlbk1vZGUgPSByZW5kZXJPcHRpb25zLmZ1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGFwZXJPcHRpb25zQ2hhbmdlZCA9XHJcbiAgICAgICAgICAgIHJlbmRlck9wdGlvbnMudXBkYXRlQm91bmRzIHx8XHJcbiAgICAgICAgICAgIGlzUGFwZXJTaXplQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICBpc09yaWVudGF0aW9uQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICBpc1NjYWxlQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzU3RhdGVDaGFuZ2VkO1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZVZpZXdGcmFtZXMgPSBpc1BhcGVyU2l6ZUNoYW5nZWQgfHwgaXNPcmllbnRhdGlvbkNoYW5nZWQgfHwgdmlld0ZyYW1lc1N0YXRlQ2hhbmdlZDtcclxuXHJcbiAgICAgICAgaWYgKGlzRWxlbWVudFNpemVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIF9zZXRFbGVtZW50c1NpemUoZWxlbWVudFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICBfcmVzaXplVmlld0ZyYW1lcyhuZXdQYXBlck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTY2FsZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgX3NjYWxlVmlld0ZyYW1lcyhuZXdQYXBlck9wdGlvbnMuc2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFwZXJPcHRpb25zQ2hhbmdlZCB8fCBpc0VsZW1lbnRTaXplQ2hhbmdlZCB8fCBpc1NjYWxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBfcmVmcmVzaFZpZXdGcmFtZXNCb3VuZHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVjYWxjdWxhdGVWaXNpYmxlRWxlbWVudHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Vmlld0ZyYW1lRGF0YSA9IHZpZXdGcmFtZU9wdGlvbnNbdmlld0ZyYW1lLmlkXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChuZXdWaWV3RnJhbWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWaWV3RnJhbWVEYXRhID0gX2dldFZpZXdGcmFtZVB1YmxpY01vZGVsKHZpZXdGcmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQm91bmRzID0gbmV3Vmlld0ZyYW1lRGF0YS51cGRhdGVCb3VuZHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0UG9zaXRpb25DaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uICYmIChcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueCAhPT0gb2xkVmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueSAhPT0gb2xkVmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplQ2hhbmdlZCA9IG5ld1ZpZXdGcmFtZURhdGEuc2l6ZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS5zaXplLndpZHRoICE9PSBvbGRWaWV3RnJhbWVEYXRhLnNpemUud2lkdGggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnNpemUuaGVpZ2h0ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnNpemUuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS5wb3NpdGlvbiAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS5wb3NpdGlvbi54ICE9PSBvbGRWaWV3RnJhbWVEYXRhLnBvc2l0aW9uLnggfHxcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uLnkgIT09IG9sZFZpZXdGcmFtZURhdGEucG9zaXRpb24ueVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNoYW5nZWQgJiYgIXJlc2l6ZVZpZXdGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUuc2V0U2l6ZShuZXdWaWV3RnJhbWVEYXRhLnNpemUsIG5ld1ZpZXdGcmFtZURhdGEuY3VzdG9tZVNpemVkKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZVZpc2libGVFbGVtZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCAmJiAhcmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5zZXRQb3NpdGlvbihuZXdWaWV3RnJhbWVEYXRhLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQm91bmRzIHx8IHNpemVDaGFuZ2VkICYmICFyZXNpemVWaWV3RnJhbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lLnVwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydFBvc2l0aW9uQ2hhbmdlZCAmJiAhcmVzaXplVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZS5wb3NpdGlvblZpZXdQb3J0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWaWV3RnJhbWVEYXRhLnZpZXdQb3J0UG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0ZyYW1lRGF0YS52aWV3UG9ydFBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICByZWNhbGN1bGF0ZVZpc2libGVFbGVtZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaXNFeHBhbmRlZCA9IF9zdGF0ZVt2aWV3RnJhbWUuaWRdIHx8IHZpZXdGcmFtZSA9PT0gX292ZXJWaWV3RnJhbWUgJiYgX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgICAgICBjb25zdCByZWNhbGN1bGF0ZUNvbnRlbnQgPSBpc0V4cGFuZGVkICYmIChcclxuICAgICAgICAgICAgICAgIHJlY2FsY3VsYXRlVmlzaWJsZUVsZW1lbnRzIHx8IHBhcGVyT3B0aW9uc0NoYW5nZWQgfHwgaXNFbGVtZW50U2l6ZUNoYW5nZWRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKHJlY2FsY3VsYXRlQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lLmNhbGN1bGF0ZVZpc2libGVDZWxscygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9yZW5kZXJPcHRpb25zID0gcmVuZGVyT3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgc3RhdGUgb2Ygdmlld0ZyYW1lcyAodmlzaWJsZS9pbnZpc2libGUpXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZU9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZVZpZXdGcmFtZVZpc2liaWxpdHkgKHZpZXdGcmFtZU9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgYXRMZWFzdE9uZVZpc2liaWxpdHlDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgX3ZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWaWV3RnJhbWVEYXRhID0gdmlld0ZyYW1lT3B0aW9uc1t2aWV3RnJhbWUuaWRdO1xyXG4gICAgICAgICAgICBpZiAobmV3Vmlld0ZyYW1lRGF0YSAmJiBuZXdWaWV3RnJhbWVEYXRhLmV4cGFuZGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2liaWxpdGlDaGFuZ2VkID0gbmV3Vmlld0ZyYW1lRGF0YS5leHBhbmRlZCAhPT0gX3N0YXRlW3ZpZXdGcmFtZS5pZF07XHJcbiAgICAgICAgICAgICAgICBfc3RhdGVbdmlld0ZyYW1lLmlkXSA9IG5ld1ZpZXdGcmFtZURhdGEuZXhwYW5kZWQ7XHJcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQgPSBhdExlYXN0T25lVmlzaWJpbGl0eUNoYW5nZWQgfHwgdmlzaWJpbGl0aUNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXRMZWFzdE9uZVZpc2liaWxpdHlDaGFuZ2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyBkZWZhdWx0IGVsZW1lbnQgc2l6ZSBmb3IgYWxsIFZpZXdGcmFtZXNcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudFNpemV9IGVsZW1lbnRTaXplIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0RWxlbWVudHNTaXplIChlbGVtZW50U2l6ZSkge1xyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHZmLnNldEVsZW1lbnRTaXplKGVsZW1lbnRTaXplKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyBib3VuZHMgZm9yIGFsbCBWaWV3RnJhbWVzXHJcbiAgICAgKiBhbmQgYWxsaWduIFZpZXdGcmFtZXNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfcmVmcmVzaFZpZXdGcmFtZXNCb3VuZHMgKCkge1xyXG4gICAgICAgIF9hbGxGcmFtZXMuZm9yRWFjaCh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHZmLnVwZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICB2Zi5wb3NpdGlvblZpZXdQb3J0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGFuZCBsaW1pdHMgdmFsdWUgb2YgdGhlIHNjYWxlIGZvciB0aGUgZ3JhcGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3NjYWxlVmlld0ZyYW1lcyAoc2NhbGUpIHtcclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgX2FsbEZyYW1lcy5mb3JFYWNoKHZmID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNjYWxlID0gdmYuZ2V0U2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHZmLnBvc2l0aW9uVmlld1BvcnQoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2NhbGUgPSB2Zi5nZXRTY2FsZSgpOyAvLyBvdmVyVmlld0ZyYW1lIGNoYW5nZXMgc2NhbGUgYmVmb3JlIGFwcGx5XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVkU2l6ZSA9IHZmLmdldCgnc2l6ZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHNjYWxlZFRvR2xvYmFsU2l6ZShzY2FsZWRTaXplLCBvbGRTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaXplID0gc2NhbGVkVG9HbG9iYWxTaXplKHNjYWxlZFNpemUsIG5ld1NjYWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJDZW50ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zLnggKyBvbGRTaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgICAgICB5OiBwb3MueSArIG9sZFNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmYucG9zaXRpb25WaWV3UG9ydChcclxuICAgICAgICAgICAgICAgICAgICBjdXJDZW50ZXIueCAtIG5ld1NpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1ckNlbnRlci55IC0gbmV3U2l6ZS5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCBWaWV3RnJhbWVzOlxyXG4gICAgICogQWRqdXN0IHZpZXdGcmFtZXMgc2l6ZSB0byBhIHBhcGVyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVNjYWxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZXNpemVWaWV3RnJhbWVzIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUZyYW1lcyA9IF9nZXRWaXNpYmxlVmlld0ZyYW1lcygpO1xyXG4gICAgICAgIGNvbnN0IHZmTnVtYmVyID0gdmlzaWJsZUZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsT3JpZW50YXRlZCA9XHJcbiAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBvcHRpb25zLm9yaWVudGF0aW9uID09PSAncmlnaHQtdG8tbGVmdCc7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoID09PSAwIHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAwIHx8IHZmTnVtYmVyIDw9IDApIHJldHVybjtcclxuICAgICAgICBsZXQgdG90YWxTaGFyZSA9IDA7XHJcbiAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoICh2ZiA9PiB7XHJcbiAgICAgICAgICAgIHRvdGFsU2hhcmUgKz0gdmYubW9kZWwuc3BhY2VTaGFyZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoIC0gRlJBTUVfT1VUX01BUkdJTiAqIDI7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgLSBGUkFNRV9PVVRfTUFSR0lOICogMjtcclxuXHJcbiAgICAgICAgY29uc3QgY3V0ZWRXaWR0aCA9IHdpZHRoICAtIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTICogKHZmTnVtYmVyIC0gMSk7XHJcbiAgICAgICAgY29uc3QgY3V0ZWRIZWlnaHQgPSBoZWlnaHQgIC0gRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgKiAodmZOdW1iZXIgLSAxKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VnbWVudFdpZHRoICA9IGN1dGVkV2lkdGggIC8gdG90YWxTaGFyZTtcclxuICAgICAgICBjb25zdCBzZWdtZW50SGVpZ2h0ID0gY3V0ZWRIZWlnaHQgLyB0b3RhbFNoYXJlO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGUgPSAxO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgICAgIGxldCBmcmVlTGVuZ3RoID0gMDtcclxuICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWxPcmllbnRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lLm1vZGVsLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHZpZXdGcmFtZS5tb2RlbC53aWR0aDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJlZUxlbmd0aCArPSBzZWdtZW50V2lkdGggKiAodmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lLm1vZGVsLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB2aWV3RnJhbWUubW9kZWwuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmVlTGVuZ3RoICs9IHNlZ21lbnRIZWlnaHQgKiAodmlld0ZyYW1lLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JpZW50YXRlZCkge1xyXG4gICAgICAgICAgICBzY2FsZSA9IChjdXRlZFdpZHRoIC0gZnJlZUxlbmd0aCkgLyBsZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGUgPSAoY3V0ZWRIZWlnaHQgLSBmcmVlTGVuZ3RoKSAvIGxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogRlJBTUVfT1VUX01BUkdJTiB9O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nKSB7XHJcblxyXG4gICAgICAgICAgICB2aXNpYmxlRnJhbWVzLmZvckVhY2ggKHZmID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgTUlOSU1BTF9WRl9TSVpFID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh3aWR0aCwgTUlOSU1BTF9WRl9TSVpFLndpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2Zi5tb2RlbC5oZWlnaHQgPyB2Zi5tb2RlbC5oZWlnaHQgOiBzZWdtZW50SGVpZ2h0ICogKHZmLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1JTklNQUxfVkZfU0laRS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmYuc2V0UG9zaXRpb24oY3VyUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2l6ZShzaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogY3VyUG9pbnQueSArIHNpemUuaGVpZ2h0ICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgfTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmlzaWJsZUZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmYgPSB2aXNpYmxlRnJhbWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2Zi5tb2RlbC53aWR0aCkgdmYubW9kZWwud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwuaGVpZ2h0KSB2Zi5tb2RlbC5oZWlnaHQgKj0gc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2Zi5tb2RlbC5oZWlnaHQgPyB2Zi5tb2RlbC5oZWlnaHQgOiBzZWdtZW50SGVpZ2h0ICogKHZmLm1vZGVsLnNwYWNlU2hhcmUgfHwgMSlcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmYuc2V0UG9zaXRpb24oY3VyUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgdmYuc2V0U2l6ZShzaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJQb2ludCA9IHsgeDogRlJBTUVfT1VUX01BUkdJTiwgeTogY3VyUG9pbnQueSArIHNpemUuaGVpZ2h0ICsgRElTVEFOQ0VfQkVUV0VFTl9GUkFNRVMgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0Jykge1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHZpc2libGVGcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZmID0gdmlzaWJsZUZyYW1lc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwud2lkdGgpIHZmLm1vZGVsLndpZHRoICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLmhlaWdodCkgdmYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZmLm1vZGVsLndpZHRoID8gdmYubW9kZWwud2lkdGggOiBzZWdtZW50V2lkdGggKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBjdXJQb2ludC54ICsgc2l6ZS53aWR0aCArIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTLCB5OiBGUkFNRV9PVVRfTUFSR0lOIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHsgLy8gaG9yaXpvbnRhbFxyXG5cclxuICAgICAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoICh2ZiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmYubW9kZWwud2lkdGgpIHZmLm1vZGVsLndpZHRoICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZmLm1vZGVsLmhlaWdodCkgdmYubW9kZWwuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZmLm1vZGVsLndpZHRoID8gdmYubW9kZWwud2lkdGggOiBzZWdtZW50V2lkdGggKiAodmYubW9kZWwuc3BhY2VTaGFyZSB8fCAxKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRQb3NpdGlvbihjdXJQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB2Zi5zZXRTaXplKHNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0geyB4OiBjdXJQb2ludC54ICsgc2l6ZS53aWR0aCArIERJU1RBTkNFX0JFVFdFRU5fRlJBTUVTLCB5OiBGUkFNRV9PVVRfTUFSR0lOIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmlzaWJsZUZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZS51cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBub3QgdG8gYmUgaW4gdGhlIGVtcHR5IHNwYWNlIGFmdGVyIHJlc2l6aW5nIGJ1dCBzb213aGVyZSBuZWFyIHRoZSBub2Rlcy5cclxuICAgICAgICAgICAgY29uc3Qgdmlld1BvcnRQb3NpdGlvbkJvdW5kcyA9IHZpZXdGcmFtZS5nZXRWaWV3UG9ydFBvc2l0aW9uQm91bmRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVDZWxscyA9IHZpZXdGcmFtZS5nZXRWaXNpYmxlQ2VsbHMoKTtcclxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlQ2VsbHMgfHwgdmlzaWJsZUNlbGxzLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVzID0gIHZpZXdGcmFtZS5nZXROb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlVG9Gb2N1cyA9IG5vZGVzW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChub2Rlcy5sZW5ndGggLSAxKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTY2FsZWRQb3MgPSBnZXRTY2FsZWROb2RlUG9zaXRpb24obm9kZVRvRm9jdXMsIG9wdGlvbnMuc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlU2NhbGVkUG9zLnggLSAodmlld0ZyYW1lLnNpemUud2lkdGggLSBub2RlVG9Gb2N1cy5zaXplLndpZHRoKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGVTY2FsZWRQb3MueSAtICh2aWV3RnJhbWUuc2l6ZS5oZWlnaHQgLSBub2RlVG9Gb2N1cy5zaXplLmhlaWdodCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXRlZFBvaW50ID0gbGltaXRQb2ludFBvc2l0aW9uKG5ld1Bvc2l0aW9uLCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydChsaW1pdGVkUG9pbnQueCwgbGltaXRlZFBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ZWRQb2ludCA9IGxpbWl0UG9pbnRQb3NpdGlvbih2aWV3RnJhbWUucG9zaXRpb25WaWV3UG9ydCgpLCB2aWV3UG9ydFBvc2l0aW9uQm91bmRzKTtcclxuICAgICAgICAgICAgdmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQobGltaXRlZFBvaW50LngsIGxpbWl0ZWRQb2ludC55KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkYXRhIChDZWxscykgZnJvbSBWaWV3RnJhbWVzLFxyXG4gICAgICogcHJvY2Vzc2VzIGl0IChhZGQgdGVybWluYXRpb24gYW5kIGFzcGVjdCBlbGVtZW50cylcclxuICAgICAqIGFuZCByZXR1cm5zIHRvIHRoZSByZW5kZXIgcGlwbGluZVxyXG4gICAgICogQHJldHVybnMgeyhMaW5rfE5vZGV8VGVybWluYXRpb25Ob2RlfFRlcm1pbmF0aW9uTGlua3xBc3BlY3RMaW5rKVtdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlUmVuZGVyRGF0YSAodmlld0ZyYW1lUmVzdWx0cywgcmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBbXTtcclxuICAgICAgICBjb25zdCBiYWRMaW5rcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlTWFwID0ge307ICAgICAgIFxyXG5cclxuICAgICAgICB2aWV3RnJhbWVSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHJlc3VsdC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICB2aXNpYmxlTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZpZXdGcmFtZVJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4gcmVzdWx0LmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0gJiYgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUpIGxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgYmFkTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25DZWxsTWFwID0ge307XHJcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uTGlua3MgPSBbXTtcclxuICAgICAgICBpZiAocmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IF9nZXRTZWxlY3RlZE5vZGVzKHJlbmRlck9wdGlvbnMuc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKHNlbGVjdGVkTm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbk9yaWdpbnMgPSBfZ2V0VGVybWluYXRpb25PcmlnaW5zKHNlbGVjdGVkTm9kZSwgdmlzaWJsZU5vZGVNYXAsIGJhZExpbmtzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZSA9IF9nZXRWaWV3RnJhbWVGb3JOb2RlKHNlbGVjdGVkTm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdGcmFtZSAmJiAoX3N0YXRlW3ZpZXdGcmFtZS5pZF0gfHwgX2Z1bGxTY3JlZW5Nb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2lucy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2FjaGVJZCA9IG5vZGUuaWQgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hdGlvbk5vZGUgPSBfdGVybWluYXRpb25DZWxsQ2FjaGVbbm9kZUNhY2hlSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk5vZGUuc2V0KCdkcmFnZ2VkJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Ob2RlID0gbmV3IFRlcm1pbmF0aW9uTm9kZSAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkNlbGxNYXBbbm9kZUNhY2hlSWRdID0gdGVybWluYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF9nZXRUZXJtaW5hdGlvbk5vZGVQb3NpdGlvbih0ZXJtaW5hdGlvbk5vZGUsIHZpZXdGcmFtZSwgcmVuZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uTm9kZS5wb3NpdGlvbihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Ob2Rlcy5wdXNoKHRlcm1pbmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2lucy5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0NhY2hlSWQgPSBsaW5rLmlkICsgJ19hdF8nICsgdmlld0ZyYW1lLmlkOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDYWNoZUlkID0gbGluay5tb2RlbC5zb3VyY2UgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDYWNoZUlkID0gbGluay5tb2RlbC50YXJnZXQgKyAnX2F0XycgKyB2aWV3RnJhbWUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVybWluYXRpb25MaW5rID0gX3Rlcm1pbmF0aW9uQ2VsbENhY2hlW2xpbmtDYWNoZUlkXSB8fCBuZXcgVGVybWluYXRpb25MaW5rICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluazogbGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRlcm1pbmF0aW9uQ2VsbE1hcFtzb3VyY2VDYWNoZUlkXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0ZXJtaW5hdGlvbkNlbGxNYXBbdGFyZ2V0Q2FjaGVJZF0gfHwgdmlzaWJsZU5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbkNlbGxNYXBbbGlua0NhY2hlSWRdID0gdGVybWluYXRpb25MaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25MaW5rcy5wdXNoKHRlcm1pbmF0aW9uTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gcmVuZGVyT3B0aW9ucy5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZFRlcm1pbmF0aW9uTGlua3MgPSBsaW5rIGluc3RhbmNlb2YgTGluayAmJiAoXHJcbiAgICAgICAgICAgICAgICAhKHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnRhcmdldF0pIHx8XHJcbiAgICAgICAgICAgICAgICByZW5kZXJPcHRpb25zLnF1aWNrVXBkYXRlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChhZGRUZXJtaW5hdGlvbkxpbmtzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWaWV3RnJhbWUgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWUgPSBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZpZXdGcmFtZSAmJiB0YXJnZXRWaWV3RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VWaWV3RnJhbWVJZCA9IHNvdXJjZVZpZXdGcmFtZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3RnJhbWVJZCA9IHRhcmdldFZpZXdGcmFtZS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQ2FjaGVJZCA9IGxpbmsubW9kZWwuc291cmNlICsgJ19hdF8nICsgc291cmNlVmlld0ZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2FjaGVJZCA9IGxpbmsubW9kZWwudGFyZ2V0ICsgJ19hdF8nICsgdGFyZ2V0Vmlld0ZyYW1lSWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRlcm1pbmF0aW9uQ2VsbE1hcFtzb3VyY2VDYWNoZUlkXSB8fCB2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGVybWluYXRpb25DZWxsTWFwW3RhcmdldENhY2hlSWRdIHx8IHZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0NhY2hlSWQgPSBzb3VyY2UuaWQgKyAnfiN+JyArIHRhcmdldC5pZDsgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hdGlvbkxpbmsgPSBfdGVybWluYXRpb25DZWxsQ2FjaGVbbGlua0NhY2hlSWRdIHx8IG5ldyBUZXJtaW5hdGlvbkxpbmsgKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazogbGluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uQ2VsbE1hcFtsaW5rQ2FjaGVJZF0gPSB0ZXJtaW5hdGlvbkxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25MaW5rcy5wdXNoKHRlcm1pbmF0aW9uTGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3Rlcm1pbmF0aW9uQ2VsbENhY2hlID0gdGVybWluYXRpb25DZWxsTWFwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IG5vZGVzLmNvbmNhdCh0ZXJtaW5hdGlvbk5vZGVzKTtcclxuICAgICAgICBjb25zdCBhc3BlY3RMaW5rcyA9IHJlbmRlck9wdGlvbnMucXVpY2tVcGRhdGUgPyBbXSA6IF9jYWxjdWxhdGVBc3BlY3RMaW5rcyh2aXNpYmxlTm9kZXMpO1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVMaW5rcyA9IGxpbmtzLmNvbmNhdCh0ZXJtaW5hdGlvbkxpbmtzKS5jb25jYXQoYXNwZWN0TGlua3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmlzaWJsZU5vZGVzLmNvbmNhdCh2aXNpYmxlTGlua3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIExpbmsgaXMgc2VsZWN0ZWQgdGhlbiB3ZSByZXByZXNlbnRcclxuICAgICAqIGl0IGFzIHR3byBzZWxlY3RlZCBub2Rlc1xyXG4gICAgICogQHBhcmFtIHtOb2RlfExpbmt9IHNlbGVjdGVkRWxlbWVudFxyXG4gICAgICogQHJldHVybnMge05vZGVbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFNlbGVjdGVkTm9kZXMgKHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgY29uc3QgaXNOb2RlID0gc2VsZWN0ZWRFbGVtZW50IGluc3RhbmNlb2YgTm9kZTtcclxuICAgICAgICByZXR1cm4gaXNOb2RlID8gW3NlbGVjdGVkRWxlbWVudF0gOiBbXHJcbiAgICAgICAgICAgIG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnNvdXJjZV0sXHJcbiAgICAgICAgICAgIG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnRhcmdldF0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBMaW5rIGlzIHNlbGVjdGVkIHRoZW4gd2UgcmVwcmVzZW50XHJcbiAgICAgKiBpdCBhcyB0d28gc2VsZWN0ZWQgbm9kZXNcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc2VsZWN0ZWROb2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBOb2RlPn0gdmlzaWJsZU5vZGVNYXAgLSBWaXNpYmxlIG5vZGVzXHJcbiAgICAgKiBAcGFyYW0ge0xpbmtbXX0gYmFkTGlua3MgLSBMaW5rcyB3aGljaCBoYXZlIGVpdGhlciBzb3VyY2UgZWl0aGVyIHRhcmdldCBpcyBub3QgdmlzaWJsZVxyXG4gICAgICogQHJldHVybnMge05vZGVbXSwgTGlua1tdfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGVybWluYXRpb25PcmlnaW5zIChzZWxlY3RlZE5vZGUsIHZpc2libGVOb2RlTWFwLCBiYWRMaW5rcykge1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uT3JpZ2luTm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbk9yaWdpbkxpbmtzID0gW107XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2VsbElkcyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWROb2RlVmlzaWJsZSA9IHZpc2libGVOb2RlTWFwW3NlbGVjdGVkTm9kZS5pZF07XHJcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWROb2RlVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBiYWRMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRDZWxsSWRzW2xpbmsuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMaW5rQ29ubmVjdGVkVG9TZWxlY3RlZE5vZGUgPSBsaW5rLm1vZGVsLnNvdXJjZSA9PT0gc2VsZWN0ZWROb2RlLmlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLm1vZGVsLnRhcmdldCA9PT0gc2VsZWN0ZWROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uc0hhdmVWaWV3RnJhbWVzID0gbGluay5tb2RlbC5zb3VyY2UgPT09IHNlbGVjdGVkTm9kZS5pZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2V0Vmlld0ZyYW1lRm9yTm9kZShub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dldFZpZXdGcmFtZUZvck5vZGUobm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSAmJiB0ZXJtaW5hdGlvbnNIYXZlVmlld0ZyYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvbk9yaWdpbkxpbmtzLnB1c2gobGluayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VJc250VmlzaWJsZSA9ICF2aXNpYmxlTm9kZU1hcFtsaW5rLm1vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJc250VmlzaWJsZSAmJiAhcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLm1vZGVsLnNvdXJjZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZENlbGxJZHNbbGluay5tb2RlbC5zb3VyY2VdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uT3JpZ2luTm9kZXMucHVzaChub2RlTWFwW2xpbmsubW9kZWwuc291cmNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldElzbnRWaXNpYmxlID0gIXZpc2libGVOb2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldElzbnRWaXNpYmxlICYmICFwcm9jZXNzZWRDZWxsSWRzW2xpbmsubW9kZWwudGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ2VsbElkc1tsaW5rLm1vZGVsLnRhcmdldF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5Ob2Rlcy5wdXNoKG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5Ob2Rlcy5wdXNoKHNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIGJhZExpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZENlbGxJZHNbbGluay5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRDZWxsSWRzW2xpbmsuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xpbmtDb25uZWN0ZWRUb1NlbGVjdGVkTm9kZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubW9kZWwuc291cmNlID09PSBzZWxlY3RlZE5vZGUuaWQgfHwgbGluay5tb2RlbC50YXJnZXQgPT09IHNlbGVjdGVkTm9kZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5rQ29ubmVjdGVkVG9TZWxlY3RlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25PcmlnaW5MaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBub2RlczogdGVybWluYXRpb25PcmlnaW5Ob2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IHRlcm1pbmF0aW9uT3JpZ2luTGlua3MsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcG9zaXRpb24gZm9yIHRoZSB0ZXJtaW5hdGlvbiBub2RlLlxyXG4gICAgICogQHBhcmFtIHtUZXJtaW5hdGlvbk5vZGV9IHRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWV9IHZpZXdGcmFtZVxyXG4gICAgICogQHBhcmFtIHtSZW5kZXJPcHRpb259IHJlbmRlck9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0VGVybWluYXRpb25Ob2RlUG9zaXRpb24gKHRlcm1pbmF0aW9uTm9kZSwgdmlld0ZyYW1lLCByZW5kZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gdGVybWluYXRpb25Ob2RlLm9yaWdpbmFsTm9kZTtcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVTaXplID0gdmlld0ZyYW1lLnNpemU7IC8vIGxvY2FsIHNpemVcclxuICAgICAgICBjb25zdCB2aWV3RnJhbWVQb3NpdGlvbiA9IHZpZXdGcmFtZS5wb3NpdGlvbigpOyAvLyBsb2NhbCBwb3NpdGlvblxyXG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gb3JpZ2luYWxOb2RlLnNpemU7IC8vIGxvY2FsIHNpemVcclxuXHJcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IHZpZXdGcmFtZVBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0geyB4OiB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCwgeTogdmlld0ZyYW1lUG9zaXRpb24ueSB9O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSB7IHg6IHZpZXdGcmFtZVBvc2l0aW9uLngsIHk6IHZpZXdGcmFtZVBvc2l0aW9uLnkgKyB2aWV3RnJhbWVTaXplLmhlaWdodCB9O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0geyB4OiB2aWV3RnJhbWVQb3NpdGlvbi54ICsgdmlld0ZyYW1lU2l6ZS53aWR0aCwgeTogdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0aW9uUG9pbnRzID0gZ2V0Q2FsY3VsYXRpb25Qb2ludHMoKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VQb2ludCA9IGNhbGN1bGF0aW9uUG9pbnRzLnNvdXJjZVBvaW50O1xyXG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uUG9pbnQgPSBjYWxjdWxhdGlvblBvaW50cy50ZXJtaW5hdGlvblBvaW50O1xyXG5cclxuICAgICAgICAvLyBjaG9vc2UgYSBzaWRlIGZvciB0ZXJtaW5hdGlvbiBub2RlXHJcblxyXG4gICAgICAgIGxldCBjcm9zc1BvaW50ID0gZ2V0Q3Jvc1BvaW50KHNvdXJjZVBvaW50LCB0ZXJtaW5hdGlvblBvaW50LCB0b3BMZWZ0LCBib3R0b21MZWZ0KTsgLy8gbGVmdFxyXG4gICAgXHJcbiAgICAgICAgaWYgKCFjcm9zc1BvaW50KSB7XHJcbiAgICAgICAgICAgIGNyb3NzUG9pbnQgPSBnZXRDcm9zUG9pbnQoc291cmNlUG9pbnQsIHRlcm1pbmF0aW9uUG9pbnQsIHRvcExlZnQsIHRvcFJpZ2h0KTsgLy8gdG9wXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY3Jvc3NQb2ludCkge1xyXG4gICAgICAgICAgICBjcm9zc1BvaW50ID0gZ2V0Q3Jvc1BvaW50KHNvdXJjZVBvaW50LCB0ZXJtaW5hdGlvblBvaW50LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpOyAvLyByaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNyb3NzUG9pbnQpIHtcclxuICAgICAgICAgICAgY3Jvc3NQb2ludCA9IGdldENyb3NQb2ludChzb3VyY2VQb2ludCwgdGVybWluYXRpb25Qb2ludCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpOyAvLyBib3R0b21cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNyb3NzUG9pbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IGNyb3NzUG9pbnQueCAtIF90ZXJtaW5hdGlvbk5vZGVTaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IGNyb3NzUG9pbnQueSAtIF90ZXJtaW5hdGlvbk5vZGVTaXplLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHRlcm1pbmF0aW9uUG9pbnQueCArIG5vZGVTaXplLndpZHRoIC8gMiwgdmlld0ZyYW1lUG9zaXRpb24ueCksXHJcbiAgICAgICAgICAgICAgICAgICAgdmlld0ZyYW1lUG9zaXRpb24ueCArIHZpZXdGcmFtZVNpemUud2lkdGhcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0ZXJtaW5hdGlvblBvaW50LnkgKyBub2RlU2l6ZS5oZWlnaHQgLyAyLCB2aWV3RnJhbWVQb3NpdGlvbi55KSxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3RnJhbWVQb3NpdGlvbi55ICsgdmlld0ZyYW1lU2l6ZS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDYWxjdWxhdGlvblBvaW50cyAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogdmlld0ZyYW1lUG9zaXRpb24ueCArIHZpZXdGcmFtZVNpemUud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG93bmVyVmlld0ZyYW1lID0gX2dldFZpZXdGcmFtZUZvck5vZGUob3JpZ2luYWxOb2RlKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBvd25lclZpZXdGcmFtZS5nZXRTY2FsZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBnZXRMb2NhbE5vZGVQb3NpdGlvbihvcmlnaW5hbE5vZGUsIHNjYWxlLCBvd25lclZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uUG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBub2RlUG9zaXRpb24ueCArIG5vZGVTaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IG5vZGVQb3NpdGlvbi55ICsgbm9kZVNpemUuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50SXNJblRoZUZyYW1lID0gdmlld0ZyYW1lLmhpdFNjYWxlZFBvaW50VGVzdCh0ZXJtaW5hdGlvblBvaW50KTtcclxuICAgICAgICAgICAgaWYgKHBvaW50SXNJblRoZUZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9MZWZ0ID0gdGVybWluYXRpb25Qb2ludC54IC0gdmlld0ZyYW1lUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RUb1RvcCA9IHRlcm1pbmF0aW9uUG9pbnQueSAtIHZpZXdGcmFtZVBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9SaWdodCA9IHZpZXdGcmFtZVBvc2l0aW9uLnggKyB2aWV3RnJhbWVTaXplLndpZHRoIC0gdGVybWluYXRpb25Qb2ludC54O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvQm90dG9tID0gdmlld0ZyYW1lUG9zaXRpb24ueSArIHZpZXdGcmFtZVNpemUuaGVpZ2h0IC0gdGVybWluYXRpb25Qb2ludC55O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgICBbZGlzdFRvTGVmdCwgZGlzdFRvVG9wLCBkaXN0VG9SaWdodCwgZGlzdFRvQm90dG9tXS5mb3JFYWNoKGRpc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZGlzdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBkaXN0VG9MZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC54IC09IG1pbjsgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1pbiA9PT0gZGlzdFRvUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnggKz0gbWluOyBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWluID09PSBkaXN0VG9Ub3ApIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnkgLT0gbWluOyBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC55ICs9IG1pbjsgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lIGl0J3MgY29uZnVzaW5nIGZvciB1c2VycyB3aGVuXHJcbiAgICAgICAgICAgIC8vIG5vZGVzIGFyZSBpbiB0aGUgbGVmdFZpZXdGcmFtZSBidXQgdGVybWluYXRpb24gbm9kZXMgZ29lcyB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgaWYgKG93bmVyVmlld0ZyYW1lLmlkICE9PSB2aWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkcyA9IF9hbGxGcmFtZXMubWFwKHZmID0+IHZmLmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZUluZGV4ID0gaWRzLmluZGV4T2Yodmlld0ZyYW1lLmlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyVmlld0ZyYW1lSW5kZXggPSBpZHMuaW5kZXhPZihvd25lclZpZXdGcmFtZS5pZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHJlbmRlck9wdGlvbnMucGFwZXJPcHRpb25zLm9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsT3JpZW50YXRlZCA9IG9yaWVudGF0aW9uID09PSAnbGVmdC10by1yaWdodCcgfHwgb3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWVJbmRleCA8IG93bmVyVmlld0ZyYW1lSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JpZW50YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnggPSBib3R0b21SaWdodC54O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQueSA9IGJvdHRvbVJpZ2h0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsT3JpZW50YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGlvblBvaW50LnggPSB0b3BMZWZ0Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYXRpb25Qb2ludC55ID0gdG9wTGVmdC55O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZVBvaW50OiBzb3VyY2VQb2ludCxcclxuICAgICAgICAgICAgICAgIHRlcm1pbmF0aW9uUG9pbnQ6IHRlcm1pbmF0aW9uUG9pbnQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyAob3IgZ2V0IGZyb20gY2FjaGUpIGFzcGVjdCBsaW5rc1xyXG4gICAgICogQHBhcmFtIHtOb2RlW119IG5vZGVzIC0gdmlzaWJsZSBub2Rlc1xyXG4gICAgICogQHJldHVybnMge0FzcGVjdExpbmtbXX1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlQXNwZWN0TGlua3MgKG5vZGVzKSB7XHJcbiAgICAgICAgY29uc3QgYXNwZWN0TGlua3NDYWNoZSA9IHt9O1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBhcnJheVRvTWFwKG5vZGVzKTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RzID0gZ2V0QmFzZUVsZW1lbnQobm9kZSkuYXNwZWN0cztcclxuICAgICAgICAgICAgYXNwZWN0cy5mb3JFYWNoKGFzcGVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNpYmxlVGVybWluYXRpb25zID0gYXNwZWN0LnRlcm1pbmF0aW9uTm9kZXMuZmlsdGVyKHRuID0+IG5vZGVNYXBbdG4uaWRdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0TGVhc3RPbmVUZXJtaW5hdGlvbiA9IHZpc2libGVUZXJtaW5hdGlvbnMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpbGxPblRoZVBhcGVyID0gIG5vZGVNYXBbYXNwZWN0LmlkXSB8fCBhdExlYXN0T25lVGVybWluYXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVPd25lciA9IF9nZXRWaWV3RnJhbWVGb3JOb2RlKGFzcGVjdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVPd25lcklzVmlzaWJsZSA9IF9zdGF0ZVt2aWV3RnJhbWVPd25lci5pZF0gfHwgX2Z1bGxTY3JlZW5Nb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFzcGVjdFdpbGxPblRoZVBhcGVyICYmIHZpZXdGcmFtZU93bmVySXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNwZWN0SW5zdGFuY2VzID0gbm9kZU1hcFthc3BlY3QuaWRdID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXNwZWN0XSA6IHZpc2libGVUZXJtaW5hdGlvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEluc3RhbmNlcy5mb3JFYWNoKGFzcGVjdEluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkTGluayA9IGdldEZyb21DYWhlKG5vZGUsIGFzcGVjdEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNwZWN0TGluayA9IGNhY2hlZExpbmsgfHwgY3JlYXRlQXNwZWN0TGluayhub2RlLCBhc3BlY3RJbnN0YW5jZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RMaW5rc0NhY2hlW2FzcGVjdExpbmsuaWRdID0gYXNwZWN0TGluaztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2FzcGVjdExpbmtzQ2FoZSA9IGFzcGVjdExpbmtzQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgYXNwZWN0TGlua3MgPSBPYmplY3Qua2V5cyhhc3BlY3RMaW5rc0NhY2hlKS5tYXAoaWQgPT4gX2FzcGVjdExpbmtzQ2FoZVtpZF0pO1xyXG4gICAgICAgIHJldHVybiBhc3BlY3RMaW5rcztcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQXNwZWN0TGluayAobm9kZSwgYXNwZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbm9kZS5pZCArICd+I34nICsgYXNwZWN0LmlkO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBc3BlY3RMaW5rKHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogYXNwZWN0LFxyXG4gICAgICAgICAgICB9LCBwYXJhbWV0ZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldEZyb21DYWhlIChub2RlLCBhc3BlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBub2RlLmlkICsgJ34jficgKyBhc3BlY3QuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VJZCA9IGFzcGVjdC5pZCArICd+I34nICsgbm9kZS5pZDtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtGcm9tTG9jYWwgPSBhc3BlY3RMaW5rc0NhY2hlW2lkXSB8fCBhc3BlY3RMaW5rc0NhY2hlW3JldmVyc2VJZF07XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtGcm9tR2xvYmFsID0gX2FzcGVjdExpbmtzQ2FoZVtpZF0gfHwgX2FzcGVjdExpbmtzQ2FoZVtyZXZlcnNlSWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gbGlua0Zyb21Mb2NhbCB8fCBsaW5rRnJvbUdsb2JhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIGhpZ2hsaWdodGluZyBvZiB0aGUgZWxlbWVudHNcclxuICAgICAqIEBwYXJhbSB7KE5vZGV8TGlua3xUZXJtaW5hdGlvbk5vZGV8VGVybWluYXRpb25MaW5rKVtdfSBjZWxsc1xyXG4gICAgICogQHBhcmFtIHtSZW5kZXJPcHRpb259IHJlbmRlck9wdGlvbnNcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0SGlnaGxpZ2h0aW5nIChjZWxscywgcmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSByZW5kZXJPcHRpb25zLnBhdGg7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IHJlbmRlck9wdGlvbnMubWFzaztcclxuXHJcbiAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFzZUNlbGwgPSBnZXRCYXNlRWxlbWVudChjZWxsKTtcclxuICAgICAgICAgICAgaWYgKG1hc2sgJiYgYmFzZUNlbGwgIT09IHJlbmRlck9wdGlvbnMuc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFza1tiYXNlQ2VsbC5pZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlQ2VsbC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDZWxsLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYmFzZUNlbGwgPT09IHJlbmRlck9wdGlvbnMuc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlQ2VsbC5zZWxlY3QoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXRoICYmICFwYXRoW2Jhc2VDZWxsLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgYmFzZUNlbGwuYmx1cmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJhc2VDZWxsLnVuYmx1cmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBsaXN0IG9mIHZpc2libGUgdmlld0ZyYW1lc1xyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVtdfVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRWaXNpYmxlVmlld0ZyYW1lcyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9mdWxsU2NyZWVuTW9kZSA/IFtfb3ZlclZpZXdGcmFtZV0gOiBfdmlld0ZyYW1lcy5maWx0ZXIodmYgPT4gX3N0YXRlW3ZmLmlkXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHZpZXdGcmFtZSBmb3IgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWUgfCB1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRWaWV3RnJhbWVGb3JOb2RlIChub2RlKSB7XHJcbiAgICAgICAgaWYgKF9mdWxsU2NyZWVuTW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX292ZXJWaWV3RnJhbWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lSWQgPSBnZXRWaWV3RnJhbWVJZEZvck5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfdmlld0ZyYW1lc01hcFt2aWV3RnJhbWVJZF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBvbiB2aWV3RnJhbWUgZXZlbnRzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZU9uVmlld0ZyYW1lRXZlbnRzICgpIHtcclxuICAgICAgICBfYWxsRnJhbWVzLmZvckVhY2godmlld0ZyYW1lID0+IHtcclxuICAgICAgICAgICAgdmlld0ZyYW1lLm9uKCdjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uJywgKG5ld1ZpZXdQb3J0UG9zaXRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3RnJhbWUubW92aW5nQnlJdHNlbGYpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVQdWJsaWNNb2RlbCA9IF9nZXRWaWV3RnJhbWVQdWJsaWNNb2RlbCh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lUHVibGljTW9kZWwudmlld1BvcnRQb3NpdGlvbiA9IG5ld1ZpZXdQb3J0UG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2Utdmlldy1wb3J0LXBvc2l0aW9uJywgdmlld0ZyYW1lUHVibGljTW9kZWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVmlld01hbmFnZXI7XHJcbiIsImltcG9ydCAqIGFzIGNvbGEgZnJvbSAnd2ViY29sYSc7XHJcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IFNhbmtleSBmcm9tICcuL3NhbmtleSc7XHJcbmltcG9ydCB7IGFycmF5VG9NYXAsIGdldEVsZW1lbnRTaXplLCBnZXRHbG9iYWxOb2RlUG9zaXRpb24gfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7XHJcbiAgICBjb252ZXJ0TmF0aXZlVG9MYXlvdXRNb2RlbHMsXHJcbiAgICBjb252ZXJ0TEdFbGVtZW50c1RvTGF5b3V0TW9kZWxzLFxyXG59IGZyb20gJy4uL3V0aWxzL2xheW91dFV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge3tcclxuICogIHNlbGVjdGVkTm9kZTogTm9kZSxcclxuICogIHJlbGF0aXZlTGlua3M6IExpbmtbXSxcclxuICogIHJlbGF0aXZlTm9kZXM6IE5vZGVbXSxcclxuICogfX0gb3B0aW9ucyBcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gcGFyYW1ldGVycyBzZXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lT3BlcmF0aW9uIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XHJcblxyXG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihvcHRpb25zLnNlbGVjdGVkTm9kZSk7XHJcbiAgICBjb25zdCBjb21iaW5lZE5vZGVzID0gW29wdGlvbnMuc2VsZWN0ZWROb2RlXS5jb25jYXQob3B0aW9ucy5yZWxhdGl2ZU5vZGVzKTtcclxuXHJcbiAgICBjb25zdCBlbGVtZW50cyA9IGNvbnZlcnRMR0VsZW1lbnRzVG9MYXlvdXRNb2RlbHMoY29tYmluZWROb2Rlcywgb3B0aW9ucy5yZWxhdGl2ZUxpbmtzLCB7XHJcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBub2RlcyA9IGVsZW1lbnRzLm5vZGVzO1xyXG4gICAgY29uc3QgbGlua3MgPSBlbGVtZW50cy5saW5rcztcclxuICAgIGNvbnN0IHNlbGVjdGVkTGF5b3V0Tm9kZSA9IG5vZGVzWzBdO1xyXG5cclxuICAgIGNvbnN0IGxheW91dE9wdGlvbnMgPSB7XHJcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgICAgICBzdGVwOiBwYXJhbWV0ZXJzLmxheW91dFN0ZXAsXHJcbiAgICAgICAgZWxlbWVudDogcGFyYW1ldGVycy5lbGVtZW50U2l6ZSxcclxuICAgICAgICBpdGVyYXRpb25zOiBwYXJhbWV0ZXJzLmxheW91dEl0ZXJhdGlvbnMsXHJcbiAgICB9O1xyXG4gICAgdHFGb3JjZUxheW91dChsYXlvdXRPcHRpb25zKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIG5vZGVzLmZvckVhY2gobGF5b3V0Tm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKGxheW91dE5vZGUgIT09IHNlbGVjdGVkTGF5b3V0Tm9kZSkge1xyXG4gICAgICAgICAgICBsYXlvdXROb2RlLnggPSBzdGFydFBvc2l0aW9uLnggKyAobGF5b3V0Tm9kZS54IC0gc2VsZWN0ZWRMYXlvdXROb2RlLngpO1xyXG4gICAgICAgICAgICBsYXlvdXROb2RlLnkgPSBzdGFydFBvc2l0aW9uLnkgKyAobGF5b3V0Tm9kZS55IC0gc2VsZWN0ZWRMYXlvdXROb2RlLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHRbbGF5b3V0Tm9kZS5vcmlnaW5hbE5vZGUuaWRdID0ge1xyXG4gICAgICAgICAgICB4OiBsYXlvdXROb2RlLngsXHJcbiAgICAgICAgICAgIHk6IGxheW91dE5vZGUueSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlIFxyXG4gKiBcclxuICogQ2FsY3VsYXRlcyBwb3NpdGlvbnMgZm9yIG5vZGVzLlxyXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTW9kZWxzIC0gbGlzdCBvZiB0aGUgbmF0aXZlIG5vZGVzXHJcbiAqIEBwYXJhbSB7QXJyYXl9IG5hdGl2ZUxpbmtzIC0gbGlzdCBvZiB0aGUgbmF0aXZlIGxpbmtzXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG9MYXlvdXQgKG5vZGVNb2RlbHMsIGxpbmtNb2RlbHMsIHZpZXdGcmFtZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGlmICghcGFyYW1ldGVycykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRzID0gY29udmVydE5hdGl2ZVRvTGF5b3V0TW9kZWxzKG5vZGVNb2RlbHMsIGxpbmtNb2RlbHMsIHBhcmFtZXRlcnMpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBlbGVtZW50cy5ub2RlcztcclxuICAgIGNvbnN0IGxpbmtzID0gZWxlbWVudHMubGlua3M7XHJcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JztcclxuICAgIFxyXG4gICAgcmVtb3ZlQ3ljbGVzKG5vZGVzLCBsaW5rcyk7XHJcbiAgICBcclxuICAgIGNvbnN0IGdyb3VwcyA9IGJyZWFrQnlHcm91cHMobm9kZXMsIGxpbmtzLCB2aWV3RnJhbWVzLCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBjb25zdCBsYXlvdXRPcHRpb25zID0ge1xyXG4gICAgICAgIGdyb3VwczogZ3JvdXBzLFxyXG4gICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICAgICAgaXNIb3Jpem9udGFsOiBpc0hvcml6b250YWwsXHJcbiAgICAgICAgc3RlcDogcGFyYW1ldGVycy5sYXlvdXRTdGVwLFxyXG4gICAgICAgIGVsZW1lbnQ6IHBhcmFtZXRlcnMuZWxlbWVudFNpemUsXHJcbiAgICAgICAgaXRlcmF0aW9uczogcGFyYW1ldGVycy5sYXlvdXRJdGVyYXRpb25zLFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgaWYgKHBhcmFtZXRlcnMubGF5b3V0QWxnb3JpdGhtID09PSAnZmxvdy1kaXJlY3RlZCcpIHtcclxuICAgICAgICB0cUZsb3dMYXlvdXQobGF5b3V0T3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRxU2Fua2V5TGF5b3V0KGxheW91dE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgYXBwbHlMYXlvdXQoKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYXBwbHlMYXlvdXQgKCkge1xyXG4gICAgICAgIC8vIENhbGN1bGF0aW5nIG1pbiBwb2ludHNcclxuICAgICAgICBsZXQgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIG5vZGUueCk7XHJcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBub2RlLnkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgbWF4WCA9IG5vZGVzLmxlbmd0aCA+IDAgPyAtSW5maW5pdHkgOiAwO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1BhZGRpbmcgPSBcclxuICAgICAgICAgICAgTWF0aC5tYXgocGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCwgcGFyYW1ldGVycy5lbGVtZW50U2l6ZS5oZWlnaHQpICogMiAqIHBhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4O1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG5vZGUub3JpZ2luYWxOb2RlLnBvc2l0aW9uLnggPSBub2RlLnggLSBtaW5YICsgY2FudmFzUGFkZGluZztcclxuICAgICAgICAgICAgbm9kZS5vcmlnaW5hbE5vZGUucG9zaXRpb24ueSA9IG5vZGUueSAtIG1pblkgKyBjYW52YXNQYWRkaW5nO1xyXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgbm9kZS5vcmlnaW5hbE5vZGUucG9zaXRpb24ueCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdib3R0b20tdG8tdG9wJykge1xyXG4gICAgICAgICAgICBub2RlTW9kZWxzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBvc2l0aW9uLnggPSBtYXhYIC0gbm9kZS5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIG5vZGVNb2RlbHMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBub2RlLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBvc2l0aW9uLnggPSBub2RlLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBvc2l0aW9uLnkgPSB4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGVNb2RlbHMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbm9kZS5kZWZhdWx0UG9zaXRpb24gPSBfLmNsb25lKG5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3ljbGVzIChub2RlcywgbGlua3MpIHtcclxuICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVwZWF0TWFwID0ge307XHJcbiAgICAgICAgY29uc3QgbGlua3NUb1JlbW92ZSA9IFtdO1xyXG5cclxuICAgICAgICByZWN1cnNpb24obik7XHJcblxyXG4gICAgICAgIGxpbmtzVG9SZW1vdmUuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGlua3Muc3BsaWNlKGxpbmtzLmluZGV4T2YobGluayksIDEpO1xyXG4gICAgICAgICAgICBsaW5rLnRhcmdldC5zb3VyY2VMaW5rcy5zcGxpY2UobGluay50YXJnZXQuc291cmNlTGlua3MuaW5kZXhPZihsaW5rKSwgMSk7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnNwbGljZShsaW5rLnNvdXJjZS50YXJnZXRMaW5rcy5pbmRleE9mKGxpbmspLCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHJlcGVhdE1hcFtub2RlLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVwZWF0TWFwW2xpbmsudGFyZ2V0LmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2lvbiAobGluay50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rc1RvUmVtb3ZlLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXBlYXRNYXBbbm9kZS5pZF0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnJlYWtCeUdyb3VwcyAobm9kZXMsIGxpbmtzLCB2aWV3RnJhbWVzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChub2Rlcyk7XHJcbiAgICBjb25zdCBncm91cHMgPSB7fTtcclxuICAgIGNvbnN0IHBhcGVyU2l6ZSA9IGdldEVsZW1lbnRTaXplKHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSk7XHJcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fCBwYXJhbWV0ZXJzLmdyYXBoT3JpZW50YXRpb24gPT09ICdyaWdodC10by1sZWZ0JztcclxuICAgIGNvbnN0IHRvdGFsU2hhcmUgPSB2aWV3RnJhbWVzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHZpZXdGcmFtZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIHZpZXdGcmFtZS5zcGFjZVNoYXJlO1xyXG4gICAgfSwgMCk7XHJcbiAgICB2aWV3RnJhbWVzLmZvckVhY2godmlld0ZyYW1lID0+IHtcclxuICAgICAgICBpZiAoIWdyb3Vwc1t2aWV3RnJhbWUuaWRdKSBncm91cHNbdmlld0ZyYW1lLmlkXSA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCxcclxuICAgICAgICAgICAgcHJlZmZlcmVkU2l6ZToge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGlzSG9yaXpvbnRhbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcGVyU2l6ZS53aWR0aCAvIHRvdGFsU2hhcmUpICogdmlld0ZyYW1lLnNwYWNlU2hhcmUgOlxyXG4gICAgICAgICAgICAgICAgICAgIChwYXBlclNpemUuaGVpZ2h0IC8gdG90YWxTaGFyZSkgKiB2aWV3RnJhbWUuc3BhY2VTaGFyZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaXNIb3Jpem9udGFsID8gcGFwZXJTaXplLmhlaWdodCA6IHBhcGVyU2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICBsaW5rczogW10sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbGFzdE5vZGVzID0gW107XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGUudmlld0ZyYW1lID09PSB2aWV3RnJhbWUuaWQpIHtcclxuICAgICAgICAgICAgICAgIGdyb3Vwc1t2aWV3RnJhbWUuaWRdLm5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Tm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGVzID0gbGFzdE5vZGVzO1xyXG5cclxuICAgICAgICBjb25zdCBsYXN0TGlua3MgPSBbXTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBub2RlTWFwW2wuc291cmNlLmlkXS52aWV3RnJhbWUgPT09IHZpZXdGcmFtZS5pZCAmJlxyXG4gICAgICAgICAgICAgICAgbm9kZU1hcFtsLnRhcmdldC5pZF0udmlld0ZyYW1lID09PSB2aWV3RnJhbWUuaWRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cHNbdmlld0ZyYW1lLmlkXS5saW5rcy5wdXNoKGwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgbm9kZU1hcFtsLnNvdXJjZS5pZF0udmlld0ZyYW1lICE9PSB2aWV3RnJhbWUuaWQgJiZcclxuICAgICAgICAgICAgICAgIG5vZGVNYXBbbC50YXJnZXQuaWRdLnZpZXdGcmFtZSAhPT0gdmlld0ZyYW1lLmlkXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgbGFzdExpbmtzLnB1c2gobCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlua3MgPSBsYXN0TGlua3M7XHJcbiAgICB9KTtcclxuICAgIGdyb3Vwc1sndW5rbm93biddID0geyBpZDogJ3Vua25vd24nLCBub2Rlczogbm9kZXMsIGxpbmtzOiBsaW5rcyB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGdyb3VwcykubWFwKGtleSA9PiBncm91cHNba2V5XSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRxU2Fua2V5TGF5b3V0IChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBzdGVwID0gKFxyXG4gICAgICAgIG9wdGlvbnMuaXNIb3Jpem9udGFsID9cclxuICAgICAgICBbb3B0aW9ucy5zdGVwLnggfHwgMTAwLCBvcHRpb25zLnN0ZXAueSB8fCAxNV0gOlxyXG4gICAgICAgIFtvcHRpb25zLnN0ZXAueSB8fCAxNSwgb3B0aW9ucy5zdGVwLnggfHwgMTAwXVxyXG4gICAgKTtcclxuICAgIG9wdGlvbnMuc3RlcCA9IG9wdGlvbnMuc3RlcCB8fCB7fTtcclxuICAgIFNhbmtleSgpLnN0ZXAoc3RlcClcclxuICAgIC5ub2RlV2lkdGgob3B0aW9ucy5lbGVtZW50LndpZHRoKVxyXG4gICAgLm5vZGVIZWlnaHQob3B0aW9ucy5lbGVtZW50LmhlaWdodClcclxuICAgIC5ub2RlcyhvcHRpb25zLm5vZGVzKVxyXG4gICAgLmxpbmtzKG9wdGlvbnMubGlua3MpXHJcbiAgICAuZ3JvdXBzKG9wdGlvbnMuZ3JvdXBzKVxyXG4gICAgLmxheW91dChvcHRpb25zLml0ZXJhdGlvbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cUZsb3dMYXlvdXQgKG9wdGlvbnMpIHtcclxuICAgIHRxU2Fua2V5TGF5b3V0KG9wdGlvbnMpO1xyXG5cclxuICAgIGNvbnN0IGxheW91dCA9IG5ldyBjb2xhLkxheW91dCgpXHJcbiAgICAgICAgLm5vZGVzKG9wdGlvbnMubm9kZXMpXHJcbiAgICAgICAgLmxpbmtzKG9wdGlvbnMubGlua3MpXHJcbiAgICAgICAgLmNvbnZlcmdlbmNlVGhyZXNob2xkKDFlLTkpXHJcbiAgICAgICAgLmphY2NhcmRMaW5rTGVuZ3RocyhvcHRpb25zLnN0ZXAueCAqIDIgfHwgNDAwKVxyXG4gICAgICAgIC5mbG93TGF5b3V0KCd4Jywgb3B0aW9ucy5zdGVwLnggKiAyfHwgNDAwKVxyXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKHRydWUpXHJcbiAgICAgICAgLmhhbmRsZURpc2Nvbm5lY3RlZCh0cnVlKTtcclxuICAgIGxheW91dC5zdGFydCgxMDAsIDAsIDUwLCB1bmRlZmluZWQsIGZhbHNlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHFGb3JjZUxheW91dCAob3B0aW9ucykge1xyXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IGNvbGEuTGF5b3V0KClcclxuICAgICAgICAubm9kZXMob3B0aW9ucy5ub2RlcylcclxuICAgICAgICAubGlua3Mob3B0aW9ucy5saW5rcylcclxuICAgICAgICAuY29udmVyZ2VuY2VUaHJlc2hvbGQoMWUtOSlcclxuICAgICAgICAuamFjY2FyZExpbmtMZW5ndGhzKG9wdGlvbnMuc3RlcC54ICogMS41IHx8IDM1MClcclxuICAgICAgICAuYXZvaWRPdmVybGFwcyh0cnVlKVxyXG4gICAgICAgIC5oYW5kbGVEaXNjb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICBsYXlvdXQuc3RhcnQoMTAwLCAwLCA1MCwgdW5kZWZpbmVkLCBmYWxzZSk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMvbGF5b3V0VXRpbHMnO1xyXG5pbXBvcnQgeyBhcnJheVRvTWFwIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxudmFyIFNhbmtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzYW5rZXkgPSB7fSxcclxuICAgICAgICBub2RlV2lkdGggPSAyNCxcclxuICAgICAgICBub2RlSGVpZ2h0ID0gOCxcclxuICAgICAgICBzaXplID0gWzEsIDFdLFxyXG4gICAgICAgIHN0ZXAgPSBbMTAwLCAzMF0sXHJcbiAgICAgICAgbm9kZXMgPSBbXSxcclxuICAgICAgICBncm91cHMgPSBbXSxcclxuICAgICAgICBzYXZlT3JkZXIgPSBmYWxzZSxcclxuICAgICAgICBsaW5rcyA9IFtdO1xyXG5cclxuICAgIHNhbmtleS5ub2RlV2lkdGggPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVXaWR0aDtcclxuICAgICAgICBub2RlV2lkdGggPSArXztcclxuICAgICAgICByZXR1cm4gc2Fua2V5O1xyXG4gICAgfTtcclxuXHJcbiAgICBzYW5rZXkubm9kZUhlaWdodCA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZUhlaWdodDtcclxuICAgICAgICBub2RlSGVpZ2h0ID0gK187XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5Lm5vZGVzID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcclxuICAgICAgICBub2RlcyA9IF87XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LnNhdmVPcmRlciA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2F2ZU9yZGVyO1xyXG4gICAgICAgIHNhdmVPcmRlciA9IF87XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5Lmdyb3VwcyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JvdXBzO1xyXG4gICAgICAgIGdyb3VwcyA9IF87XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LmxpbmtzID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rcztcclxuICAgICAgICBsaW5rcyA9IF87XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LnN0ZXAgPSBmdW5jdGlvbiAoXykge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0ZXA7XHJcbiAgICAgICAgc3RlcCA9IF87XHJcbiAgICAgICAgcmV0dXJuIHNhbmtleTtcclxuICAgIH07XHJcblxyXG4gICAgc2Fua2V5LmNvbXB1dGVOb2RlQnJlYWR0aHMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgc2Fua2V5LmxheW91dCA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgY29tcHV0ZU5vZGVMaW5rcygpO1xyXG4gICAgICAgIGNvbXB1dGVOb2RlVmFsdWVzKCk7XHJcblxyXG4gICAgICAgIGlmIChzYW5rZXkuY29tcHV0ZU5vZGVCcmVhZHRocylcclxuICAgICAgICAgICAgc2Fua2V5LmNvbXB1dGVOb2RlQnJlYWR0aHMobm9kZXMsIGxpbmtzLCBncm91cHMpO1xyXG4gICAgICAgIGVsc2UgY29tcHV0ZU5vZGVCcmVhZHRocygpO1xyXG5cclxuICAgICAgICBjb21wdXRlTm9kZURlcHRocyhpdGVyYXRpb25zKTtcclxuICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5yZWxheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xyXG4gICAgICAgIHJldHVybiBzYW5rZXk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNhbmtleS5saW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJ2YXR1cmUgPSAuNTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbGluayAoZCkge1xyXG4gICAgICAgICAgICB2YXIgeDAgPSBkLnNvdXJjZS54ICsgZC5zb3VyY2UuZHgsXHJcbiAgICAgICAgICAgICAgICB4MSA9IGQudGFyZ2V0LngsXHJcbiAgICAgICAgICAgICAgICB4aSA9IHV0aWxzLmludGVycG9sYXRlTnVtYmVyKHgwLCB4MSksXHJcbiAgICAgICAgICAgICAgICB4MiA9IHhpKGN1cnZhdHVyZSksXHJcbiAgICAgICAgICAgICAgICB4MyA9IHhpKDEgLSBjdXJ2YXR1cmUpLFxyXG4gICAgICAgICAgICAgICAgeTAgPSBkLnNvdXJjZS55ICsgZC5zeSArIGQuZHkgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTEgPSBkLnRhcmdldC55ICsgZC50eSArIGQuZHkgLyAyO1xyXG4gICAgICAgICAgICByZXR1cm4gJ00nICsgeDAgKyAnLCcgKyB5MCArXHJcbiAgICAgICAgICAgICAgICAnQycgKyB4MiArICcsJyArIHkwICtcclxuICAgICAgICAgICAgICAgICcgJyArIHgzICsgJywnICsgeTEgK1xyXG4gICAgICAgICAgICAgICAgJyAnICsgeDEgKyAnLCcgKyB5MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmsuY3VydmF0dXJlID0gZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY3VydmF0dXJlO1xyXG4gICAgICAgICAgICBjdXJ2YXR1cmUgPSArXztcclxuICAgICAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBvcHVsYXRlIHRoZSBzb3VyY2VMaW5rcyBhbmQgdGFyZ2V0TGlua3MgZm9yIGVhY2ggbm9kZS5cclxuICAgIC8vIEFsc28sIGlmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBhcmUgbm90IG9iamVjdHMsIGFzc3VtZSB0aGV5IGFyZSBpbmRpY2VzLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcyAoKSB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzID0gW107XHJcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBsaW5rLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHNvdXJjZSA9IGxpbmsuc291cmNlID0gbm9kZXNbbGluay5zb3VyY2VdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicpIHRhcmdldCA9IGxpbmsudGFyZ2V0ID0gbm9kZXNbbGluay50YXJnZXRdO1xyXG4gICAgICAgICAgICBzb3VyY2Uuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdmFsdWUgKHNpemUpIG9mIGVhY2ggbm9kZSBieSBzdW1taW5nIHRoZSBhc3NvY2lhdGVkIGxpbmtzLlxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVWYWx1ZXMgKCkge1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgdXRpbHMuc3VtKG5vZGUuc291cmNlTGlua3MsIHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHV0aWxzLnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSlcclxuICAgICAgICAgICAgKSB8fCAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGl2ZWx5IGFzc2lnbiB0aGUgYnJlYWR0aCAoeC1wb3NpdGlvbikgZm9yIGVhY2ggbm9kZS5cclxuICAgIC8vIE5vZGVzIGFyZSBhc3NpZ25lZCB0aGUgbWF4aW11bSBicmVhZHRoIG9mIGluY29taW5nIG5laWdoYm9ycyBwbHVzIG9uZTtcclxuICAgIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGJyZWFkdGggemVybywgd2hpbGVcclxuICAgIC8vIG5vZGVzIHdpdGggbm8gb3V0Z29pbmcgbGlua3MgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGJyZWFkdGguXHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVCcmVhZHRocyAoKSB7XHJcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goZ3JvdXAgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2Rlc09mR3Jwb3VwID0gYXJyYXlUb01hcChncm91cC5ub2Rlcyk7XHJcbiAgICAgICAgICAgIGxldCByZW1haW5pbmdOb2RlcyA9IGdyb3VwLm5vZGVzO1xyXG4gICAgICAgICAgICBsZXQgbmV4dE5vZGVzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmVtYWluaW5nTm9kZXMuc29ydCgobjEsIG4yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRMaW5rcyhuMi5zb3VyY2VMaW5rcykubGVuZ3RoIC0gZ2V0TGlua3MobjEuc291cmNlTGlua3MpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TGlua3MobjIudGFyZ2V0TGlua3MpLmxlbmd0aCAtIGdldExpbmtzKG4xLnRhcmdldExpbmtzKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSB4O1xyXG4gICAgICAgICAgICB3aGlsZSAocmVtYWluaW5nTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmdOb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0geDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmR4ID0gbm9kZVdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBnb2luZyB0byB1c2UgaXZlcnNlIGRpcmVjdGlvbiB0byBtYWtlIG5vZGVzIGNsb3NlciB0byB0aGVpciB0YXJnZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgcGFzcyB0YXJnZXRMaW5rcyBpbnN0ZWFkIG9mIHNvdXJjZUxpbmtzXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGlua3Mobm9kZS50YXJnZXRMaW5rcykuZm9yRWFjaCgobGluaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGVzLmluZGV4T2YobGluay5zb3VyY2UpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGVzLnB1c2gobGluay5zb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ05vZGVzID0gbmV4dE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgKyt4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3VwLmJyZWFkdGggPSB4IC0gc3RhcnRYO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV2ZXJ0IGRpcmVjdGlvbiBiYWNrXHJcbiAgICAgICAgICAgIGdyb3VwLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnggPSBzdGFydFggKyAoeCAtIDEpIC0gbm9kZS54O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldExpbmtzIChsaW5rcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzLmZpbHRlcihsID0+IG5vZGVzT2ZHcnBvdXBbbC5zb3VyY2UuaWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBjdXJYUG9zaXRpb24gPSAwO1xyXG4gICAgICAgIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcclxuICAgICAgICAgICAgbGV0IGdyb3VwU2l6ZSA9IGNhbGN1bGF0ZUdyb3VwV2lkdGgoZ3JvdXApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGdyb3VwLnByZWZmZXJlZFNpemUgJiYgZ3JvdXAuYnJlYWR0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSA9IE1hdGgubWF4KGdyb3VwU2l6ZSwgZ3JvdXAucHJlZmZlcmVkU2l6ZS53aWR0aCAvKiAqIG1heEsgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGt4ID0gZ3JvdXAuYnJlYWR0aCA+IDEgPyBncm91cFNpemUgLyAoZ3JvdXAuYnJlYWR0aCAtIDEpIDogMDtcclxuICAgICAgICAgICAgZ3JvdXAubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIG5vZGUueCA9IGN1clhQb3NpdGlvbiArIG5vZGUueCAqIGt4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VyWFBvc2l0aW9uICs9IGdyb3VwU2l6ZSArIHN0ZXBbMF0gKyBub2RlV2lkdGg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3VwV2lkdGggKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZ3JvdXAuYnJlYWR0aCAtIDEpICogKHN0ZXBbMF0gKyBub2RlV2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0IChub2Rlc0J5QnJlYWR0aCkge1xyXG4gICAgICAgIHZhciBtYXhDb2x1bW5IZWlnaHQgPSAwO1xyXG4gICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgIG1heENvbHVtbkhlaWdodCA9IE1hdGgubWF4KG1heENvbHVtbkhlaWdodCwgbm9kZXMubGVuZ3RoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzaXplWzFdID0gKG1heENvbHVtbkhlaWdodCkgKiBub2RlSGVpZ2h0ICsgKG1heENvbHVtbkhlaWdodCAtIDEpICogc3RlcFsxXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRocyAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBub2Rlc0J5QnJlYWR0aCA9IHV0aWxzLm5lc3QoKVxyXG4gICAgICAgICAgICAua2V5KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC54O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc29ydEtleXMoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVudHJpZXMobm9kZXMpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVIZWlnaHQobm9kZXNCeUJyZWFkdGgpO1xyXG5cclxuICAgICAgICBpbml0aWFsaXplTm9kZURlcHRoKCk7XHJcbiAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcclxuICAgICAgICBmb3IgKHZhciBhbHBoYSA9IDE7IGl0ZXJhdGlvbnMgPiAwOyAtLWl0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgcmVsYXhSaWdodFRvTGVmdChhbHBoYSAqPSAuOTkpO1xyXG4gICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xyXG4gICAgICAgICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcclxuICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcclxuICAgICAgICAgICAgaWYgKHNhdmVPcmRlcikgcmVzdG9yZU9yZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsb29yVG9Nb2R1bGUoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVEZXB0aCAoKSB7XHJcbiAgICAgICAgICAgIHZhciBreSA9IHV0aWxzLm1pbihub2Rlc0J5QnJlYWR0aCwgZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNpemVbMV0gLSAobm9kZXMubGVuZ3RoIC0gMSkgKiBub2RlSGVpZ2h0KSAvIHV0aWxzLnN1bShub2RlcywgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS55ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmR5ID0gbm9kZS52YWx1ZSAqIGt5O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgICAgICAgICAgbGluay5keSA9IGxpbmsudmFsdWUgKiBreTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWxheExlZnRUb1JpZ2h0IChhbHBoYSkge1xyXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnRhcmdldExpbmtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHV0aWxzLnN1bShub2RlLnRhcmdldExpbmtzLCB3ZWlnaHRlZFNvdXJjZSkgLyB1dGlscy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gd2VpZ2h0ZWRTb3VyY2UgKGxpbmspIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIobGluay5zb3VyY2UpICogbGluay52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVsYXhSaWdodFRvTGVmdCAoYWxwaGEpIHtcclxuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zb3VyY2VMaW5rcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSB1dGlscy5zdW0obm9kZS5zb3VyY2VMaW5rcywgd2VpZ2h0ZWRUYXJnZXQpIC8gdXRpbHMuc3VtKG5vZGUuc291cmNlTGlua3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS55ICs9ICh5IC0gY2VudGVyKG5vZGUpKSAqIGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHdlaWdodGVkVGFyZ2V0IChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyKGxpbmsudGFyZ2V0KSAqIGxpbmsudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZsb29yVG9Nb2R1bGUgKCkge1xyXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsU3RlcCA9IChzdGVwWzFdICsgbm9kZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSBub2RlLnkgLSBub2RlLnkgJSAoZnVsbFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwbGFjZU1hcFt5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IGZ1bGxTdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlTWFwW3ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlc3RvcmVPcmRlciAoKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVBID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUIgPSBub2Rlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVBLm9yZGVyIDwgbm9kZUIub3JkZXIgJiYgbm9kZUEueSA+IG5vZGVCLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wWSA9IG5vZGVBLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlQS55ID0gbm9kZUIueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVCLnkgPSB0ZW1wWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucyAoKSB7XHJcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBkeSxcclxuICAgICAgICAgICAgICAgICAgICB5MCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGRvd24uXHJcbiAgICAgICAgICAgICAgICBub2Rlcy5zb3J0KGFzY2VuZGluZ0RlcHRoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZHkgPSB5MCAtIG5vZGUueTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnkgKz0gZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBub2RlLnkgKyBub2RlLmR5ICsgbm9kZUhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYm90dG9tbW9zdCBub2RlIGdvZXMgb3V0c2lkZSB0aGUgYm91bmRzLCBwdXNoIGl0IGJhY2sgdXAuXHJcbiAgICAgICAgICAgICAgICBkeSA9IHkwIC0gbm9kZUhlaWdodCAtIHNpemVbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBub2RlLnkgLT0gZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGJhY2sgdXAuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBub2RlLnkgKyBub2RlLmR5ICsgbm9kZUhlaWdodCAtIHkwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnkgLT0gZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbm9kZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhc2NlbmRpbmdEZXB0aCAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS55IC0gYi55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTGlua0RlcHRocyAoKSB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLnNvcnQoYXNjZW5kaW5nVGFyZ2V0RGVwdGgpO1xyXG4gICAgICAgICAgICBub2RlLnRhcmdldExpbmtzLnNvcnQoYXNjZW5kaW5nU291cmNlRGVwdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5ID0gMCxcclxuICAgICAgICAgICAgICAgIHR5ID0gMDtcclxuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnN5ID0gc3k7XHJcbiAgICAgICAgICAgICAgICBzeSArPSBsaW5rLmR5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5rLnR5ID0gdHk7XHJcbiAgICAgICAgICAgICAgICB0eSArPSBsaW5rLmR5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nU291cmNlRGVwdGggKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc291cmNlLnkgLSBiLnNvdXJjZS55O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nVGFyZ2V0RGVwdGggKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudGFyZ2V0LnkgLSBiLnRhcmdldC55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjZW50ZXIgKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5keSAvIDI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWUgKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gbGluay52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2Fua2V5O1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNhbmtleTsiLCJpbXBvcnQgVFFHcmFtVUkgZnJvbSAndmlzdWFsaXphdGlvbnMtbGlicmFyeSc7XHJcbmltcG9ydCAqIGFzIGpvaW50IGZyb20gJ3JhcHBpZCc7XHJcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuL2xheW91dC9sYXlvdXQnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4vam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzJztcclxuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgTGluZWFnZURpYWdyYW0gZnJvbSAnLi9qb2ludFZpZXdzL2xpbmVhZ2VEaWFncmFtJztcclxuaW1wb3J0IERlcml2YXRpb25NYXAgZnJvbSAnLi9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcCc7XHJcbmltcG9ydCBHcmFwaE1hcCBmcm9tICcuL3NpZ21hVmlld3MvZ3JhcGhNYXAnO1xyXG5pbXBvcnQgQmlyZEV5ZSBmcm9tICcuL3NpZ21hVmlld3MvYmlyZEV5ZSc7XHJcbmltcG9ydCBEYXRhQ29udGFpbmVyIGZyb20gJy4vZGF0YS9kYXRhQ29udGFpbmVyJztcclxuaW1wb3J0IFN0YXRlU3RvcmFnZSBmcm9tICcuL3N0YXRlU3RvcmFnZSc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZSc7XHJcbmltcG9ydCB7XHJcbiAgICBERUZBVUxUX0xJTktfU1RZTEUsXHJcbiAgICBGRUVEX1BJUEVfTElOS19TVFlMRSxcclxuICAgIERFRkFVTFRfR1JPVVBfTElOS19TVFlMRSxcclxufSBmcm9tICcuL2RhdGEvcmVzb3VyY2VQcm92aWRlcic7XHJcbmltcG9ydCB7XHJcbiAgICBjcmVhdGVKb2ludE5vZGVzLFxyXG4gICAgY3JlYXRlSm9pbnRMaW5rcyxcclxuICAgIGdldEJhc2VFbGVtZW50LFxyXG4gICAgY2hlY2tMZ1Jhd0RhdGEsXHJcbiAgICBkZWZlbml0aW9uVG9QdWJsaWNNb2RlbCxcclxufSBmcm9tICcuL3V0aWxzL2RhdGFVdGlscyc7XHJcbmltcG9ydCB7IHByb2Nlc3NEYXRhLCBjcmVhdGVBc3BlY3RSZWxhdGlvbnMgfSBmcm9tICcuL2RhdGEvZGF0YVByb2Nlc3NpbmcnO1xyXG5pbXBvcnQgeyBnZXREZWZhdWx0UGFyYW1ldGVyc1NldCBhcyBnZXREZXJpdmF0aW9uTWFwUGFyYW1ldGVyU2V0IH0gZnJvbSAnLi9qb2ludFZpZXdzL2Rlcml2YXRpb25NYXAvZGVyaXZhdGlvbk1hcCc7XHJcblxyXG4vKipcclxuICogQ2xhc3Mgd2hpY2ggcHJvdmlkZXMgZGF0YSBmb3IgdGhlIExpbmVhZ2VHcmFtLlxyXG4gKiBAaW50ZXJmYWNlIERhdGFQcm92aWRlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBub2RlcyBhbmQgbGluayBtb2RlbHMgZm9yIHRoZSBncmFwaC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBuYW1lIERhdGFQcm92aWRlciNmZXRjaERhdGFcclxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5vZGVJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lYWdlR3JhbVZpZXdDbGFzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlhZ3JhbVR5cGVcclxuICAgQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTZXJ2ZXJEYXRhPn0gUHJvbWlzZSB3aGljaCBwcm92aWRlcyBncmFwaCBkYXRhLlxyXG4gKi9cclxuXHJcbiAvKipcclxuICogVGhlIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgbm9kZXMgYW5kIGxpbmsgbW9kZWxzIGZvciB0aGUgZ3JhcGguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbmFtZSBEYXRhUHJvdmlkZXIjZ2V0Vmlld0ZyYW1lc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VcclxuICogQHJldHVybnMge1Byb21pc2U8Vmlld0ZyYW1lRGVmaW5pdGlvbltdPn0gUHJvbWlzZSB3aGljaCBwcm92aWRlcyBncmFwaCBkYXRhLlxyXG4gKi9cclxuXHJcbiAvKipcclxuICogVGhlIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgbm9kZXMgYW5kIGxpbmsgbW9kZWxzIGZvciB0aGUgZ3JhcGguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAbmFtZSBEYXRhUHJvdmlkZXIjZ2V0Vmlld0NsYXNzRm9yUmVzb3VyY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtkYXRhUHJvdmlkZXI6IHN0cmluZ30+fSBQcm9taXNlIHdoaWNoIHByb3ZpZGVzIGdyYXBoIGRhdGEuXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBub2RlcyBhbmQgbGluayBtb2RlbHMgZm9yIHRoZSBncmFwaC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBuYW1lIERhdGFQcm92aWRlciNyZWxhdGlvbkluZm9cclxuICogQHBhcmFtIHtMaW5rfSByZWxhdGlvblxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxEZXJpdmF0aW9uTWFwRGF0YT59IFByb21pc2Ugd2hpY2ggcHJvdmlkZXMgZ3JhcGggZGF0YS5cclxuICovXHJcblxyXG4gLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBub2RlIG1vZGVsIHdoaWNoIGlzIGV4dGVuZGVkIGJ5IGRpYWdyYW1UeXBlIGZpZWxkXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1YmxpY05vZGVNb2RlbFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNvdXJjZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb3VyY2VUeXBlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaWFncmFtVHlwZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZUlkXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aWV3RnJhbWVcclxuICogQHByb3BlcnR5IHthbnl9IGRhdGFcclxuKi9cclxuXHJcbiAvKipcclxuICogUmVwcmVzZW50cyBhIGxpbmsgbW9kZWwgd2hpY2ggaXMgZXh0ZW5kZWQgYnkgZGlhZ3JhbVR5cGUgZmllbGRcclxuICogQHR5cGVkZWYge09iamVjdH0gUHVibGljTGlua01vZGVsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRpYWdyYW1UeXBlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5rVHlwZVxyXG4gKiBAcHJvcGVydHkge2FueX0gZGF0YVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBkYXRhUHJvdmlkZXIgcmVzcG9uc2Ugd2hpY2ggaW5jbHVkZXNcclxuICogbGlua3MgYW5kIG5vZGVzIGZvciB0aGUgTGluZWFnZUdyYW1cclxuICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyRGF0YVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGlhZ3JhbVR5cGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvY3VzTm9kZSAtIElSSSBvZiBmb2N1c05vZGVcclxuICogQHByb3BlcnR5IHtMaW5rTW9kZWxbXX0gbGlua3MgLSBMaW5rIG1vZGVsc1xyXG4gKiBAcHJvcGVydHkge05vZGVNb2RlbFtdfSBub2RlcyAtIE5vZGUgbW9kZWxzXHJcbiovXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHN0YXRlXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEhpc3RvcnlTdGF0ZVxyXG4gKiBAcHJvcGVydHkge0xpbmtbXX0gbGlua3MgLSBMaW5rc1xyXG4gKiBAcHJvcGVydHkge05vZGVbXX0gbm9kZXMgLSBOb2Rlc1xyXG4gKiBAcHJvcGVydHkge1ZpZXdGcmFtZURlZmluaXRpb25bXX0gdmlld0ZyYW1lc1xyXG4gKiBAcHJvcGVydHkge05vZGV9IGZvY3VzTm9kZSAtIEZvY3VzIG5vZGUgZm9yIHRoZSBzdGF0ZVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFNpemVcclxuICogQHR5cGVkZWYge09iamVjdH0gU2l6ZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0XHJcbiovXHJcblxyXG4vKipcclxuICogUG9pbnRcclxuICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBYXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gWVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFZpZXcgZnJhbWUgZGVmaW5pdGlvbixcclxuICogQHR5cGVkZWYge09iamVjdH0gVmlld0ZyYW1lRGVmaW5pdGlvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgLSBWaWV3IGZyYW1lIGlkZW50aWZ5ZXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsIC0gVGl0bGUgb2YgdGhlIHZpZXcgZnJhbWUsXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBib3JkZXJDb2xvciAtIENvbG9yIG9mIHRoZSBib3JkZXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIENvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzcGFjZVNoYXJlIC0gSG93IG11Y2ggdGhlIHZpZXcgZnJhbWUgd2lsbCB0YWtlXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGFwc2VkIC0gRGVmaW5lIGRlZmF1bHQgc3RhdGVcclxuICogZnJvbSB3aG9sZSBzcGFjZSBvZiB0aGUgZ3JhcGggKFlvdSBjYW4gdGFrZSBpdCBhcyBwZXJzZW50cyBvciBmbGV4IGdyb3cpXHJcbiovXHJcblxyXG4vKipcclxuICogTGluayB0b29sIGJ1dHRvbiBkZWZpbml0aW9uXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IExpbmtUb29sQnV0dG9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbWFnZSAtIHBhdGggdG8gaW1hZ2VcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBMaW5rIHN0eWxlIGRlZmluaXRpb25cclxuICogQHR5cGVkZWYge09iamVjdH0gTGlua1N0eWxlRGVmaW5pdGlvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3NzQ2xhc3MgLSBDU1MgY2xhc3Mgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgc3ZnIGNvbXBvbmVudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZVR5cGUgLSAnc29saWQnIG9yICdkYXNoZWQnXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvciAtIENvbG9yIG9mIHRoZSBsaW5lXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGlja25lc3NcclxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNBcnJvdyAtIFRlbGxzIHVzIHdoZXRoZXIgbGluZSBoYXMgYSB0ZXJtaW5hdGlvbiBhcnJvdyBvciBub3RcclxuICogQHByb3BlcnR5IHtMaW5rVG9vbEJ1dHRvbn0gdG9vbEJ1dHRvblxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFNpemUgb2YgdGhlIG5vZGVzIG9mIHRoZSBncmFwaCAobWF4aW11bSwgbWluaW11bSwgZGVmYXVsdClcclxuICogQHR5cGVkZWYge09iamVjdH0gRWxlbWVudFNpemVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gRGVmYXVsdCB3aWR0aCBvZiB0aGUgbm9kZXNcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIERlZmF1bHQgaGVpZ2h0IG9mIHRoZSBub2Rlc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluV2lkdGggLSBNaW5pbXVtIHdpZHRoIG9mIHRoZSBub2Rlc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4V2lkdGggLSBNYXhpbXVtIHdpZHRoIG9mIHRoZSBub2Rlc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluSGVpZ2h0IC0gTWluaW11bSBoZWlnaHQgb2YgdGhlIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhIZWlnaHQgLSBNYXhpbXVtIGhlaWdodCBvZiB0aGUgbm9kZXNcclxuKi9cclxuXHJcbi8qKlxyXG4gKiBTY2FsZSBib3VuZHMuXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjYWxlQm91bmRzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEluIGZhY3QgdGhlIG9iamVjdCBpcyBhIG1hcCBiZXR3ZWVuIGNvbG9ycyBhbmQga2V5cyAoaWRzKSBvZiBlbGVtZW50cyxcclxuICogYnV0IHRoZXJlIGFyZSBudW1iZXIgb2YgZGVmYXVsdCBjb2xvciBrZXlzLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IENvbG9yc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGVybWluYXRpb25UZXh0IC0gQ29sb3Igb2YgdGhlIHRleHQgb24gdGVybWluYXRpb24gbm9kZXNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHQgLSBDb2xvciBvZiB0aGUgdGV4dCBvbiB0aGUgZ3JhcGgncyBub2RlcyxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVua25vd24gLSBDb2xvciBmb3Igbm9kZXMgd2hvc2UgaWQgaXMgdW5rbm93blxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVmYXVsdCAtIERlZmF1bHQgY29sb3IgZm9yIG5vZGVzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RlZCAtIENvbG9yIG9mIGVsZW1lbnRzIHdoaWNoIGFyZSBzZWxlY3RlZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmx1cmVkIC0gQ29sb3IgZm9yIGJsdXJlZCBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluayAtIENvbG9yIGZvciBsaW5rc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGVybWluYXRpb25MaW5rIC0gQ29sb3IgZm9yIHRlcm1pbmF0aW9uIGxpbmtzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhc3BlY3RMaW5rIC0gQ29sb3IgZm9yIGFzcGVjdCBsaW5rc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRvb2wgYnV0dG9uLlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMaW5rVG9vbEJ1dHRvblxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW1hZ2UgLSBzcmMgb3IgeGhyZWYgZm9yIHRvb2wgYnV0dG9uXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIGJ1dHRvbiB3aWR0aFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaGVpZ2h0IC0gYnV0dG9uIGhlaWdodFxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgcGFyYW1ldGVycyBzZXQgZm9yIExpbmVhZ2VHcmFtLiBZb3UgY2FuIHBhc3MgYW55IG9mIHRoZXNlIHBhcmFtZXRlcnMgaW50byB0aGUgY29uc3RydWN0b3IgZHVyaW5nIHRoZSBMaW5lYWdlR3JhbSBpbml0aWFsaXphdGlvbi5cclxuICogQHR5cGVkZWYge09iamVjdH0gUGFyYW1ldGVyc1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gZ3JhcGhQbGFjZSAtIElkZW50aWZpZXIgb2YgdGhlIHJvb3QgaHRtbCBlbGVtZW50IGZvciBiaW5kaW5nIGdyYXBoIG9yIGp1c3Qgcm9vdCBIVE1MRWxlbWVudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gbWFwUm9vdEh0bWwgLSBJZGVudGlmaWVyIG9mIHRoZSByb290IGh0bWwgZWxlbWVudCBmb3IgYmluZGluZyBtYXAgb3IganVzdCByb290IGh0bWwgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge0RhdGFQcm92aWRlcn0gZGF0YVByb3ZpZGVyIC0gRnVuY3Rpb24gdGhhdCByZXNpZXZlcyBhbmQgcmV0dXJucyBkYXRhIGZvciB0aGUgZ3JhcGhcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvY3VzTm9kZSAtIEZvY3VzIG5vZGUgaWRcclxuICpcclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gbGF1bmNoRXh0ZXJuYWwgLSBJdCBjYW4gYmUgY2FsbGVkIGluIG9yZGVyIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHNvbWUgZWxlbWVudCBpbiBkZXJpdmF0aW9uIG1hcCBhbmQgaW4gbWFpbiBjbGFzcy5cclxuICpcclxuICogQHByb3BlcnR5IHtFbGVtZW50U2l6ZX0gZWxlbWVudFNpemUgLSBTaXplIG9mIHRoZSBub2RlcyBvZiB0aGUgZ3JhcGhcclxuICogQHByb3BlcnR5IHtFbGVtZW50U2l6ZX0gb3ZlclZpZXdFbGVtZW50U2l6ZSAtIFNpemUgb2YgdGhlIG5vZGVzIG9mIHRoZSBncmFwaCBpbiBPdmVyVmlld0ZyYW1lXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXlvdXRTdGVwIC0gRGlzdGFuY2UgYmV0d2VlbiBlbGVtZW50cyBvZiB0aGUgZ3JhcGhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxheW91dEl0ZXJhdGlvbnMgLSBIb3cgbXVjaCBpdGVyYXRpb25zIHdpbGwgYmUgZG9uZSBkdXJpbmcgdGhlIGxheW91dCBhbGdvcml0aG1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldEJldHdlZW5Hcm91cHMgLSBBZGRpdGlvbmFsIG9mZnNldCBiZXR3ZWVuIGdyb3VwcyBvZiBub2RlcyAodmlld0ZyYW1lIGdyb3VwcylcclxuICpcclxuICogQHByb3BlcnR5IHtDb2xvcnN9IGNvbG9ycyAtIENvbG9yIG1hcFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuaW1hdGlvbiAtIElmIGl0J3MgdHJ1ZSwgdGhlIGFuaW1hdGlvbiBpcyBhbGxvd2VkLiBCeSBkZWZhdWx0IC0gdHJ1ZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4RnJhbWVSYXRlIC0gTWF4aW11bSBzcGVlZCBvZiBhbmltYXRpb24uIEJ5IGRlZmF1bCAtIDUwIGZyYW1lcyBwZXIgc2Vjb25kXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5GcmFtZVJhdGUgLSBNaW5pbXVtIHNwZWVkIG9mIGFuaW1hdGlvbi4gQnkgZGVmYXVsIC0gMTAgZnJhbWVzIHBlciBzZWNvbmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFuaW1hdGlvblN0ZXAgLSBIb3cgZmFyIHZpZXdGcmFtZSBwb3NpdGlvbiBpcyBjaGFuZ2luZyBwZXIgYW5pbWF0aW9uIGZyYW1lXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Vmlld0ZyYW1lRGVmaW5pdGlvbltdfSAtIFZpZXcgZnJhbWVzIGRlZmluaXRpb25cclxuICogQHByb3BlcnR5IHtib29sZWFufSBmdWxsU2NyZWVuTW9kZSAtIERlZmluZXMgd2hldGhlciB3ZSB3YW50IHRvIG9wZW4gTEcgaW4gZnVsbC1zY3JlZW4tbW9kZSBvciBpbiB0aGUgcmVndWxhciBtb2RlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IGltYWdlcyAtIE1hcCBiZXR3ZWVuIG5vZGUgdHlwZXMgYW5kIGltYWdlIHVybHMuXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59IGljb25zIC0gTWFwIGJldHdlZW4gbm9kZSB0eXBlcyBhbmQgaWNvbnMgKGNzcykuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNvdXJjZVBhdGggLSBQcmVmaXggZm9yIHJlc291cmNlcyBsaWtlIGltYWdlcyAob3B0aW9uYWwpXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlUE9TVEV4ZWN1dG9yIC0gdG8gbWFrZSBhYmxlIHVzZSBwb3N0IHJlcXVlc3RzIGZvciBzcGFycWxQcm92aWRlclxyXG4gKiBAcHJvcGVydHkge1BvaW50fSBmcmFtZVBhZGRpbmcgLSBWaWV3UG9ydHMgZW5hYmxlZCBhcmVhIGV4cGFuZGVkIGJ5IHRoaXMgdmFsdWVcclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBjbGlwTm9kZXMgLSBUZWxscyB1cyBkbyBvciBub3QgY2xpcHBpbmcgbm9kZXMgYnkgdmlld0ZyYW1lc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZnJhbWVCb3JkZXJXaWR0aCAtIFdpZHRoIG9mIHRoZSBmcmFtZSBib3JkZXJcclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG93Q29sbGFwc2VkRnJhbWVzIC0gVGVsbHMgd2hldGhlciBoaWRlIG9yIHNob3cgY29sbGFwc2VkIHZpZXdGcm1hZXMgaW4gdGhlIGJvdHRvbSBvZiB0aGUgZ3JhcGguXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IGRlZmF1bHRTY2FsZVxyXG4gKiBAcHJvcGVydHkge1NjYWxlQm91bmRzfSBzY2FsZUJvdW5kcyAtIENvbnRhaW5zIG1pbmltYWwobWluKSBhbmQgbWF4aW11bShtYXgpIHZhbHVlcyBvZiB0aGUgc2NhbGUuXHJcbiAqIEBwcm9wZXJ0eSB7U2NhbGVCb3VuZHN9IG92ZXJWaWV3U2NhbGVCb3VuZHMgLSBDb250YWlucyBtaW5pbWFsKG1pbikgYW5kIG1heGltdW0obWF4KSB2YWx1ZXMgb2YgdGhlIHNjYWxlIGZvciBPdmVyVmlld0ZyYW1lLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NhbGVTdGVwIC0gSG93IG11Y2ggc2NhbGUgY2hhbmdlcyBwZXIgc3RlcC5cclxuICpcclxuICogQHByb3BlcnR5IHtTaXplfSB0ZXJtaW5hdGlvbk5vZGVTaXplIC0gU2l6ZSBvZiB0aGUgdGVybWluYXRpb24gbm9kZXNcclxuICogQHByb3BlcnR5IHtTaXplfSBkYXRhWm9uZVNpemUgLSBTaXplIG9mIHpvbmVzIGluIGRhdGEgY29udGFpbmVyLiBab25lcyBhcmUgZ3JvdXBpbmcgYW5kIHNvcnRpbmcgaW4gc3BlY2lhbCBhcmVhcyB0byBpbXBsZW1lbnQgYmluYXJ5IHNlYXJjaGluZ1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9uZXNJbkdyb3VwIC0gR3JvdXBpbmcgZGF0YSB6b25lcyBpbiBiaWdnZXIgZ3JvdXBzIGJ5IGdyb3VwcyBvZiAoZm9yIGV4YW1wbGUpIGZvdXJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmtSb3V0aW5nIC0gTGlua3Mgcm91dGluZyAoYmFzZWQgb24gam9pbnRqcyByb3V0aW5nczogbWV0cm8vbm9ybWFsL21hbmhhdHRhbi9vcnRob2dvbmFsKVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBMaW5rU3R5bGVEZWZpbml0aW9uPn0gbGlua1N0eWxlcyAtIE1hcCBiZXR3ZWVuIHRoZSBsaW5rVHlwZXMgYW5kIExpbmtTdHlsZXMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBncmFwaE9yaWVudGF0aW9uIC0gT3JpZW50YXRpb24gb2YgdGhlIGdyYXBoLiBDYW4gYmU6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gKiBAcHJvcGVydHkge0Rlcml2YXRpb25NYXBQYXJhbWV0ZXJzfSBkZXJpdmF0aW9uTWFwIC0gcGFyYW1ldGVycyBzZXQgZm9yIERlcml2YXRpb25NYXBcclxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59IG1hc2sgLSBtYXAgb2YgZWxlbWVudHMuIEVsZW1lbnRzIGluIHRoZSBtYXNrIHdpbGwgYmUgaGlkZGVuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yQ2FsbEJhY2sgLSBpdCBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gd2FybmluZ3MgYW5kIGVycm9yc1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZGVmYXVsdCBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiBAcmV0dXJucyB7UGFyYW1ldGVyc31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UGFyYW1ldGVyc1NldCAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgZ3JhcGhQbGFjZTogdW5kZWZpbmVkLCAvLyBJZGVudGlmaWVyIG9mIHRoZSByb290IGh0bWwgZWxlbWVudCBmb3IgYmluZGluZyBncmFwaFxyXG4gICAgICAgIG1hcFJvb3RIdG1sOiB1bmRlZmluZWQsICAgICAvLyBJZGVudGlmaWVyIG9mIHRoZSByb290IGh0bWwgZWxlbWVudCBmb3IgYmluZGluZyBtYXAgb3IganVzdCByb290IEhUTUxFbGVtZW50XHJcbiAgICAgICAgZGF0YVByb3ZpZGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZm9jdXNOb2RlOiB1bmRlZmluZWQsXHJcblxyXG4gICAgICAgIC8vIEVsZW1lbnRzXHJcbiAgICAgICAgZWxlbWVudFNpemU6IHsgd2lkdGg6IDEyMCwgaGVpZ2h0OiAxMjAsIG1pbldpZHRoOiA0NSwgbWF4V2lkdGg6IDU1MCwgbWluSGVpZ2h0OiA0NSwgbWF4SGVpZ2h0OiA1NTAgfSwgLy8gZGVmYXVsdCBlbGVtZW50IHNpemVcclxuICAgICAgICBvdmVyVmlld0VsZW1lbnRTaXplOiB7IHdpZHRoOiAxMjAsIGhlaWdodDogMTIwLCBtaW5XaWR0aDogNSwgbWF4V2lkdGg6IDU1MCwgbWluSGVpZ2h0OiA1LCBtYXhIZWlnaHQ6IDU1MCB9LCAvLyBkZWZhdWx0IGVsZW1lbnQgc2l6ZSBmb3IgdGhlIE92ZXJWaWV3RnJhbWVcclxuXHJcbiAgICAgICAgLy8gTGF5b3V0XHJcbiAgICAgICAgbGF5b3V0U3RlcDogeyB4OiAyMDAsIHk6IDEwMCB9LCAvLyBEaXN0YW5jZSBiZXR3ZWVuIGVsZW1lbnRzIG9mIHRoZSBncmFwaFxyXG4gICAgICAgIGxheW91dEl0ZXJhdGlvbnM6IDMyLCAvLyBIb3cgbXVjaCBpdGVyYXRpb25zIHdpbGwgaGF2ZSBiZWVuIGRvbmUgZHVyaW5nIHRoZSBsYXlvdXQgYWxnb3JpdGhtXHJcbiAgICAgICAgb2Zmc2V0QmV0d2Vlbkdyb3VwczogMTUwLCAvLyBBZGRpdGlvbmFsIG9mZnNldCBiZXR3ZWVuIGdyb3VwcyBvZiBub2RlcyAodmlld0ZyYW1lIGdyb3VwcylcclxuXHJcbiAgICAgICAgLy8gQ29sb3Igc2NoZW1lXHJcbiAgICAgICAgY29sb3JzOiB7IC8vIGNvbG9yIG1hcFxyXG4gICAgICAgICAgICAnZWRnOkRhdGFiYXNlQ29sdW1uJzogJyMyM2IwZjQnLFxyXG4gICAgICAgICAgICAnZWRnOlNvZnR3YXJlUHJvZ3JhbSc6ICdncmVlbicsXHJcbiAgICAgICAgICAgICdodHRwOi8vZWRnLnRvcGJyYWlkLnNvbHV0aW9ucy9tb2RlbC9Tb2Z0d2FyZVByb2dyYW0nOiAnZ3JlZW4nLFxyXG4gICAgICAgICAgICAnaHR0cDovL2VkZy50b3BicmFpZC5zb2x1dGlvbnMvbW9kZWwvUmVwb3J0JzogJyMyM2IwZjQnLFxyXG4gICAgICAgICAgICAnaHR0cDovL2VkZy50b3BicmFpZC5zb2x1dGlvbnMvbW9kZWwvUmVwb3J0Q29sdW1uJzogJyNmZjc0MTAnLFxyXG5cclxuICAgICAgICAgICAgJ3Rlcm1pbmF0aW9uVGV4dCc6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICd0ZXh0JzogJ2JsYWNrJyxcclxuICAgICAgICAgICAgJ3Vua25vd24nOiAnYmxhY2snLFxyXG4gICAgICAgICAgICAnZGVmYXVsdCc6ICdibGFjaycsXHJcbiAgICAgICAgICAgICdzZWxlY3RlZCc6ICdyZWQnLFxyXG4gICAgICAgICAgICAnYmx1cmVkJzogJ3JnYmEoMTAwLCAxMDAsIDEwMCwgMC4zKScsXHJcbiAgICAgICAgICAgICd0ZXJtaW5hdGlvbkxpbmsnOiAnIzkwOTRhOCcsXHJcbiAgICAgICAgICAgICdhc3BlY3RMaW5rJzogJ3JnYmEoMCwgMjU1LCAwLCAwLjUpJyxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBBbmltYXRpb25cclxuICAgICAgICBhbmltYXRpb246IHRydWUsIC8vIHN3aXRoYyBvZmYvb24gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgIG1heEZyYW1lUmF0ZTogNTAsXHJcbiAgICAgICAgbWluRnJhbWVSYXRlOiAxMCxcclxuICAgICAgICBhbmltYXRpb25TdGVwOiA2MCxcclxuXHJcbiAgICAgICAgLy8gVmlldyBmcmFtZXMgZGVmaW5pdGlvblxyXG4gICAgICAgIGZ1bGxTY3JlZW5Nb2RlOiB0cnVlLCAvLyBEZWZpbmVzIHdoZXRoZXIgd2Ugd2FudCB0byBvcGVuIExHIGluIGZ1bGwtc2NyZWVuLW1vZGUgb3IgaW4gdGhlIHJlZ3VsYXIgbW9kZVxyXG4gICAgICAgIHZpZXdGcmFtZXM6IFtcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgaWQ6ICdmdWxsUGFuZWwnLCAvLyBpZGVudGlmaWVyIG9mIHRoZSBmcmFtZSBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICAgICAgICAvLyAgICAgbGFiZWw6ICdBbGwnLCAgIC8vIGxhYmVsIGluIHRoZSByaWdodC10b3AgY29ybmVyXHJcbiAgICAgICAgICAgIC8vICAgICBib3JkZXJDb2xvcjogJyMyM2IwZjQnLFxyXG4gICAgICAgICAgICAvLyAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Y0ZjRmZicsXHJcbiAgICAgICAgICAgIC8vICAgICAvLyBJdCB0ZWxscyBob3cgbXVjaCBzcGFjZSB3aWxsIHRha2VzIHRoaXMgZnJhbWUgb24gdGhlIHBhcGVyLlxyXG4gICAgICAgICAgICAvLyAgICAgLy8gfFsxXVsgMiBdWyAgMyAgIF18IG9yXHJcbiAgICAgICAgICAgIC8vICAgICAvLyB8WyAgNTAgIF1bICA1MCAgXXwgb3JcclxuICAgICAgICAgICAgLy8gICAgIC8vIHxbMTBdWzEwXVsxMF1bMTBdfFxyXG4gICAgICAgICAgICAvLyAgICAgc3BhY2VTaGFyZTogMSxcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIF0sXHJcblxyXG4gICAgICAgIC8vIEltYWdlcyBmb3IgdHlwZXNcclxuICAgICAgICBpbWFnZXM6IHsgICAvLyBtYXAgb2YgaW1hZ2VzIGZvciB0eXBlcyBvZiBlbGVtZW50c1xyXG4gICAgICAgICAgICAnZWRnOkRhdGFiYXNlQ29sdW1uJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL3RhYmxlLnBuZycsXHJcbiAgICAgICAgICAgICdlZGc6VGFibGUnOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvdGFibGUucG5nJyxcclxuICAgICAgICAgICAgJ2VkZzpTb2Z0d2FyZVByb2dyYW0nOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvYXBwLnBuZycsXHJcbiAgICAgICAgICAgICdodHRwOi8vZWRnLnRvcGJyYWlkLnNvbHV0aW9ucy9tb2RlbC9Tb2Z0d2FyZVByb2dyYW0nOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvYXBwLnBuZycsXHJcbiAgICAgICAgICAgICdlZGc6TGluZWFnZU1vZGVsJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2Zvcm0ucG5nJyxcclxuICAgICAgICAgICAgJ2VkZzpTY2hlZHVsZSc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9jb2x1bW4ucG5nJyxcclxuICAgICAgICAgICAgLy8gJ2xpbmstb3B0aW9ucyc6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy9kZXJpdmF0aW9uLW1hcC5wbmcnLFxyXG4gICAgICAgICAgICAvLyAnZmVlZC1waXBlJzogJ3NyYy9yZXNvdXJjZXMvaW1hZ2VzL2ZlZWQtcGlwZS5wbmcnLFxyXG4gICAgICAgICAgICAndW5rbm93bic6ICdzcmMvcmVzb3VyY2VzL2ltYWdlcy91bmtub3duLnBuZycsIC8vIEl0IHdpbGwgd29yayBvbmx5IGZvciB1bmtub3duIHR5cGVzXHJcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHlvdSB3YW50IGNoYW5nZSBpdCBmb3IgbG9zdCBpbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlvdSBzaG91bGQgY2hhbmdlIGl0IGluIHRoZSBib3R0b20gb2YgJy4vam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzLmpzJ1xyXG5cclxuICAgICAgICByZXNvdXJjZVBhdGg6ICcnLCAvLyBwcmVmaXggZm9yIHJlc291cmNlcyBsaWtlIGltYWdlcyAob3B0aW9uYWwpXHJcbiAgICAgICAgbGF1bmNoRXh0ZXJuYWw6IG51bGwsIC8vb3B0aW9uYWxcclxuICAgICAgICB1c2VQT1NURXhlY3V0b3I6IGZhbHNlLCAvLyB0byBtYWtlIGFibGUgdXNlIHBvc3QgcmVxdWVzdHMgZm9yIHNwYXJxbFByb3ZpZGVyXHJcblxyXG4gICAgICAgIC8vIEJlIGNhcmVmdWwhIElmIHlvdSB3YW50IHRvIGNoYW5nZSBpdCwgeW91IHNob3VsZCByZW1lbWJlciBhYm91dCBjc3MgKC50cV9saW5lYWdlX3VpIGUudC5jLilcclxuICAgICAgICBmcmFtZVBhZGRpbmc6IHsgeDogNTUsIHk6IDU1IH0sIC8vIHZpZXdQb3J0cyBlbmFibGVkIGFyZWEgZXhwYW5kZWQgYnkgdGhpcyB2YWx1ZVxyXG5cclxuICAgICAgICBjbGlwTm9kZXM6IGZhbHNlLCAvLyB0ZWxscyB1cyBkbyBvciBub3QgY2xpcHBpbmcgbm9kZXMgYnkgdmlld0ZyYW1lcy5cclxuICAgICAgICBmcmFtZUJvcmRlcldpZHRoOiAzLCAvLyBzdHlsaW5nXHJcblxyXG4gICAgICAgIHNob3dDb2xsYXBzZWRGcmFtZXM6IGZhbHNlLFxyXG5cclxuICAgICAgICBkZWZhdWx0U2NhbGU6IHsgeDogMS4wLCB5OiAxLjAgfSwgLy8gSXQncyBuZWNlc3NhcnkgZm9yIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgIHNjYWxlQm91bmRzOiB7IG1pbjogMC43LCBtYXg6IDEuNSB9LFxyXG4gICAgICAgIG92ZXJWaWV3U2NhbGVCb3VuZHM6IHsgbWluOiAwLjAxLCBtYXg6IDIgfSwgLy8gc2NhbGUgYm91bmRzIGZvciBvdmVyVmlldyBmcmFtZVxyXG4gICAgICAgIHNjYWxlU3RlcDogMC4xLCAvLyBzdGVwIG9mIHNjYWxlIGNoYW5naW5nXHJcblxyXG4gICAgICAgIHRlcm1pbmF0aW9uTm9kZVNpemU6IHsgd2lkdGg6IDMwLCBoZWlnaHQ6IDMwIH0sIC8vIHNpemUgb2YgdGhlIHRlcm1pbmF0aW9uIG5vZGVzXHJcbiAgICAgICAgZGF0YVpvbmVTaXplOiB7IHdpZHRoOiA4MDAsIGhlaWdodDogNjAwIH0sICAgICAgLy8gc2l6ZSBvZiB6b25lcyBpbiBkYXRhIGNvbnRhaW5lci4gWm9uZXMgYXJlIGdyb3VwaW5nIGFuZCBzb3J0aW5nIGluIHNwZWNpYWwgYXJlYXMgdG8gaW1wbGVtZW50IGJpbmFyeSBzZWFyY2hpbmdcclxuICAgICAgICB6b25lc0luR3JvdXA6IDQsICAvLyBncm91cGluZyBkYXRhIHpvbmVzIGluIGJpZ2dlciBncm91cHMgYnkgZ3JvdXBzIG9mIChmb3IgZXhhbXBsZSkgZm91clxyXG4gICAgICAgIGxpbmtSb3V0aW5nOiAnbWV0cm8nLCAvLyBsaW5rcyByb3V0aW5nIChiYXNlZCBvbiBqb2ludGpzIHJvdXRpbmdzOiBtZXRyby9ub3JtYWwvbWFuaGF0dGFuL29ydGhvZ29uYWwpXHJcblxyXG4gICAgICAgIGxpbmtTdHlsZXM6IHtcclxuICAgICAgICAgICAgJ2RlZmF1bHQtbGluay1zdHlsZSc6IERFRkFVTFRfTElOS19TVFlMRSxcclxuICAgICAgICAgICAgJ2ZlZWRwaXBlJzogRkVFRF9QSVBFX0xJTktfU1RZTEUsXHJcbiAgICAgICAgICAgICd0cS1sZy1ncm91cCc6IERFRkFVTFRfR1JPVVBfTElOS19TVFlMRSxcclxuICAgICAgICAgICAgLy8gRXhhbXBsZTpcclxuICAgICAgICAgICAgLy8gJ2ZlZWRwaXBlJzoge1xyXG4gICAgICAgICAgICAvLyAgICAgY3NzQ2xhc3M6ICdsaW5lYWdlLWdyYW0tZmVlZC1waXBlLWxpbmsnLFxyXG4gICAgICAgICAgICAvLyAgICAgbGluZVR5cGU6ICdzb2xpZCcsIC8vICdkYXNoZWQnXHJcbiAgICAgICAgICAgIC8vICAgICBjb2xvcjogJyMzYzQyNjAnLFxyXG4gICAgICAgICAgICAvLyAgICAgdG9vbEJ1dHRvbjoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIGltYWdlOiAnc3JjL3Jlc291cmNlcy9pbWFnZXMvZmVlZC1waXBlLnBuZycsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgd2lkdGg6IDMwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIGhlaWdodDogMzAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgYWx3YXlzVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICB0aGlja25lc3M6IDMsXHJcbiAgICAgICAgICAgIC8vICAgICBoYXNBcnJvdzogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpYWdyYW1UeXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZ3JhcGhPcmllbnRhdGlvbjogJ2xlZnQtdG8tcmlnaHQnLCAvLyBDYW4gYmU6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICAgIGxheW91dEFsZ29yaXRobTogJ3NhbmtleScsIC8vIENhbiBiZTogJ3NhbmtleScsICdmbG93LWRpcmVjdGVkJ1xyXG4gICAgICAgIGRlcml2YXRpb25NYXA6IGdldERlcml2YXRpb25NYXBQYXJhbWV0ZXJTZXQoKSxcclxuICAgICAgICBtYXNrOiB1bmRlZmluZWQsIC8vIE1hcCBvZiBlbGVtZW50cy4gRWxlbWVudHMgaW4gdGhlIG1hc2sgd2lsbCBiZSBoaWRkZW5cclxuXHJcbiAgICAgICAgZXJyb3JDYWxsQmFjazogdW5kZWZpbmVkLCAvLyBJdCBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gd2FybmluZ3MgYW5kIGVycm9yc1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGNsYXNzIG9mIHRoZSBsaWJyYXJ5LCB0aGF0IG1hbmFnZSBhbGwgdmlld3MgYW5kIGRhdGEuXHJcbiAqIENyZWF0ZXMgdHdvIHZpZXcgb24gdGhlIGluaXRpYWxpemF0aW9uIHN0YWdlLiBUaGUgZmlyc3QgdmlldyBpcyBhIExpbmVhZ2UgZGlhZ3JhbSB2aWV3LlxyXG4gKiBUaGUgc2Vjb25kIHZpZXcgaXMgYSBCaXJkIEV5ZSB2aWV3LiBBbHNvIHRoZSBtYXAgY2FuIGJlIHBsYWNlZCBvbiB0aGUgcGFnZSBpZiB0aGUgbWFwUm9vdEh0bWxJZFxyXG4gKiB3YXMgc3BlY2lmaWVkIGluIHRoZSBwYXNzZWQgcGFyYW1ldGVycy5cclxuICogQGNsYXNzXHJcbiAqIEBhdWdtZW50cyBTdWJzY3JpYmFibGVcclxuICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyBzZXRcclxuICpcclxuICogQGZpcmVzIHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZFxyXG4gKiBAZmlyZXMgaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBmb2N1cy1ub2RlLWNoYW5nZWRcclxuICogQGZpcmVzIGN1cnJlbnQtdmlldy1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBzY2FsZS12YWx1ZS1jaGFuZ2VkXHJcbiAqIEBmaXJlcyBkaWFncmFtLXN0YXRlLWNoYW5nZWRcclxuICogQGZpcmVzIHZpZXctZnJhbWUtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgZGVyaXZhdGlvbi1tYXAtc3RhdGUtY2hhbmdlZFxyXG4gKiBAZmlyZXMgZGVyaXZhdGlvbi1tYXAtc3RhdGUtaW5pdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIExpbmVhZ2VHcmFtIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAvLyBFdmVudHNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVsZW1lbnQgc2VsZWN0ZWQgZXZlbnQgLSBmaXJlcyB3aGVuIG9iamVjdCBjaGFuZ2VzIGVsZW1lbnQgc2VsZWN0aW9uXHJcbiAgICAgKiBTZWxlY3RlZCBlbGVtZW50IGlzIHJldHVybmVkIGFzIGEgcGFyYW1ldGVyIG9mIHRoZSBldmVudC5cclxuICAgICAqIEBldmVudCBzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY05vZGVNb2RlbHxQdWJsaWNMaW5rTW9kZWx8dW5kZWZpbmVkfSBlbGVtZW50IC0gU2VsZWN0ZWRFbGVtZW50XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgZmlyZXMgd2hlbiBuZXcgZWxlbWVudCBpcyBzZWxlY3RlZCBhcyBmb2N1c05vZGUuXHJcbiAgICAgKiBAZXZlbnQgZm9jdXMtbm9kZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtQdWJsaWNOb2RlTW9kZWx9IGVsZW1lbnQgLSBGb2N1c05vZGUgbW9kZWxcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IHN3aXRjaGVkIGV2ZW50IC0gZmlyZXMgd2hlbiBjdXJyZW50IHZpZXcgaXMgY2hhbmdlZFxyXG4gICAgICogVmlldyBpZCBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBjdXJyZW50LXZpZXctY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aWV3SWQgLSBTZWxlY3RlZFZpZXcgY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICdsaW5lYWdlRGlhZ3JhbScsICdiaXJkRXllJyBvciAnbm9uZSdcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZSBjaGFuZ2VkIGV2ZW50IC0gZmlyZXMgd2hlbiBzY2FsZSB2YWx1ZSBvZiB0aGUgTGluZWFnZSBEaWFncmFtIHZpZXcgaXMgY2hhbmdlZC5cclxuICAgICAqIFtOZXcgc2NhbGUgdmFsdWVde0BsaW5rIFNjYWxlfSBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBzY2FsZS12YWx1ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtTY2FsZX0gc2NhbGUgLSBOZXcgc2NhbGUgb2JqZWN0LlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXRlIGNoYW5nZWQgZXZlbnQgLSBmaXJlcyB3aGVuIExpbmVhZ2VHcmFtIHN0YXRlIGlzIGNoYW5nZWQuXHJcbiAgICAgKiBFLmcuIGZyb20gYSBmZXRjaGluZyBzdGF0ZSB0byBhIHJlbmRlcmluZyBzdGF0ZS5cclxuICAgICAqIFRoZSBzdGF0ZSBzdHJpbmcgaWRlbnRpZmllciBpcyByZXR1cm5lZCBhcyBhIHBhcmFtZXRlciBvZiB0aGUgZXZlbnRcclxuICAgICAqIEBldmVudCBkaWFncmFtLXN0YXRlLWNoYW5nZWRcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBQYXJhbWV0ZXIgY2FuIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICdmZXRjaGluZycgfCAncmVuZGVyaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJ1xyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0IGZpcmVzIHdoZW4gdXNlciBpcyBuYXZpZ2F0aW5nIGFsb25nIHRoZSBoaXN0b3J5LlxyXG4gICAgICogQGV2ZW50IGhpc3Rvcnktc3RhdGUtY2hhbmdlZFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7SGlzdG9yeVN0YXRlW119IHN0YXRlcyAtIExpc3Qgb2Ygc3RhdGVzXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4IC0gb3JkZXIgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHN0YXRlIGluIHRoZSBsaXN0XHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlldyBmcmFtZSBzdGF0ZSBjaGFuZ2VkIC0gZmlyZXMgd2hlbiB0aGUgVmlldyBmcmFtZSBpcyBiZWluZyBjb2xsYXBzZWQgb3IgZXhwYW5kZWQuXHJcbiAgICAgKiBAZXZlbnQgdmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gaWQgb2YgdGhlIGNoYW5nZWQgVmlld0ZyYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSAtIGV4cGFuZGVkLCBmYWxzZSAtIGNvbGxhcHNlZFxyXG4gICAgKi9cclxuXHJcbiAgICAvLyBJbml0XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTdWJzY3JpYmFibGUuYXBwbHkodGhpcyk7ICAgLy8gbWFrZSB0aGlzIGNsYXNzIFN1YnNjcmliYWJsZVxyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzOyAvLyBTYXZlIHBvaW50ZXIgdG8gYSBjb250ZXh0XHJcblxyXG4gICAgbGV0IF9zdGF0ZSA9ICdpbml0aWFsJztcclxuICAgIGxldCBfc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgIGxldCBfZm9jdXNFbGVtZW50O1xyXG4gICAgbGV0IF9jdXJyZW50VmlldyA9ICdsaW5lYWdlRGlhZ3JhbSc7ICAgIC8vIFNldCB0aGUgbGluZWFnZURpYWdyYW0gdmlldyBhcyBhIGN1cnJlbnQgdmlld1xyXG5cclxuXHJcbiAgICBjb25zdCBkZWZhdWx0UGFyYW1ldGVyU2V0ID0gZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQoKTsgLy8gR2V0aW5nIGRlZmF1bHQgcGFyYW1ldGVycyBzZXRcclxuICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgc2V0IGluY2x1ZGVzIHZpZXdGcmFtZXMgZGVmaW5pdGlvbiwgY2xlYXIgdGhlIHZpZXdGcmFtZXMgZGVmaW5pdGlvbiBpbiB0aGUgZGVmYXVsdCBzZXQgZm9yIGEgY29ycmVjdCBtZXJnaW5nXHJcbiAgICAvLyAoV2UgZG9uJ3Qgd2FudCB0byBnZXQgZXh0cmEgdmlld0ZyYW1lcyBmcm9tIHRoZSBkZWZhdWx0IHNldC4pXHJcbiAgICBpZiAocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLnZpZXdGcmFtZXMgJiYgcGFyYW1ldGVycy52aWV3RnJhbWVzLmxlbmd0aCA+IDApIGRlZmF1bHRQYXJhbWV0ZXJTZXQudmlld0ZyYW1lcyA9IHVuZGVmaW5lZDtcclxuICAgIC8vIE1lcmdpbmcgZGVmYXVsdCBwYXJhbWV0ZXJzIHNldCBhbmQgY3VzdG9tZSBwYXJhbWV0ZXJzIHNldFxyXG4gICAgY29uc3QgX3BhcmFtZXRlcnMgPSAgXy5tZXJnZShkZWZhdWx0UGFyYW1ldGVyU2V0LCBwYXJhbWV0ZXJzKTtcclxuXHJcbiAgICBjb25zdCBfZXJyb3JDYWxsYmFjayA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBfcGFyYW1ldGVycy5lcnJvckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihlKSA6IGU7XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmVycm9yQ2FsbGJhY2suY2FsbCh0aGlzLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiB0aGUgZ3JhcGhQbGFjZSBpcyB1bmRlZmluZWQgd2Ugc3RvcCB0aGUgd29ya2luZyBwcm9jZXNzLlxyXG4gICAgaWYgKCFwYXJhbWV0ZXJzLmdyYXBoUGxhY2UpIHRocm93IG5ldyBFcnJvcignVGhlIGdyYXBoIHBsYWNlIGlzblxcJ3Qgc3BlY2lmaWVkJyk7XHJcbiAgICBsZXQgZ3JhcGhQbGFjZUh0bWw7XHJcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBncmFwaFBsYWNlSHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtZXRlcnMuZ3JhcGhQbGFjZSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzLmdyYXBoUGxhY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZ3JhcGhQbGFjZUh0bWwgPSBwYXJhbWV0ZXJzLmdyYXBoUGxhY2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdyYXBoIHBsYWNlIGlzblxcJ3Qgc3BlY2lmaWVkIG9yIHNwZWNpZGVkIGluY29ycmVjdGx5Jyk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGluZyBodG1sIG1hcmt1cC5cclxuICAgIGNvbnN0IF9iYXNlID0gX2NyZWF0ZUJhc2UoZ3JhcGhQbGFjZUh0bWwpO1xyXG4gICAgY29uc3QgX2RhdGFQcm92aWRlciA9IF9wYXJhbWV0ZXJzLmRhdGFQcm92aWRlcjtcclxuICAgIGNvbnN0IF9zdGF0ZVN0b3JhZ2UgPSBuZXcgU3RhdGVTdG9yYWdlKF9wYXJhbWV0ZXJzKTtcclxuICAgIGNvbnN0IF9wcm9ncmVzc1NjcmVlbiA9IG5ldyBUUUdyYW1VSS5Qcm9ncmVzc1NjcmVlbih7XHJcbiAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLmNvbnRhaW5lcixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lci5cclxuICAgIGxldCBfZGF0YUNvbnRhaW5lcjtcclxuXHJcbiAgICBsZXQgX2xpbmVhZ2VEaWFncmFtOyAvLyBMaW5lYWdlIGRpYWdyYW0gdmlld1xyXG4gICAgbGV0IF9iaXJkRXllOyAvLyBCaXJkRXllIGJpZXdcclxuICAgIGxldCBfZGVyaXZhdGlvbk1hcDtcclxuICAgIGxldCBfZ3JhcGhNYXA7IC8vIGRlZmluZSB2YXJpYWJsZVxyXG4gICAgbGV0IF9kZXJpdmF0aW9uTWFwUGFuZWw7XHJcblxyXG4gICAgbGV0IF9kaWFncmFtVHlwZSA9IF9wYXJhbWV0ZXJzLmRpYWdyYW1UeXBlO1xyXG5cclxuICAgIHNlbGYubGF1bmNoRXh0ZXJuYWwgPSBfcGFyYW1ldGVycy5sYXVuY2hFeHRlcm5hbDtcclxuXHJcbiAgICBfY3JlYXRlQ29tcG9uZW50cygpO1xyXG5cclxuICAgIF9mZXRjaERpYWdyYW0oe1xyXG4gICAgICAgIGZvY3VzTm9kZUlkOiBfcGFyYW1ldGVycy5mb2N1c05vZGUsXHJcbiAgICAgICAgdmlld0ZyYW1lczogX3BhcmFtZXRlcnMudmlld0ZyYW1lcyxcclxuICAgICAgICBsaW5lYWdlR3JhbVZpZXdDbGFzczogX3BhcmFtZXRlcnMubGluZWFnZUdyYW1WaWV3Q2xhc3MsXHJcbiAgICAgICAgZGlhZ3JhbVR5cGU6IF9kaWFncmFtVHlwZSxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY292ZXJzIG5vZGVzIHBvc2l0aW9ucyB0byB0aGUgaW5pdGlhbC5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlc2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlc2V0TGF5b3V0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gU2NhbGVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSB2YWx1ZVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCAtIFRoZSBtYXhpbXVtIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VyIC0gVGhlIGN1cnJlbnQgdmFsdWVcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgYnkgdGhlIHN0ZXAgKGRlZmF1bDogKyswLjEpLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbUluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS56b29tSW4oKTtcclxuICAgICAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZHJhdyh7IHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pbjogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWluLFxyXG4gICAgICAgICAgICBtYXg6IF9wYXJhbWV0ZXJzLnNjYWxlQm91bmRzLm1heCxcclxuICAgICAgICAgICAgY3VyOiBfc3RhdGUgPT09ICdjb21wbGV0ZWQnID8gX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCkgOiBfcGFyYW1ldGVycy5kZWZhdWx0U2NhbGUsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgdG8gYmUgYWJsZSB0byBmaXQgd2hvbGUgZGlhZ3JhbSBpbiB0aGUgc2NyZWVuLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbVRvRml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF96b29tVG9GaXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY3VycmVudCB2aWV3IGlkXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGN1cnJlbnRWaWV3SWQgLSdsaW5lYWdlRGlhZ3JhbScgfCAnYmlyZEV5ZScgfCAnbm9uZSdcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldEN1cnJlbnRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfY3VycmVudFZpZXc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBjdXJyZW50IHN0YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGF0ZSAtICdmZXRjaGluZycgfCAnYWN0aXZlJyB8ICdjb21wbGV0ZWQnIHwgJ2Vycm9yJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGF0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHNjYWxlIG9mIHRoZSBtYWluIHZpZXcgYnkgdGhlIHN0ZXAgKGRlZmF1bDogLS0wLjEpLlxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbU91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uem9vbU91dCgpO1xyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHsgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc2NhbGUgb2YgdGhlIG1haW4gTGluZWFnZSBEaWFncmFtIHZpZXcuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzY2FsZVxyXG4gICAgICogQHJldHVybnMge1NjYWxlfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuem9vbSA9IGZ1bmN0aW9uIHpvb20gKHNjYWxlKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgaWYgKHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uc2NhbGUoc2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZWRyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWF4LFxyXG4gICAgICAgICAgICBjdXI6IF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgPyBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSA6IF9wYXJhbWV0ZXJzLmRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCB3aGljaCBwYXNzZWQgaW50byB0aGUgZXhwb3J0IGZ1bmN0aW9uIGluIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFeHBvcnRQYXJhbXNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIGZpbGUgbmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSAocG5nL3N2ZylcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aWV3IC0gQmlyZEV5ZSAvIGxpbmVhZ2VHcmFtXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyB0aGUgZ3JhcGggaW4gYSBwbmcgb3Igc3ZnIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge0V4cG9ydFBhcmFtc30gb3B0aW9uc1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5leHBvcnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMudmlldyA9IG9wdGlvbnMudmlldyB8fCBfY3VycmVudFZpZXc7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0uZXhwb3J0KHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnZpZXcgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5leHBvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgcHJpbnQgZGlhbG9nLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5wcmludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5wcmludCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX2N1cnJlbnRWaWV3ID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgX2JpcmRFeWUucHJpbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhbGwgbm9kZXNcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZXhwYW5kQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2RlcztcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0KCdleHBhbmRlZCcsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2VzIGFsbCBub2Rlc1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAqL1xyXG4gICAgc2VsZi5jb2xsYXBzZUFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gX2RhdGFDb250YWluZXIubm9kZXM7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnNldCgnZXhwYW5kZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgbWFwLCB1c2luZyBodG1sIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgSUQgYXMgYSByb290IGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudH0gbWFwUm9vdEh0bWwgLSBJRCBvZiByb290IGVsZW1lbnQgb3IgSFRNTEVsZW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldFJvb3RIdG1sRm9yTWFwID0gZnVuY3Rpb24gKG1hcFJvb3RIdG1sKSB7XHJcbiAgICAgICAgY29uc3QgbWFwSFRNTEVsZW1lbnQgPSBfZ2V0TWFwSFRNTChtYXBSb290SHRtbCk7XHJcbiAgICAgICAgX3BhcmFtZXRlcnMubWFwUm9vdEh0bWwgPSBtYXBSb290SHRtbDtcclxuICAgICAgICBfYmFzZS5tYXBIVE1MRWxlbWVudCA9IG1hcEhUTUxFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBfdXBkYXRlTWFwKF9kYXRhQ29udGFpbmVyLCBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBjaGFuZ2VzIGxheW91dCBhbGdvcml0aG0gZm9yIHRoZSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiAtIFZhbHVlczogJ3NhbmtleScsICdmbG93LWRpcmVjdGVkJ1xyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0TGF5b3V0QWxnb3JpdGhtID0gZnVuY3Rpb24gKGFsZ29yaXRobUlkKSB7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobUlkID09PSAnc2Fua2V5JyB8fCBhbGdvcml0aG1JZCA9PT0gJ2Zsb3ctZGlyZWN0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9wYXJhbWV0ZXJzLmxheW91dEFsZ29yaXRobSA9IGFsZ29yaXRobUlkO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2Rlcy5tYXAobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG4ubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbW9kZWwuZGVmYXVsdFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgbW9kZWwudmlld0ZyYW1lT3duZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IF9kYXRhQ29udGFpbmVyLmxpbmtzLm1hcChsID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGwubW9kZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsLm1vZGVsLnNvdXJjZVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBsLm1vZGVsLnRhcmdldFR5cGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZXMgPSBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG5cclxuICAgICAgICAgICAgbGF5b3V0LmRvTGF5b3V0KFxyXG4gICAgICAgICAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgICAgICAgICBsaW5rcyxcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXMsXHJcbiAgICAgICAgICAgICAgICBfcGFyYW1ldGVycyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgX2RhdGFDb250YWluZXIucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBfYmlyZEV5ZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIF9ncmFwaE1hcC5yZWRyYXcoe1xyXG4gICAgICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbGF5b3V0IGFsZ29yaXRobSB3aGljaCBpcyBjdXJyZW50bHkgdXNlZCBmb3IgZGlhZ3JhbS5cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcm91dGluZzogbWV0cm8vbm9ybWFsL21hbmhhdHRhblxyXG4gICAgICovXHJcbiAgICBzZWxmLmdldExheW91dEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3BhcmFtZXRlcnMubGF5b3V0QWxnb3JpdGhtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25maWd1cmVkIHJlYWNoIGZyb20gdGhlIGRhdGEgcHJvdmlkZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0UmVhY2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9kYXRhUHJvdmlkZXIuZ2V0UmVhY2goKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByZWFjaCBmb3IgdGhlIGRhdGEgcHJvdmlkZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0UmVhY2ggPSBmdW5jdGlvbiAoX3JlYWNoKSB7XHJcbiAgICAgICAgaWYoX2RhdGFQcm92aWRlcikge1xyXG4gICAgICAgICAgICBfZGF0YVByb3ZpZGVyLnNldFJlYWNoKF9yZWFjaCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBfcmVmZXRjaERpYWdyYW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlndXJlZCBicmVhZHRoIGZyb20gdGhlIGRhdGEgcHJvdmlkZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0QnJlYWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX2RhdGFQcm92aWRlci5nZXRCcmVhZHRoKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYnJlYWR0aCBmb3IgdGhlIGRhdGEgcHJvdmlkZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHNlbGYuc2V0QnJlYWR0aCA9IGZ1bmN0aW9uIChfYnJlYWR0aCkge1xyXG4gICAgICAgIGlmKF9kYXRhUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgX2RhdGFQcm92aWRlci5zZXRCcmVhZHRoKF9icmVhZHRoKTtcclxuXHJcbiAgICAgICAgICAgIF9yZWZldGNoRGlhZ3JhbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBjaGFuZ2VzIG9yaWVudGF0aW9uIG9mIHRoZSBncmFwaFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIC0gVmFsdWVzOiAnbGVmdC10by1yaWdodCcsICdyaWdodC10by1sZWZ0JywgJ3RvcC10by1ib3R0b20nLCAnYm90dG9tLXRvLXRvcCdcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uICYmIChcclxuICAgICAgICAgICAgb3JpZW50YXRpb24gPT09ICdsZWZ0LXRvLXJpZ2h0JyB8fFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9PT0gJ3JpZ2h0LXRvLWxlZnQnIHx8XHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID09PSAndG9wLXRvLWJvdHRvbScgfHxcclxuICAgICAgICAgICAgb3JpZW50YXRpb24gPT09ICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICAgICkpIHtcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMuZ3JhcGhPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBfZGF0YUNvbnRhaW5lci5ub2Rlcy5tYXAobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IG4ubW9kZWw7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC5kZWZhdWx0X3ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC5kZWZhdWx0X3kgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC52aWV3RnJhbWVPd25lcklkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIG4uc2V0T3JpZW50YXRpb24ob3JpZW50YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBfZGF0YUNvbnRhaW5lci5saW5rcy5tYXAobGluayA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBsaW5rLm1vZGVsLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbGluay5tb2RlbC5zb3VyY2VUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbGluay5tb2RlbC50YXJnZXRUeXBlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGxheW91dC5kb0xheW91dChcclxuICAgICAgICAgICAgICAgIG5vZGVzLFxyXG4gICAgICAgICAgICAgICAgbGlua3MsXHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICAgICAgX3BhcmFtZXRlcnMsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgX2JpcmRFeWUucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVmcmVzaCh7XHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVzOiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQgcmV0dXJucyBvcmllbnRhdGlvbiBvZiB0aGUgZ3JhcGhcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gb3JlaW50YXRpb24gLSBWYWx1ZXM6ICdsZWZ0LXRvLXJpZ2h0JywgJ3JpZ2h0LXRvLWxlZnQnLCAndG9wLXRvLWJvdHRvbScsICdib3R0b20tdG8tdG9wJ1xyXG4gICAgICovXHJcbiAgICBzZWxmLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5ncmFwaE9yaWVudGF0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyBMaW5lYWdlR3JhbSAtIHJlZnJlc2hlcyBhbGwgdmlld3MgYW5kIGFkanVzdCBzaXplIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgLSAnbGluZWFnZURpYWdyYW0nIHwgJ2JpcmRFeWUnIHwgJ2dyYXBoTWFwJ1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCB0YXJnZXQgPT09ICdsaW5lYWdlRGlhZ3JhbScpIF9saW5lYWdlRGlhZ3JhbS5yZWRyYXcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCB0YXJnZXQgPT09ICdiaXJkRXllJykgX2JpcmRFeWUucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2dyYXBoTWFwICYmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gJ2dyYXBoTWFwJykpIF9ncmFwaE1hcC5yZWZyZXNoKHtcclxuICAgICAgICAgICAgdmlld0ZyYW1lczogX2xpbmVhZ2VEaWFncmFtLmdldFZpZXdGcmFtZXMoKSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3RnJtYWVzIHB1YmxpYyBkYXRhXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3RnJhbWVQdWJsaWNNb2RlbFxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gSWRlbnRpZmllclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsIC0gVGV4dCBsYWJlbFxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJvcmRlckNvbG9yIC0gQ1NTIGJvcmRlciBjb2xvclxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmRDb2xvciAtIENTUyBiYWNncm91bmQgY29sb3JcclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgVmlld0ZyYW1lcyBzdGF0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lUHVibGljTW9kZWxbXX0gc3RhdGVzIC0ga2V5IC0+IGlkLCB2YWx1ZSAtPiB0cnVlIC0gZXhwYW5kZWQsIGZhbHNlIC0gY29sbGFwc2VkXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRWaWV3RnJhbWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIHJldHVybiBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb25lIFZpZXdGcmFtZSBieSBpZFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld0ZyYW1lSWRcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH1cclxuICAgICovXHJcbiAgICBzZWxmLmdldFZpZXdGcmFtZUJ5SWQgPSBmdW5jdGlvbiAodmlld0ZyYW1lSWQpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVCeUlkKHZpZXdGcmFtZUlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG9uZSBWaWV3RnJhbWUgYnkgaWRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHJldHVybnMge1ZpZXdGcmFtZVB1YmxpY01vZGVsfVxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0T3ZlclZpZXdGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lYWdlRGlhZ3JhbS5nZXRPdmVyVmlld0ZyYW1lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGFwc2UgdGhlIFZpZXdGcmFtZSB3aXRoIHNwZWNpZmllZCBJZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3RnJhbWVJZCAtIGlkIG9mIHRoZSB0YXJnZXQgVmlld0ZyYW1lXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5jb2xsYXBzZVZpZXdGcmFtZSA9IGZ1bmN0aW9uICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLmNsb3NlVmlld0ZyYW1lKHZpZXdGcmFtZUlkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgVmlld0ZyYW1lIHdpdGggc3BlY2lmaWVkIElkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZpZXdGcmFtZUlkIC0gaWQgb2YgdGhlIHRhcmdldCBWaWV3RnJhbWVcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLmV4cGFuZFZpZXdGcmFtZSA9IGZ1bmN0aW9uICh2aWV3RnJhbWVJZCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9wZW5WaWV3RnJhbWUodmlld0ZyYW1lSWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxhcHNlcy9FeHBhbmRzIE92ZXJWaWV3RnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLnNldEZ1bGxTY3JlZW5Nb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uc2V0RnVsbFNjcmVlbk1vZGUodmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxhcHNlcy9FeHBhbmRzIE92ZXJWaWV3RnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmlzRnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiBfcGFyYW1ldGVycy5mdWxsU2NyZWVuTW9kZTtcclxuICAgICAgICByZXR1cm4gX2xpbmVhZ2VEaWFncmFtLmlzRnVsbFNjcmVlbk1vZGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cHMgcmVsYXRpdmUgdG8gc2VsZWN0ZWQgbm9kZVxyXG4gICAgICogbm9kZXMgYXJvdW5kICB0aGUgc2VsZWN0ZWQgbm9kZSBhbmQgaGlnaGxpZ2h0IHRoZW0uXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICovXHJcbiAgICBzZWxmLmNvbWJpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLmNvbWJpbmUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyBlbGVtZW50cyBieSBpZChzKSBhbmQgc2V0cyBpdCBhcyBzZWxlY3RlZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGlkMSAtIFNlbGVjdGVkIGVsZW1lbnQgaWQgb3Igc291cmNlIGVsZW1lbnQgaWQgb2YgdGhlIGxpbmtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZDIgLSBUYXJnZXQgZWxlbWVudCBpZFxyXG4gICAgICogQHJldHVybnMge05vZGV8TGlua30gLSBTZWxlY3RlZCBlbGVtZW50XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoaWQxLCBpZDIpIHtcclxuICAgICAgICBpZiAoaWQxID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGlkMSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBfZ2V0RWxlbWVudEJ5SWQoaWQxLCBpZDIpO1xyXG4gICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3NldFNlbGVjdGVkRWxlbWVudChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVidWlsZHMgZGlhZ3JhbW0gd2l0aCBuZXcgZm9jdXMgbm9kZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvY3VzTm9kZSAtIEZvY3VzIG5vZGUgaWRcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldEZvY3VzTm9kZSA9IGZ1bmN0aW9uIChmb2N1c05vZGVJZCkge1xyXG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IF9nZXRFbGVtZW50QnlJZChmb2N1c05vZGVJZCk7XHJcblxyXG4gICAgICAgIGlmICghKGZvY3VzTm9kZSBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW5jb3JyZWN0IHZhbHVlIG9mIGVsZW1lbnQnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3N0YXRlU3RvcmFnZS51cGRhdGVTdGF0ZShfZ2V0SGlzdG9yeVN0YXRlKCkpO1xyXG4gICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2ZldGNoaW5nJyk7XHJcblxyXG4gICAgICAgIGxldCBmb2N1c1Jlc291cmNlID0gZm9jdXNOb2RlLm1vZGVsLnJlc291cmNlO1xyXG5cclxuICAgICAgICBpZihmb2N1c05vZGUubW9kZWwuaGFzT3duUHJvcGVydHkoJ2FjdGl2ZVJlc291cmNlJykpe1xyXG4gICAgICAgICAgICBmb2N1c1Jlc291cmNlID0gZm9jdXNOb2RlLm1vZGVsLmFjdGl2ZVJlc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2ZldGNoRGlhZ3JhbSh7XHJcbiAgICAgICAgICAgIGZvY3VzTm9kZUlkOiBmb2N1c1Jlc291cmNlLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWU6IGZvY3VzTm9kZS5tb2RlbC52aWV3RnJhbWUsXHJcbiAgICAgICAgICAgIG9mZnNldDogKGZvY3VzTm9kZS5tb2RlbC5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykgPyBmb2N1c05vZGUubW9kZWwub2Zmc2V0IDogbnVsbCksXHJcbiAgICAgICAgICAgIGRpYWdyYW1UeXBlOiBfZGlhZ3JhbVR5cGUsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdG8gcHJldmlvdXMgc2VsZWN0ZWQgbm9kZSAoUmVzdG9yZXMgcHJldmlvdXMgZGlhZ3JhbSlcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnVuZG9TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3RhdGVTdG9yYWdlLnVwZGF0ZVN0YXRlKF9nZXRIaXN0b3J5U3RhdGUoKSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IF9zdGF0ZVN0b3JhZ2UudW5kb1N0YXRlKCk7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUpIF9sb2FkU3RhdGUocHJldmlvdXNTdGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0byBuZXh0IHNlbGVjdGVkIG5vZGVcclxuICAgICAqIChOb2RlIHdoaWNoIGhhZCBiZWVuIHNlbGVjdGVkIGJlZm9yZSB0aGUgc3RhdGUgd2FzIHJlc3RvcmVkKVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYucmVkb1N0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdGF0ZVN0b3JhZ2UudXBkYXRlU3RhdGUoX2dldEhpc3RvcnlTdGF0ZSgpKTtcclxuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBfc3RhdGVTdG9yYWdlLnJlZG9TdGF0ZSgpO1xyXG4gICAgICAgIGlmIChuZXh0U3RhdGUpIF9sb2FkU3RhdGUobmV4dFN0YXRlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHB1YmxpYyBtb2RlbCBvZiBzZWxlY3RlZCBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJucyB7UHVibGljTGlua01vZGVsfFB1YmxpY05vZGVNb2RlbH0gc2VsZWN0ZWRFbGVtZW50XHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXRNb2RlbChfc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHB1YmxpYyBtb2RlbCBvZiBmb2N1cyBlbGVtZW50LlxyXG4gICAgICogRWxlbWVudCB3aGljaCB3YXMgdXNlZCB0byBidWlsZCBkaWFncmFtIGFyb3VuZFxyXG4gICAgICogQHJldHVybnMge1B1YmxpY0xpbmtNb2RlbHxQdWJsaWNOb2RlTW9kZWx9IGZvY3VzRWxlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0Rm9jdXNFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfZ2V0TW9kZWwoX2ZvY3VzRWxlbWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRlcml2YXRpb24gbWFwLlxyXG4gICAgKiBAcmV0dXJucyB7RGVyaXZhdGlvbk1hcH0gZGVydmlhdGlvbk1hcFxyXG4gICAgKiBAbWVtYmVyb2YgbGluZWFnZUdyYW1cclxuICAgICogQG1ldGhvZFxyXG4gICAgKi9cclxuICAgIHNlbGYuZ2V0RGVyaXZhdGlvbk1hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gX2Rlcml2YXRpb25NYXA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybiBbXTtcclxuICAgICAgICByZXR1cm4gX2RhdGFDb250YWluZXIubm9kZXMubWFwKG4gPT4gX2dldE1vZGVsKG4pKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRMaW5rcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIFtdO1xyXG4gICAgICAgIHJldHVybiBfZGF0YUNvbnRhaW5lci5saW5rcy5tYXAobCA9PiBfZ2V0TW9kZWwobCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyYXBocyBwdWJsaWMgbWFwc1xyXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHVibGljR3JhcGhNYXBzXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBQdWJsaWNOb2RlTW9kZWw+fSBub2RlTWFwXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBQdWJsaWNMaW5rTW9kZWw+fSBsaW5rTWFwXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBQdWJsaWNMaW5rTW9kZWw+fSBzb3VyY2VNYXBcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIFB1YmxpY0xpbmtNb2RlbD59IHRhcmdldE1hcFxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyYXBoIG1vZGVsXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQdWJsaWNHcmFwaE1vZGVsXHJcbiAgICAgKiBAcHJvcGVydHkge1B1YmxpY05vZGVNb2RlbFtdfSBub2Rlc1xyXG4gICAgICogQHByb3BlcnR5IHtQdWJsaWNMaW5rTW9kZWxbXX0gbGlua3NcclxuICAgICAqIEBwcm9wZXJ0eSB7UHVibGljR3JhcGhNYXBzfSBtYXBzXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGEgbW9kZWwgb2YgTGluZWFnR3JhbS5cclxuICAgICAqIEByZXR1cm5zIHtQdWJsaWNHcmFwaE1vZGVsfVxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHNlbGYuZ2V0R3JhcGhNb2RlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuIHt9O1xyXG5cclxuICAgICAgICBjb25zdCBncmFwaE1vZGVsID0ge1xyXG4gICAgICAgICAgICBub2RlczogX2RhdGFDb250YWluZXIubm9kZXMubWFwKG4gPT4gX2dldE1vZGVsKG4pKSxcclxuICAgICAgICAgICAgbGlua3M6IF9kYXRhQ29udGFpbmVyLmxpbmtzLm1hcChsID0+IF9nZXRNb2RlbChsKSksXHJcbiAgICAgICAgICAgIG1hcHM6IHtcclxuICAgICAgICAgICAgICAgIG5vZGVNYXA6IHt9LFxyXG4gICAgICAgICAgICAgICAgbGlua01hcDoge30sXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VNYXA6IHt9LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0TWFwOiB7fSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGdyYXBoTW9kZWwubm9kZXMuZm9yRWFjaChub2RlTW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMubm9kZU1hcFtub2RlTW9kZWwuaWRdID0gbm9kZU1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdyYXBoTW9kZWwubGlua3MuZm9yRWFjaChsaW5rTW9kZWwgPT4ge1xyXG4gICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMubGlua01hcFtsaW5rTW9kZWwuaWRdID0gbGlua01vZGVsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwW2xpbmtNb2RlbC50YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMuc291cmNlTWFwW2xpbmtNb2RlbC50YXJnZXRdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFncmFwaE1vZGVsLm1hcHMudGFyZ2V0TWFwW2xpbmtNb2RlbC5zb3VyY2VdKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMudGFyZ2V0TWFwW2xpbmtNb2RlbC5zb3VyY2VdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdyYXBoTW9kZWwubWFwcy5zb3VyY2VNYXBbbGlua01vZGVsLnRhcmdldF0ucHVzaChsaW5rTW9kZWwpO1xyXG4gICAgICAgICAgICBncmFwaE1vZGVsLm1hcHMudGFyZ2V0TWFwW2xpbmtNb2RlbC5zb3VyY2VdLnB1c2gobGlua01vZGVsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdyYXBoTW9kZWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjdXJyZW50IHZpZXcuIE1ldGhvZCB0YWtlcyBzdHJpbmcgaWRlbnRpZmllciBvZiB0aGUgdmlldyBhcyBhIHBhcmFtZXRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IC0gdmlld0lkIGNhbiBiZSAnbGluZWFnZURpYWdyYW0nIG9yICdiaXJkRXllJyBvciAnbm9uZSdcclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBzZWxmLnNldEN1cnJlbnRWaWV3ID0gZnVuY3Rpb24gKHZpZXdJZCkge1xyXG4gICAgICAgIGlmICh2aWV3SWQgPT09ICdsaW5lYWdlRGlhZ3JhbScpIHtcclxuICAgICAgICAgICAgX3Nob3dKb2ludEdyYXBoKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3SWQgPT09ICdiaXJkRXllJykge1xyXG4gICAgICAgICAgICBfc2hvd1NpZ21hR3JhcGgoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZpZXdJZCA9PT0gJ25vbmUnKSAge1xyXG4gICAgICAgICAgICBfaGlkZVZpZXdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNlbGYuc2V0Q3VycmVudFZpZXcoX2N1cnJlbnRWaWV3KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbGlua3Mgcm91dGluZyB3aGljaCBpcyBiYXNlZFxyXG4gICAgICogb24gam9pbnRqcyByb3V0aW5nczogbWV0cm8gfCBub3JtYWwgfCBtYW5oYXR0YW4gfCBvcnRob2dvbmFsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGluZ0lkIC0gbWV0cm8gfCBub3JtYWwgfCBtYW5oYXR0YW4gfCBvcnRob2dvbmFsXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRSb3V0aW5nID0gZnVuY3Rpb24gKHJvdXRpbmdJZCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRSb3V0aW5nKHJvdXRpbmdJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcm91dGluZyB3aGljaCBpcyBjdXJyZW50bHkgYXBwbGllZCBmb3IgYWxsIGxpbmtzLlxyXG4gICAgICogQG1lbWJlcm9mIExpbmVhZ2VHcmFtXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSByb3V0aW5nOiBtZXRybyB8IG5vcm1hbCB8IG1hbmhhdHRhbiB8IG9ydGhvZ29uYWxcclxuICAgICAqL1xyXG4gICAgc2VsZi5nZXRSb3V0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfbGluZWFnZURpYWdyYW0uZ2V0Um91dGluZygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLmxpbmtSb3V0aW5nO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgd2hpY2ggdGVsbHMgdXMgd2hldGVyIHdlIHNob3VsZFxyXG4gICAgICogdHJpbSBub2RlcyBieSB0aGUgYm9yZGVycyBvciBub3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xpcHBpbmdcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgc2VsZi5zZXRDbGlwcGluZyA9IGZ1bmN0aW9uIChjbGlwcGluZykge1xyXG4gICAgICAgIF9wYXJhbWV0ZXJzLmNsaXBOb2RlcyA9IGNsaXBwaW5nO1xyXG4gICAgICAgIGlmIChfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZWRyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIHdoaWNoIHRlbGxzIHVzIHdoZXRlciB3ZVxyXG4gICAgICogdHJpbSBub2RlcyBieSB0aGUgYm9yZGVycyBvciBub3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgTGluZWFnZUdyYW1cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBjbGlwcGluZ1xyXG4gICAgICovXHJcbiAgICBzZWxmLmdldENsaXBwaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfcGFyYW1ldGVycy5jbGlwTm9kZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuc2V0TWFzayA9IGZ1bmN0aW9uIChwdWJsaWNNYXNrKSB7XHJcbiAgICAgICAgY29uc3QgaWRNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLmlkTWFwO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhwdWJsaWNNYXNrKS5mb3JFYWNoKGlkID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGlhZ3JhbUlkID0gaWRNYXBbaWRdO1xyXG4gICAgICAgICAgICBtYXNrW2RpYWdyYW1JZF0gPSBwdWJsaWNNYXNrW2lkXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uc2V0TWFzayhtYXNrKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRNYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSBfbGluZWFnZURpYWdyYW0uZ2V0TWFzaygpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgY29uc3QgbGlua01hcCA9IF9kYXRhQ29udGFpbmVyLm1hcHMubGlua01hcDtcclxuICAgICAgICBjb25zdCBwdWJsaWNNYXNrID0ge307XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFzaykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBfZ2V0TW9kZWwobm9kZU1hcFtrZXldIHx8IGxpbmtNYXBba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljTWFza1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHB1YmxpY01hc2s7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBkaWFncmFtIHVzaW5nIHBhc3NlZCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgZm9jdXNOb2RlSWQ6IHN0cmluZyxcclxuICAgICAqICAgICAgdmlld0ZyYW1lczogVmlld0ZyYW1lRGVmaW5pdGlvbltdLFxyXG4gICAgICogICAgICB2aWV3RnJhbWU6IHN0cmluZ1xyXG4gICAgICogICAgICBsaW5lYWdlR3JhbVZpZXdDbGFzczogc3RyaW5nLFxyXG4gICAgICogICAgICBkaWFncmFtVHlwZTogc3RyaW5nLFxyXG4gICAgICogfX1cclxuICAgICAqIEBtZW1iZXJvZiBMaW5lYWdlR3JhbVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2ZldGNoRGlhZ3JhbSAob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGVJZCA9IG9wdGlvbnMuZm9jdXNOb2RlSWQ7XHJcbiAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gb3B0aW9ucy52aWV3RnJhbWU7XHJcbiAgICAgICAgY29uc3QgZGlhZ3JhbVR5cGUgPSBvcHRpb25zLmRpYWdyYW1UeXBlO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/ICBvcHRpb25zLm9mZnNldCA6IG51bGwpO1xyXG5cclxuICAgICAgICAvLyBTd2l0Y2ggdGhlIGxvYWRpbmcgaW5kaWNhdG9yIGluIHN0YXRlICdmZXRjaGluZydcclxuICAgICAgICAvLyBSZXF1ZXN0IGRhdGEgdGhyb3VnaCBkYXRhIHByb3ZpZGVyXHJcbiAgICAgICAgX3NldERpYWdyYW1TdGF0ZSgnZmV0Y2hpbmcnKTtcclxuICAgICAgICBpZiAoIV9kYXRhUHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0RhdGEgcHJvdmlkZXIgaXMgbm90IHNwZWNpZmllZCEnO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicsIGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIF9lcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX2RhdGFQcm92aWRlci5mZXRjaERhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0RhdGEgcHJvdmlkZXIgaGFzIGluY29ycmVjdCBpbnRlcmZhY2UhIChUaGVyZSBpcyBubyBcXCdmZXRjaERhdGFcXCcgbWV0aG9kKSc7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJywgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgX2Vycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZpZXdGcmFtZXNQcm9taXNlID0gb3B0aW9ucy52aWV3RnJhbWVzICYmIG9wdGlvbnMudmlld0ZyYW1lcy5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHsgZnJhbWVzOiBvcHRpb25zLnZpZXdGcmFtZXMgfSkgOlxyXG4gICAgICAgICAgICBfZGF0YVByb3ZpZGVyLmdldFZpZXdGcmFtZXModGFyZ2V0Tm9kZUlkKTtcclxuICAgICAgICBjb25zdCB2aWV3Q2xhc3NQcm9taXNlID0gb3B0aW9ucy5saW5lYWdlR3JhbVZpZXdDbGFzcyA/XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShvcHRpb25zLmxpbmVhZ2VHcmFtVmlld0NsYXNzKSA6XHJcbiAgICAgICAgICAgIF9kYXRhUHJvdmlkZXIuZ2V0Vmlld0NsYXNzRm9yUmVzb3VyY2UodGFyZ2V0Tm9kZUlkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt2aWV3RnJhbWVzUHJvbWlzZSwgdmlld0NsYXNzUHJvbWlzZV0pLnRoZW4odmFsdWVzID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lcyA9IHZhbHVlc1swXS5mcmFtZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdDbGFzcyA9IHZhbHVlc1sxXS5kYXRhUHJvdmlkZXI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX2RhdGFQcm92aWRlci5mZXRjaERhdGEoe1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZUlkOiB0YXJnZXROb2RlSWQsXHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWU6IHZpZXdGcmFtZSxcclxuICAgICAgICAgICAgICAgIGxpbmVhZ2VHcmFtVmlld0NsYXNzOiB2aWV3Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICBkaWFncmFtVHlwZTogZGlhZ3JhbVR5cGUsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6b2Zmc2V0XHJcbiAgICAgICAgICAgIH0pLnRoZW4ocmF3RGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdyZW5kZXJpbmcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjaGVja0xnUmF3RGF0YShyYXdEYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29udGFpbmVyID0gX2NyZWF0ZURhdGFDb250YWluZXIocmF3RGF0YSwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVEZWZpbml0aW9ucyA9IGZpbHRlclZpZXdGcmFtZUxpc3Qodmlld0ZyYW1lcywgZGF0YUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNWaWV3RnJhbWVNb2RlbHMgPSB2aWV3RnJhbWVEZWZpbml0aW9ucy5tYXAoZCA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVuaXRpb25Ub1B1YmxpY01vZGVsKGQsIF9saW5lYWdlRGlhZ3JhbS5pc0Z1bGxTY3JlZW5Nb2RlKCkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIF91cGRhdGVDb21wb25lbnRzKGRhdGFDb250YWluZXIsIHB1YmxpY1ZpZXdGcmFtZU1vZGVscyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2RpYWdyYW1UeXBlID0gcmF3RGF0YS5kaWFncmFtVHlwZTtcclxuICAgICAgICAgICAgICAgIF9kYXRhQ29udGFpbmVyID0gZGF0YUNvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZVN0b3JhZ2UucHVzaFN0YXRlKF9nZXRIaXN0b3J5U3RhdGUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9jdXNOb2RlSWQgPSByYXdEYXRhLmZvY3VzTm9kZSB8fCAocmF3RGF0YS5ub2Rlc1swXSA/IHJhd0RhdGEubm9kZXNbMF0uaWQgOiBmb2N1c05vZGVJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb2N1c0VsZW1lbnQgPSBfZ2V0RWxlbWVudEJ5SWQoZm9jdXNOb2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgX2ZvY3VzRWxlbWVudCA9IGZvY3VzRWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KGZvY3VzRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdjb21wbGV0ZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2ZvY3VzLW5vZGUtY2hhbmdlZCcsIF9nZXRNb2RlbChmb2N1c0VsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkJywgX3N0YXRlU3RvcmFnZS5nZXRIaXN0b3J5KCkpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIGUgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKGUpIDogZTtcclxuXHJcbiAgICAgICAgICAgIF9zZXREaWFncmFtU3RhdGUoJ2Vycm9yJywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIF9lcnJvckNhbGxiYWNrKGVycm9yKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3Iuc3RhY2spO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGVtcHR5IHZpZXdGcmFtZXNcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lRGVmaW5pdGlvbltdfSB2aWV3RnJhbWVzXHJcbiAgICAgICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyXHJcbiAgICAgICAgICogQHJldHVybnMge1ZpZXdGcmFtZVtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGZpbHRlclZpZXdGcmFtZUxpc3QgKHZpZXdGcmFtZXMsIGRhdGFDb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmlld0ZyYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyLm5vZGVzLmZvckVhY2gobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVWaWV3RnJhbWVzW24ubW9kZWwudmlld0ZyYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2aWV3RnJhbWVzLmZpbHRlcih2ZiA9PiBhY3RpdmVWaWV3RnJhbWVzW3ZmLmlkXSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBhIGRhdGEgcmVmZXJzaCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWZldGNoRGlhZ3JhbSAoKSB7XHJcblxyXG4gICAgICAgIGlmKF9mb2N1c0VsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBmb2N1c05vZGUgPSBfZm9jdXNFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgZm9jdXNSZXNvdXJjZSA9IGZvY3VzTm9kZS5tb2RlbC5hY3RpdmVSZXNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIF9mZXRjaERpYWdyYW0oe1xyXG4gICAgICAgICAgICAgICAgZm9jdXNOb2RlSWQ6IGZvY3VzUmVzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWU6IGZvY3VzTm9kZS5tb2RlbC52aWV3RnJhbWUsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IChmb2N1c05vZGUubW9kZWwuaGFzT3duUHJvcGVydHkoJ29mZnNldCcpID8gZm9jdXNOb2RlLm1vZGVsLm9mZnNldCA6IG51bGwpLFxyXG4gICAgICAgICAgICAgICAgZGlhZ3JhbVR5cGU6IF9kaWFncmFtVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEZpbmRzIGVsZW1lbnRzIGJ5IGlkKHMpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkMSAtIFNlbGVjdGVkIGVsZW1lbnQgaWQgb3Igc291cmNlIGVsZW1lbnQgaWQgb2YgdGhlIGxpbmtcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZDIgLSBUYXJnZXQgZWxlbWVudCBpZFxyXG4gICAgICogQHJldHVybnMge05vZGV8TGlua30gLSBTZWxlY3RlZCBlbGVtZW50XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldEVsZW1lbnRCeUlkIChpZDEsIGlkMikge1xyXG4gICAgICAgIGlmICghaWQyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gX2RhdGFDb250YWluZXIubm9kZXMuY29uY2F0KF9kYXRhQ29udGFpbmVyLmxpbmtzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm1vZGVsLnJlc291cmNlID09PSBpZDEgfHwgZWxlbWVudHNbaV0ubW9kZWwuaWQgPT09IGlkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBfZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gX2RhdGFDb250YWluZXIubGlua3M7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGlua3NbaV0ubW9kZWwuc291cmNlXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGlua3NbaV0ubW9kZWwudGFyZ2V0XTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucmVzb3VyY2UgPT09IGlkMSAmJiB0YXJnZXQucmVzb3VyY2UgPT09IGlkMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5yZXNvdXJjZSA9PT0gaWQyICYmIHRhcmdldC5yZXNvdXJjZSA9PT0gaWQxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLmlkID09PSBpZDEgJiYgdGFyZ2V0LmlkID09PSBpZDIgfHxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaWQgPT09IGlkMiAmJiB0YXJnZXQuaWQgPT09IGlkMVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ2hlY2tzIHBhc3NlZCBlbGVtZW50IGFuZCBzZXQgaXQgYXMgYSBzZWxlY3RlZC4gUmVmcmVzaGVzIHRoaXMgdmFsdWUgZm9yIHRoZSB2aWV3cy5cclxuICAgICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSAtIFNlbGVjdGVkIGVsZW1lbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0U2VsZWN0ZWRFbGVtZW50IChzZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBJdCBzaG91ZGxuJ3QgYmUgdW5kZWZpbmVkLCBidXQgaXQgY2FuIGJlIG51bGxcclxuICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0luY29ycmVjdCB2YWx1ZSBvZiBzZWxlY3RlZCBlbGVtZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAuc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChzZWxlY3RlZEVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogUmV0dXJucyBjdXJyZW50IHN0YXRlLlxyXG4gICAgICogQHJldHVybnMge0hpc3RvcnlTdGF0ZX0gY3VycmVudCBzdGF0ZVxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRIaXN0b3J5U3RhdGUgKCkge1xyXG4gICAgICAgIGNvbnN0IG92ZXJWaWV3RnJhbWUgPSBfbGluZWFnZURpYWdyYW0uZ2V0T3ZlclZpZXdGcmFtZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5vZGVzOiBfZGF0YUNvbnRhaW5lci5ub2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IF9kYXRhQ29udGFpbmVyLmxpbmtzLFxyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQ6IF9mb2N1c0VsZW1lbnQsXHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCkuZmlsdGVyKHZmID0+IHZmLmlkICE9PSBvdmVyVmlld0ZyYW1lLmlkKSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50OiBfc2VsZWN0ZWRFbGVtZW50LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogUmVzdG9yZXMgZGlhZ3JhbSB1c2luZyB0aGUgcGFzc2VkIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIHtIaXN0b3J5U3RhdGV9IHN0YXRlIC0gdGFyZ2V0IHN0YXRlXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2xvYWRTdGF0ZSAoc3RhdGUpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdyZW5kZXJpbmcnKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29udGFpbmVyID0gbmV3IERhdGFDb250YWluZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBzdGF0ZS5ub2RlcyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5rczogc3RhdGUubGlua3MsXHJcbiAgICAgICAgICAgICAgICB9LCBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3VwZGF0ZUNvbXBvbmVudHMoZGF0YUNvbnRhaW5lciwgc3RhdGUudmlld0ZyYW1lcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb1NlbGVjdCA9IHN0YXRlLnNlbGVjdGVkRWxlbWVudCA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5mb2N1c0VsZW1lbnQgOiBzdGF0ZS5zZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBfZm9jdXNFbGVtZW50ID0gc3RhdGUuZm9jdXNFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBlbGVtZW50VG9TZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICBfc2V0U2VsZWN0ZWRFbGVtZW50KGVsZW1lbnRUb1NlbGVjdCk7XHJcbiAgICAgICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdjb21wbGV0ZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2ZvY3VzLW5vZGUtY2hhbmdlZCcsIF9nZXRNb2RlbChzdGF0ZS5mb2N1c0VsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignaGlzdG9yeS1zdGF0ZS1jaGFuZ2VkJywgX3N0YXRlU3RvcmFnZS5nZXRIaXN0b3J5KCkpO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBfc2V0RGlhZ3JhbVN0YXRlKCdlcnJvcicpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQ2hhbmdlcyBzY2FsZSBvZiB0aGUgbWFpbiB2aWV3IHRvIGJlIGFibGUgdG8gZml0IHdob2xlIGRpYWdyYW0gaW4gdGhlIHNjcmVlbi5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfem9vbVRvRml0ICgpIHtcclxuICAgICAgICBfbGluZWFnZURpYWdyYW0uem9vbVRvRml0KCk7XHJcbiAgICAgICAgaWYgKF9ncmFwaE1hcCkgX2dyYXBoTWFwLnJlZHJhdyh7XHJcbiAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgICAgIHNjYWxlOiBfbGluZWFnZURpYWdyYW0uc2NhbGUoKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDcmVhdGVzIGRhdGFDb250YWluZXIgKGRpYWdyYW0gbW9kZWwpIHVzaW5nIHBhc3NlZCByYXcgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7U2VydmVyRGF0YX0gcmF3RGF0YSAtIGRhdGFcclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lRGVmaW5pdGlvbltdfSB2aWV3RnJhbWVzIC0gVmlldyBmcmFtZSBkZWZlbml0aW9uc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVEYXRhQ29udGFpbmVyIChyYXdEYXRhLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZ2V0IGFueSBkYXRhLCB3ZSBjcmVhdGUgYW4gZW1wdHkgZGF0YXRcclxuICAgICAgICBpZiAoIXJhd0RhdGEpIHJhd0RhdGEgPSB7IG5vZGVzOiBbXSwgbGlua3M6IFtdIH07XHJcbiAgICAgICAgaWYgKCFyYXdEYXRhLm5vZGVzKSByYXdEYXRhLm5vZGVzID0gW107XHJcbiAgICAgICAgaWYgKCFyYXdEYXRhLmxpbmtzKSByYXdEYXRhLmxpbmtzID0gW107XHJcblxyXG4gICAgICAgIC8vIFRoZSBmdW5jdGlvbiBmaWx0ZXJzIHRoZSBkYXRhLCBzZXRzIGF1dGhvcml0aWVzIGFuZCBjb2xsYXBzZXMgbGlua3MuXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3NEYXRhKHJhd0RhdGEpO1xyXG4gICAgICAgIC8vIEZpbmQgYW5kIHNldCBwbGFjZSBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBkYXRhIHNldFxyXG4gICAgICAgIGxheW91dC5kb0xheW91dChcclxuICAgICAgICAgICAgZGF0YS5ub2RlcyxcclxuICAgICAgICAgICAgZGF0YS5saW5rcyxcclxuICAgICAgICAgICAgdmlld0ZyYW1lcyxcclxuICAgICAgICAgICAgX3BhcmFtZXRlcnMsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyB0d28gbGluZXMgY3JlYXRlIG5vZGVzIGFuZCBsaW5rcyBmcm9tIGRhdGEgbW9kZWxzXHJcbiAgICAgICAgY29uc3Qgam9pbnROb2RlcyA9IGNyZWF0ZUpvaW50Tm9kZXMoZGF0YS5ub2RlcywgX3BhcmFtZXRlcnMpO1xyXG4gICAgICAgIGNvbnN0IGpvaW50TGlua3MgPSBjcmVhdGVKb2ludExpbmtzKGRhdGEubGlua3MsIGpvaW50Tm9kZXMsICBfcGFyYW1ldGVycyk7XHJcblxyXG4gICAgICAgIGNyZWF0ZUFzcGVjdFJlbGF0aW9ucyhqb2ludE5vZGVzKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGRhdGEgY29udGFpbmVyIGJ5IG5ldyBub2RlcyBhbmQgbGlua3NcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFDb250YWluZXIoe1xyXG4gICAgICAgICAgICBub2Rlczogam9pbnROb2RlcyxcclxuICAgICAgICAgICAgbGlua3M6IGpvaW50TGlua3MsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgKG9yIHJlZnJlc2hlcyBpZiBub3QgdGhlIGZpcnN0IHRpbWUpXHJcbiAgICAgKiB0aGUgTGluZWFnZUdyYW0gLSBDcmVhdGVzIChSZWZyZXNoZXMpIHRoZSBtYWluIHZpZXdzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUNvbXBvbmVudHMgKCkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5RGF0YUNvbnRhaW5lciA9IG5ldyBEYXRhQ29udGFpbmVyICh7XHJcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgbGlua3M6IFtdLFxyXG4gICAgICAgIH0sIF9wYXJhbWV0ZXJzKTtcclxuICAgICAgICBjb25zdCBlbXB0eUxpc3QgPSBbXTtcclxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBmaXJzdCB2aWV3IC0gTGluZWFnZURpYWdyYW1cclxuICAgICAgICBfY3JlYXRlTGluZWFnZURpYWdyYW0oZW1wdHlEYXRhQ29udGFpbmVyLCBlbXB0eUxpc3QpO1xyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBzaWdtYSBncmFwaCBtYXAgb24gdGhlIHByaXZhdGUgcm9vdC5cclxuICAgICAgICAvLyBfY3JlYXRlTWFwKGVtcHR5RGF0YUNvbnRhaW5lciwgZW1wdHlMaXN0KTtcclxuICAgICAgICAvLyBDcmVhdGVzIHRoZSBzZWNvbmQgdmlldyAtIEJpcmRFeWUgKEhpc3RvcmljYWxseSAtIFNpZ21hUGF0aFZpZXcpXHJcbiAgICAgICAgX2NyZWF0ZUJpcmRFeWUoZW1wdHlEYXRhQ29udGFpbmVyKTtcclxuICAgICAgICBfY3JlYXRlRGVyaXZhdGlvbk1hcChfZGF0YVByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgX2FkZEhvdmVySGFuZGxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAob3IgcmVmcmVzaGVzIGlmIG5vdCB0aGUgZmlyc3QgdGltZSlcclxuICAgICAqIHRoZSBMaW5lYWdlR3JhbSAtIENyZWF0ZXMgKFJlZnJlc2hlcykgdGhlIG1haW4gdmlld3MuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfdXBkYXRlQ29tcG9uZW50cyAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIC8vIFVwZGF0ZXMgdGhlIGZpcnN0IHZpZXcgLSBMaW5lYWdlRGlhZ3JhbVxyXG4gICAgICAgIF91cGRhdGVMaW5lYWdlRGlhZ3JhbShkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICAvLyBVcGRhdGVzIGEgc2lnbWEgZ3JhcGggbWFwIG9uIHRoZSBwcml2YXRlIHJvb3QuXHJcbiAgICAgICAgX3VwZGF0ZU1hcChkYXRhQ29udGFpbmVyLCBfbGluZWFnZURpYWdyYW0uZ2V0Vmlld0ZyYW1lcygpKTtcclxuICAgICAgICAvLyBVcGRhdGVzIHRoZSBzZWNvbmQgdmlldyAtIEJpcmRFeWUgKEhpc3RvcmljYWxseSAtIFNpZ21hUGF0aFZpZXcpXHJcbiAgICAgICAgX3VwZGF0ZUJpcmRFeWUoZGF0YUNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIF96b29tVG9GaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbm5lciBmdW5jdGlvbnNcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVMaW5lYWdlRGlhZ3JhbSAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbSA9IG5ldyBMaW5lYWdlRGlhZ3JhbSh7XHJcbiAgICAgICAgICAgIGdyYXBoUGxhY2U6IF9iYXNlLmxpbmVhZ2VEaWFncmFtLFxyXG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBkYXRhQ29udGFpbmVyLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICBmdWxsU2NyZWVuTW9kZTogX3BhcmFtZXRlcnMuZnVsbFNjcmVlbk1vZGUsXHJcbiAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIChldmVudE9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJyAmJiBfc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAuc2V0U2VsZWN0ZWRFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIF9nZXRNb2RlbChfc2VsZWN0ZWRFbGVtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCdzY2FsZS1jaGFuZ2VkJywgKG5ld1NjYWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAucmVkcmF3KHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcmFtZXM6IF9saW5lYWdlRGlhZ3JhbS5nZXRWaWV3RnJhbWVzKCksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogbmV3U2NhbGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2NhbGUtdmFsdWUtY2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgIG1pbjogX3BhcmFtZXRlcnMuc2NhbGVCb3VuZHMubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4OiBfcGFyYW1ldGVycy5zY2FsZUJvdW5kcy5tYXgsXHJcbiAgICAgICAgICAgICAgICBjdXI6IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2xpbmVhZ2VEaWFncmFtLm9uKCd2aWV3LWZyYW1lcy1zdGF0ZS1jaGFuZ2VkJywgKHZpZXdGcmFtZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZS1zdGF0ZS1jaGFuZ2VkJywgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbigndmlldy1mcmFtZXMtc2l6ZS1vci1wb3NpdGlvbi1jaGFuZ2VkJywgKHZpZXdGcmFtZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoeyB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignbm9kZXMtcG9zaXRpb24tY2hhbmdlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgICAgIF9ncmFwaE1hcC5yZWRyYXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfYmlyZEV5ZS5yZWRyYXcoKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICBfbGluZWFnZURpYWdyYW0ub24oJ2NlbGwtZG91YmxlLWNsaWNrJywgKGV2ZW50T2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPYmplY3QgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmsgfHwgZXZlbnRPYmplY3QgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLlRlcm1pbmF0aW9uTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRTZWxlY3RlZEVsZW1lbnQoZXZlbnRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldmVudE9iamVjdC5vcmlnaW5hbExpbmsgfHwgZXZlbnRPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Nob3dEZXJpdmF0aW9uTWFwKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5vbignbGluay1vcHRpb25zLWNsaWNrJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZXZlbnQubGluaztcclxuICAgICAgICAgICAgY29uc3QgbGlua1R5cGUgPSBldmVudC5saW5rVHlwZTtcclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2xpbmVhZ2VEaWFncmFtJykge1xyXG4gICAgICAgICAgICAgICAgX3Nob3dEZXJpdmF0aW9uTWFwKGxpbmssIGxpbmtUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF91cGRhdGVMaW5lYWdlRGlhZ3JhbSAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXREYXRhKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpO1xyXG4gICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zY2FsZShfcGFyYW1ldGVycy5kZWZhdWx0U2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9hZGRIb3ZlckhhbmRsZXIgKCkge1xyXG4gICAgICAgIC8vIEluaXQgdGhlIHRvb2x0aXAgdG9vbCBmb3IgdGVybWludGF0aW9uIG5vZGVzLlxyXG4gICAgICAgIG5ldyBqb2ludC51aS5Ub29sdGlwKHtcclxuICAgICAgICAgICAgcm9vdFRhcmdldDogZG9jdW1lbnQuYm9keSxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnLnRlcm1pbmF0aW9uLW5vZGUnLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdhdXRvJyxcclxuICAgICAgICAgICAgcGFkZGluZzogMTUsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IChjZWxsID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZXh0JylbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHJpYnV0ZXMudG9vbHRpcC52YWx1ZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBqb2ludC51aS5Ub29sdGlwKHtcclxuICAgICAgICAgICAgcm9vdFRhcmdldDogZG9jdW1lbnQuYm9keSxcclxuICAgICAgICAgICAgdGFyZ2V0OiAnLnRxLWxnLXNob3J0LWxhYmVsJyxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnYXV0bycsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDE1LFxyXG4gICAgICAgICAgICBjb250ZW50OiAoY2VsbCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGV4dCcpWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyaWJ1dGVzLnRvb2x0aXAudmFsdWU7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVEZXJpdmF0aW9uTWFwIChkYXRhUHJvdmlkZXIpIHtcclxuICAgICAgICBfZGVyaXZhdGlvbk1hcFBhbmVsID0gbmV3IFRRR3JhbVVJLkZseWluZ1BhbmVsKHtcclxuICAgICAgICAgICAgYmFzZUVsZW1lbnQ6IF9iYXNlLmRlcml2YXRpb25NYXAsXHJcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGhlYWRlcjogJ0Rlcml2YXRpb24gTWFwJyxcclxuICAgICAgICAgICAgZW1wdHlCb2R5OiBmYWxzZSxcclxuICAgICAgICAgICAgc2l6ZTogeyB3aWR0aDogJ2NhbGMoMTAwJSAtIDIwMHB4KScsIGhlaWdodDogJ2NhbGMoMTAwJSAtIDIwMHB4KSd9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiAnMTAwcHgnLCB5OiAnMTAwcHgnfSxcclxuICAgICAgICAgICAgYm9keTogJycsXHJcbiAgICAgICAgICAgIHJlc2l6YWJsZTogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2Rlcml2YXRpb25NYXBQYW5lbC5vbignc2l6ZS1jaGFuZ2VkJywgKCkgPT4gX2Rlcml2YXRpb25NYXAucmVzZXRGb2N1cygpKTtcclxuXHJcbiAgICAgICAgX2Rlcml2YXRpb25NYXAgPSBuZXcgRGVyaXZhdGlvbk1hcCh7XHJcbiAgICAgICAgICAgIHJvb3RFbGVtZW50OiBfZGVyaXZhdGlvbk1hcFBhbmVsLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoJy50cS11aS1ib2R5X2NvbnRhaW5lcicpLFxyXG4gICAgICAgICAgICBkYXRhUHJvdmlkZXI6IGRhdGFQcm92aWRlclxyXG4gICAgICAgIH0sIF9wYXJhbWV0ZXJzLmRlcml2YXRpb25NYXApO1xyXG5cclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Rlcml2YXRpb24tbWFwLXN0YXRlLWNoYW5nZWQnKTtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2Rlcml2YXRpb24tbWFwLXN0YXRlLWluaXQnLF9kZXJpdmF0aW9uTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQmlyZEV5ZSAoZGF0YUNvbnRhaW5lcikge1xyXG4gICAgICAgIF9iaXJkRXllID0gbmV3IEJpcmRFeWUoe1xyXG4gICAgICAgICAgICBlbDogX2Jhc2Uuc2lnbWFHcmFwaCxcclxuICAgICAgICAgICAgc2NhbGU6IF9saW5lYWdlRGlhZ3JhbS5zY2FsZSgpLFxyXG4gICAgICAgICAgICBkYXRhQ29udGFpbmVyOiBkYXRhQ29udGFpbmVyLFxyXG4gICAgICAgIH0sIF9wYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgX2JpcmRFeWUub24oJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIChldmVudE9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoX3N0YXRlICE9PSAnY29tcGxldGVkJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyA9PT0gJ2JpcmRFeWUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2dyYXBoTWFwKSBfZ3JhcGhNYXAuc2V0U2VsZWN0ZWRFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCcsIF9nZXRNb2RlbChfc2VsZWN0ZWRFbGVtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2JpcmRFeWUub24oJ2NlbGwtZG91YmxlLWNsaWNrJywgKGV2ZW50T2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgIT09ICdjb21wbGV0ZWQnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnYmlyZEV5ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluayB8fCBldmVudE9iamVjdCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuVGVybWluYXRpb25MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KGV2ZW50T2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rcyA9IGV2ZW50T2JqZWN0Lm9yaWdpbmFsTGluayB8fCBldmVudE9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICBfc2hvd0Rlcml2YXRpb25NYXAobGlua3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZUJpcmRFeWUgKGRhdGFDb250YWluZXIpIHtcclxuICAgICAgICBfYmlyZEV5ZS5zZXREYXRhKGRhdGFDb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbWFwIElmIG5vdCBjcmVhdGVkLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiAgICAgKiBAcmV0dXJucyB7Vmlld0ZyYW1lW119XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVNYXAgKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpIHtcclxuICAgICAgICBpZiAoX2Jhc2UubWFwSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgX2dyYXBoTWFwID0gIG5ldyBHcmFwaE1hcCh7XHJcbiAgICAgICAgICAgICAgICBlbDogX2Jhc2UubWFwSFRNTEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogX2xpbmVhZ2VEaWFncmFtLnNjYWxlKCksXHJcbiAgICAgICAgICAgICAgICB2aWV3RnJhbWVzOiB2aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICAgICAgZGF0YUNvbnRhaW5lcjogZGF0YUNvbnRhaW5lcixcclxuICAgICAgICAgICAgfSwgX3BhcmFtZXRlcnMpO1xyXG5cclxuICAgICAgICAgICAgX2dyYXBoTWFwLm9uKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ID09PSAnbGluZWFnZURpYWdyYW0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlzSW52aXNpYmxlID0gX2xpbmVhZ2VEaWFncmFtLmdldFZpc2libGVOb2RlcygpLmluZGV4T2Yobm9kZSkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5zZXRTZWxlY3RlZEVsZW1lbnQobm9kZSwgbm9kZUlzSW52aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChfY3VycmVudFZpZXcgPT09ICdiaXJkRXllJykgX2JpcmRFeWUuc2V0U2VsZWN0ZWRFbGVtZW50KG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9zZWxlY3RlZEVsZW1lbnQgPSBnZXRCYXNlRWxlbWVudChub2RlKTtcclxuICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgX2dldE1vZGVsKF9zZWxlY3RlZEVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBfZ3JhcGhNYXAub24oJ3ZpZXctZnJhbWVzLXBvc2l0aW9uLWNoYW5nZWQnLCAodmlld0ZyYW1lcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9zdGF0ZSAhPT0gJ2NvbXBsZXRlZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmlld0ZyYW1lcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uKHZpZXdGcmFtZXNbaW5kZXgrK10pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2lvbiAodmlld0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnBvc2l0aW9uVmlld1BvcnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdGcmFtZSwgdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24sIF9wYXJhbWV0ZXJzLmFuaW1hdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdGcmFtZVtpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb24odmlld0ZyYW1lc1tpbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBfZ3JhcGhNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBtYXAuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtEYXRhQ29udGFpbmVyfSBkYXRhQ29udGFpbmVyXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqIEByZXR1cm5zIHtWaWV3RnJhbWVbXX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3VwZGF0ZU1hcCAoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcykge1xyXG4gICAgICAgIGlmIChfZ3JhcGhNYXApIHtcclxuICAgICAgICAgICAgX2dyYXBoTWFwLnNldERhdGEoZGF0YUNvbnRhaW5lciwgdmlld0ZyYW1lcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX2NyZWF0ZU1hcChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtMaW5rfE5vZGV8VGVybWluYXRpb25MaW5rfFRlcm1pbmF0aW9uTm9kZX0gZWxlbWVudFxyXG4gICAgICogQHJldHVybnMge1B1YmxpY05vZGVNb2RlbHxQdWJsaWNMaW5rTW9kZWx9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRNb2RlbCAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBlbGVtZW50TW9kZWwgPSBfLmNsb25lRGVlcChlbGVtZW50Lm1vZGVsKTtcclxuICAgICAgICBlbGVtZW50TW9kZWwuYmx1cmVkID0gQm9vbGVhbihlbGVtZW50LmdldCgnYmx1cmVkJykpO1xyXG4gICAgICAgIGVsZW1lbnRNb2RlbC5oaWdobGlnaHRlZCA9IEJvb2xlYW4oZWxlbWVudC5nZXQoJ2hpZ2hsaWdodGVkJykpO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSkge1xyXG4gICAgICAgICAgICBlbGVtZW50TW9kZWwuZGlhZ3JhbVR5cGUgPSAnbm9kZSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5MaW5rKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRNb2RlbC5zb3VyY2UgPSBlbGVtZW50TW9kZWwuc291cmNlVHlwZTtcclxuICAgICAgICAgICAgZWxlbWVudE1vZGVsLnRhcmdldCA9IGVsZW1lbnRNb2RlbC50YXJnZXRUeXBlO1xyXG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudE1vZGVsLnNvdXJjZVR5cGU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50TW9kZWwudGFyZ2V0VHlwZTtcclxuICAgICAgICAgICAgZWxlbWVudE1vZGVsLmRpYWdyYW1UeXBlID0gJ2xpbmsnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudE1vZGVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgZGVyaXZhdGlvbiBtYXAgd2luZG93LlxyXG4gICAgICogQHBhcmFtIHtMaW5rfSBsaW5rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlua1R5cGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9zaG93RGVyaXZhdGlvbk1hcCAobGluaywgbGlua1R5cGUpIHtcclxuICAgICAgICBpZiAobGluayBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluaykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlTWFwID0gX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGFjdHVhbExpbmsgPSBudWxsO1xyXG4gICAgICAgICAgICBpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChsaW5rLm1vZGVsLCAnZ3JvdXAnKSl7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGxpbmsubW9kZWwuZ3JvdXA7XHJcblxyXG4gICAgICAgICAgICAgICAgYWN0dWFsTGluayA9IGdyb3VwLmZpbHRlcigoZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnLnNvdXJjZSA9PSBsaW5rLm1vZGVsLnNvdXJjZVR5cGUgJiYgZy50YXJnZXQgPT0gbGluay5tb2RlbC50YXJnZXRUeXBlICYmIGcubGlua1R5cGUgPT0gbGlua1R5cGVcclxuICAgICAgICAgICAgICAgIH0pWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgX2Rlcml2YXRpb25NYXAub3BlbldpdGhSZWxhdGlvbih7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdLm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2RlTWFwW2xpbmsubW9kZWwudGFyZ2V0XS5tb2RlbCxcclxuICAgICAgICAgICAgICAgIGxpbmtUeXBlOiBsaW5rVHlwZSxcclxuICAgICAgICAgICAgICAgIGFjdGl2ZVJlc291cmNlc0xpc3Q6IGFjdHVhbExpbmsgPyBhY3R1YWxMaW5rLmFjdGl2ZVJlc291cmNlc0xpc3QgOiBsaW5rLm1vZGVsLmFjdGl2ZVJlc291cmNlc0xpc3RcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF9kZXJpdmF0aW9uTWFwUGFuZWwuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc3RhdGUgb2YgaW5kaWNhdG9yXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlIC0gZmV0Y2hpbmcgfCByZW5kZXJpbmcgfCBjb21wbGV0ZWQgfCBlcnJvclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBDdXN0b20gbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2V0RGlhZ3JhbVN0YXRlIChzdGF0ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIF9zdGF0ZSA9IHN0YXRlO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUgPT09ICdmZXRjaGluZycpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdhY3RpdmUnLCBtZXNzYWdlIHx8ICdGZXRjaGluZyBkYXRhJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ3JlbmRlcmluZycpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdhY3RpdmUnLCBtZXNzYWdlIHx8ICdSZW5kZXJpbmcgZ3JhcGgnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBfcHJvZ3Jlc3NTY3JlZW4uc2V0U3RhdGUoJ2NvbXBsZXRlZCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgX3Byb2dyZXNzU2NyZWVuLnNldFN0YXRlKCdlcnJvcicsIG1lc3NhZ2UgfHwgJ0Vycm9yIGhhcyBvY2N1cnJlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdkaWFncmFtLXN0YXRlLWNoYW5nZWQnLCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGh0bWwgbWFya3VwLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxOb2RlIC0gUm9vdCBub2RlIGZvciBtYXJrdXBcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywgSFRNTEVsZW1lbnQ+fSAtIE1hcCBvZiBodG1sIGVsZW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9jcmVhdGVCYXNlIChodG1sTm9kZSkge1xyXG4gICAgICAgIGh0bWxOb2RlLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGh0bWxOb2RlLnRhYkluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIGJhc2VEaXYuY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2UnO1xyXG4gICAgICAgIGJhc2VEaXYuaWQgPSAndHFfbGluZWFnZSc7XHJcbiAgICAgICAgaHRtbE5vZGUuYXBwZW5kQ2hpbGQoYmFzZURpdik7XHJcblxyXG4gICAgICAgIGNvbnN0IGxpbmVhZ2VEaWFncmFtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcbiAgICAgICAgbGluZWFnZURpYWdyYW0uY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfX2dyYXBoJztcclxuICAgICAgICBsaW5lYWdlRGlhZ3JhbS5pZCA9ICd0cV9saW5lYWdlLWdyYXBoJztcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKGxpbmVhZ2VEaWFncmFtKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2lnbWFHcmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xyXG4gICAgICAgIHNpZ21hR3JhcGguY2xhc3NOYW1lID0gJ3RxX2xpbmVhZ2VfX3NpZ21hX2dyYXBoJztcclxuICAgICAgICBzaWdtYUdyYXBoLmlkID0gJ3RxX2xpbmVhZ2Utc2lnbWEtZ3JhcGgnO1xyXG4gICAgICAgIGJhc2VEaXYuYXBwZW5kQ2hpbGQoc2lnbWFHcmFwaCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlcml2YXRpb25NYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICBiYXNlRGl2LmFwcGVuZENoaWxkKGRlcml2YXRpb25NYXApO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb250YWluZXI6IGh0bWxOb2RlLFxyXG4gICAgICAgICAgICBiYXNlRGl2OiBiYXNlRGl2LFxyXG4gICAgICAgICAgICBsaW5lYWdlRGlhZ3JhbTogbGluZWFnZURpYWdyYW0sXHJcbiAgICAgICAgICAgIHNpZ21hR3JhcGg6IHNpZ21hR3JhcGgsXHJcbiAgICAgICAgICAgIGRlcml2YXRpb25NYXA6IGRlcml2YXRpb25NYXAsXHJcbiAgICAgICAgICAgIG1hcEhUTUxFbGVtZW50OiBfZ2V0TWFwSFRNTChfcGFyYW1ldGVycy5tYXBSb290SHRtbCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBDcmVhdGVzIGh0bWwgbWFya3VwIGZvciBtYXAuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudH0gbWFwUm9vdEh0bWwgLSBJRCBvZiByb290IGVsZW1lbnQgb3IgSFRNTEVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldE1hcEhUTUwgKG1hcFJvb3RIdG1sKSB7XHJcbiAgICAgICAgbGV0IG1hcFJvb3RIdG1sSHRtbDtcclxuICAgICAgICBpZiAodHlwZW9mIG1hcFJvb3RIdG1sID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBtYXBSb290SHRtbEh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXBSb290SHRtbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFwUm9vdEh0bWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG1hcFJvb3RIdG1sSHRtbCA9IG1hcFJvb3RIdG1sO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtYXBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAobWFwUm9vdEh0bWxIdG1sKSB7IC8vIGNoZWNrIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gQ2xlYXIgYSBjb250ZW50IG9mIHRoZSBtYXAgcm9vdCBodG1sIGVsZW1lbnRcclxuICAgICAgICAgICAgbWFwUm9vdEh0bWxIdG1sLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBwcml2YXRlIHJvb3QgZm9yIG1hcCBpbnRvIHRoZSBwdWJsaWMgcm9vdC5cclxuICAgICAgICAgICAgLy8gKFVzZXIgY2FuIGNoYW5nZSBzdHlsZSBvZiBwdWJsaWMgcm9vdClcclxuICAgICAgICAgICAgbWFwSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcclxuICAgICAgICAgICAgbWFwSFRNTEVsZW1lbnQuY2xhc3NOYW1lID0gJ3RxLWxnX19tYXAnO1xyXG4gICAgICAgICAgICBtYXBSb290SHRtbEh0bWwuYXBwZW5kQ2hpbGQobWFwSFRNTEVsZW1lbnQpOyAvLyBhZGRpbmcgdGhlIHByaXZhdGUgcm9vdCBpbnRvIHRoZSBwdWJsaWNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcEhUTUxFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIE1ha2VzIHRoZSB2aWV3LTEgdmlzaWJsZSBhbmQgdGhlIHZpZXctMiBpbnZpc2libGUuXHJcbiAgICAgKiBAZmlyZXMgY3VycmVudC12aWV3LWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3Nob3dTaWdtYUdyYXBoICgpIHtcclxuICAgICAgICBfYmFzZS5zaWdtYUdyYXBoLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcclxuXHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgX2Jhc2UubGluZWFnZURpYWdyYW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuXHJcbiAgICAgICAgaWYgKF9zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgaWYgKF9jdXJyZW50VmlldyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBfYmlyZEV5ZS5zZXRTZWxlY3RlZEVsZW1lbnQoX2xpbmVhZ2VEaWFncmFtLmdldFNlbGVjdGVkRWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgIF9iaXJkRXllLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9saW5lYWdlRGlhZ3JhbS5yZXNpemUoKTtcclxuICAgICAgICAgICAgICAgIF9iaXJkRXllLnNpZ21hR3JhcGgucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfY3VycmVudFZpZXcgPSAnYmlyZEV5ZSc7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsIF9jdXJyZW50Vmlldyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogTWFrZXMgdGhlIHZpZXctMiB2aXNpYmxlIGFuZCB0aGUgdmlldy0xIGludmlzaWJsZS5cclxuICAgICAqIEBmaXJlcyBjdXJyZW50LXZpZXctY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfc2hvd0pvaW50R3JhcGggKCkge1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgX2Jhc2Uuc2lnbWFHcmFwaC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgICAgICBfYmFzZS5saW5lYWdlRGlhZ3JhbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xyXG5cclxuICAgICAgICBpZiAoX3N0YXRlID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgICBpZiAoX2N1cnJlbnRWaWV3ICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBfbGluZWFnZURpYWdyYW0uZ2V0VmlzaWJsZU5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZE5vZGUgPSBfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlzSW52aXNpYmxlID0gdmlzaWJsZU5vZGVzLmluZGV4T2YoX2JpcmRFeWUuc2VsZWN0ZWRFbGVtZW50KSA9PT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZExpbmsgPSBfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsT2ZUaGVFbmRzSXNJbnZpc2libGUgPSB2aXNpYmxlTm9kZXMuaW5kZXhPZihcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW19iaXJkRXllLnNlbGVjdGVkRWxlbWVudC5tb2RlbC5zb3VyY2VdXHJcbiAgICAgICAgICAgICAgICAgICAgKSA9PT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9jdXNPbiA9IGlzU2VsZWN0ZWROb2RlICYmIG5vZGVJc0ludmlzaWJsZSB8fCBpc1NlbGVjdGVkTGluayAmJiBhbGxPZlRoZUVuZHNJc0ludmlzaWJsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhZ2VEaWFncmFtLnNldFNlbGVjdGVkRWxlbWVudChfYmlyZEV5ZS5zZWxlY3RlZEVsZW1lbnQsIGZvY3VzT24pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVkcmF3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVzaXplKCk7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFnZURpYWdyYW0ucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9jdXJyZW50VmlldyA9ICdsaW5lYWdlRGlhZ3JhbSc7XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjdXJyZW50LXZpZXctY2hhbmdlZCcsIF9jdXJyZW50Vmlldyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogTWFrZXMgdGhlIHZpZXctMiBhbmQgdGhlIHZpZXctMSBpbnZpc2libGUuXHJcbiAgICAgKiBAZmlyZXMgY3VycmVudC12aWV3LWNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2hpZGVWaWV3cyAoKSB7XHJcbiAgICAgICAgLy8gX2Jhc2UuY29udGFpbmVyLmNsYXNzTmFtZSA9ICd0cV9saW5lYWdlX2Rpc2FibGUnO1xyXG4gICAgICAgIF9iYXNlLnNpZ21hR3JhcGguc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgX2Jhc2Uuc2lnbWFHcmFwaC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIF9iYXNlLmxpbmVhZ2VEaWFncmFtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIF9jdXJyZW50VmlldyA9ICdub25lJztcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2N1cnJlbnQtdmlldy1jaGFuZ2VkJywgX2N1cnJlbnRWaWV3KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBMaW5lYWdlR3JhbTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5pbXBvcnQgKiBhcyBMaW5lYWdlR3JhbSBmcm9tICcuL2xpbmVhZ2VHcmFtJztcclxuaW1wb3J0IERlZmF1bHREYXRhUHJvdmlkZXIgZnJvbSAnLi9kYXRhL2RlZmF1bHREYXRhUHJvdmlkZXInO1xyXG5pbXBvcnQgSW5mb1BhbmVsIGZyb20gJy4vaHRtbFVJL2luZm9QYW5lbCc7XHJcbmltcG9ydCBPcHRpb25zUGFuZWwgZnJvbSAnLi9odG1sVUkvb3B0aW9uc1BhbmVsJztcclxuaW1wb3J0IE1hcCBmcm9tICcuL2h0bWxVSS9tYXAnO1xyXG5pbXBvcnQgRGVmYXVsdFVJIGZyb20gJy4vaHRtbFVJL2RlZmF1bHRVSSc7XHJcbmltcG9ydCB7IERlcml2YXRpb25NYXAgfSBmcm9tICcuL2pvaW50Vmlld3MvZGVyaXZhdGlvbk1hcC9kZXJpdmF0aW9uTWFwJztcclxucmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xyXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgTGluZWFnZUdyYW06IExpbmVhZ2VHcmFtLkxpbmVhZ2VHcmFtLFxyXG4gICAgZ2V0RGVmYXVsdFBhcmFtZXRlcnNTZXQ6IExpbmVhZ2VHcmFtLmdldERlZmF1bHRQYXJhbWV0ZXJzU2V0LFxyXG4gICAgRGVmYXVsdERhdGFQcm92aWRlcjogRGVmYXVsdERhdGFQcm92aWRlcixcclxuICAgIERlcml2YXRpb25NYXA6IERlcml2YXRpb25NYXAsXHJcbiAgICB1aVV0aWxzOiB7XHJcbiAgICAgICAgRGVmYXVsdFVJOiBEZWZhdWx0VUksXHJcbiAgICAgICAgTWFwOiBNYXAsXHJcbiAgICAgICAgSW5mb1BhbmVsOiBJbmZvUGFuZWwsXHJcbiAgICAgICAgT3B0aW9uc1BhbmVsOiBPcHRpb25zUGFuZWwsXHJcbiAgICB9LFxyXG59OyIsImltcG9ydCBTaWdtYUJhc2UgZnJvbSAnLi9zaWdtYUJhc2UnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4uL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCB7IGdldFBhdGggfSBmcm9tICcuLi91dGlscy9saW5lYWdlRGlhZ3JhbVV0aWxzJztcclxuXHJcbi8qKiBcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqIE1pbmkgbWFwIGluIHRoZSByaWdodC1ib3R0b20gY29ybmVyLFxyXG4gKiB3aGljaCBzaG93cyB0aGUgZnVsbCBncmFwaCB3aXRoIHZpZXdGcmFtZSdzIHBvc2l0aW9ucyB3aXRob3V0IGxpbmtzXHJcbiAqIEBhdWdtZW50cyBTaWdtYUJhc2VcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJpcmRFeWUgKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3QgX2NvbG9ycyA9IHBhcmFtZXRlcnMuY29sb3JzO1xyXG4gICAgbGV0IF9wYXRoID0gbnVsbDtcclxuXHJcbiAgICBTaWdtYUJhc2UuYXBwbHkoc2VsZiwgW29wdGlvbnMsIHBhcmFtZXRlcnNdKTtcclxuXHJcbiAgICBjb25zdCBvbGRTZXRTZWxlY3RlZEVsZW1lbnQgPSBzZWxmLnNldFNlbGVjdGVkRWxlbWVudDtcclxuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSB8fFxyXG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbk5vZGVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudC5vcmlnaW5hbE5vZGUgfHwgZWxlbWVudDtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRWxlbWVudCAhPT0gc2VsZWN0ZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIF9wYXRoID0gZ2V0UGF0aChzZWxlY3RlZEVsZW1lbnQsIHNlbGYuX2RhdGFDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3BhdGggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9sZFNldFNlbGVjdGVkRWxlbWVudC5jYWxsKHNlbGYsIHNlbGVjdGVkRWxlbWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuX3JlZnJlc2hOb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5ub2RlcygpLmZvckVhY2goc2lnbWFOb2RlID0+IHtcclxuICAgICAgICAgICAgaWYgKG5vZGVNYXBbc2lnbWFOb2RlLmlkXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXBbc2lnbWFOb2RlLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbm9kZS5tb2RlbDtcclxuICAgICAgICAgICAgICAgIHNpZ21hTm9kZS54ID0gbW9kZWwucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHNpZ21hTm9kZS55ID0gbW9kZWwucG9zaXRpb24ueTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaWdtYU5vZGUuY29sb3IgPSBzZWxmLnNlbGVjdGVkRWxlbWVudCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pZCA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cy5maWx0ZXIoYSA9PiBhLmlkID09PSBub2RlLmlkKS5sZW5ndGggPiAwXHJcbiAgICAgICAgICAgICAgICApID8gXHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snc2VsZWN0ZWQnXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgKCFfcGF0aHx8IF9wYXRoW25vZGUuaWRdID8gX2NvbG9yc1ttb2RlbC50eXBlSWRdIDogX2NvbG9yc1snYmx1cmVkJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgc2VsZi5fcmVmcmVzaExpbmtzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5lZGdlcygpLmZvckVhY2gobCA9PiB7XHJcbiAgICAgICAgICAgIGwuc2l6ZSA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIGwuaWQgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50LmlkID8gNSA6IDEsXHJcbiAgICAgICAgICAgIGwuY29sb3IgPSBcclxuICAgICAgICAgICAgICAgICFfcGF0aCB8fCBfcGF0aFtsLmlkXSA/IFxyXG4gICAgICAgICAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiYgbC5pZCA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1snc2VsZWN0ZWQnXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXNwZWN0TGlua3NbbC5pZF0gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29sb3JzWydhc3BlY3RMaW5rJ10gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29sb3JzWydsaW5rJ11cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICAgICBfY29sb3JzWydibHVyZWQnXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHNlbGYuX2luaXRpYWxpemUoKTtcclxufVxyXG5cclxuQmlyZEV5ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpZ21hQmFzZS5wcm90b3R5cGUpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmlyZEV5ZTtcclxuIiwiaW1wb3J0IFNpZ21hQmFzZSBmcm9tICcuL3NpZ21hQmFzZSc7XHJcbmltcG9ydCAqIGFzIGdyYXBoRWxlbWVudHMgZnJvbSAnLi4vam9pbnRWaWV3cy9ncmFwaEVsZW1lbnRzL2VsZW1lbnRzJztcclxuXHJcbi8qKiBcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqIE1pbmkgbWFwIGluIHRoZSByaWdodC1ib3R0b20gY29ybmVyLFxyXG4gKiB3aGljaCBzaG93cyB0aGUgZnVsbCBncmFwaCB3aXRoIHZpZXdGcmFtZSdzIHBvc2l0aW9ucyB3aXRob3V0IGxpbmtzXHJcbiAqIEBhdWdtZW50cyBTaWdtYUJhc2VcclxuICogQGZpcmVzIHZpZXctZnJhbWVzLXBvc2l0aW9uLWNoYW5nZWQgKHBhcmFtczogVmlld0ZyYW1lUHVibGljTW9kZWxbXSlcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdyYXBoTWFwIChvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGxldCBfdmlld0ZyYW1lc01hcCA9IHt9O1xyXG4gICAgb3B0aW9ucy52aWV3RnJhbWVzLmZvckVhY2godmYgPT4gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdID0gdmYpO1xyXG5cclxuICAgIFNpZ21hQmFzZS5hcHBseShzZWxmLCBbb3B0aW9ucywgcGFyYW1ldGVyc10pO1xyXG5cclxuICAgIHNlbGYuX2dldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IHNlbGYuX2RhdGFDb250YWluZXIubm9kZXMsIGxpbmtzOiBbXSB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZGVmaW5pdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdCBvbGRTZXRTZWxlY3RlZEVsZW1lbnQgPSBzZWxmLnNldFNlbGVjdGVkRWxlbWVudDtcclxuICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTm9kZSB8fFxyXG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5UZXJtaW5hdGlvbk5vZGVcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gZWxlbWVudC5vcmlnaW5hbE5vZGUgfHwgZWxlbWVudDtcclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluayA9IGVsZW1lbnQub3JpZ2luYWxMaW5rIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGxpbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGdyYXBoID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoO1xyXG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluaykge1xyXG4gICAgICAgICAgICBncmFwaC5kcm9wRWRnZShzZWxmLnNlbGVjdGVkRWxlbWVudC5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLkxpbmspIHtcclxuICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShzZWxmLl9jcmVhdGVMaW5rKHNlbGVjdGVkRWxlbWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbGRTZXRTZWxlY3RlZEVsZW1lbnQuY2FsbChzZWxmLCBzZWxlY3RlZEVsZW1lbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvdmVycmlkZVJlZHJhdyA9IHNlbGYucmVkcmF3O1xyXG4gICAgc2VsZi5yZWRyYXcgPSBmdW5jdGlvbiAocmVuZGVyT3B0aW9ucykge1xyXG4gICAgICAgIG92ZXJyaWRlUmVkcmF3KHJlbmRlck9wdGlvbnMpO1xyXG4gICAgICAgIHJlbmRlck9wdGlvbnMgPSByZW5kZXJPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmIChyZW5kZXJPcHRpb25zLnZpZXdGcmFtZXMpIHJlbmRlck9wdGlvbnMudmlld0ZyYW1lcy5mb3JFYWNoKHZmID0+IF92aWV3RnJhbWVzTWFwW3ZmLmlkXSA9IHZmKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb3ZlcnJpZGVkU2V0RGF0YSA9IHNlbGYuc2V0RGF0YTtcclxuICAgIHNlbGYuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKSB7XHJcbiAgICAgICAgb3ZlcnJpZGVkU2V0RGF0YShkYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzKTtcclxuICAgICAgICBfdmlld0ZyYW1lc01hcCA9IHt9O1xyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2ZiA9PiBfdmlld0ZyYW1lc01hcFt2Zi5pZF0gPSB2Zik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdmlld0ZyYW1lcyBzdGF0ZS4gXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsfSB2aWV3RnJhbWVzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IF9vbGRJbXBsZW1lbnRhdGlvbiA9IHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzO1xyXG4gICAgc2VsZi5fcmVmcmVzaFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAodmlld0ZyYW1lcykge1xyXG4gICAgICAgIF9vbGRJbXBsZW1lbnRhdGlvbih2aWV3RnJhbWVzKTtcclxuICAgICAgICB2aWV3RnJhbWVzLmZvckVhY2godmYgPT4gX3ZpZXdGcmFtZXNNYXBbdmYuaWRdID0gdmYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRlZmluaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3N1YnNjcmliZU9uRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5iaW5kKCdjbGlja1N0YWdlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsQ2xpY2tQb2ludCA9IF9jb25udmVydFBvaW50KGUpO1xyXG4gICAgICAgICAgICBjb25zdCB2aWV3RnJhbWVzID0gT2JqZWN0LmtleXMoX3ZpZXdGcmFtZXNNYXApLm1hcChrZXkgPT4gX3ZpZXdGcmFtZXNNYXBba2V5XSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlld0ZyYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdmlld0ZyYW1lID0gdmlld0ZyYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICghdmlld0ZyYW1lLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblg6IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluWTogdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWluWSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhYOiB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcy5tYXhYICsgdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IHZpZXdGcmFtZS52aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1heFkgKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEhpdHNUaGVCb3VuZHMgPSBib3VuZHMubWluWCA8PSBnbG9iYWxDbGlja1BvaW50LnggJiYgZ2xvYmFsQ2xpY2tQb2ludC54IDw9IGJvdW5kcy5tYXhYICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMubWluWSA8PSBnbG9iYWxDbGlja1BvaW50LnkgJiYgZ2xvYmFsQ2xpY2tQb2ludC55IDw9IGJvdW5kcy5tYXhZO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50SGl0c1RoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdGcmFtZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQb3J0UG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGdsb2JhbENsaWNrUG9pbnQueCAtIHZpZXdGcmFtZS5zaXplLndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGdsb2JhbENsaWNrUG9pbnQueSAtIHZpZXdGcmFtZS5zaXplLmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcigndmlldy1mcmFtZXMtcG9zaXRpb24tY2hhbmdlZCcsIFtbdmlld0ZyYW1lT3B0aW9uc11dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguYmluZCgnY2xpY2tOb2RlJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gZXZ0LmRhdGEubm9kZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5ub2RlTWFwW2V2dC5kYXRhLm5vZGUuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQobm9kZSk7XHJcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5iaW5kKCdjbGlja0VkZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldnQuZGF0YS5lZGdlID8gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLmxpbmtNYXBbZXZ0LmRhdGEuZWRnZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICBzZWxmLnNldFNlbGVjdGVkRWxlbWVudChsaW5rKTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQ2FsY3VsYXRlcyBzaWdtYSBwYXBlciBwb2ludCB0byBqb2ludCBwYXBlciBwb2ludC5cclxuICAgICAqIEBwYXJhbSB7XHJcbiAgICAgKiAgZGF0YToge1xyXG4gICAgICogICAgICBjcHRvcjoge1xyXG4gICAgICogICAgICAgICAgY2xpZW50WCxcclxuICAgICAqICAgICAgICAgIGNsaWVudFlcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqIH0gZXZlbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfY29ubnZlcnRQb2ludCAoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHNlbGYuc2lnbWFHcmFwaC5yZW5kZXJlcnNbMF07XHJcbiAgICAgICAgY29uc3QgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4O1xyXG4gICAgICAgIHJldHVybiBleGVjdXRlTm9kZU1vdXNlTW92ZSgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlTm9kZU1vdXNlTW92ZSAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfY2FsY3VsYXRlT2Zmc2V0KHJlbmRlcmVyLmNvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICB4ID0gZXZlbnQuZGF0YS5jYXB0b3IuY2xpZW50WCAtIG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgeSA9IGV2ZW50LmRhdGEuY2FwdG9yLmNsaWVudFkgLSBvZmZzZXQudG9wLFxyXG4gICAgICAgICAgICAgICAgY29zID0gTWF0aC5jb3Moc2VsZi5zaWdtYUdyYXBoLmNhbWVyYS5hbmdsZSksXHJcbiAgICAgICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihzZWxmLnNpZ21hR3JhcGguY2FtZXJhLmFuZ2xlKSxcclxuICAgICAgICAgICAgICAgIG5vZGVzID0gc2VsZi5zaWdtYUdyYXBoLmdyYXBoLm5vZGVzKCksXHJcbiAgICAgICAgICAgICAgICByZWYgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldHRpbmcgYW5kIGRlcm90YXRpbmcgdGhlIHJlZmVyZW5jZSBjb29yZGluYXRlcy5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYXV4ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IG4ueCAqIGNvcyArIG4ueSAqIHNpbixcclxuICAgICAgICAgICAgICAgICAgICB5OiBuLnkgKiBjb3MgLSBuLnggKiBzaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuWDogbltfcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgICAgICByZW5ZOiBuW19wcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlZi5wdXNoKGF1eCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5aW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZXMgYXJlIG9uIHRvcCBvZiBlYWNoIG90aGVyLCB3ZSB1c2UgdGhlIGNhbWVyYSByYXRpbyB0byBpbnRlcnBvbGF0ZVxyXG4gICAgICAgICAgICBpZiAocmVmWzBdLnggPT09IHJlZlsxXS54ICYmIHJlZlswXS55ID09PSByZWZbMV0ueSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhSYXRpbyA9IChyZWZbMF0ucmVuWCA9PT0gMCkgPyAxIDogcmVmWzBdLnJlblg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeVJhdGlvID0gKHJlZlswXS5yZW5ZID09PSAwKSA/IDEgOiByZWZbMF0ucmVuWTtcclxuICAgICAgICAgICAgICAgIHggPSAocmVmWzBdLnggLyB4UmF0aW8pICogKHggLSByZWZbMF0ucmVuWCkgKyByZWZbMF0ueDtcclxuICAgICAgICAgICAgICAgIHkgPSAocmVmWzBdLnkgLyB5UmF0aW8pICogKHkgLSByZWZbMF0ucmVuWSkgKyByZWZbMF0ueTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhSYXRpbyA9IChyZWZbMV0ucmVuWCAtIHJlZlswXS5yZW5YKSAvIChyZWZbMV0ueCAtIHJlZlswXS54KTtcclxuICAgICAgICAgICAgICAgIHlSYXRpbyA9IChyZWZbMV0ucmVuWSAtIHJlZlswXS5yZW5ZKSAvIChyZWZbMV0ueSAtIHJlZlswXS55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29vcmRpbmF0ZXMgYXJlIHRoZSBzYW1lLCB3ZSB1c2UgdGhlIG90aGVyIHJhdGlvIHRvIGludGVycG9sYXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocmVmWzFdLnggPT09IHJlZlswXS54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFJhdGlvID0geVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZWZbMV0ueSA9PT0gcmVmWzBdLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB5UmF0aW8gPSB4UmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeCA9ICh4IC0gcmVmWzBdLnJlblgpIC8geFJhdGlvICsgcmVmWzBdLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gKHkgLSByZWZbMF0ucmVuWSkgLyB5UmF0aW8gKyByZWZbMF0ueTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogKHggKiBjb3MgLSB5ICogc2luKSwgeTogKHkgKiBjb3MgKyB4ICogc2luKSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50IG1vcmUgYWNjdXJhdGVseSB0aGFuXHJcbiAgICAvLyBlbGVtZW50Lm9mZnNldFRvcCBhbmQgZWxlbWVudC5vZmZzZXRMZWZ0LlxyXG4gICAgZnVuY3Rpb24gX2NhbGN1bGF0ZU9mZnNldCAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gICAgICAgIHZhciBnZXRDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApLnJlcGxhY2UoJ3B4JywgJycpKSB8fCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctbGVmdCcpLFxyXG4gICAgICAgICAgICB0b3A6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctdG9wJylcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuX2luaXRpYWxpemUoKTtcclxufVxyXG5HcmFwaE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpZ21hQmFzZS5wcm90b3R5cGUpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JhcGhNYXA7XHJcbiIsImltcG9ydCBTaWdtYSBmcm9tICdzaWdtYSc7XHJcbmltcG9ydCAqIGFzIFNpZ21hU25hcHNob3RQbHVnaW4gZnJvbSAnLi9zaWdtYVBsYWdpbnMvc2lnbWEucmVuZGVyZXJzLnNuYXBzaG90L3NpZ21hLnJlbmRlcmVycy5zbmFwc2hvdCc7XHJcbmltcG9ydCBTdWJzY3JpYmFibGUgZnJvbSAnLi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGUnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4uL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcbmltcG9ydCBzYXZlQXMgZnJvbSAnZmlsZS1zYXZlcmpzJztcclxuaW1wb3J0IHsgZGF0ZTJTdHJpbmcsIHBuZzJCbG9iIH0gZnJvbSAnLi4vdXRpbHMvZGF0YVV0aWxzJztcclxuaW1wb3J0IHsgZ2V0R2xvYmFsTm9kZVBvc2l0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuU2lnbWFTbmFwc2hvdFBsdWdpbi51c2VQbHVnaW4oU2lnbWEpO1xyXG5cclxuLyoqIFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY2xhc3NcclxuICogSXQncyB0aGUgYmFzZSBjbGFzcyBmb3Igc2lnbWEgdmlld3MuXHJcbiAqIFxyXG4gKiBDb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBwYXJhbSB7XHJcbiAqICBkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyXHJcbiAqICB2aWV3RnJhbWVzOiBWaWV3RnJhbWVQdWJsaWNNb2RlbFtdXHJcbiAqICBlbDogSFRNTEVsZW1lbnRcclxuICogIHNlbGVjdGVkRWxlbWVudDogTm9kZXxMaW5rXHJcbiAqICBzY2FsZTpudW1iZXJcclxuICogfSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVycyAtIHBhcmFtZXRlcnMgc2V0XHJcbiAqIFxyXG4gKiBQdWJsaWMgcHJvcGVydGllczpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBzZWxlY3RlZEVsZW1lbnQ6IE5vZGV8TGlua1xyXG4gKiBcclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogc2V0U2VsZWN0ZWRFbGVtZW50OiAoZWxlbWVudDogTm9kZXxMaW5rKSA9PiB2b2lkXHJcbiAqIHNldERhdGE6IChkYXRhQ29udGFpbmVyOiBEYXRhQ29udGFpbmVyLCB2aWV3RnJhbWVzOiBWaWV3RnJhbWVbXSkgPT4gdm9pZFxyXG4gKiBzZXRTY2FsZTogKHNjYWxlOiBudW1iZXIpID0+IHZvaWRcclxuICogcmVmcmVzaDogKCkgPT4gdm9pZFxyXG4gKiBleHBvcnQ6IChuYW1lPzogc3RyaW5nKSA9PiB2b2lkXHJcbiAqIHByaW50OiAoKSA9PiB2b2lkXHJcbiAqIHJlZHJhdzogKCkgPT4gdm9pZFxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIG9uIChldmVudDogc3RyaW5nLCBjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHVuc3Vic2NyaWJlIChjYWxsYmFjazogZnVuY3Rpb24pOiB2b2lkXHJcbiAqIHRyaWdnZXIgKGV2ZW50OiBzdHJpbmcsIHBhcmFtZXRlcnM6IGFueSk6IHZvaWRcclxuICogXHJcbiAqIEV2ZW50czpcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAZmlyZXMgc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkIChwYXJhbXM6IE5vZGV8TGluaylcclxuICogQGZpcmVzIGNlbGwtZG91YmxlLWNsaWNrIChwYXJhbXM6IE5vZGV8TGluaylcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNpZ21hQmFzZSAob3B0aW9ucywgcGFyYW1ldGVycykge1xyXG5cclxuICAgIFN1YnNjcmliYWJsZS5hcHBseSh0aGlzKTsgICAvLyBtYWtlIHRoaXMgY2xhc3MgU3Vic2NyaWJhYmxlXHJcblxyXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBfY29sb3JzID0gcGFyYW1ldGVycy5jb2xvcnM7XHJcblxyXG4gICAgbGV0IF9tYXhOb2RlU2l6ZSA9IDA7XHJcbiAgICBsZXQgX3Jvb3RFbGVtZW50O1xyXG4gICAgbGV0IF9zaWdtYUZyYW1lcyA9IHt9O1xyXG5cclxuICAgIHNlbGYuX2FzcGVjdExpbmtzID0ge307XHJcbiAgICBzZWxmLnNlbGVjdGVkRWxlbWVudDtcclxuICAgIHNlbGYuX2RhdGFDb250YWluZXI7ICAgIC8vIHRvIG92ZXJyaWRlXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBpbml0aWFsaXphdGlvbi4gSXQncyBleGVjdXRlZCBhZnRlciBjcmVhdGlvbiBieSBkZXNjZW5kYW50XHJcbiAgICAgKi9cclxuICAgIHNlbGYuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX2luaXRpYWxpemUoXHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YUNvbnRhaW5lcixcclxuICAgICAgICAgICAgb3B0aW9ucy52aWV3RnJhbWVzLFxyXG4gICAgICAgICAgICBvcHRpb25zLmVsLFxyXG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdGVkRWxlbWVudCxcclxuICAgICAgICAgICAgb3B0aW9ucy5zY2FsZVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXQncyBraW5kIG9mIGNvbnN0cnVjdG9yLCB3aGljaCBjYWxsZWQgYWZ0ZXIgY3JlYXRpb24gdGhlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHtBcnJheSBvZiBWaWV3RnJhbWV9IHZpZXdGcmFtZXNcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge05vZGV8TGlua30gc2VsZWN0ZWRFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBfaW5pdGlhbGl6ZSAoXHJcbiAgICAgICAgZGF0YUNvbnRhaW5lcixcclxuICAgICAgICB2aWV3RnJhbWVzLFxyXG4gICAgICAgIHJvb3RFbGVtZW50LFxyXG4gICAgICAgIHNlbGVjdGVkRWxlbWVudCxcclxuICAgICkge1xyXG4gICAgICAgIF9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xyXG4gICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIHZpZXdGcmFtZXMgPSB2aWV3RnJhbWVzIHx8IFtdO1xyXG4gICAgICAgIHNlbGYuX2RhdGFDb250YWluZXIgPSBkYXRhQ29udGFpbmVyO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHNlbGYuX2dldERhdGEoKTtcclxuICAgICAgICBjb25zdCBnID0ge1xyXG4gICAgICAgICAgICBub2RlczogW10sXHJcbiAgICAgICAgICAgIGVkZ2VzOiBbXSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBkYXRhLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBzZWxmLl9jcmVhdGVOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICBnLm5vZGVzLnB1c2gobmV3Tm9kZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRhdGEubGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3TGluayA9IHNlbGYuX2NyZWF0ZUxpbmsobGluayk7XHJcbiAgICAgICAgICAgIGcuZWRnZXMucHVzaChuZXdMaW5rKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgYXNwZWN0TGlua3MgPSBfY3JlYXRlQXNwZWN0TGlua3MoZGF0YS5ub2Rlcyk7XHJcbiAgICAgICAgYXNwZWN0TGlua3MuZm9yRWFjaChhbCA9PiB7XHJcbiAgICAgICAgICAgIGcuZWRnZXMucHVzaChhbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9tYXhOb2RlU2l6ZSA9IF9nZXROb2RlU2l6ZSgpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGggPSBuZXcgU2lnbWEoe1xyXG4gICAgICAgICAgICBncmFwaDogZyxcclxuICAgICAgICAgICAgY29udGFpbmVyOiBfcm9vdEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBtaW5Ob2RlU2l6ZTogMCxcclxuICAgICAgICAgICAgICAgIG1heE5vZGVTaXplOiBfbWF4Tm9kZVNpemUsXHJcbiAgICAgICAgICAgICAgICBub2Rlc1Bvd1JhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlRWRnZUhvdmVyaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRFZGdlSG92ZXJDb2xvcjogJyMwMDAnLFxyXG4gICAgICAgICAgICAgICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiA0LFxyXG4gICAgICAgICAgICAgICAgZWRnZUhvdmVyRXh0cmVtaXRpZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNsb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvOiAxLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2VsZi5fc3Vic2NyaWJlT25FdmVudHMoKTtcclxuICAgICAgICBfbWF4Tm9kZVNpemUgPSBfZ2V0Tm9kZVNpemUoKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguc2V0dGluZ3MoJ21heE5vZGVTaXplJywgX21heE5vZGVTaXplKTtcclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3RnJhbWUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfYWRkVmlld0ZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXSA9IF9jcmVhdGVTaWdtYUZyYW1lKHZpZXdGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgZ3JhcGggdG8gcG5nIGZpbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFncmFtTmFtZVxyXG4gICAgKi9cclxuICAgIHNlbGYuZXhwb3J0ID0gZnVuY3Rpb24gKGRpYWdyYW1OYW1lKSB7XHJcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBkaWFncmFtTmFtZSB8fCAnTEdfYmlyZF9leWVfc25hcHNob3RfJyArIGRhdGUyU3RyaW5nKG5ldyBEYXRlKCkpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZWxmLnNpZ21hR3JhcGgucmVuZGVyZXJzWzBdLnNuYXBzaG90KHtcclxuICAgICAgICAgICAgZm9ybWF0OiAncG5nJyxcclxuICAgICAgICAgICAgZG93bmxvYWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBsYWJlbHM6IHRydWUsXHJcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2F2ZUFzKHBuZzJCbG9iKGRhdGEpLCBmaWxlTmFtZSArICcucG5nJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0cyBncmFwaCB0byBwZGYgZmlsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpYWdyYW1OYW1lXHJcbiAgICAqL1xyXG4gICAgc2VsZi5wcmludCA9IGZ1bmN0aW9uIChkaWFncmFtTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gZGlhZ3JhbU5hbWUgfHwgJ0xHX2JpcmRfZXllX3NuYXBzaG90XycgKyBkYXRlMlN0cmluZyhuZXcgRGF0ZSgpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gc2VsZi5zaWdtYUdyYXBoLnJlbmRlcmVyc1swXS5zbmFwc2hvdCh7XHJcbiAgICAgICAgICAgIGZvcm1hdDogJ3BuZycsXHJcbiAgICAgICAgICAgIGRvd25sb2FkOiBmYWxzZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgbGFiZWxzOiB0cnVlLFxyXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcHJpbnRXaW5kb3cgPSB3aW5kb3cub3BlbignJywgdW5kZWZpbmVkLCAnd2lkdGg9MTI4MCxoZWlnaHQ9NzIwJyk7XHJcbiAgICAgICAgaWYgKHByaW50V2luZG93KSB7XHJcbiAgICAgICAgICAgIHByaW50V2luZG93LmRvY3VtZW50LndyaXRlKGBcclxuICAgICAgICAgICAgICAgIDxodG1sPlxyXG4gICAgICAgICAgICAgICAgICAgIDxib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIiR7ZGF0YX1cIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9ib2R5PlxyXG4gICAgICAgICAgICAgICAgPC9odG1sPlxyXG4gICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW1nJykub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJpbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIHByaW50V2luZG93LnByaW50KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWxlcnQoJ1lvdSBzaG91bGQgdW5ibG9jayBwb3B1cCB3aW5kb3dzIGZvciB0aGUgY3VycmVudCB1cmwgdG8gYmUgYWJsZSB0byBwcmludCB0aGlzIGRpYWdyYW0hJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2VsZWN0ZWQgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7Tm9kZXxMaW5rfSBlbGVtZW50XHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXRTZWxlY3RlZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgZ3JhcGhFbGVtZW50cy5Ob2RlIHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBncmFwaEVsZW1lbnRzLlRlcm1pbmF0aW9uTm9kZVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBlbGVtZW50Lm9yaWdpbmFsTm9kZSB8fCBlbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIGdyYXBoRWxlbWVudHMuTGluaykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZWxlbWVudC5vcmlnaW5hbExpbmsgfHwgZWxlbWVudDtcclxuICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbGluaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcmVmcmVzaCA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICE9PSBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHJlZnJlc2gpIHNlbGYucmVkcmF3KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgZGF0YSBjb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7RGF0YUNvbnRhaW5lcn0gZGF0YUNvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbFtdfSB2aWV3RnJhbWVzXHJcbiAgICAqL1xyXG4gICAgc2VsZi5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGFDb250YWluZXIsIHZpZXdGcmFtZXMpIHtcclxuICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgc2VsZi5fZGF0YUNvbnRhaW5lciA9IGRhdGFDb250YWluZXI7XHJcbiAgICAgICAgdmlld0ZyYW1lcyA9IHZpZXdGcmFtZXMgfHwgW107XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZWxmLl9nZXREYXRhKCk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5jbGVhcigpO1xyXG4gICAgICAgIF9tYXhOb2RlU2l6ZSA9IF9nZXROb2RlU2l6ZSgpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5zZXR0aW5ncygnbWF4Tm9kZVNpemUnLCBfbWF4Tm9kZVNpemUpO1xyXG5cclxuICAgICAgICBkYXRhLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBzZWxmLl9jcmVhdGVOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShuZXdOb2RlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmlld0ZyYW1lcy5mb3JFYWNoKHZpZXdGcmFtZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gX2NyZWF0ZVNpZ21hRnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gPSBmcmFtZTtcclxuICAgICAgICAgICAgaWYgKHZpZXdGcmFtZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIF9hZGRWaWV3RnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9zaWdtYUZyYW1lc1t2aWV3RnJhbWUuaWRdID0gX2NyZWF0ZVNpZ21hRnJhbWUodmlld0ZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBhc3BlY3RMaW5rcyA9IF9jcmVhdGVBc3BlY3RMaW5rcyhkYXRhLm5vZGVzKTtcclxuICAgICAgICBhc3BlY3RMaW5rcy5mb3JFYWNoKGFsID0+IHtcclxuICAgICAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UoYWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkYXRhLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0xpbmsgPSBzZWxmLl9jcmVhdGVMaW5rKGxpbmspO1xyXG4gICAgICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShuZXdMaW5rKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnJlZnJlc2goKTtcclxuICAgICAgICBzZWxmLnJlZHJhdygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZGVib3VuY2VyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIGFsbCBncmFwaC4gTWFpbmx5IC0gdXBkYXRlcyBjb2xvcnMgb2YgZWxlbWVudHNcclxuICAgICAqIEBwYXJhbSB7dmlld0ZyYW1lcywgc2NhbGUsIG5vZGVzLCBmdWxsU2NyZWVuTW9kZX0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzZWxmLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgX21heE5vZGVTaXplID0gX2dldE5vZGVTaXplKCk7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLnNldHRpbmdzKCdtYXhOb2RlU2l6ZScsIF9tYXhOb2RlU2l6ZSk7XHJcblxyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGRlYm91bmNlcik7XHJcbiAgICAgICAgZGVib3VuY2VyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgc2VsZi5fcmVmcmVzaE5vZGVzKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlZnJlc2hMaW5rcygpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnZpZXdGcmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3JlZnJlc2hWaWV3RnJhbWVzKG9wdGlvbnMudmlld0ZyYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBzZWxmLnNpZ21hR3JhcGgucmVmcmVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjYW4gYmUgb3ZlcnJpZGVkXHJcbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5yZWRyYXcoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBsaW5rcyBzdGF0ZXMuIFxyXG4gICAgICovXHJcbiAgICBzZWxmLl9yZWZyZXNoTGlua3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZWRnZXMgPSBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZWRnZXMoKTtcclxuICAgICAgICBlZGdlcy5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBsLmlkLmluZGV4T2YoJ19fdG9wJykgPT09IC0xICYmXHJcbiAgICAgICAgICAgICAgICBsLmlkLmluZGV4T2YoJ19fYm90dG9tJykgPT09IC0xICYmXHJcbiAgICAgICAgICAgICAgICBsLmlkLmluZGV4T2YoJ19fbGVmdCcpID09PSAtMSAmJlxyXG4gICAgICAgICAgICAgICAgbC5pZC5pbmRleE9mKCdfX3JpZ2h0JykgPT09IC0xXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgbC5zaXplID0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiYgbC5pZCA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgPyA1IDogMSxcclxuICAgICAgICAgICAgICAgICAgICBsLmNvbG9yID0gc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiYgbC5pZCA9PT0gc2VsZi5zZWxlY3RlZEVsZW1lbnQuaWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29sb3JzWydzZWxlY3RlZCddIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYuX2FzcGVjdExpbmtzW2wuaWRdID8gX2NvbG9yc1snYXNwZWN0TGluayddIDogX2NvbG9yc1snbGluayddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIG5vZGVzIHN0YXRlcy4gXHJcbiAgICAgKi9cclxuICAgIHNlbGYuX3JlZnJlc2hOb2RlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXA7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBzZWxmLnNpZ21hR3JhcGguZ3JhcGgubm9kZXMoKTtcclxuICAgICAgICBub2Rlcy5mb3JFYWNoKHNpZ21hTm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlTWFwW3NpZ21hTm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwW3NpZ21hTm9kZS5pZF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIHNpZ21hTm9kZS54ID0gcG9zaXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHNpZ21hTm9kZS55ID0gcG9zaXRpb24ueTtcclxuICAgICAgICAgICAgICAgIHNpZ21hTm9kZS5jb2xvciA9IHNlbGYuc2VsZWN0ZWRFbGVtZW50ICYmIChcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRWxlbWVudC5pZCA9PT0gc2lnbWFOb2RlLmlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQuYXNwZWN0cyAmJiBzZWxmLnNlbGVjdGVkRWxlbWVudC5hc3BlY3RzLmZpbHRlcihhID0+IGEuaWQgPT09IHNpZ21hTm9kZS5pZCkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgKSA/IF9jb2xvcnNbJ3NlbGVjdGVkJ10gOiBfY29sb3JzW25vZGUubW9kZWwudHlwZUlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdmlld0ZyYW1lcyBzdGF0ZS4gXHJcbiAgICAgKiBAcGFyYW0ge1ZpZXdGcmFtZVB1YmxpY01vZGVsW119IHZpZXdGcmFtZXNcclxuICAgICAqL1xyXG4gICAgc2VsZi5fcmVmcmVzaFZpZXdGcmFtZXMgPSBmdW5jdGlvbiAodmlld0ZyYW1lcykge1xyXG4gICAgICAgIHZpZXdGcmFtZXMuZm9yRWFjaCh2aWV3RnJhbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld0ZyYW1lLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IF9nZXRGcmFtZXNQb2ludHModmlld0ZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMS54ID0gcG9pbnRzLnAxLng7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wMS55ID0gcG9pbnRzLnAxLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnJhbWUucDIueCA9IHBvaW50cy5wMi54O1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucDIueSA9IHBvaW50cy5wMi55O1xyXG5cclxuICAgICAgICAgICAgICAgIGZyYW1lLnAzLnggPSBwb2ludHMucDMueDtcclxuICAgICAgICAgICAgICAgIGZyYW1lLnAzLnkgPSBwb2ludHMucDMueTtcclxuXHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wNC54ID0gcG9pbnRzLnA0Lng7XHJcbiAgICAgICAgICAgICAgICBmcmFtZS5wNC55ID0gcG9pbnRzLnA0Lnk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2FkZFZpZXdGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3JlbW92ZVZpZXdGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB2aWV3RnJhbWUgb24gdGhlIHNpZ21hIGdyYXBoLlxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH0gdmlld0ZyYW1lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9hZGRWaWV3RnJhbWUgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGZyYW1lID0gX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0gPVxyXG4gICAgICAgICAgICBfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXSB8fCBfY3JlYXRlU2lnbWFGcmFtZSh2aWV3RnJhbWUpO1xyXG4gICAgICAgIGlmICghdmlld0ZyYW1lIHx8IGZyYW1lLmFjdGl2ZSkgcmV0dXJuOyAgICAgICAgXHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGROb2RlKGZyYW1lLnAxKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkTm9kZShmcmFtZS5wMik7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZE5vZGUoZnJhbWUucDMpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGROb2RlKGZyYW1lLnA0KTtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmFkZEVkZ2UoZnJhbWUudG9wKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguYWRkRWRnZShmcmFtZS5ib3R0b20pO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGZyYW1lLmxlZnQpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5hZGRFZGdlKGZyYW1lLnJpZ2h0KTtcclxuXHJcbiAgICAgICAgZnJhbWUuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdmlld0ZyYW1lIGZyb20gdGhlIHNpZ21hIGdyYXBoLlxyXG4gICAgICogQHBhcmFtIHtWaWV3RnJhbWVQdWJsaWNNb2RlbH0gdmlld0ZyYW1lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZW1vdmVWaWV3RnJhbWUgKHZpZXdGcmFtZSkge1xyXG4gICAgICAgIGlmICghdmlld0ZyYW1lIHx8ICFfc2lnbWFGcmFtZXNbdmlld0ZyYW1lLmlkXS5hY3RpdmUpIHJldHVybjtcclxuXHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmdyYXBoLmRyb3BFZGdlKHZpZXdGcmFtZS5pZCArICdfX3RvcCcpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5kcm9wRWRnZSh2aWV3RnJhbWUuaWQgKyAnX19ib3R0b20nKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcEVkZ2Uodmlld0ZyYW1lLmlkICsgJ19fbGVmdCcpO1xyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5ncmFwaC5kcm9wRWRnZSh2aWV3RnJhbWUuaWQgKyAnX19yaWdodCcpO1xyXG5cclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcE5vZGUodmlld0ZyYW1lLmlkICsgJ19fVEwnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcE5vZGUodmlld0ZyYW1lLmlkICsgJ19fQkwnKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcE5vZGUodmlld0ZyYW1lLmlkICsgJ19fVFInKTtcclxuICAgICAgICBzZWxmLnNpZ21hR3JhcGguZ3JhcGguZHJvcE5vZGUodmlld0ZyYW1lLmlkICsgJ19fQlInKTtcclxuXHJcbiAgICAgICAgX3NpZ21hRnJhbWVzW3ZpZXdGcmFtZS5pZF0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGxpbmtzIGFuZCBub2Rlcy5cclxuICAgICAqIEByZXR1cm5zIHt7Tm9kZVtdLCBMaW5rW119fVxyXG4gICAgICovXHJcbiAgICBzZWxmLl9nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBzZWxmLl9kYXRhQ29udGFpbmVyLm5vZGVzLCBsaW5rczogc2VsZi5fZGF0YUNvbnRhaW5lci5saW5rcyB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgc2lnbWEgbm9kZSBmcm9tIGpvaW50anMgbm9kZS5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBcclxuICAgICAqL1xyXG4gICAgc2VsZi5fY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICAgICAgY29uc3QgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICBsYWJlbDogbW9kZWwubGFiZWwsXHJcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIGNvbG9yOiBub2RlID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudCB8fCAoc2VsZi5zZWxlY3RlZEVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMgJiZcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50LmFzcGVjdHMuZmlsdGVyKGEgPT4gYS5pZCA9PT0gbm9kZS5pZCkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICApID8gX2NvbG9yc1snc2VsZWN0ZWQnXSA6IF9jb2xvcnNbbW9kZWwudHlwZUlkXSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgc2lnbWEgZWRnZSBmcm9tIGpvaW50anMgbGluay5cclxuICAgICAqIEBwYXJhbSB7TGlua30gbGluayBcclxuICAgICAqL1xyXG4gICAgc2VsZi5fY3JlYXRlTGluayA9IGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGxpbmsuaWQsXHJcbiAgICAgICAgICAgIHNvdXJjZTogbGluay5tb2RlbC5zb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogbGluay5tb2RlbC50YXJnZXQsXHJcbiAgICAgICAgICAgIHNpemU6IGxpbmsgPT09IHNlbGYuc2VsZWN0ZWRFbGVtZW50ID8gNSA6IDEsXHJcbiAgICAgICAgICAgIGNvbG9yOiBsaW5rID09PSBzZWxmLnNlbGVjdGVkRWxlbWVudCA/IF9jb2xvcnNbJ3NlbGVjdGVkJ10gOiAnYmxhY2snLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlcyBvbiBldmVudHMuXHJcbiAgICAgKiBAZmlyZXM6IHNlbGVjdGVkLWVsZW1lbnQtY2hhbmdlZCAocGFyYW1zOiBOb2RlfExpbmspXHJcbiAgICAgKiBAZmlyZXM6IGNlbGwtZG91YmxlLWNsaWNrIChwYXJhbXM6IE5vZGV8TGluaylcclxuICAgICAqL1xyXG4gICAgc2VsZi5fc3Vic2NyaWJlT25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5zaWdtYUdyYXBoLmJpbmQoJ2NsaWNrTm9kZSBjbGlja1N0YWdlJywgZSA9PiBfb25DbGljayhlLCBcclxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gZXZlbnQuZGF0YS5ub2RlID8gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLm5vZGVNYXBbZXZlbnQuZGF0YS5ub2RlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSB8fCAhZXZlbnQuZGF0YS5jYXB0b3IuaXNEcmFnZ2luZyAmJiAhbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkJywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmRhdGEuZWRnZSA/IHNlbGYuX2RhdGFDb250YWluZXIubWFwcy5saW5rTWFwW2V2ZW50LmRhdGEuZWRnZS5pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdjZWxsLWRvdWJsZS1jbGljaycsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKSk7XHJcblxyXG4gICAgICAgIHNlbGYuc2lnbWFHcmFwaC5iaW5kKCdjbGlja0VkZ2UnLCBlID0+IF9vbkNsaWNrKGUsIFxyXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSBldmVudC5kYXRhLmVkZ2UgPyBzZWxmLl9kYXRhQ29udGFpbmVyLm1hcHMubGlua01hcFtldmVudC5kYXRhLmVkZ2UuaWRdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2V0U2VsZWN0ZWRFbGVtZW50KGxpbmspO1xyXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWQnLCBsaW5rKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZXZlbnQuZGF0YS5lZGdlID8gc2VsZi5fZGF0YUNvbnRhaW5lci5tYXBzLmxpbmtNYXBbZXZlbnQuZGF0YS5lZGdlLmlkXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2NlbGwtZG91YmxlLWNsaWNrJywgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGRlZmF1bHQgc2l6ZSBmb3Igbm9kZXMuIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0Tm9kZVNpemUgKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RhdGFDb250YWluZXIubm9kZXMubGVuZ3RoIDw9IDApIHJldHVybiAwO1xyXG4gICAgICAgIGlmIChzZWxmLnNpZ21hR3JhcGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBzZWxmLnNpZ21hR3JhcGgucmVuZGVyZXJzWzBdIHx8IHsgd2lkdGg6IF9yb290RWxlbWVudC5jbGllbnRXaWR0aCwgaGVpZ2h0OiBfcm9vdEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB9O1xyXG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5lbGVtZW50U2l6ZS53aWR0aCA+IHBhcmFtZXRlcnMuZWxlbWVudFNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZW5kZXJlci53aWR0aCAvIChwYXJhbWV0ZXJzLmVsZW1lbnRTaXplLndpZHRoICsgcGFyYW1ldGVycy5sYXlvdXRTdGVwLngpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVuZGVyZXIuaGVpZ2h0IC8gKHBhcmFtZXRlcnMuZWxlbWVudFNpemUuaGVpZ2h0ICsgcGFyYW1ldGVycy5sYXlvdXRTdGVwLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGYuX2dldE5vZGVTaXplKSByZXR1cm4gc2VsZi5fZ2V0Tm9kZVNpemUocmVzdWx0KTtcclxuICAgICAgICBlbHNlIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFzcGVjdCBsaW5rcy5cclxuICAgICAqIEBwYXJhbSB7Tm9kZVtdfSBub2Rlc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlQXNwZWN0TGlua3MgKG5vZGVzKSB7XHJcbiAgICAgICAgc2VsZi5fYXNwZWN0TGlua3MgPSB7fTtcclxuICAgICAgICBjb25zdCBsaW5rc1RvUmV0dXJuID0gW107XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgbGV0IGFzcGVjdHMgPSBub2RlLmFzcGVjdHM7XHJcblxyXG4gICAgICAgICAgICBhc3BlY3RzLmZvckVhY2goYXNwZWN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGFkZExpbmsobm9kZSwgYXNwZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZExpbmsgKG5vZGUsIGFzcGVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpZDEgPSBub2RlLmlkICsgJ34jdHFMZ0FzcGVjdExpbmsjficgKyBhc3BlY3QuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkMiA9IGFzcGVjdC5pZCArICd+I3RxTGdBc3BlY3RMaW5rI34nICsgbm9kZS5pZDtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2VsZi5fYXNwZWN0TGlua3NbaWQxXSAmJiAhc2VsZi5fYXNwZWN0TGlua3NbaWQyXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkMSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBhc3BlY3QuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IF9jb2xvcnNbJ2FzcGVjdExpbmsnXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9hc3BlY3RMaW5rc1tpZDFdID0gYWw7XHJcbiAgICAgICAgICAgICAgICBsaW5rc1RvUmV0dXJuLnB1c2goYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGlua3NUb1JldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgc2lnbWEgbm90YXRpb24gb2YgdGhlIGpvaW50IHZpZXdGcmFtZSBhbmQgcGxhY2VzIG9uIHRoZSBzaWdtYSBncmFwaC5cclxuICAgICAqIEBwYXJhbSB7Vmlld0ZyYW1lUHVibGljTW9kZWx9IHZpZXdGcmFtZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfY3JlYXRlU2lnbWFGcmFtZSAodmlld0ZyYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gX2dldEZyYW1lc1BvaW50cyh2aWV3RnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gdmlld0ZyYW1lLmJvcmRlckNvbG9yO1xyXG5cclxuICAgICAgICAvLyBub2Rlc1xyXG5cclxuICAgICAgICBjb25zdCBwMSA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX1RMJyxcclxuICAgICAgICAgICAgbGFiZWw6IHZpZXdGcmFtZS5pZCxcclxuICAgICAgICAgICAgeDogcG9pbnRzLnAxLngsXHJcbiAgICAgICAgICAgIHk6IHBvaW50cy5wMS55LFxyXG4gICAgICAgICAgICBzaXplOiAwLjMsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBwMiA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX0JMJyxcclxuICAgICAgICAgICAgbGFiZWw6IHZpZXdGcmFtZS5pZCxcclxuICAgICAgICAgICAgeDogcG9pbnRzLnAzLngsXHJcbiAgICAgICAgICAgIHk6IHBvaW50cy5wMy55LFxyXG4gICAgICAgICAgICBzaXplOiAwLjMsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBwMyA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX1RSJyxcclxuICAgICAgICAgICAgbGFiZWw6IHZpZXdGcmFtZS5pZCxcclxuICAgICAgICAgICAgeDogcG9pbnRzLnAyLngsXHJcbiAgICAgICAgICAgIHk6IHBvaW50cy5wMi55LFxyXG4gICAgICAgICAgICBzaXplOiAwLjMsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBwNCA9IHtcclxuICAgICAgICAgICAgaWQ6IHZpZXdGcmFtZS5pZCArICdfX0JSJyxcclxuICAgICAgICAgICAgbGFiZWw6IHZpZXdGcmFtZS5pZCxcclxuICAgICAgICAgICAgeDogcG9pbnRzLnA0LngsXHJcbiAgICAgICAgICAgIHk6IHBvaW50cy5wNC55LFxyXG4gICAgICAgICAgICBzaXplOiAwLjMsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFZGdlc1xyXG5cclxuICAgICAgICBjb25zdCB0b3AgPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX190b3AnLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHZpZXdGcmFtZS5pZCArICdfX1RMJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB2aWV3RnJhbWUuaWQgKyAnX19UUicsXHJcbiAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBib3R0b20gPSB7XHJcbiAgICAgICAgICAgIGlkOiB2aWV3RnJhbWUuaWQgKyAnX19ib3R0b20nLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHZpZXdGcmFtZS5pZCArICdfX0JMJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB2aWV3RnJhbWUuaWQgKyAnX19CUicsXHJcbiAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBsZWZ0ID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fbGVmdCcsXHJcbiAgICAgICAgICAgIHNvdXJjZTogdmlld0ZyYW1lLmlkICsgJ19fVEwnLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHZpZXdGcmFtZS5pZCArICdfX0JMJyxcclxuICAgICAgICAgICAgc2l6ZTogMTAsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0ge1xyXG4gICAgICAgICAgICBpZDogdmlld0ZyYW1lLmlkICsgJ19fcmlnaHQnLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHZpZXdGcmFtZS5pZCArICdfX1RSJyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB2aWV3RnJhbWUuaWQgKyAnX19CUicsXHJcbiAgICAgICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwMTogcDEsXHJcbiAgICAgICAgICAgIHAyOiBwMixcclxuICAgICAgICAgICAgcDM6IHAzLFxyXG4gICAgICAgICAgICBwNDogcDQsXHJcblxyXG4gICAgICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcclxuXHJcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfZ2V0RnJhbWVzUG9pbnRzICh2aWV3RnJhbWUpIHtcclxuICAgICAgICBjb25zdCBwMSA9IHtcclxuICAgICAgICAgICAgeDogdmlld0ZyYW1lLnZpZXdQb3J0Qm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgIHk6IHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy5taW5ZLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IHg6IHAxLnggKyB2aWV3RnJhbWUudmlld1BvcnRCb3VuZHMud2lkdGgsIHk6IHAxLnkgfTtcclxuICAgICAgICBjb25zdCBwMyA9IHsgeDogcDEueCwgeTogcDEueSArIHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy5oZWlnaHQgfTtcclxuICAgICAgICBjb25zdCBwNCA9IHsgeDogcDEueCArIHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy53aWR0aCwgeTogcDEueSArIHZpZXdGcmFtZS52aWV3UG9ydEJvdW5kcy5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcDE6IHAxLFxyXG4gICAgICAgICAgICBwMjogcDIsXHJcbiAgICAgICAgICAgIHAzOiBwMyxcclxuICAgICAgICAgICAgcDQ6IHA0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRml4aW5nIHRoZSBzaWdtYSBidWcgd2l0aCBob3Jpem9udGFsL3ZlcnRpY2FsIGxpbmVzIGhvdmVyaW5nLlxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBTaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50ID0gZnVuY3Rpb24gKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XHJcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI4MTIyXHJcbiAgICAgICAgdmFyIGNyb3NzUHJvZHVjdCA9IE1hdGguYWJzKCh5IC0geTEpICogKHgyIC0geDEpIC0gKHggLSB4MSkgKiAoeTIgLSB5MSkpLFxyXG4gICAgICAgICAgICBkID0gU2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpLFxyXG4gICAgICAgICAgICBuQ3Jvc3NQcm9kdWN0ID0gY3Jvc3NQcm9kdWN0IC8gZDsgLy8gbm9ybWFsaXplZCBjcm9zcyBwcm9kdWN0XHJcblxyXG4gICAgICAgIHJldHVybiAobkNyb3NzUHJvZHVjdCA8IGVwc2lsb24gJiZcclxuICAgICAgICAgICAgTWF0aC5taW4oeDEsIHgyKSAtIGVwc2lsb24gPD0geCAmJiB4IDw9IE1hdGgubWF4KHgxLCB4MikgKyBlcHNpbG9uICYmXHJcbiAgICAgICAgICAgIE1hdGgubWluKHkxLCB5MikgLSBlcHNpbG9uIDw9IHkgJiYgeSA8PSBNYXRoLm1heCh5MSwgeTIpICsgZXBzaWxvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBfY2xpY2tzID0gMDtcclxuICAgIGZ1bmN0aW9uIF9vbkNsaWNrIChldmVudCwgY2xpY2tDYWxsYmFjaywgZG91YmxlQ2xpY2tDYWxsYmFjaykge1xyXG4gICAgICAgIF9jbGlja3MrKztcclxuXHJcbiAgICAgICAgaWYgKF9jbGlja3MgPj0gMikge1xyXG4gICAgICAgICAgICBfY2xpY2tzID0gMDtcclxuICAgICAgICAgICAgZG91YmxlQ2xpY2tDYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfY2xpY2tzID09PSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jbGlja3MgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGlja0NhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9jbGlja3MgPSAwO1xyXG4gICAgICAgICAgICB9LCAyNTApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBTaWdtYUJhc2U7XHJcbiIsImV4cG9ydCBmdW5jdGlvbiB1c2VQbHVnaW4gKHNpZ21hKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWdtYSBSZW5kZXJlciBTbmFwc2hvdCBVdGlsaXR5XHJcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICpcclxuICAgICAqIFRoZSBhaW0gb2YgdGhpcyBwbHVnaW4gaXMgdG8gZW5hYmxlIHVzZXJzIHRvIHJldHJpZXZlIGEgc3RhdGljIGltYWdlXHJcbiAgICAgKiBvZiB0aGUgZ3JhcGggYmVpbmcgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQXV0aG9yOiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKVxyXG4gICAgICogVmVyc2lvbjogMC4wLjFcclxuICAgICAqL1xyXG5cclxuICAgIC8vIFRlcm1pbmF0aW5nIGlmIHNpZ21hIHdlcmUgbm90IHRvIGJlIGZvdW5kXHJcbiAgICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLnNuYXBzaG90OiBzaWdtYSBub3QgaW4gc2NvcGUuJztcclxuXHJcbiAgICAvLyBDb25zdGFudHNcclxuICAgIHZhciBDT05URVhUUyA9IFsnc2NlbmUnLCAnZWRnZXMnLCAnbm9kZXMnLCAnbGFiZWxzJ10sXHJcbiAgICAgICAgVFlQRVMgPSB7XHJcbiAgICAgICAgICAgIHBuZzogJ2ltYWdlL3BuZycsXHJcbiAgICAgICAgICAgIGpwZzogJ2ltYWdlL2pwZWcnLFxyXG4gICAgICAgICAgICBnaWY6ICdpbWFnZS9naWYnLFxyXG4gICAgICAgICAgICB0aWZmOiAnaW1hZ2UvdGlmZidcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIFV0aWxpdGllc1xyXG4gICAgZnVuY3Rpb24gZG93bmxvYWQgKGRhdGFVcmwsIGV4dGVuc2lvbiwgZmlsZW5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gQW5jaG9yXHJcbiAgICAgICAgdmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdocmVmJywgZGF0YVVybCk7XHJcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlbmFtZSB8fCAnZ3JhcGguJyArIGV4dGVuc2lvbik7XHJcblxyXG4gICAgICAgIC8vIENsaWNrIGV2ZW50XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcclxuICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCBmYWxzZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XHJcblxyXG4gICAgICAgIGFuY2hvci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICBhbmNob3IgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFpbiBmdW5jdGlvblxyXG4gICAgZnVuY3Rpb24gc25hcHNob3QgKHBhcmFtcykge1xyXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gRW5mb3JjaW5nXHJcbiAgICAgICAgaWYgKHBhcmFtcy5mb3JtYXQgJiYgIShwYXJhbXMuZm9ybWF0IGluIFRZUEVTKSlcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3NpZ21hLnJlbmRlcmVycy5zbmFwaG90OiB1bnN1cHBvcnRlZCBmb3JtYXQgXCInICtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgKyAnXCIuJyk7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgd2ViZ2wgPSB0aGlzIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLndlYmdsLFxyXG4gICAgICAgICAgICBkb25lQ29udGV4dHMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRpbmcgYSBmYWxzZSBjYW52YXMgd2hlcmUgd2UnbGwgbWVyZ2UgdGhlIG90aGVyXHJcbiAgICAgICAgdmFyIG1lcmdlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxyXG4gICAgICAgICAgICBtZXJnZWRDb250ZXh0ID0gbWVyZ2VkLmdldENvbnRleHQoJzJkJyksXHJcbiAgICAgICAgICAgIHNpemVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIGNvbnRleHRcclxuICAgICAgICBDT05URVhUUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5jb250ZXh0c1tuYW1lXSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGFiZWxzID09PSBmYWxzZSAmJiBuYW1lID09PSAnbGFiZWxzJylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBzZWxmLmRvbUVsZW1lbnRzW25hbWVdIHx8IHNlbGYuZG9tRWxlbWVudHNbJ3NjZW5lJ10sXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gc2VsZi5jb250ZXh0c1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh+ZG9uZUNvbnRleHRzLmluZGV4T2YoY29udGV4dCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWQud2lkdGggPSB3ZWJnbCAmJiBjb250ZXh0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ID9cclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggLyAyIDpcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtZXJnZWQuaGVpZ2h0ID0gd2ViZ2wgJiYgY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCAvIDIgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBzaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gd2Ugd2FudCBhIGJhY2tncm91bmQgY29sb3I/XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LnJlY3QoMCwgMCwgbWVyZ2VkLndpZHRoLCBtZXJnZWQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDb250ZXh0LmZpbGxTdHlsZSA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZENvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dClcclxuICAgICAgICAgICAgICAgIG1lcmdlZENvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG1lcmdlZENvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XHJcblxyXG4gICAgICAgICAgICBkb25lQ29udGV4dHMucHVzaChjb250ZXh0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFVcmwgPSBtZXJnZWQudG9EYXRhVVJMKFRZUEVTW3BhcmFtcy5mb3JtYXQgfHwgJ3BuZyddKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZClcclxuICAgICAgICAgICAgZG93bmxvYWQoXHJcbiAgICAgICAgICAgICAgICBkYXRhVXJsLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmZvcm1hdCB8fCAncG5nJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5maWxlbmFtZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBDbGVhbmluZ1xyXG4gICAgICAgIG1lcmdlZENvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbWVyZ2VkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRvbmVDb250ZXh0cyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFVcmw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXh0ZW5kaW5nIGNhbnZhcyBhbmQgd2VibCByZW5kZXJlcnNcclxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgdXNlUGx1Z2luOyIsIid1c2Ugc3RyaWN0JztcclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IERFRkFVTFRfREVDS19MRU5HVEggPSA0O1xyXG5cclxuLyoqXHJcbiAqIFN0b3JlIHN0YXRlcyBvZiBMRy4gU3RhdGVzIGlzIGEgRGlhZ3JhbXMgcmVuZGVyZWQgYXJvdW5kIGZvY3VzTm9kZS5cclxuICogQGNsYXNzXHJcbiAqIEBwcml2YXRlXHJcbiAqIENvbnN0cnVjdG9yIHBhcmFtZXRlcnNcclxuICogIEBwYXJhbSB7UGFyYW1ldGVyc30gcGFyYW1ldGVyc1xyXG5cclxuICogUHVibGljIG1ldGhvZHM6XHJcbiAqIHB1c2hTdGF0ZTogKCkgPT4gdm9pZFxyXG4gKiBnZXRIaXN0b3J5OiAoKSA9PiB7XHJcbiAqICBzdGF0ZXM6IHsgbm9kZXM6IE5vZGVbXSwgbGlua3M6IExpbmtbXSwgZm9jdXNOb2RlOiBOb2RlIH1bXSxcclxuICogIGN1cnJlbnRJbmRleDogbnVtYmVyLFxyXG4gKiB9XHJcbiAqIHVuZG9TdGF0ZTogKCkgPT4gdm9pZFxyXG4gKiByZWRvU3RhdGU6ICgpID0+IHZvaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBTdGF0ZVN0b3JhZ2UgKHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKCFwYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0ge307XHJcblxyXG4gICAgY29uc3QgX3N0YXRlRGVjayA9IFtdO1xyXG4gICAgY29uc3QgX21heERlY2tMZW5ndGggPSBwYXJhbWV0ZXJzLmRlY2tMZW5ndGggfHwgREVGQVVMVF9ERUNLX0xFTkdUSDtcclxuICAgIGxldCBfY3VycmVudEluZGV4ID0gLTE7XHJcblxyXG4gICAgc2VsZi5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICBpZiAoX3N0YXRlRGVjay5sZW5ndGggLSAxID4gX2N1cnJlbnRJbmRleCkge1xyXG4gICAgICAgICAgICBfc3RhdGVEZWNrLnNwbGljZShfY3VycmVudEluZGV4ICsgMSwgX3N0YXRlRGVjay5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3RhdGVEZWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgIF9jaGVjaygpO1xyXG4gICAgICAgIF9jdXJyZW50SW5kZXggPSBfc3RhdGVEZWNrLmxlbmd0aCAtIDE7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICBfc3RhdGVEZWNrW19jdXJyZW50SW5kZXhdID0gc3RhdGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGF0ZXM6IGNsb25lRGVlcChfc3RhdGVEZWNrKSxcclxuICAgICAgICAgICAgY3VycmVudEluZGV4OiBfY3VycmVudEluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYudW5kb1N0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfY3VycmVudEluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICBfY3VycmVudEluZGV4LS07XHJcbiAgICAgICAgICAgIHJldHVybiBfcmV0dXJuU3RhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVkb1N0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfY3VycmVudEluZGV4ICsgMSA8IF9zdGF0ZURlY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIF9jdXJyZW50SW5kZXgrKztcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXR1cm5TdGF0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIF9yZXR1cm5TdGF0ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGF0ZURlY2tbX2N1cnJlbnRJbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2NoZWNrICgpIHtcclxuICAgICAgICBpZiAoX3N0YXRlRGVjay5sZW5ndGggPiBfbWF4RGVja0xlbmd0aCkgX3N0YXRlRGVjay5zaGlmdCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdGF0ZVN0b3JhZ2U7XHJcblxyXG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5cbi8qKiBcbiAqIEl0J3MgYmFzZSBjbGFzcyB3aGljaCBwcm92aWRlcyBzdWJzY3JpcHRpb24gQVBJIGZvciBzdWNjZXNzb3JzLlxuICogQGNsYXNzXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIFN1YnNjcmliYWJsZSAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5fc3Vic2NyaWJ0aW9ucyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGFsbG93cyB0byBzdWJzY3JpYmUgb24gYSBzb21lIHNwZWNpZmljIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBldmVudCBoYW5kbGVyXG4gICAgICogQG1lbWJlcm9mIFN1YnNjcmliYWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAqL1xuICAgIHNlbGYub24gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0pIHNlbGYuX3N1YnNjcmlidGlvbnNbZXZlbnRdID0gW107XG4gICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBzZWxmLl9zdWJzY3JpYnRpb25zW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCB0eXBlIG9mIGNhbGxiYWNrIScpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBhbGxvd3MgdG8gdW5zdWJzY3JpYmUgZnJvbSBhIHNvbWUgc3BlY2lmaWMgZXZlbnQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBldmVudCBoYW5kbGVyXG4gICAgICogQG1lbWJlcm9mIFN1YnNjcmliYWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAqL1xuICAgIHNlbGYudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgXy52YWx1ZXMoc2VsZi5fc3Vic2NyaWJ0aW9ucykuZm9yRWFjaChzdWJzY3JpYmVycyA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB3aGljaCBmaXJlcyB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBwYXJhbWV0ZXJzXG4gICAgICogQG1lbWJlcm9mIFN1YnNjcmliYWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAqL1xuICAgIHNlbGYudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1ldGVycykge1xuICAgICAgICBpZiAoIShwYXJhbWV0ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSBwYXJhbWV0ZXJzID0gW3BhcmFtZXRlcnNdO1xuICAgICAgICBpZiAoc2VsZi5fc3Vic2NyaWJ0aW9ucyAmJiBzZWxmLl9zdWJzY3JpYnRpb25zW2V2ZW50XSkge1xuICAgICAgICAgICAgc2VsZi5fc3Vic2NyaWJ0aW9uc1tldmVudF0uZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgICAgICBjLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgU3Vic2NyaWJhYmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgKiBhcyBncmFwaEVsZW1lbnRzIGZyb20gJy4uL2pvaW50Vmlld3MvZ3JhcGhFbGVtZW50cy9lbGVtZW50cyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZUVsZW1lbnQgKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gZWxlbWVudC5vcmlnaW5hbExpbmsgfHwgZWxlbWVudC5vcmlnaW5hbE5vZGUgfHwgZWxlbWVudDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTGdSYXdEYXRhIChkYXRhKSB7XHJcbiAgICBpZiAoKCFkYXRhLmxpbmtzKSAmJiAoIWRhdGEubm9kZXMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YS5ub2Rlcykge1xyXG4gICAgICAgIGlmICghKGRhdGEubm9kZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdub2Rlc1xcJyBzaG91bGQgYmUgYW4gQXJyYXksIGJ1dCBpdCBpcyBvYmplY3QhJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGRhdGEgdG8gc2hvdyEnKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gbm9kZXMgaW5mb3JtYXRpb24gaW4gdGhlIGRhdGEsIHNvIHdlIGhhdmUgbm90aGluZyB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubGlua3MgJiYgIShkYXRhLmxpbmtzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdsaW5rc1xcJyBzaG91bGQgYmUgYW4gQXJyYXksIGJ1dCBpdCBpcyBvYmplY3QhJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRG1SYXdEYXRhIChkYXRhKSB7XHJcbiAgICBpZiAoKCFkYXRhLmVkZ2VzKSAmJiAoIWRhdGEubm9kZXMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBkYXRhIHRvIHNob3chJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YS5ub2Rlcykge1xyXG4gICAgICAgIGlmICghKGRhdGEubm9kZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdub2Rlc1xcJyBzaG91bGQgYmUgYW4gQXJyYXksIGJ1dCBpdCBpcyBvYmplY3QhJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGRhdGEgdG8gc2hvdyEnKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gbm9kZXMgaW5mb3JtYXRpb24gaW4gdGhlIGRhdGEsIHNvIHdlIGhhdmUgbm90aGluZyB0byBzaG93IScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEubGlua3MgJiYgIShkYXRhLmVkZ2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdsaW5rc1xcJyBzaG91bGQgYmUgYW4gQXJyYXksIGJ1dCBpdCBpcyBvYmplY3QhJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBWaWV3IGZyYW1lIGRlZmluaXRpb24sXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFZpZXdGcmFtZURlZmluaXRpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVmlldyBmcmFtZSBpZGVudGlmeWVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbCAtIFRpdGxlIG9mIHRoZSB2aWV3IGZyYW1lLFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYm9yZGVyQ29sb3IgLSBDb2xvciBvZiB0aGUgYm9yZGVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWNrZ3JvdW5kQ29sb3IgLSBDb2xvciBvZiB0aGUgYmFja2dyb3VuZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3BhY2VTaGFyZSAtIEhvdyBtdWNoIHRoZSB2aWV3IGZyYW1lIHdpbGwgdGFrZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxhcHNlZCAtIERlZmluZSBkZWZhdWx0IHN0YXRlXHJcbiAqIGZyb20gd2hvbGUgc3BhY2Ugb2YgdGhlIGdyYXBoIChZb3UgY2FuIHRha2UgaXQgYXMgcGVyc2VudHMgb3IgZmxleCBncm93KVxyXG4qL1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZlbml0aW9uVG9QdWJsaWNNb2RlbCAoZGVmZW5pdGlvbiwgZnVsbFNjcmVlbk1vZGUpIHtcclxuICAgIGNvbnN0IGlzQWN0aXZlID0gZnVsbFNjcmVlbk1vZGUgPyBmYWxzZSA6ICFkZWZlbml0aW9uLmNvbGxhcHNlZDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBkZWZlbml0aW9uLmlkLFxyXG4gICAgICAgIGxhYmVsOiBkZWZlbml0aW9uLmxhYmVsLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZGVmZW5pdGlvbi5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgYm9yZGVyQ29sb3I6IGRlZmVuaXRpb24uYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgICAgICBleHBhbmRlZDogIWRlZmVuaXRpb24uY29sbGFwc2VkLFxyXG4gICAgICAgIHBvc2l0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgdmlld1BvcnRQb3NpdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgICAgIHZpZXdQb3J0UG9zaXRpb25Cb3VuZHM6IHVuZGVmaW5lZCxcclxuICAgICAgICB2aWV3UG9ydEJvdW5kczogdW5kZWZpbmVkLFxyXG4gICAgICAgIG5vZGVCb3VuZHM6IHVuZGVmaW5lZCxcclxuICAgICAgICBzaXplOiB1bmRlZmluZWQsXHJcbiAgICAgICAgY3VzdG9tZVNpemVkOiBmYWxzZSxcclxuICAgICAgICBzcGFjZVNoYXJlOiBkZWZlbml0aW9uLnNwYWNlU2hhcmUsXHJcbiAgICAgICAgdXBkYXRlQm91bmRzOiBmYWxzZSxcclxuICAgICAgICBpc092ZXJWaWV3OiBmYWxzZSxcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBDcmV0ZXMgam9pbnQgbm9kZXMgZnJvbSBub2RlTW9kZWxzXHJcbiAqIEBwYXJhbSB7XHJcbiAqICAgICAgQXJyYXkgb2Yge1xyXG4gICAgICAgICAgICBpZDogc3RyaW5nLFxyXG4gICAgICAgICAgICBsYWJlbDogc3RyaW5nLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWU6IHN0cmluZyxcclxuICAgICAgICAgICAgdHlwZUlkOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIHJlc291cmNlVHlwZTogc3RyaW5nLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogc3RyaW5nLFxyXG4gKiAgICAgIH1cclxuICogfSBOb2RlTW9kZWxzIC0gbGlzdCBvZiBtb2RlbHNcclxuICogQHJldHVybnMge0FycmF5IG9mIE5vZGV9IGxpc3Qgb2Ygam9pbnQgbm9kZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVKb2ludE5vZGVzIChub2RlTW9kZWxzLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBqb2ludE5vZGVzID0gW107XHJcbiAgICBub2RlTW9kZWxzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgam9pbnROb2Rlcy5wdXNoKG5ldyBncmFwaEVsZW1lbnRzLk5vZGUobm9kZSwgcGFyYW1ldGVycykpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gam9pbnROb2RlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIENyZXRlcyBqb2ludCBsaW5rcyBmcm9tIG1vZGVscyAobmF0aXZlTGlua3MpXHJcbiAqIEBwYXJhbSB7XHJcbiAqICAgICAgQXJyYXkgb2Yge1xyXG4gKiAgICAgICAgICBpZDogc3RyaW5nLFxyXG4gKiAgICAgICAgICB0YXJnZXQ6IHN0cmluZyxcclxuICogICAgICAgICAgc291cmNlOiBzdHJpbmcsXHJcbiAqICAgICAgfVxyXG4gKiB9IG5hdGl2ZUxpbmtzIC0gbGlzdCBvZiBtb2RlbHNcclxuICogQHJldHVybnMge0xpbmtbXX0gbGlzdCBvZiBqb2ludCBsaW5rc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUpvaW50TGlua3MgKGxpbmtNb2RlbHMsIGpvaW50Tm9kZXMsIHBhcmFtZXRlcnMpIHtcclxuICAgIGNvbnN0IGpvaW50TGlua3MgPSBbXTtcclxuICAgIGNvbnN0IGlkTWFwID0ge307XHJcbiAgICBqb2ludE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgaWRNYXBbbm9kZS5tb2RlbC5pZF0gPSBub2RlLmlkO1xyXG4gICAgfSk7XHJcbiAgICBsaW5rTW9kZWxzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgdmFyIGxpbmtNb2RlbCA9IF8uY2xvbmVEZWVwKGxpbmspO1xyXG4gICAgICAgIGxpbmtNb2RlbC5zb3VyY2VUeXBlID0gbGluay5zb3VyY2U7XHJcbiAgICAgICAgbGlua01vZGVsLnRhcmdldFR5cGUgPSBsaW5rLnRhcmdldDtcclxuICAgICAgICBsaW5rTW9kZWwuc291cmNlID0gaWRNYXBbbGluay5zb3VyY2VdO1xyXG4gICAgICAgIGxpbmtNb2RlbC50YXJnZXQgPSBpZE1hcFtsaW5rLnRhcmdldF07XHJcbiAgICAgICAgbGlua01vZGVsLmFjdGl2ZVJlc291cmNlc0xpc3QgPSBsaW5rLmFjdGl2ZVJlc291cmNlc0xpc3Q7XHJcbiAgICAgICAgbGlua01vZGVsLnJvdXRpbmcgPSBwYXJhbWV0ZXJzLmxpbmtSb3V0aW5nO1xyXG4gICAgICAgIGNvbnN0IG5ld0xpbmsgPSBuZXcgZ3JhcGhFbGVtZW50cy5MaW5rKGxpbmtNb2RlbCwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgam9pbnRMaW5rcy5wdXNoKG5ld0xpbmspO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gam9pbnRMaW5rcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRhdGUyU3RyaW5nIChkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkU3RyKGRhdGUuZ2V0RnVsbFllYXIoKSkgKyAnXycgK1xyXG4gICAgICAgICAgICBwYWRTdHIoMSArIGRhdGUuZ2V0TW9udGgoKSkgKyAnXycgK1xyXG4gICAgICAgICAgICBwYWRTdHIoZGF0ZS5nZXREYXRlKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0SG91cnMoKSkgKyAnXycgK1xyXG4gICAgICAgICAgICBwYWRTdHIoZGF0ZS5nZXRNaW51dGVzKCkpICsgJ18nICtcclxuICAgICAgICAgICAgcGFkU3RyKGRhdGUuZ2V0U2Vjb25kcygpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYWRTdHIgKGkpIHtcclxuICAgICAgICByZXR1cm4gKGkgPCAxMCkgPyAnMCcgKyBpIDogJycgKyBpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcG5nMkJsb2IgKGRhdGFVUkkpIHtcclxuICAgIC8vIGNvbnZlcnQgYmFzZTY0IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgc3RyaW5nXHJcbiAgICAvLyBkb2Vzbid0IGhhbmRsZSBVUkxFbmNvZGVkIERhdGFVUklzIC0gc2VlIFNPIGFuc3dlciAjNjg1MDI3NiBmb3IgY29kZSB0aGF0IGRvZXMgdGhpc1xyXG4gICAgdmFyIGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkkuc3BsaXQoJywnKVsxXSk7XHJcblxyXG4gICAgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcclxuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XHJcbiAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShhYik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3cml0ZSB0aGUgQXJyYXlCdWZmZXIgdG8gYSBibG9iLCBhbmQgeW91J3JlIGRvbmVcclxuICAgIHZhciBiYiA9IG5ldyBCbG9iKFthYl0sIHsgdHlwZTogJ2ltYWdlL3BuZycgfSk7XHJcbiAgICByZXR1cm4gYmI7XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgYXJyYXlUb01hcCxcclxuICAgIG1hcFRvQXJyYXksXHJcbiAgICBnZXRHbG9iYWxOb2RlUG9zaXRpb24sXHJcbiAgICBzY2FsZWRUb0dsb2JhbFNpemUsXHJcblxyXG59IGZyb20gJy4vdXRpbHMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnROYXRpdmVUb0xheW91dE1vZGVscyAobm9kZU1vZGVscywgbGlua01vZGVscywgcGFyYW1ldGVycykge1xyXG4gICAgY29uc3Qgc2l6ZSA9IHBhcmFtZXRlcnMuZWxlbWVudFNpemU7XHJcbiAgICBjb25zdCBub2RlcyA9IG5vZGVNb2RlbHNUb0xheW91dE5vZGVzKG5vZGVNb2RlbHMsIHBhcmFtZXRlcnMuZWxlbWVudFNpemUpO1xyXG4gICAgY29uc3QgbGlua3MgPSBsaW5rTW9kZWxzVG9MYXlvdXRMaW5rcyhsaW5rTW9kZWxzLCBub2Rlcyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBub2Rlczogbm9kZXMsXHJcbiAgICAgICAgbGlua3M6IGxpbmtzLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBub2RlTW9kZWxzVG9MYXlvdXROb2RlcyAobm9kZU1vZGVscykge1xyXG4gICAgICAgIHJldHVybiBub2RlTW9kZWxzLm1hcChub2RlTW9kZWwgPT4gbm9kZU1vZGVsVG9MYXlvdXROb2RlKG5vZGVNb2RlbCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBsaW5rTW9kZWxzVG9MYXlvdXRMaW5rcyAobGlua01vZGVscywgbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChub2Rlcyk7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rTW9kZWxzLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtNb2RlbFRvTGF5b3V0TGluayhsaW5rLCBub2RlTWFwKTtcclxuICAgICAgICB9KS5maWx0ZXIobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rLnNvdXJjZSAmJiBsaW5rLnRhcmdldCAmJiBsaW5rLnNvdXJjZSAhPT0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGluay5zb3VyY2UudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgbGluay50YXJnZXQuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGlua3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vZGVsVG9MYXlvdXROb2RlIChub2RlTW9kZWwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbm9kZU1vZGVsLmlkLFxyXG4gICAgICAgICAgICB4OiBub2RlTW9kZWwucG9zaXRpb24ueCB8fCBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICB5OiBub2RlTW9kZWwucG9zaXRpb24ueSB8fCBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICBvcmlnaW5hbE5vZGU6IG5vZGVNb2RlbCxcclxuICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzOiBbXSxcclxuICAgICAgICAgICAgc291cmNlTGlua3M6IFtdLFxyXG4gICAgICAgICAgICB2aWV3RnJhbWU6IG5vZGVNb2RlbC52aWV3RnJhbWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaW5rTW9kZWxUb0xheW91dExpbmsgKGxpbmtNb2RlbCwgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGlua01vZGVsLnNvdXJjZV07XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbm9kZU1hcFtsaW5rTW9kZWwudGFyZ2V0XTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbExpbms6IGxpbmtNb2RlbCxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydExHRWxlbWVudHNUb0xheW91dE1vZGVscyAobGdOb2RlcywgbGdMaW5rcywgb3B0aW9ucykge1xyXG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBsZ05vZGVzLm1hcChub2RlID0+IG5vZGVUb0xheW91dE5vZGUobm9kZSkpO1xyXG4gICAgY29uc3QgbGlua3MgPSBsaW5rc1RvTGF5b3V0TGlua3MobGdMaW5rcywgbm9kZXMpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua3NUb0xheW91dExpbmtzIChsaW5rLCBub2Rlcykge1xyXG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBhcnJheVRvTWFwKG5vZGVzKTtcclxuICAgICAgICBjb25zdCBsaW5rcyA9IGxpbmsubWFwKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGlua1RvTGF5b3V0TGluayhsaW5rLCBub2RlTWFwKTtcclxuICAgICAgICB9KS5maWx0ZXIobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rLnNvdXJjZSAmJiBsaW5rLnRhcmdldCAmJiBsaW5rLnNvdXJjZSAhPT0gbGluay50YXJnZXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgbGluay5zb3VyY2UudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICAgICAgbGluay50YXJnZXQuc291cmNlTGlua3MucHVzaChsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGlua3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZVRvTGF5b3V0Tm9kZSAobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0R2xvYmFsTm9kZVBvc2l0aW9uKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSBzY2FsZWRUb0dsb2JhbFNpemUobm9kZS5zaXplLCBzY2FsZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIG9yaWdpbmFsTm9kZTogbm9kZSxcclxuICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWd0aDogc2l6ZS5oZWlndGgsXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzOiBbXSxcclxuICAgICAgICAgICAgc291cmNlTGlua3M6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua1RvTGF5b3V0TGluayAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGVNYXBbbGluay5tb2RlbC5zb3VyY2VdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGluay5tb2RlbC50YXJnZXRdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsTGluazogbGluayxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICB2YWx1ZTogMSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRETUVsZW1lbnRzVG9MYXlvdXRNb2RlbHMgKGRtTm9kZXMsIGRtTGlua3MpIHtcclxuICAgIGNvbnN0IG5vZGVNYXAgPSBhcnJheVRvTWFwKGRtTm9kZXMubWFwKG5vZGUgPT4gbm9kZVRvTGF5b3V0Tm9kZShub2RlKSkpO1xyXG4gICAgY29uc3QgbGlua3MgPSBsaW5rc1RvTGF5b3V0TGlua3MoZG1MaW5rcywgbm9kZU1hcCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBub2RlczogbWFwVG9BcnJheShub2RlTWFwKSxcclxuICAgICAgICBsaW5rczogbGlua3MsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGxpbmtzVG9MYXlvdXRMaW5rcyAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbGluay5tYXAobGluayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5rVG9MYXlvdXRMaW5rKGxpbmssIG5vZGVNYXApO1xyXG4gICAgICAgIH0pLmZpbHRlcihsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmsuc291cmNlICYmIGxpbmsudGFyZ2V0ICYmIGxpbmsuc291cmNlICE9PSBsaW5rLnRhcmdldDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICBsaW5rLnNvdXJjZS50YXJnZXRMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgICAgICBsaW5rLnRhcmdldC5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBsaW5rcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub2RlVG9MYXlvdXROb2RlIChub2RlKSB7XHJcbiAgICAgICAgY29uc3QgcG9ydFBvc2l0aW9uID0gbm9kZS5nZXRQb3J0UG9zaXRpb24oKTtcclxuICAgICAgICBjb25zdCBwb3J0UHJpbWl0aXZlID0gbm9kZS5nZXRQb3J0KCkucHJpbWl0aXZlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBwb3J0UHJpbWl0aXZlLmlkLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICBvcmlnaW5hbE5vZGU6IHBvcnRQcmltaXRpdmUsXHJcbiAgICAgICAgICAgIHRhcmdldExpbmtzOiBbXSxcclxuICAgICAgICAgICAgc291cmNlTGlua3M6IFtdLFxyXG4gICAgICAgICAgICBvcmRlcjogcG9ydFBvc2l0aW9uLnksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGlua1RvTGF5b3V0TGluayAobGluaywgbm9kZU1hcCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVByaW1pdGl2ZSA9IGxpbmsuc291cmNlLmdldFBvcnQoKS5wcmltaXRpdmU7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UHJpbWl0aXZlID0gbGluay50YXJnZXQuZ2V0UG9ydCgpLnByaW1pdGl2ZTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcFtzb3VyY2VQcmltaXRpdmUuaWRdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbdGFyZ2V0UHJpbWl0aXZlLmlkXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2FjaGVJZDogY2FjaExpbmtGdW5jdGlvbiAoc291cmNlUHJpbWl0aXZlLCB0YXJnZXRQcmltaXRpdmUpLFxyXG4gICAgICAgICAgICBvcmlnaW5hbExpbms6IGxpbmssXHJcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgdmFsdWU6IDEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoTGlua0Z1bmN0aW9uIChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuaWQgKyAnfiN0cURNTGluayN+JyArIHRhcmdldC5pZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRKb2ludEVsZW1lbnRzVG9MYXlvdXRNb2RlbHMgKGpOb2RlcywgakxpbmtzKSB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gYXJyYXlUb01hcChqTm9kZXMubWFwKG5vZGUgPT4gbm9kZVRvTGF5b3V0Tm9kZShub2RlKSkpO1xyXG4gICAgY29uc3QgbGlua3MgPSBsaW5rc1RvTGF5b3V0TGlua3MoakxpbmtzLCBub2RlTWFwKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBtYXBUb0FycmF5KG5vZGVNYXApLFxyXG4gICAgICAgIGxpbmtzOiBsaW5rcyxcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua3NUb0xheW91dExpbmtzIChsaW5rLCBub2RlTWFwKSB7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rLm1hcChsaW5rID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmtUb0xheW91dExpbmsobGluaywgbm9kZU1hcCk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbGluay5zb3VyY2UgJiYgbGluay50YXJnZXQgJiYgbGluay5zb3VyY2UgIT09IGxpbmsudGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuc291cmNlLnRhcmdldExpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0LnNvdXJjZUxpbmtzLnB1c2gobGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVUb0xheW91dE5vZGUgKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgb3JpZ2luYWxOb2RlOiBub2RlLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB0YXJnZXRMaW5rczogW10sXHJcbiAgICAgICAgICAgIHNvdXJjZUxpbmtzOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBsaW5rVG9MYXlvdXRMaW5rIChsaW5rLCBub2RlTWFwKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcFtsaW5rLmdldCgnc291cmNlJykuaWRdO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5vZGVNYXBbbGluay5nZXQoJ3RhcmdldCcpLmlkXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxMaW5rOiBsaW5rLFxyXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdW0gKGFycmF5LCBmKSB7XHJcbiAgICBsZXQgcyA9IDAsXHJcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGkgPSAtMTtcclxuXHJcbiAgICBpZiAoZiA9PSBudWxsKSB7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcclxuICAgICAgICAgICAgYSA9ICthcnJheVtpXTtcclxuICAgICAgICAgICAgaWYgKGEpIHMgKz0gYTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgICAgICAgIGEgPSArZihhcnJheVtpXSwgaSwgYXJyYXkpO1xyXG4gICAgICAgICAgICBpZiAoYSkgcyArPSBhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcztcclxufVxyXG5cclxubGV0IHByZWZpeCA9ICckJztcclxuZnVuY3Rpb24gTWFwICgpIHt9XHJcbk1hcC5wcm90b3R5cGUgPSBtYXAkMS5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogTWFwLFxyXG4gICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmVmaXggKyBrZXkpIGluIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbcHJlZml4ICsga2V5XTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpc1twcmVmaXggKyBrZXldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgbGV0IHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcclxuICAgIH0sXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBkZWxldGUgdGhpc1twcm9wZXJ0eV07XHJcbiAgICB9LFxyXG4gICAga2V5czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBrZXlzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGtleXMucHVzaChwcm9wZXJ0eS5zbGljZSgxKSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9LFxyXG4gICAgdmFsdWVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSB2YWx1ZXMucHVzaCh0aGlzW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH0sXHJcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IGVudHJpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZW50cmllcy5wdXNoKHtrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV19KTtcclxuICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgIH0sXHJcbiAgICBzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHNpemUgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSArK3NpemU7XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9LFxyXG4gICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGVhY2g6IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGYodGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LnNsaWNlKDEpLCB0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXAkMSAob2JqZWN0LCBmKSB7XHJcbiAgICBsZXQgbWFwID0gbmV3IE1hcDtcclxuXHJcbiAgICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxyXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgbWFwLnNldChrZXksIHZhbHVlKTsgfSk7XHJcblxyXG4gICAgLy8gSW5kZXggYXJyYXkgYnkgbnVtZXJpYyBpbmRleCBvciBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XHJcbiAgICAgICAgbGV0IGkgPSAtMSxcclxuICAgICAgICAgICAgbiA9IG9iamVjdC5sZW5ndGgsXHJcbiAgICAgICAgICAgIG87XHJcblxyXG4gICAgICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7XHJcbiAgICAgICAgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmKG8gPSBvYmplY3RbaV0sIGksIG9iamVjdCksIG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgb2JqZWN0IHRvIG1hcC5cclxuICAgIGVsc2UgaWYgKG9iamVjdCkgZm9yIChsZXQga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5lc3QgKCkge1xyXG4gICAgbGV0IGtleXMgPSBbXSxcclxuICAgICAgICBzb3J0S2V5cyA9IFtdLFxyXG4gICAgICAgIHNvcnRWYWx1ZXMsXHJcbiAgICAgICAgcm9sbHVwLFxyXG4gICAgICAgIG5lc3Q7XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHkgKGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcclxuICAgICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiByb2xsdXAgIT0gbnVsbFxyXG4gICAgICAgICAgICA/IHJvbGx1cChhcnJheSkgOiAoc29ydFZhbHVlcyAhPSBudWxsXHJcbiAgICAgICAgICAgID8gYXJyYXkuc29ydChzb3J0VmFsdWVzKVxyXG4gICAgICAgICAgICA6IGFycmF5KTtcclxuXHJcbiAgICAgICAgbGV0IGkgPSAtMSxcclxuICAgICAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcclxuICAgICAgICAgICAga2V5VmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZXNCeUtleSA9IG1hcCQxKCksXHJcbiAgICAgICAgICAgIHZhbHVlcyxcclxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlUmVzdWx0KCk7XHJcblxyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleSh2YWx1ZSA9IGFycmF5W2ldKSArICcnKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsdWVzQnlLZXkuZWFjaChmdW5jdGlvbiAodmFsdWVzLCBrZXkpIHtcclxuICAgICAgICAgICAgc2V0UmVzdWx0KHJlc3VsdCwga2V5LCBhcHBseSh2YWx1ZXMsIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVudHJpZXMgKG1hcCwgZGVwdGgpIHtcclxuICAgICAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwO1xyXG4gICAgICAgIGxldCBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XHJcbiAgICAgICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKSBhcnJheSA9IG1hcC5lbnRyaWVzKCk7XHJcbiAgICAgICAgZWxzZSBhcnJheSA9IFtdLCBtYXAuZWFjaChmdW5jdGlvbiAodiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHNvcnRLZXkoYS5rZXksIGIua2V5KTsgfSkgOiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVzdCA9IHtcclxuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcclxuICAgICAgICBtYXA6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKTsgfSxcclxuICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXHJcbiAgICAgICAga2V5OiBmdW5jdGlvbiAoZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxyXG4gICAgICAgIHNvcnRLZXlzOiBmdW5jdGlvbiAob3JkZXIpIHsgc29ydEtleXNba2V5cy5sZW5ndGggLSAxXSA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcclxuICAgICAgICBzb3J0VmFsdWVzOiBmdW5jdGlvbiAob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcclxuICAgICAgICByb2xsdXA6IGZ1bmN0aW9uIChmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE9iamVjdCAob2JqZWN0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVNYXAgKCkge1xyXG4gICAgICAgIHJldHVybiBtYXAkMSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldE1hcCAobWFwLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUgKGEsIGIpIHtcclxuICAgIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICByZXR1cm4gYSArIGIgKiB0O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1pbiAoYXJyYXksIGYpIHtcclxuICAgIGxldCBpID0gLTEsXHJcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGI7XHJcblxyXG4gICAgaWYgKGYgPT0gbnVsbCkge1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGI7IGJyZWFrOyB9XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbn0iLCJpbXBvcnQgKiBhcyBqb2ludCBmcm9tICdyYXBwaWQnO1xyXG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FjaGVJZEZvclZpZXdGcmFtZVVJICh2aWV3RnJhbWUpIHtcclxuICAgIHJldHVybiAndHEtbGctdmlldy1mcmFtZS11aS0nICsgdmlld0ZyYW1lLmlkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld0ZyYW1lSWRGb3JOb2RlIChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS52aWV3RnJhbWVPd25lcklkIHx8IG5vZGUubW9kZWwudmlld0ZyYW1lO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQYWdpbmF0aW9uICh2aWV3RnJhbWUpIHtcclxuICAgIGNvbnN0IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbkJvdW5kcztcclxuICAgIGNvbnN0IHZpZXdQb3J0UG9zaXRpb24gPSB2aWV3RnJhbWUudmlld1BvcnRQb3NpdGlvbjtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNhbk1vdmVVcDogdmlld1BvcnRQb3NpdGlvbkJvdW5kcyAmJiB2aWV3UG9ydFBvc2l0aW9uLnkgPiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzLm1pblksXHJcbiAgICAgICAgY2FuTW92ZURvd246IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgJiYgdmlld1BvcnRQb3NpdGlvbi55IDwgdmlld1BvcnRQb3NpdGlvbkJvdW5kcy5tYXhZLFxyXG4gICAgICAgIGNhbk1vdmVMZWZ0OiB2aWV3UG9ydFBvc2l0aW9uQm91bmRzICYmIHZpZXdQb3J0UG9zaXRpb24ueCA+IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMubWluWCxcclxuICAgICAgICBjYW5Nb3ZlUmlnaHQ6IHZpZXdQb3J0UG9zaXRpb25Cb3VuZHMgJiYgdmlld1BvcnRQb3NpdGlvbi54IDwgdmlld1BvcnRQb3NpdGlvbkJvdW5kcy5tYXhYLFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFJldHVybnMgcG9pbnQgb2YgY3Jvc3Npbmcgb2YgdHdvIGxpbmVzXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAxIC0gdGhlIGZpcnN0IHBvaW50IG9mIGxpbmUtMVxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMiAtIHRoZSBzZWNvbmQgcG9pbnQgb2YgbGluZS0xXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAzIC0gdGhlIGZpcnN0IHBvaW50IG9mIGxpbmUtMlxyXG4gKiBAcGFyYW0ge1BvaW50fSBwNCAtIHRoZSBzZWNvbmQgcG9pbnQgb2YgbGluZS0yXHJcbiAqIEByZXR1cm5zIHtQb2ludH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcm9zUG9pbnQgKHAxLCBwMiwgcDMsIHA0KSB7XHJcbiAgICBsZXQgeDEgPSBwMS54O1xyXG4gICAgbGV0IHkxID0gcDEueTtcclxuXHJcbiAgICBsZXQgeDIgPSBwMi54O1xyXG4gICAgbGV0IHkyID0gcDIueTtcclxuICAgIFxyXG4gICAgbGV0IHgzID0gcDMueDtcclxuICAgIGxldCB5MyA9IHAzLnk7XHJcbiAgICBcclxuICAgIGxldCB4NCA9IHA0Lng7XHJcbiAgICBsZXQgeTQgPSBwNC55O1xyXG5cclxuICAgIGxldCBrMSwgazIsIGIxLCBiMjtcclxuICAgIGxldCByeCwgcnksIHh4LCB5eTtcclxuICAgIGxldCByZXMgPSB7fTtcclxuICAgIFxyXG4gICAgaWYgKHgxID09IHgyICYmIHgzID09IHg0KSByZXR1cm4gbnVsbDtcclxuICAgIGlmICh4MSA9PT0geDIpIHtcclxuICAgICAgICBrMiA9ICh5MyAtIHk0KSAvICh4MyAtIHg0KTtcclxuICAgICAgICBiMiA9IHkzIC0gazIgKiB4MztcclxuXHJcbiAgICAgICAgcnggPSB4MTtcclxuICAgICAgICByeSA9IGsyICogcnggKyBiMjtcclxuICAgIH0gZWxzZSBpZiAoeDMgPT09IHg0KSB7XHJcbiAgICAgICAgazEgPSAoeTEgLSB5MikgLyAoeDEgLSB4Mik7XHJcbiAgICAgICAgYjEgPSB5MSAtIGsxICogeDE7XHJcblxyXG4gICAgICAgIHJ4ID0geDM7XHJcbiAgICAgICAgcnkgPSBrMSAqIHJ4ICsgYjE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGsxID0gKHkxIC0geTIpIC8gKHgxIC0geDIpO1xyXG4gICAgICAgIGIxID0geTEgLSBrMSAqIHgxO1xyXG5cclxuICAgICAgICBrMiA9ICh5MyAtIHk0KSAvICh4MyAtIHg0KTtcclxuICAgICAgICBiMiA9IHkzIC0gazIgKiB4MztcclxuXHJcbiAgICAgICAgaWYgKGsxID09IGsyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIHJ4ID0gKGIyIC0gYjEpIC8gKGsxIC0gazIpO1xyXG4gICAgICAgIHJ5ID0gazEgKiByeCArIGIxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh5MiA8IHkxKSB7XHJcbiAgICAgICAgeXkgPSB5MTtcclxuICAgICAgICB5MSA9IHkyO1xyXG4gICAgICAgIHkyID0geXk7XHJcbiAgICB9XHJcbiAgICBpZiAoeTQgPCB5Mykge1xyXG4gICAgICAgIHl5ID0geTM7XHJcbiAgICAgICAgeTMgPSB5NDtcclxuICAgICAgICB5NCA9IHl5O1xyXG4gICAgfVxyXG4gICAgaWYgKHgyIDwgeDEpIHtcclxuICAgICAgICB4eCA9IHgxO1xyXG4gICAgICAgIHgxID0geDI7XHJcbiAgICAgICAgeDIgPSB4eDtcclxuICAgIH1cclxuICAgIGlmICh4NCA8IHgzKSB7XHJcbiAgICAgICAgeHggPSB4MztcclxuICAgICAgICB4MyA9IHg0O1xyXG4gICAgICAgIHg0ID0geHg7XHJcbiAgICB9XHJcbiAgICByZXMueCA9IHJ4O1xyXG4gICAgcmVzLnkgPSByeTtcclxuICAgIGNvbnN0IGVycm9yID0gMTtcclxuICAgIGlmIChcclxuICAgICAgICB4MSAtIGVycm9yIDw9IHJlcy54ICYmIHJlcy54IDw9IHgyICsgZXJyb3IgJiZcclxuICAgICAgICB4MyAtIGVycm9yIDw9IHJlcy54ICYmIHJlcy54IDw9IHg0ICsgZXJyb3IgJiZcclxuICAgICAgICB5MSAtIGVycm9yIDw9IHJlcy55ICYmIHJlcy55IDw9IHkyICsgZXJyb3IgJiZcclxuICAgICAgICB5MyAtIGVycm9yIDw9IHJlcy55ICYmIHJlcy55IDw9IHk0ICsgZXJyb3IgXHJcbiAgICApIHtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuLy8gVGhpcyBpcyB0aGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIGxpbmtzXHJcbmV4cG9ydCBjb25zdCBHQVAgPSAxMDsgLy8gcHhcclxuLy8gT25seSBmb3IgRGVyaXZhdGlvbiBtYXBcclxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFZlcnRpY2VzIChncmFwaCwgY2VsbCkge1xyXG4gICAgaWYgKCFjZWxsKSB7XHJcbiAgICAgICAgZ3JhcGguZ2V0TGlua3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFZlcnRpY2VzKGdyYXBoLCBsaW5rKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgY2VsbCBpcyBhIHZpZXcsIGZpbmQgaXRzIG1vZGVsLlxyXG4gICAgY2VsbCA9IGNlbGwubW9kZWwgJiYgY2VsbC5tb2RlbC5nZXQgPyBjZWxsLm1vZGVsIDogY2VsbDtcclxuXHJcbiAgICBpZiAoY2VsbCBpbnN0YW5jZW9mIGpvaW50LmRpYS5FbGVtZW50KSB7XHJcbiAgICAgICAgZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3MoY2VsbCkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xyXG4gICAgICAgICAgICBhZGp1c3RWZXJ0aWNlcyhncmFwaCwgbGluayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoY2VsbC5oaWRkZW4pIHJldHVybjtcclxuICAgIGNlbGwuc2V0KCd2ZXJ0aWNlcycsIFtdKTtcclxuICAgIFxyXG4gICAgLy8gVGhlIGNlbGwgaXMgYSBsaW5rLiBMZXQncyBmaW5kIGl0cyBzb3VyY2UgYW5kIHRhcmdldCBtb2RlbHMuXHJcbiAgICBjb25zdCBzcmNJZCA9IGNlbGwuZ2V0KCdzb3VyY2UnKS5pZCB8fCBjZWxsLnByZXZpb3VzKCdzb3VyY2UnKS5pZDtcclxuICAgIGNvbnN0IHRyZ0lkID0gY2VsbC5nZXQoJ3RhcmdldCcpLmlkIHx8IGNlbGwucHJldmlvdXMoJ3RhcmdldCcpLmlkO1xyXG4gICAgY29uc3Qgc3JjUG9ydCA9IGNlbGwuZ2V0KCdzb3VyY2UnKS5wb3J0IHx8IGNlbGwucHJldmlvdXMoJ3NvdXJjZScpLnBvcnQ7XHJcbiAgICBjb25zdCB0cmdQb3J0ID0gY2VsbC5nZXQoJ3RhcmdldCcpLnBvcnQgfHwgY2VsbC5wcmV2aW91cygndGFyZ2V0JykucG9ydDtcclxuXHJcbiAgICAvLyBJZiBvbmUgb2YgdGhlIGVuZHMgaXMgbm90IGEgbW9kZWwsIHRoZSBsaW5rIGhhcyBubyBzaWJsaW5ncy5cclxuICAgIGlmICghc3JjSWQgfHwgIXRyZ0lkKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgc2libGluZ3MgPSBncmFwaC5nZXRMaW5rcygpLmZpbHRlcihzaWJsaW5nID0+IHtcclxuICAgICAgICBpZiAoc2libGluZy5oaWRkZW4pIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjb25zdCBfc3JjSWQgPSBzaWJsaW5nLmdldCgnc291cmNlJykuaWQ7XHJcbiAgICAgICAgY29uc3QgX3RyZ0lkID0gc2libGluZy5nZXQoJ3RhcmdldCcpLmlkO1xyXG4gICAgICAgIGNvbnN0IF9zcmNQb3J0ID0gc2libGluZy5nZXQoJ3NvdXJjZScpLnBvcnQ7XHJcbiAgICAgICAgY29uc3QgX3RyZ1BvcnQgPSBzaWJsaW5nLmdldCgndGFyZ2V0JykucG9ydDtcclxuXHJcbiAgICAgICAgY29uc3Qgc2FtZUVuZHNTYW1lRGlyZWN0aW9uID0gX3NyY0lkID09PSBzcmNJZCAmJiBfdHJnSWQgPT09IHRyZ0lkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NyY1BvcnQgPT09IHNyY1BvcnQgJiYgX3RyZ1BvcnQgPT09IHRyZ1BvcnQ7XHJcbiAgICAgICAgY29uc3Qgc2FtZUVuZHNTYW1lT3Bwb3NpdGVEaXJlY3Rpb24gPSBfc3JjSWQgPT09IHRyZ0lkICYmIF90cmdJZCA9PT0gc3JjSWQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjUG9ydCA9PT0gdHJnUG9ydCAmJiBfdHJnUG9ydCA9PT0gc3JjUG9ydDtcclxuICAgICAgICByZXR1cm4gKHNhbWVFbmRzU2FtZURpcmVjdGlvbikgfHwgKHNhbWVFbmRzU2FtZU9wcG9zaXRlRGlyZWN0aW9uKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHN3aXRjaCAoc2libGluZ3MubGVuZ3RoKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgLy8gVGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBzaWJsaW5ncy4gV2UgbmVlZCB0byBjcmVhdGUgdmVydGljZXMuXHJcbiAgICAgICAgLy8gRmlyc3Qgb2YgYWxsIHdlJ2xsIGZpbmQgdGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgbGluay5cclxuICAgICAgICBjb25zdCBzcmNDZWxsID0gZ3JhcGguZ2V0Q2VsbChzcmNJZCk7XHJcbiAgICAgICAgY29uc3Qgc3JjUG9zaXRpb24gPSBzcmNDZWxsLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3Qgc3JjUG9ydCA9IHNyY0NlbGwuYXR0cignLicgKyBjZWxsLmdldCgnc291cmNlJykucG9ydCk7XHJcbiAgICAgICAgaWYgKCFzcmNQb3J0KSByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgc3JjUG9ydFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICB4OiBzcmNQb3J0WydyZWYteCddICsgc3JjUG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogc3JjUG9ydFsncmVmLXknXSArIHNyY1Bvc2l0aW9uLnksXHJcbiAgICAgICAgICAgIHRoZXRhOiBqb2ludC5nLnBvaW50LnByb3RvdHlwZS50aGV0YSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRyZ0NlbGwgPSBncmFwaC5nZXRDZWxsKHRyZ0lkKTtcclxuICAgICAgICBjb25zdCB0cmdQb3NpdGlvbiA9IHRyZ0NlbGwucG9zaXRpb24oKTtcclxuICAgICAgICBjb25zdCB0cmdQb3J0ID0gdHJnQ2VsbC5hdHRyKCcuJyArIGNlbGwuZ2V0KCd0YXJnZXQnKS5wb3J0KTtcclxuICAgICAgICBpZiAoIXRyZ1BvcnQpIHJldHVybjtcclxuICAgICAgICBjb25zdCB0cmdQb3J0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IHRyZ1BvcnRbJ3JlZi14J10gKyB0cmdQb3NpdGlvbi54LFxyXG4gICAgICAgICAgICB5OiB0cmdQb3J0WydyZWYteSddICsgdHJnUG9zaXRpb24ueSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG1pZFBvaW50ID0gam9pbnQuZy5saW5lKHNyY1BvcnRQb3NpdGlvbiwgdHJnUG9ydFBvc2l0aW9uKS5taWRwb2ludCgpO1xyXG5cclxuICAgICAgICAvLyBUaGVuIGZpbmQgdGhlIGFuZ2xlIGl0IGZvcm1zLlxyXG4gICAgICAgIGNvbnN0IHRoZXRhID0gc3JjUG9ydFBvc2l0aW9uLnRoZXRhKHRyZ1BvcnRQb3NpdGlvbik7XHJcbiAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gc2libGluZ3MuaW5kZXhPZihjZWxsKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2FudCB0aGUgb2Zmc2V0IHZhbHVlcyB0byBiZSBjYWxjdWxhdGVkIGFzIGZvbGxvd3MgMCwgMjAsIDIwLCA0MCwgNDAsIDYwLCA2MCAuLlxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEdBUCAqIE1hdGguY2VpbCgoY2VsbEluZGV4ICsgKHNpYmxpbmdzLmxlbmd0aCAlIDIgPT09IDAgPyAxIDogMCkpIC8gMik7XHJcblxyXG4gICAgICAgIC8vIE5vdyB3ZSBuZWVkIHRoZSB2ZXJ0aWNlcyB0byBiZSBwbGFjZWQgYXQgcG9pbnRzIHdoaWNoIGFyZSAnb2Zmc2V0JyBwaXhlbHMgZGlzdGFudFxyXG4gICAgICAgIC8vIGZyb20gdGhlIGZpcnN0IGxpbmsgYW5kIGZvcm1zIGEgcGVycGVuZGljdWxhciBhbmdsZSB0byBpdC4gQW5kIGFzIGluZGV4IGdvZXMgdXBcclxuICAgICAgICAvLyBhbHRlcm5hdGUgbGVmdCBhbmQgcmlnaHQuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgXiAgb2RkIGluZGV4ZXMgXHJcbiAgICAgICAgLy8gIHxcclxuICAgICAgICAvLyAgfC0tLS0+ICBpbmRleCAwIGxpbmUgKHN0cmFpZ2h0IGxpbmUgYmV0d2VlbiBhIHNvdXJjZSBjZW50ZXIgYW5kIGEgdGFyZ2V0IGNlbnRlci5cclxuICAgICAgICAvLyAgfFxyXG4gICAgICAgIC8vICB2ICBldmVuIGluZGV4ZXNcclxuICAgICAgICBjb25zdCBzaWduID0gY2VsbEluZGV4ICUgMiA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IGpvaW50LmcudG9SYWQodGhldGEgKyBzaWduICogOTApO1xyXG5cclxuICAgICAgICAvLyBXZSBmb3VuZCB0aGUgdmVydGV4LlxyXG4gICAgICAgIGNvbnN0IHZlcnRleCA9IGpvaW50LmcucG9pbnQuZnJvbVBvbGFyKG9mZnNldCwgYW5nbGUsIG1pZFBvaW50KTtcclxuXHJcbiAgICAgICAgY2VsbC5zZXQoJ3ZlcnRpY2VzJywgW3sgeDogdmVydGV4LngsIHk6IHZlcnRleC55IH1dKTtcclxuICAgIH19XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoIChzZWxlY3RlZEVsZW1lbnQsIGRhdGFDb250YWluZXIpIHtcclxuICAgIGNvbnN0IHNvdXJjZU1hcCA9IGRhdGFDb250YWluZXIubWFwcy5zb3VyY2VNYXA7XHJcbiAgICBjb25zdCB0YXJnZXRNYXAgPSBkYXRhQ29udGFpbmVyLm1hcHMudGFyZ2V0TWFwO1xyXG4gICAgY29uc3Qgbm9kZU1hcCA9IGRhdGFDb250YWluZXIubWFwcy5ub2RlTWFwO1xyXG5cclxuICAgIGNvbnN0IHBhdGhOb2RlcyA9IHt9O1xyXG4gICAgY29uc3QgcGF0aExpbmtzV2VzdCA9IHt9O1xyXG4gICAgY29uc3QgcGF0aExpbmtzRWFzdCA9IHt9O1xyXG5cclxuICAgIGlmIChub2RlTWFwW3NlbGVjdGVkRWxlbWVudC5pZF0pIHtcclxuICAgICAgICBzZWxlY3ROb2RlIChzZWxlY3RlZEVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgIHNlbGVjdE5vZGUgKHNlbGVjdGVkRWxlbWVudCwgZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwYXRoTGlua3NXZXN0W3NlbGVjdGVkRWxlbWVudC5pZF0gPSBzZWxlY3RlZEVsZW1lbnQ7XHJcbiAgICAgICAgcGF0aExpbmtzRWFzdFtzZWxlY3RlZEVsZW1lbnQuaWRdID0gc2VsZWN0ZWRFbGVtZW50O1xyXG4gICAgICAgIHNlbGVjdE5vZGUgKG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnRhcmdldF0sIHRydWUpO1xyXG4gICAgICAgIHNlbGVjdE5vZGUgKG5vZGVNYXBbc2VsZWN0ZWRFbGVtZW50Lm1vZGVsLnNvdXJjZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWxlY3ROb2RlIChjdXJOb2RlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICBwYXRoTm9kZXNbY3VyTm9kZS5pZF0gPSBjdXJOb2RlO1xyXG4gICAgICAgIGN1ck5vZGUuYXNwZWN0cy5mb3JFYWNoKGFzcGVjdCA9PiBwYXRoTm9kZXNbYXNwZWN0LmlkXSA9IGFzcGVjdCk7XHJcbiAgICAgICAgY29uc3QgbGlua3MgPSBkaXJlY3Rpb24gPyB0YXJnZXRNYXBbY3VyTm9kZS5pZF0gOiBzb3VyY2VNYXBbY3VyTm9kZS5pZF07XHJcbiAgICAgICAgaWYgKGxpbmtzKSB7XHJcbiAgICAgICAgICAgIGxpbmtzLmZvckVhY2ggKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICFwYXRoTGlua3NFYXN0W2xpbmsuaWRdICYmIGRpcmVjdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFwYXRoTGlua3NXZXN0W2xpbmsuaWRdICYmICFkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aExpbmtzRWFzdFtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aExpbmtzV2VzdFtsaW5rLmlkXSA9IGxpbms7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdE5vZGUobm9kZU1hcFtkaXJlY3Rpb24gPyBsaW5rLm1vZGVsLnRhcmdldCA6IGxpbmsubW9kZWwuc291cmNlXSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfLm1lcmdlKHBhdGhMaW5rc0Vhc3QsIHBhdGhMaW5rc1dlc3QsIHBhdGhOb2Rlcyk7XHJcbn0iLCJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogUmV0dXJucyBsaW1pdHRlZCBieSBib3VuZHMgcG9pbnQgdmFsdWVcclxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgXHJcbiAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGltaXRQb2ludFBvc2l0aW9uIChwb2ludCwgYm91bmRzKSB7XHJcbiAgICBpZiAoIWJvdW5kcykgcmV0dXJuIHBvaW50O1xyXG4gICAgXHJcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgTWF0aC5taW4oXHJcbiAgICAgICAgICAgIHBvaW50LngsXHJcbiAgICAgICAgICAgIGJvdW5kcy5tYXhYLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgYm91bmRzLm1pblgsXHJcbiAgICApO1xyXG4gICAgY29uc3QgeSA9IE1hdGgubWF4KFxyXG4gICAgICAgIE1hdGgubWluKFxyXG4gICAgICAgICAgICBwb2ludC55LFxyXG4gICAgICAgICAgICBib3VuZHMubWF4WSxcclxuICAgICAgICApLFxyXG4gICAgICAgIGJvdW5kcy5taW5ZLFxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG59XHJcblxyXG4vLyBnbG9iYWwgPSB7XHJcbi8vICAgICB4OiAxLFxyXG4vLyAgICAgeTogMSxcclxuLy8gfVxyXG4vLyBzY2FsZWQgPSB7XHJcbi8vICAgICB4OiBnbG9iYWwueCAqIHNjYWxlLFxyXG4vLyAgICAgeTogZ2xvYmFsLnkgKiBzY2FsZSxcclxuLy8gfVxyXG4vLyBsb2NhbCA9IHtcclxuLy8gICAgIHg6IHNjYWxlZC54ICsgdmlld0ZyYW1lU2NhbGVkUG9zLnggLSB2aWV3RnJhbWVWaWV3UG9ydFBvc2l0aW9uLngsXHJcbi8vICAgICB5OiBzY2FsZWQueSArIHZpZXdGcmFtZVNjYWxlZFBvcy55IC0gdmlld0ZyYW1lVmlld1BvcnRQb3NpdGlvbi55LFxyXG4vLyB9XHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlZFZpZXdGcmFtZVBvc2l0aW9uICh2aWV3RnJhbWUpIHtcclxuICAgIGlmICh2aWV3RnJhbWUucG9zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIHJldHVybiB2aWV3RnJhbWUucG9zaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodmlld0ZyYW1lLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdGcmFtZS5wb3NpdGlvbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFyYW1ldGVyIScpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsVmlld1BvcnRQb3NpdGlvbiAodmlld0ZyYW1lKSB7XHJcbiAgICBpZiAodmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQpIHtcclxuICAgICAgICByZXR1cm4gdmlld0ZyYW1lLnBvc2l0aW9uVmlld1BvcnQoKTtcclxuICAgIH0gZWxzZSBpZiAodmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdmlld0ZyYW1lLnZpZXdQb3J0UG9zaXRpb247XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHBhcmFtZXRlciEnKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE5vZGVQb3NpdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIF8uY2xvbmUobm9kZS5tb2RlbC5wb3NpdGlvbik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsZWROb2RlUG9zaXRpb24gKG5vZGUsIHNjYWxlKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldEdsb2JhbE5vZGVQb3NpdGlvbihub2RlKTtcclxuICAgIHJldHVybiBnbG9iYWxUb1NjYWxlZFBvaW50KHBvc2l0aW9uLCBzY2FsZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbE5vZGVQb3NpdGlvbiAobm9kZSwgc2NhbGUsIHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBnZXRHbG9iYWxOb2RlUG9zaXRpb24obm9kZSk7XHJcbiAgICByZXR1cm4gZ2xvYmFsVG9Mb2NhbFBvaW50KHBvc2l0aW9uLCBzY2FsZSwgdmlld0ZyYW1lKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE5vZGVTaXplIChub2RlLCBzY2FsZSkge1xyXG4gICAgY29uc3Qgc2NhbGVkU2l6ZSA9IGdldFNjYWxlZE5vZGVTaXplKG5vZGUpO1xyXG5cclxuICAgIHJldHVybiBzY2FsZWRUb0dsb2JhbFNpemUoc2NhbGVkU2l6ZSwgc2NhbGUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGVkTm9kZVNpemUgKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLmdldCgnc2l6ZScpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2xvYmFsVG9TY2FsZWRQb2ludCAocG9pbnQsIHNjYWxlKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvaW50LnggKiBzY2FsZS54LFxyXG4gICAgICAgIHk6IHBvaW50LnkgKiBzY2FsZS55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlZFRvR2xvYmFsUG9pbnQgKHBvaW50LCBzY2FsZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBwb2ludC54IC8gc2NhbGUueCxcclxuICAgICAgICB5OiBwb2ludC55IC8gc2NhbGUueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnbG9iYWxUb0xvY2FsUG9pbnQgKHBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKSB7XHJcbiAgICBpZiAoIXNjYWxlKSB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgIGNvbnN0IHNjYWxlZFBvaW50ID0gZ2xvYmFsVG9TY2FsZWRQb2ludChwb2ludCwgc2NhbGUpO1xyXG5cclxuICAgIHJldHVybiBzY2FsZWRUb0xvY2FsUG9pbnQoc2NhbGVkUG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUb0dsb2JhbFBvaW50IChwb2ludCwgc2NhbGUsIHZpZXdGcmFtZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICBjb25zdCBzY2FsZWRQb2ludCA9IGxvY2FsVG9TY2FsZWRQb2ludChwb2ludCwgc2NhbGUsIHZpZXdGcmFtZSk7XHJcbiAgICBcclxuICAgIHJldHVybiBzY2FsZWRUb0dsb2JhbFBvaW50KHNjYWxlZFBvaW50LCBzY2FsZSwgdmlld0ZyYW1lKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsVG9TY2FsZWRQb2ludCAocG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIGNvbnN0IHNjYWxlZFZpZXdGcmFtZU9mZnNldCA9IGdldFNjYWxlZFZpZXdGcmFtZVBvc2l0aW9uKHZpZXdGcmFtZSk7XHJcbiAgICBjb25zdCBnbG9iYWxWaWV3UG9ydE9mZnNldCA9IGdldEdsb2JhbFZpZXdQb3J0UG9zaXRpb24odmlld0ZyYW1lKTtcclxuICAgIGNvbnN0IHNjYWxlZFZpZXdQb3J0T2Zmc2V0ID0gZ2xvYmFsVG9TY2FsZWRQb2ludChnbG9iYWxWaWV3UG9ydE9mZnNldCwgc2NhbGUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcG9pbnQueCAtIHNjYWxlZFZpZXdGcmFtZU9mZnNldC54ICsgc2NhbGVkVmlld1BvcnRPZmZzZXQueCxcclxuICAgICAgICB5OiBwb2ludC55IC0gc2NhbGVkVmlld0ZyYW1lT2Zmc2V0LnkgKyBzY2FsZWRWaWV3UG9ydE9mZnNldC55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlZFRvTG9jYWxQb2ludCAocG9pbnQsIHNjYWxlLCB2aWV3RnJhbWUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgIGNvbnN0IHNjYWxlZFZpZXdGcmFtZU9mZnNldCA9IGdldFNjYWxlZFZpZXdGcmFtZVBvc2l0aW9uKHZpZXdGcmFtZSk7XHJcbiAgICBjb25zdCBnbG9iYWxWaWV3UG9ydE9mZnNldCA9IGdldEdsb2JhbFZpZXdQb3J0UG9zaXRpb24odmlld0ZyYW1lKTtcclxuICAgIGNvbnN0IHNjYWxlZFZpZXdQb3J0T2Zmc2V0ID0gZ2xvYmFsVG9TY2FsZWRQb2ludChnbG9iYWxWaWV3UG9ydE9mZnNldCwgc2NhbGUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogcG9pbnQueCArIHNjYWxlZFZpZXdGcmFtZU9mZnNldC54IC0gc2NhbGVkVmlld1BvcnRPZmZzZXQueCxcclxuICAgICAgICB5OiBwb2ludC55ICsgc2NhbGVkVmlld0ZyYW1lT2Zmc2V0LnkgLSBzY2FsZWRWaWV3UG9ydE9mZnNldC55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JhbFRvU2NhbGVkU2l6ZSAoc2l6ZSwgc2NhbGUpIHtcclxuICAgIGlmICghc2NhbGUpIHRocm93IG5ldyBFcnJvcignU2NhbGUgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCAqIHNjYWxlLngsXHJcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCAqIHNjYWxlLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVkVG9HbG9iYWxTaXplIChzaXplLCBzY2FsZSkge1xyXG4gICAgaWYgKCFzY2FsZSkgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoIC8gc2NhbGUueCxcclxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0IC8gc2NhbGUueSxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnbG9iYWxUb1NjYWxlZEJvdW5kcyAoYm91bmRzLCBzY2FsZSkge1xyXG4gICAgY29uc3Qgc2NhbGVkTWluUG9zaXRpb24gPSBnbG9iYWxUb1NjYWxlZFBvaW50KHsgeDogYm91bmRzLm1pblgsIHk6IGJvdW5kcy5taW5ZIH0sIHNjYWxlKTtcclxuICAgIGNvbnN0IHNjYWxlZE1heFBvc2l0aW9uID0gZ2xvYmFsVG9TY2FsZWRQb2ludCh7IHg6IGJvdW5kcy5tYXhYLCB5OiBib3VuZHMubWF4WSB9LCBzY2FsZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pblg6IHNjYWxlZE1pblBvc2l0aW9uLngsXHJcbiAgICAgICAgbWF4WDogc2NhbGVkTWF4UG9zaXRpb24ueCxcclxuICAgICAgICBtaW5ZOiBzY2FsZWRNaW5Qb3NpdGlvbi55LFxyXG4gICAgICAgIG1heFk6IHNjYWxlZE1heFBvc2l0aW9uLnksXHJcbiAgICAgICAgd2lkdGg6IHNjYWxlZE1heFBvc2l0aW9uLnggLSBzY2FsZWRNaW5Qb3NpdGlvbi54LFxyXG4gICAgICAgIGhlaWdodDogc2NhbGVkTWF4UG9zaXRpb24ueSAtIHNjYWxlZE1pblBvc2l0aW9uLnksXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVkVG9HbG9iYWxCb3VuZHMgKGJvdW5kcywgc2NhbGUpIHtcclxuICAgIGNvbnN0IHNjYWxlZE1pblBvc2l0aW9uID0gc2NhbGVkVG9HbG9iYWxQb2ludCh7IHg6IGJvdW5kcy5taW5YLCB5OiBib3VuZHMubWluWSB9LCBzY2FsZSk7XHJcbiAgICBjb25zdCBzY2FsZWRNYXhQb3NpdGlvbiA9IHNjYWxlZFRvR2xvYmFsUG9pbnQoeyB4OiBib3VuZHMubWF4WCwgeTogYm91bmRzLm1heFkgfSwgc2NhbGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5YOiBzY2FsZWRNaW5Qb3NpdGlvbi54LFxyXG4gICAgICAgIG1heFg6IHNjYWxlZE1heFBvc2l0aW9uLngsXHJcbiAgICAgICAgbWluWTogc2NhbGVkTWluUG9zaXRpb24ueSxcclxuICAgICAgICBtYXhZOiBzY2FsZWRNYXhQb3NpdGlvbi55LFxyXG4gICAgICAgIHdpZHRoOiBzY2FsZWRNYXhQb3NpdGlvbi54IC0gc2NhbGVkTWluUG9zaXRpb24ueCxcclxuICAgICAgICBoZWlnaHQ6IHNjYWxlZE1heFBvc2l0aW9uLnkgLSBzY2FsZWRNaW5Qb3NpdGlvbi55LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNocmlua0JvdW5kcyAoYm91bmRzLCBwYWRkaW5nUmVjdGFuZ2xlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1pblg6IGJvdW5kcy5taW5YICsgcGFkZGluZ1JlY3RhbmdsZS54LFxyXG4gICAgICAgIG1heFg6IGJvdW5kcy5tYXhYIC0gcGFkZGluZ1JlY3RhbmdsZS54LFxyXG4gICAgICAgIG1pblk6IGJvdW5kcy5taW5ZICsgcGFkZGluZ1JlY3RhbmdsZS55LFxyXG4gICAgICAgIG1heFk6IGJvdW5kcy5tYXhZIC0gcGFkZGluZ1JlY3RhbmdsZS55LFxyXG4gICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YIC0gcGFkZGluZ1JlY3RhbmdsZS54ICogMixcclxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pblkgLSBwYWRkaW5nUmVjdGFuZ2xlLnkgKiAyLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEJvdW5kcyAoYm91bmRzLCBleHRlbmRCeSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5YOiBib3VuZHMubWluWCAtIGV4dGVuZEJ5LngsXHJcbiAgICAgICAgbWF4WDogYm91bmRzLm1heFggKyBleHRlbmRCeS54LFxyXG4gICAgICAgIG1pblk6IGJvdW5kcy5taW5ZIC0gZXh0ZW5kQnkueSxcclxuICAgICAgICBtYXhZOiBib3VuZHMubWF4WSArIGV4dGVuZEJ5LnksXHJcbiAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYICsgZXh0ZW5kQnkueCAqIDIgLSBib3VuZHMubWluWCxcclxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZICsgZXh0ZW5kQnkueSAqIDIgLSBib3VuZHMubWluWSxcclxuICAgIH07XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50U2l6ZSAocm9vdElkKSB7XHJcbiAgICBjb25zdCBwYXBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJvb3RJZCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBwYXBlci5jbGllbnRXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHBhcGVyLmNsaWVudEhlaWdodCxcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvTWFwIChhcnJheSwgdXNlQXNJZCkge1xyXG4gICAgdXNlQXNJZCA9IHVzZUFzSWQgfHwgJ2lkJztcclxuICAgIGNvbnN0IG1hcCA9IHt9O1xyXG4gICAgYXJyYXkuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgbWFwW2VsW3VzZUFzSWRdXSA9IGVsO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbWFwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9BcnJheSAobWFwKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5tYXAoa2V5ID0+IG1hcFtrZXldKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3QgKHAxLCBwMikge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZiAobjEsIG4yKSB7XHJcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihuMSwgbjIpO1xyXG4gICAgaWYgKG1pbiA8IDApIHtcclxuICAgICAgICBuMSArPSAtbWluO1xyXG4gICAgICAgIG4yICs9IC1taW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5hYnMobjIgLSBuMSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvbkRyYWdTdGFydCAoZXZlbnQsIG1vdmVDYWxsYmFjaywgcmVsZWFzZUNhbGxiYWNrKSB7XHJcbiAgICBsZXQgc3RhcnRYID0gMDtcclxuICAgIGxldCBzdGFydFkgPSAwO1xyXG4gIFxyXG4gICAgY29uc3QgcG9pbnRQcm92aWRlciA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGV2ZW50IDogZXZlbnQudG91Y2hlc1swXTtcclxuICBcclxuICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VYKSBzdGFydFggPSBwb2ludFByb3ZpZGVyLnBhZ2VYO1xyXG4gICAgZWxzZSBpZiAocG9pbnRQcm92aWRlci5jbGllbnRYKSBzdGFydFggPSBwb2ludFByb3ZpZGVyLmNsaWVudFg7XHJcbiAgXHJcbiAgICBpZiAocG9pbnRQcm92aWRlci5wYWdlWSkgc3RhcnRZID0gcG9pbnRQcm92aWRlci5wYWdlWTtcclxuICAgIGVsc2UgaWYgKHBvaW50UHJvdmlkZXIuY2xpZW50WSkgc3RhcnRZID0gcG9pbnRQcm92aWRlci5jbGllbnRZO1xyXG4gIFxyXG4gICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gIFxyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25jaGFuZ2UpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29uZW5kKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX29uY2hhbmdlKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfb25lbmQpO1xyXG4gIFxyXG4gICAgZnVuY3Rpb24gX29uY2hhbmdlIChldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50UHJvdmlkZXIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudCA6IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgXHJcbiAgICAgICAgbGV0IGVuZFggPSAwO1xyXG4gICAgICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VYKSBlbmRYID0gcG9pbnRQcm92aWRlci5wYWdlWDtcclxuICAgICAgICBlbHNlIGlmIChwb2ludFByb3ZpZGVyLmNsaWVudFgpIGVuZFggPSBwb2ludFByb3ZpZGVyLmNsaWVudFg7XHJcbiAgXHJcbiAgICAgICAgY29uc3QgZGlmZlggPSBlbmRYIC0gc3RhcnRYO1xyXG4gICAgICAgIHN0YXJ0WCA9IGVuZFg7XHJcbiAgXHJcbiAgICAgICAgbGV0IGVuZFkgPSAwO1xyXG4gICAgICAgIGlmIChwb2ludFByb3ZpZGVyLnBhZ2VZKSBlbmRZID0gcG9pbnRQcm92aWRlci5wYWdlWTtcclxuICAgICAgICBlbHNlIGlmIChwb2ludFByb3ZpZGVyLmNsaWVudFkpIGVuZFkgPSBwb2ludFByb3ZpZGVyLmNsaWVudFk7XHJcbiAgXHJcbiAgICAgICAgY29uc3QgZGlmZlkgPSBlbmRZIC0gc3RhcnRZO1xyXG4gICAgICAgIHN0YXJ0WSA9IGVuZFk7XHJcbiAgXHJcbiAgICAgICAgbW92ZUNhbGxiYWNrKHsgeDogZGlmZlgsIHk6IGRpZmZZLCB9KTtcclxuICAgIH1cclxuICBcclxuICAgIGZ1bmN0aW9uIF9vbmVuZCAoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5vbm1vdXNlbW92ZSA9IGRvY3VtZW50LmJvZHkub25tb3VzZXVwID0gbnVsbDtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX29uZW5kKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9vbmNoYW5nZSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9vbmVuZCk7XHJcbiAgICAgICAgaWYgKHJlbGVhc2VDYWxsYmFjaykgcmVsZWFzZUNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfSIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIHQ7dD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsdC5UUUdyYW1VST1lKCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLG8pe2Z1bmN0aW9uIHIobCxhKXtpZighbltsXSl7aWYoIXRbbF0pe3ZhciBzPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWEmJnMpcmV0dXJuIHMobCwhMCk7aWYoaSlyZXR1cm4gaShsLCEwKTt2YXIgdT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2wrXCInXCIpO3Rocm93IHUuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix1fXZhciBkPW5bbF09e2V4cG9ydHM6e319O3RbbF1bMF0uY2FsbChkLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtsXVsxXVtlXTtyZXR1cm4gcihuP246ZSl9LGQsZC5leHBvcnRzLGUsdCxuLG8pfXJldHVybiBuW2xdLmV4cG9ydHN9Zm9yKHZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsbD0wO2w8by5sZW5ndGg7bCsrKXIob1tsXSk7cmV0dXJuIHJ9cmV0dXJuIGV9KCkoezE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe2Z1bmN0aW9uIHQoKXtpLnJvb3RIdG1sLmlubmVySFRNTD1cIlwiLGkucm9vdEh0bWwuc3R5bGUuYm9yZGVyVG9wPTAhPT1pLmJ1dHRvbnMubGVuZ3RoP1wiMXB4IHNvbGlkICNjY2NjY2NcIjpudWxsLGkucm9vdEh0bWwuc3R5bGUuYm9yZGVyQm90dG9tPTAhPT1pLmJ1dHRvbnMubGVuZ3RoP1wiMXB4IHNvbGlkICNjY2NjY2NcIjpudWxsLGkuYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCVVRUT05cIik7dC50aXRsZT1lLmxhYmVsLHQuY2xhc3NOYW1lPVwidHEtdWktdG9vbGJhcl9fYnV0dG9uIHRxLXVpLWNvbG9yZWQtYnV0dG9uXCIsdC5pbm5lckhUTUw9JzxzcGFuIHN0eWxlPVwiY29sb3I6ICcrZS5ib3JkZXJDb2xvcisnXCI+JytuKGUubGFiZWwpK1wiPC9zcGFuPlwiLHQuc3R5bGUuYmFja2dyb3VuZENvbG9yPWUuYmFja2dyb3VuZENvbG9yfHxcIndoaXRlXCIsdC5zdHlsZS5ib3JkZXJDb2xvcj1lLmJvcmRlckNvbG9yfHxcImJsYWNrXCIsdC5vbmNsaWNrPWZ1bmN0aW9uKHQpe2UuY2FsbGJhY2soZSx0KX0saS5yb290SHRtbC5hcHBlbmRDaGlsZCh0KX0pfWZ1bmN0aW9uIG4oZSl7aWYoZSl7dmFyIHQ9ZS5tYXRjaCgvW2EteidcXC1dKy9naSk7cmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVyblwiYW5kXCIhPT1lLnRvTG93ZXJDYXNlKCkmJlwiJlwiIT09ZX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVswXX0pLmpvaW4oXCJcIil9fWZ1bmN0aW9uIG8oKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiBlLmNsYXNzTmFtZT1cInRxLXVpLWNvbG9yZWQtYnV0dG9ucy1saXN0XCIsZS5pbm5lckhUTUw9XCJcIixlfXZhciBpPXRoaXM7ZXx8KGU9e30pLGkucm9vdEh0bWw9bygpLGkuaWQ9ZS5pZHx8XCJjb2xvcmVkQnV0dG9ucy1cIityKyssaS5yb290SHRtbC5pZD1pLmlkLGkuYnV0dG9ucz1lLmJ1dHRvbnN8fFtdLHQoKSxpLnJlbW92ZUFsbD1mdW5jdGlvbigpe2kuYnV0dG9ucz1bXSx0KCl9LGkuYWRkQnV0dG9uPWZ1bmN0aW9uKGUpe2kuYnV0dG9ucy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KS5pbmRleE9mKGUuaWQpPT09LTEmJihpLmJ1dHRvbnMucHVzaChlKSx0KCkpfSxpLnJlbW92ZUJ1dHRvbj1mdW5jdGlvbihlKXtpLmJ1dHRvbnMuc3BsaWNlKGkuYnV0dG9ucy5pbmRleE9mKGUpLDEpLHQoKX19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5Db2xvcmVkQnV0dG9uc0xpc3Q9bzt2YXIgcj0wO25bXCJkZWZhdWx0XCJdPW99LHt9XSwyOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIHIoZSl7ZnVuY3Rpb24gdCgpe2lmKGUuYm9keSBpbnN0YW5jZW9mIE9iamVjdCl7dmFyIHQ9ci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWJvZHlfY29udGFpbmVyXCIpO3QuYXBwZW5kQ2hpbGQoZS5ib2R5LnJvb3RIdG1sKX12YXIgYT1yLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX2hlYWRlclwiKTthLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixvKTt2YXIgcz1yLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktd2luZG93cy1jb2xsYXBzZS1idXR0b25cIik7aWYocy5vbmNsaWNrPXIuaGlkZSxlLnJlc2l6YWJsZSl7dmFyIHU9ci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLXRvcC1ib3JkZXJcIik7dS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwiblwiKX0pO3ZhciBkPXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS1yaWdodC1ib3JkZXJcIik7ZC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwiZVwiKX0pO3ZhciBjPXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS1ib3R0b20tYm9yZGVyXCIpO2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcInNcIil9KTt2YXIgZj1yLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIudHEtdWktbGVmdC1ib3JkZXJcIik7Zi5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oZSl7byhlLFwid1wiKX0pO3ZhciBwPXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS10b3AtcmlnaHQtYm9yZGVyXCIpO3AuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcIm5lXCIpfSk7dmFyIGI9ci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLXRvcC1sZWZ0LWJvcmRlclwiKTtiLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJud1wiKX0pO3ZhciBtPXIucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIi50cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlci50cS11aS1ib3R0b20tcmlnaHQtYm9yZGVyXCIpO20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGUpe28oZSxcInNlXCIpfSk7dmFyIHk9ci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiLnRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyLnRxLXVpLWJvdHRvbS1sZWZ0LWJvcmRlclwiKTt5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixmdW5jdGlvbihlKXtvKGUsXCJzd1wiKX0pfXIuX3RyaWdnZXJCdXR0b249aShlLnRyaWdnZXJCdXR0b24pLG4oKSxyLl90cmlnZ2VyQnV0dG9uJiYoci5fdHJpZ2dlckJ1dHRvbi5vbmNsaWNrPWZ1bmN0aW9uKCl7bD9yLnNob3coKTpyLmhpZGUoKX0pfWZ1bmN0aW9uIG4oKXtsPyhyLl90cmlnZ2VyQnV0dG9uJiYoci5fdHJpZ2dlckJ1dHRvbi5jbGFzc05hbWU9ci5fdHJpZ2dlckJ1dHRvbi5jbGFzc05hbWUucmVwbGFjZSgvIHRxLXVpLXNlbGVjdGVkL2dpLFwiXCIpKSxyLnJvb3RIdG1sLmNsYXNzTmFtZT1yLnJvb3RIdG1sLmNsYXNzTmFtZStcIiB0cS11aS1jb2xsYXBzZWRcIik6KHIuX3RyaWdnZXJCdXR0b24mJihyLl90cmlnZ2VyQnV0dG9uLmNsYXNzTmFtZT1yLl90cmlnZ2VyQnV0dG9uLmNsYXNzTmFtZStcIiB0cS11aS1zZWxlY3RlZFwiKSxyLnJvb3RIdG1sLmNsYXNzTmFtZT1yLnJvb3RIdG1sLmNsYXNzTmFtZS5yZXBsYWNlKC8gdHEtdWktY29sbGFwc2VkL2dpLFwiXCIpKX1mdW5jdGlvbiBvKGUsdCl7ZnVuY3Rpb24gbihlKXtyLl9tb3VzZU1vdmU9ITA7dmFyIG49MDtlLnBhZ2VYP249ZS5wYWdlWDplLmNsaWVudFgmJihuPWUuY2xpZW50WCk7dmFyIG89bi1sO2w9bix0fHwoci5yb290SHRtbC5zdHlsZS5sZWZ0PXIucm9vdEh0bWwub2Zmc2V0TGVmdCtvK1wicHhcIik7dmFyIHM9MDtlLnBhZ2VZP3M9ZS5wYWdlWTplLmNsaWVudFkmJihzPWUuY2xpZW50WSk7dmFyIHU9cy1hO2E9cyx0fHwoci5yb290SHRtbC5zdHlsZS50b3A9ci5yb290SHRtbC5vZmZzZXRUb3ArdStcInB4XCIpLHQ/KGkobyx1LHQpLHIudHJpZ2dlcihcInNpemUtY2hhbmdlZFwiLHt3aWR0aDpyLnJvb3RIdG1sLm9mZnNldFdpZHRoLGhlaWdodDpyLnJvb3RIdG1sLm9mZnNldEhlaWdodH0pLHQuaW5kZXhPZihcIm5cIik9PT0tMSYmdC5pbmRleE9mKFwid1wiKT09PS0xfHxyLnRyaWdnZXIoXCJwb3NpdGlvbi1jaGFuZ2VkXCIse3g6ci5yb290SHRtbC5vZmZzZXRMZWZ0LHk6ci5yb290SHRtbC5vZmZzZXRUb3B9KSk6ci50cmlnZ2VyKFwicG9zaXRpb24tY2hhbmdlZFwiLHt4OnIucm9vdEh0bWwub2Zmc2V0TGVmdCx5OnIucm9vdEh0bWwub2Zmc2V0VG9wfSl9ZnVuY3Rpb24gbyhlKXtyLl9tb3VzZU1vdmUmJihuKGUsITApLHIuX21vdXNlTW92ZT0hMSksZG9jdW1lbnQuYm9keS5vbm1vdXNlbW92ZT1kb2N1bWVudC5ib2R5Lm9ubW91c2V1cD1udWxsLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLG4pLGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixvKX1mdW5jdGlvbiBpKGUsdCxuKXtzd2l0Y2gobil7Y2FzZVwiblwiOnIucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PXIucm9vdEh0bWwub2Zmc2V0SGVpZ2h0LXQrXCJweFwiLHIucm9vdEh0bWwuc3R5bGUudG9wPXIucm9vdEh0bWwub2Zmc2V0VG9wK3QrXCJweFwiO2JyZWFrO2Nhc2VcImVcIjpyLnJvb3RIdG1sLnN0eWxlLndpZHRoPXIucm9vdEh0bWwub2Zmc2V0V2lkdGgrZStcInB4XCI7YnJlYWs7Y2FzZVwic1wiOnIucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PXIucm9vdEh0bWwub2Zmc2V0SGVpZ2h0K3QrXCJweFwiO2JyZWFrO2Nhc2VcIndcIjpyLnJvb3RIdG1sLnN0eWxlLndpZHRoPXIucm9vdEh0bWwub2Zmc2V0V2lkdGgtZStcInB4XCIsci5yb290SHRtbC5zdHlsZS5sZWZ0PXIucm9vdEh0bWwub2Zmc2V0TGVmdCtlK1wicHhcIjticmVhaztjYXNlXCJuZVwiOnIucm9vdEh0bWwuc3R5bGUud2lkdGg9ci5yb290SHRtbC5vZmZzZXRXaWR0aCtlK1wicHhcIixyLnJvb3RIdG1sLnN0eWxlLmhlaWdodD1yLnJvb3RIdG1sLm9mZnNldEhlaWdodC10K1wicHhcIixyLnJvb3RIdG1sLnN0eWxlLnRvcD1yLnJvb3RIdG1sLm9mZnNldFRvcCt0K1wicHhcIjticmVhaztjYXNlXCJud1wiOnIucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PXIucm9vdEh0bWwub2Zmc2V0SGVpZ2h0LXQrXCJweFwiLHIucm9vdEh0bWwuc3R5bGUudG9wPXIucm9vdEh0bWwub2Zmc2V0VG9wK3QrXCJweFwiLHIucm9vdEh0bWwuc3R5bGUud2lkdGg9ci5yb290SHRtbC5vZmZzZXRXaWR0aC1lK1wicHhcIixyLnJvb3RIdG1sLnN0eWxlLmxlZnQ9ci5yb290SHRtbC5vZmZzZXRMZWZ0K2UrXCJweFwiO2JyZWFrO2Nhc2VcInNlXCI6ci5yb290SHRtbC5zdHlsZS53aWR0aD1yLnJvb3RIdG1sLm9mZnNldFdpZHRoK2UrXCJweFwiLHIucm9vdEh0bWwuc3R5bGUuaGVpZ2h0PXIucm9vdEh0bWwub2Zmc2V0SGVpZ2h0K3QrXCJweFwiO2JyZWFrO2Nhc2VcInN3XCI6ci5yb290SHRtbC5zdHlsZS5oZWlnaHQ9ci5yb290SHRtbC5vZmZzZXRIZWlnaHQrdCtcInB4XCIsci5yb290SHRtbC5zdHlsZS53aWR0aD1yLnJvb3RIdG1sLm9mZnNldFdpZHRoLWUrXCJweFwiLHIucm9vdEh0bWwuc3R5bGUubGVmdD1yLnJvb3RIdG1sLm9mZnNldExlZnQrZStcInB4XCJ9fXZhciBsPTAsYT0wO2UucGFnZVg/bD1lLnBhZ2VYOmUuY2xpZW50WCYmKGw9ZS5jbGllbnRYKSxlLnBhZ2VZP2E9ZS5wYWdlWTplLmNsaWVudFkmJihhPWUuY2xpZW50WSksd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpLGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLG4pLGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixvKX1zW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKTt2YXIgcj10aGlzO2V8fChlPXt9KTt2YXIgbD0hZS5hY3RpdmU7ci5tYXJrdXA9J1xcbiAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbFwiXFxuICAgICAgICAgICAgc3R5bGU9XCJcXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcrKGUuc2l6ZT9lLnNpemUud2lkdGg6XCJcIikrXCI7XFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCIrKGUuc2l6ZT9lLnNpemUuaGVpZ2h0OlwiXCIpK1wiO1xcbiAgICAgICAgICAgICAgICBsZWZ0OiBcIisoZS5wb3NpdGlvbj9lLnBvc2l0aW9uLng6XCJcIikrXCI7XFxuICAgICAgICAgICAgICAgIHRvcDogXCIrKGUucG9zaXRpb24/ZS5wb3NpdGlvbi55OlwiXCIpKyc7XFxuICAgICAgICAgICAgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX2hlYWRlclwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX2hlYWRlcl9faGVhZGVyXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS11aS13aW5kb3ctaGVhZGVyLWxhYmVsXCI+JysoZS5oZWFkZXI/ZS5oZWFkZXI6XCJcIikrJzwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW1nIGFsdD1cIkNvbGxhcHNlIEJ1dHRvblwiIGNsYXNzPVwidHEtdWktd2luZG93cy1jb2xsYXBzZS1idXR0b25cIi8+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ib2R5XCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1ib2R5X2NvbnRhaW5lciAnKyhlLnJlbW92ZUJhY2tncm91bmQ/XCJ0cS11aS1ib2R5X2VtcHR5LWNvbnRhaW5lclwiOlwidHEtdWktYm9keV9kZWZhdWx0LWNvbnRhaW5lclwiKSsnXCI+XFxuICAgICAgICAgICAgICAgICAgICAnKyhlLmJvZHkmJlwic3RyaW5nXCI9PXR5cGVvZiBlLmJvZHk/ZS5ib2R5OlwiXCIpK1wiXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIFwiKyhlLnJlc2l6YWJsZT8nXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS10b3AtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS1yaWdodC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLWJvdHRvbS1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLWxlZnQtYm9yZGVyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS1mbHlpbmctcGFuZWxfX2JvcmRlciB0cS11aS10b3AtbGVmdC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLXRvcC1yaWdodC1ib3JkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWZseWluZy1wYW5lbF9fYm9yZGVyIHRxLXVpLWJvdHRvbS1sZWZ0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktZmx5aW5nLXBhbmVsX19ib3JkZXIgdHEtdWktYm90dG9tLXJpZ2h0LWJvcmRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICc6XCJcIikrXCJcXG4gICAgICAgIDwvZGl2PlwiO3ZhciBhPWkoZS5iYXNlRWxlbWVudCk7YS5pbm5lckhUTUw9ci5tYXJrdXAsci5yb290SHRtbD1hLnF1ZXJ5U2VsZWN0b3IoXCIudHEtdWktZmx5aW5nLXBhbmVsXCIpLHIuaWQ9ZS5pZHx8XCJmbHlpbmdQYW5lbC1cIit1Kyssci5yb290SHRtbC5pZD1yLmlkLHIuc2hvdz1mdW5jdGlvbihlKXtlJiZlLnN0b3BQcm9wYWdhdGlvbigpLGwmJihsPSExLG4oKSl9LHIuaGlkZT1mdW5jdGlvbihlKXtlJiZlLnN0b3BQcm9wYWdhdGlvbigpLGx8fChsPSEwLG4oKSl9LHQoKX1mdW5jdGlvbiBpKGUpe3ZhciB0PXZvaWQgMDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpOlwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIjpsKGUpKSYmKHQ9ZSksdH1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTtuLkZseWluZ1BhbmVsPXI7dmFyIGE9ZShcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIikscz1vKGEpLHU9MDtuW1wiZGVmYXVsdFwiXT1yfSx7XCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI6OH1dLDM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gcihlKXtmdW5jdGlvbiB0KGUpe2Z1bmN0aW9uIHQoZSl7dmFyIHQ9ZS5sYWJlbCxuPWUubGFiZWwrXCIgKFwiK2UuaWQrXCIpXCIsbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiTElcIik7cmV0dXJuIG8uY2xhc3NOYW1lPVwidHEtdWktcHJvcGVydHktYnV0dG9uXCIsby50aXRsZT1uLG8uaW5uZXJUZXh0PXQsby5vbmNsaWNrPWZ1bmN0aW9uKCl7ci50cmlnZ2VyKFwic2VsZWN0ZWQtZWxlbWVudC1jaGFuZ2VkXCIsZS5pZCl9LG99dmFyIG49ci5yb290SHRtbC5xdWVyeVNlbGVjdG9yKFwiI3JlbGF0ZWRFbGVtZW50c1wiKTtuLmlubmVySFRNTD1cIlwiO3ZhciBvPWUuaW5jb21pbmdzfHxbXTtpZihvLmxlbmd0aCl7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkxBQkVMXCIpO2kuY2xhc3NOYW1lPVwidHEtbGFiZWxcIixpLmlubmVyVGV4dD1cIkluY29taW5nIG5vZGVzOlwiLG4uYXBwZW5kQ2hpbGQoaSk7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlVMXCIpO2wuY2xhc3NOYW1lPVwidHEtdWktaW5mby1wYW5lbF9yZWxhdGVkLWVsZW1lbnRzX2xpc3RcIixuLmFwcGVuZENoaWxkKGwpLG8uZm9yRWFjaChmdW5jdGlvbihlKXtsLmFwcGVuZENoaWxkKHQoZSkpfSl9dmFyIGE9ZS5vdXRnb2luZ3N8fFtdO2lmKGEubGVuZ3RoKXt2YXIgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiTEFCRUxcIik7cy5jbGFzc05hbWU9XCJ0cS1sYWJlbFwiLHMuaW5uZXJUZXh0PVwiT3V0Z29pbmcgbm9kZXM6XCIsbi5hcHBlbmRDaGlsZChzKTt2YXIgdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiVUxcIik7dS5jbGFzc05hbWU9XCJ0cS11aS1pbmZvLXBhbmVsX3JlbGF0ZWQtZWxlbWVudHNfbGlzdFwiLG4uYXBwZW5kQ2hpbGQodSksYS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3UuYXBwZW5kQ2hpbGQodChlKSl9KX19ZnVuY3Rpb24gbihlKXt2YXIgdD1cIlwiO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3QrPSc8bGFiZWwgZm9yPVwiJytuKydcIiBjbGFzcz1cInRxLWxhYmVsXCI+JytuKyc8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cIicrbisnXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgdmFsdWU9XCInK2Vbbl0rJ1wiIGRpc2FibGVkPjwvaW5wdXQ+J30pLHR9ZnVuY3Rpb24gbygpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuY2xhc3NOYW1lPVwidHEtdWktaW5mby1wYW5lbFwiLGUuaW5uZXJIVE1MPXIubWFya3VwLGV9bFtcImRlZmF1bHRcIl0uYXBwbHkodGhpcyksZXx8KGU9e30pO3ZhciByPXRoaXMsaT1lLnBsYWNlaG9sZGVyfHxcIlNlbGVjdCBhIGRpYWdyYW0gZWxlbWVudFwiLHM9JzxkaXYgY2xhc3M9XCJ0cS11aS1pbmZvLXBhbmVsX2VtcHR5LXN0dWZmXCI+JytpK1wiPC9kaXY+XCI7ci5yb290SHRtbD1vKCksci5yb290SHRtbC5pbm5lckhUTUw9cyxyLmlkPWUuaWR8fFwiaW5mb1BhbmVsLVwiK2ErKyxyLnJvb3RIdG1sLmlkPXIuaWQsci5zZXRTZWxlY3RlZEVsZW1lbnQ9ZnVuY3Rpb24obyl7aWYobyl7aWYoci5yb290SHRtbC5pbm5lckhUTUw9XCJcIisoZS5sYXVuY2hFeHRlcm5hbCYmXCJub2RlXCI9PT1vLmRpYWdyYW1UeXBlPyc8ZGl2IGNsYXNzPVwidHEtdWktZ3JvdXBcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cInRxTGF1bmNoRXh0ZXJuYWxCdG5cIiBjbGFzcz1cInRxLWJ1dHRvblwiIHRpdGxlPVwiVmlldyBtb3JlIGluIG5ldyB0YWIuXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgTW9yZSAmbmJzcDtcXG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLW5ldy13aW5kb3dcIj48L3NwYW4+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgPC9kaXY+JzpcIlwiKSsoby5pZD8nXFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJ0cS1sYWJlbFwiPklEPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cIicrby5pZCsnXCIgdHlwZT1cInRleHRcIiBhcmlhLWxhYmVsPVwiSW5wdXQgZm9yIElEXCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8ubGFiZWw/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj5MYWJlbDwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdmFsdWU9XCInK28ubGFiZWwrJ1wiIHR5cGU9XCJ0ZXh0XCIgYXJpYS1sYWJlbD1cIklucHV0IGZvciBMYWJlbFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHlcIiBkaXNhYmxlZD48L2lucHV0PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpKyhvLnR5cGVzPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInRxLWxhYmVsXCI+VHlwZXM8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHZhbHVlPVwiJytvLnR5cGVzKydcIiB0eXBlPVwidGV4dFwiIGFyaWEtbGFiZWw9XCJJbnB1dCBmb3IgVHlwZXNcIiBjbGFzcz1cInRxLXVpLXByb3BlcnR5XCIgZGlzYWJsZWQ+PC9pbnB1dD5cXG4gICAgICAgICAgICAgICAgJzpcIlwiKSsoby5zb3VyY2U/J1xcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cImxpbmtGcm9tXCIgY2xhc3M9XCJ0cS1sYWJlbFwiPlNvdXJjZTwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwibGlua0Zyb21cIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHktYnV0dG9uXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8udGFyZ2V0PydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJsaW5rVG9cIiBjbGFzcz1cInRxLWxhYmVsXCI+VGFyZ2V0PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJsaW5rVG9cIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwidHEtdWktcHJvcGVydHktYnV0dG9uXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8udGhpY2tuZXNzPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJ0aGlja25lc3NcIiBjbGFzcz1cInRxLWxhYmVsXCI+VGhpY2tuZXNzPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cIicrby50aGlja25lc3MrJ1wiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ0cS11aS1wcm9wZXJ0eVwiIGRpc2FibGVkPjwvaW5wdXQ+XFxuICAgICAgICAgICAgICAgICc6XCJcIikrKG8uZGF0YT9uKG8uZGF0YSk6XCJcIikrKG8ucmVsYXRpb25zPydcXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZWxhdGVkRWxlbWVudHNcIiBjbGFzcz1cInRxLWxhYmVsXCI+UmVsYXRlZCBlbGVtZW50czwvbGFiZWw+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICAgaWQ9XCJyZWxhdGVkRWxlbWVudHNcIiBjbGFzcz1cInRxLXVpLWluZm8tcGFuZWxfcmVsYXRlZC1lbGVtZW50c1wiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAnOlwiXCIpLGUubGF1bmNoRXh0ZXJuYWwmJlwibm9kZVwiPT09by5kaWFncmFtVHlwZSl7dmFyIGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cUxhdW5jaEV4dGVybmFsQnRuXCIpO2kub25jbGljaz1mdW5jdGlvbigpe2UubGF1bmNoRXh0ZXJuYWwobyl9fWlmKG8ucmVsYXRpb25zJiZ0KG8ucmVsYXRpb25zKSxvLnNvdXJjZSl7dmFyIGw9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaW5rRnJvbVwiKTtsLmlubmVyVGV4dD1vLnNvdXJjZS5sYWJlbCxsLnRpdGxlPW8uc291cmNlLmxhYmVsK1wiKElEOiBcIitvLnNvdXJjZS5pZCtcIilcIixsLm9uY2xpY2s9ZnVuY3Rpb24oKXtyLnRyaWdnZXIoXCJzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcIixvLnNvdXJjZS5pZCl9fWlmKG8udGFyZ2V0KXt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpbmtUb1wiKTthLmlubmVyVGV4dD1vLnRhcmdldC5sYWJlbCxhLnRpdGxlPW8udGFyZ2V0LmxhYmVsK1wiKElEOiBcIitvLnRhcmdldC5pZCtcIilcIixhLm9uY2xpY2s9ZnVuY3Rpb24oKXtyLnRyaWdnZXIoXCJzZWxlY3RlZC1lbGVtZW50LWNoYW5nZWRcIixvLnRhcmdldC5pZCl9fX1lbHNlIHIucm9vdEh0bWwuaW5uZXJIVE1MPXN9LGUuc2VsZWN0ZWRFbGVtZW50JiZyLnNldFNlbGVjdGVkRWxlbWVudChlLnNlbGVjdGVkRWxlbWVudCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5JbmZvUGFuZWw9cjt2YXIgaT1lKFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiKSxsPW8oaSksYT0wO25bXCJkZWZhdWx0XCJdPXJ9LHtcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIjo4fV0sNDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuaW5uZXJIVE1MPW4ubWFya3VwLGUucXVlcnlTZWxlY3RvcihcIi50cS11aS1sZWdlbmQtcGFuZWxfYm9keV9sZWdlbmRzXCIpfXZhciBuPXRoaXM7ZXx8KGU9e30pO3ZhciBvPWUubGVnZW5kc3x8W107bi5tYXJrdXA9J1xcbiAgICAgICAgPGRpdiBjbGFzcz1cInRxLXVpLWxlZ2VuZC1wYW5lbF9ib2R5X2xlZ2VuZHNcIj5cXG4gICAgICAgICcrby5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuJ1xcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktbGVnZW5kLXBhbmVsX2JvZHlfbGVnZW5kc19sZWdlbmRcIiB0aXRsZT1cIicrZS5kZXNjcmlwdGlvbisnXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktbGVnZW5kLXBhbmVsX2JvZHlfbGVnZW5kc19sZWdlbmRfaW1nXCI+PGltZyBzcmM9XCInK2UuaW1hZ2UrJ1wiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwidHEtbGFiZWxcIj4nK2UubGFiZWwrXCI8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICBcIn0pLmpvaW4oXCJcIikrXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixuLnJvb3RIdG1sPXQoKSxuLmlkPWUuaWR8fFwibGVnZW5kcy1cIityKyssbi5yb290SHRtbC5pZD1uLmlkfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4uTGVnZW5kcz1vO3ZhciByPTA7bltcImRlZmF1bHRcIl09b30se31dLDU6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIHI9ZShcIi4vY29sb3JlZEJ1dHRvbnNMaXN0XCIpLGk9byhyKSxsPWUoXCIuL2ZseWluZ1BhbmVsXCIpLGE9byhsKSxzPWUoXCIuL2luZm9QYW5lbFwiKSx1PW8ocyksZD1lKFwiLi9sZWdlbmRzXCIpLGM9byhkKSxmPWUoXCIuL3Byb2dyZXNzU2NyZWVuXCIpLHA9byhmKSxiPWUoXCIuL3NlYXJjaFBhbmVsXCIpLG09byhiKSx5PWUoXCIuL3N3aXRjaGVyXCIpLHY9byh5KSxnPWUoXCIuL3RhYlBhbmVsXCIpLGg9byhnKSxIPWUoXCIuL3Rvb2xiYXJcIikscT1vKEgpO3QuZXhwb3J0cz17Q29sb3JlZEJ1dHRvbnNMaXN0OmlbXCJkZWZhdWx0XCJdLEZseWluZ1BhbmVsOmFbXCJkZWZhdWx0XCJdLEluZm9QYW5lbDp1W1wiZGVmYXVsdFwiXSxMZWdlbmRzOmNbXCJkZWZhdWx0XCJdLFByb2dyZXNzU2NyZWVuOnBbXCJkZWZhdWx0XCJdLFNlYXJjaFBhbmVsOm1bXCJkZWZhdWx0XCJdLFN3aXRjaGVyOnZbXCJkZWZhdWx0XCJdLFRhYlBhbmVsOmhbXCJkZWZhdWx0XCJdLFRvb2xiYXI6cVtcImRlZmF1bHRcIl19fSx7XCIuL2NvbG9yZWRCdXR0b25zTGlzdFwiOjEsXCIuL2ZseWluZ1BhbmVsXCI6MixcIi4vaW5mb1BhbmVsXCI6MyxcIi4vbGVnZW5kc1wiOjQsXCIuL3Byb2dyZXNzU2NyZWVuXCI6NixcIi4vc2VhcmNoUGFuZWxcIjo3LFwiLi9zd2l0Y2hlclwiOjksXCIuL3RhYlBhbmVsXCI6MTAsXCIuL3Rvb2xiYXJcIjoxMX1dLDY6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gcihlKXtmdW5jdGlvbiB0KCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtyZXR1cm4gZS5jbGFzc05hbWU9XCJ0cS11aS1wcm9ncmVzcy1zY3JlZW5cIixlLmlubmVySFRNTD1vLm1hcmt1cCxlfWZ1bmN0aW9uIG4oZSl7dmFyIHQ9dm9pZCAwO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3Q9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk6XCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgZT9cInVuZGVmaW5lZFwiOmkoZSkpJiYodD1lKSx0fWFbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMpO3ZhciBvPXRoaXM7ZXx8KGU9e30pLG8ubWFya3VwPVwiXCIsby5zdGF0ZT1cImNvbXBsZXRlZFwiLG8ucm9vdEh0bWw9dCgpLG8uaWQ9ZS5pZHx8XCJ0YWJQYW5lbC1cIitzKyssby5yb290SHRtbC5pZD1vLmlkO3ZhciByPW4oZS5iYXNlRWxlbWVudCk7ci5hcHBlbmRDaGlsZChvLnJvb3RIdG1sKSxvLnNldFN0YXRlPWZ1bmN0aW9uKGUsdCl7ZSYmKG8uc3RhdGU9ZSxcImFjdGl2ZVwiPT09ZT8oby5yb290SHRtbC5pbm5lckhUTUw9XCI8aDE+XCIrKHR8fHUpKyc8L2gxPjxkaXYgY2xhc3M9XCJ0cS11aS1wcm9ncmVzcy1zY3JlZW5fX3Byb2dyZXNzXCI+PC9kaXY+JyxvLnJvb3RIdG1sLnN0eWxlLmRpc3BsYXk9bnVsbCk6XCJjb21wbGV0ZWRcIj09PWU/KG8ucm9vdEh0bWwuaW5uZXJIVE1MPVwiXCIsby5yb290SHRtbC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKTpcImVycm9yXCI9PT1lJiYoby5yb290SHRtbC5pbm5lckhUTUw9XCI8aDE+XCIrKHR8fGQpK1wiPC9oMT5cIixvLnJvb3RIdG1sLnN0eWxlLmRpc3BsYXk9bnVsbCksby50cmlnZ2VyKFwiZGlhZ3JhbS1zdGF0ZS1jaGFuZ2VkXCIsZSkpfSxvLnNldFN0YXRlKGUuc3RhdGUsZS50ZXh0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTtuLlByb2dyZXNzU2NyZWVuPXI7dmFyIGw9ZShcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIiksYT1vKGwpLHM9TWF0aC5mbG9vcig1MCpNYXRoLnJhbmRvbSgpKSsxLHU9XCJMb2FkaW5nXCIsZD1cIkVycm9yIGhhcyBvY2N1cnJlZCFcIjtuW1wiZGVmYXVsdFwiXT1yfSx7XCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCI6OH1dLDc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gcihlKXtsW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKSxlfHwoZT17fSk7dmFyIHQ9ZS5zZWFyY2hCdXR0b25JZHx8XCJ0cUxnU2VhcmNoQnV0dG9uXCIsbj1lLnNlYXJjaElkfHxcInNlYXJjaFwiLG89ZS5hcmlhTGFiZWx8fFwiU2VhcmNoIEZseW91dCBQYW5lbFwiO3NbXCJkZWZhdWx0XCJdLmFwcGx5KHRoaXMsW3tpZDplLmlkLGJhc2VFbGVtZW50OmUuYmFzZUVsZW1lbnQsYWN0aXZlOmUuYWN0aXZlLGhlYWRlcjplLmhlYWRlcnx8XCJTZWFyY2ggcGFuZWxcIix0cmlnZ2VyQnV0dG9uOmUudHJpZ2dlckJ1dHRvbixib2R5OlwiXFxuICAgICAgICAgICAgPHNwYW4gaWQ9XCIrdCsnIGNsYXNzPVwidHEtdWktc2VhcmNoLWljb24gZ2x5cGhpY29uIGdseXBoaWNvbi1zZWFyY2hcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IGFyaWEtbGFiZWw9XCInK28rJ1wiIGlkPVwiJytuKydcIiBwbGFjZUhvbGRlcj1cIlNlYXJjaC4uLlwiIGNsYXNzPVwidHEtdWktc2VhcmNoLWlucHV0XCI+PC9pbnB1dD5cXG4gICAgICAgICcscmVtb3ZlQmFja2dyb3VuZDohMCxzaXplOnt3aWR0aDpcIjI2MHB4XCIsaGVpZ2h0OlwiNzBweFwifX1dKX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLlNlYXJjaFBhbmVsPXI7dmFyIGk9ZShcIi4vc3Vic2NyaXB0aW9uQVBJL3N1YnNjcmliZWFibGVcIiksbD1vKGkpLGE9ZShcIi4vZmx5aW5nUGFuZWxcIikscz1vKGEpO25bXCJkZWZhdWx0XCJdPXJ9LHtcIi4vZmx5aW5nUGFuZWxcIjoyLFwiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSw4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbygpe3ZhciBlPXRoaXM7ZS5fc3Vic2NyaWJ0aW9ucz17fSxlLm9uPWZ1bmN0aW9uKHQsbil7ZS5fc3Vic2NyaWJ0aW9uc1t0XXx8KGUuX3N1YnNjcmlidGlvbnNbdF09W10pLGUuX3N1YnNjcmlidGlvbnNbdF0ucHVzaChuKX0sZS51bnN1YnNjcmliZT1mdW5jdGlvbih0KXtPYmplY3Qua2V5cyhlLl9zdWJzY3JpYnRpb25zKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuX3N1YnNjcmlidGlvbnNbdF19KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUuaW5kZXhPZih0KTtuIT09LTEmJmUuc3BsaWNlKG4sMSl9KX0sZS50cmlnZ2VyPWZ1bmN0aW9uKHQsbil7dmFyIG89dGhpcztuIGluc3RhbmNlb2YgQXJyYXl8fChuPVtuXSksZS5fc3Vic2NyaWJ0aW9ucyYmZS5fc3Vic2NyaWJ0aW9uc1t0XSYmZS5fc3Vic2NyaWJ0aW9uc1t0XS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXBwbHkobyxuKX0pfX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLlN1YnNjcmliYWJsZT1vLG5bXCJkZWZhdWx0XCJdPW99LHt9XSw5OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIHIoZSl7ZnVuY3Rpb24gdCgpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIHQuY2xhc3NOYW1lPVwidHEtdWktc3dpdGNoLWJ1dHRvbnNcIisoZS52ZXJ0aWNhbE9yaWVudGF0aW9uP1wiLXZlcnRpY2FsXCI6XCJcIiksdC5pbm5lckhUTUw9bi5tYXJrdXAsdH1sW1wiZGVmYXVsdFwiXS5hcHBseSh0aGlzKSxlfHwoZT17fSk7dmFyIG49dGhpcyxvPWUuc3RhdGVzfHxbXTtuLm1hcmt1cD1vLm1hcChmdW5jdGlvbih0LG4pe3JldHVybic8YnV0dG9uIGlkPVwiJyt0LmlkKydcIiAnKygwIT09bj9cIlwiOlwiZGlzYWJsZWRcIikrJyB0aXRsZT1cIicrKHQubGFiZWx8fHQuaWQpKydcIj5cXG4gICAgICAgICAgICAnKyhlLnZlcnRpY2FsT3JpZW50YXRpb24mJnQuaWNvbj8nPHNwYW4gY2xhc3M9XCInK3QuaWNvbisnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPic6dC5sYWJlbHx8dC5pZCkrXCJcXG4gICAgICAgIDwvYnV0dG9uPlwifSkuam9pbihcIlwiKSxuLnJvb3RIdG1sPXQoKSxuLmlkPWUuaWR8fFwic3dpdGNoZXItXCIrYSsrLG4ucm9vdEh0bWwuaWQ9bi5pZDt2YXIgcj1udWxsO28uZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkKTswPT09dCYmKHI9byksby5vbmNsaWNrPWZ1bmN0aW9uKCl7by5kaXNhYmxlZD0hMCxyLmRpc2FibGVkPSExLHI9byxuLnRyaWdnZXIoXCJzdGF0ZS1jaGFuZ2VkXCIsZS5pZCl9fSksbi5zZXRTdGF0ZT1mdW5jdGlvbihlKXt2YXIgdD1uLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjXCIrZSk7dCYmZSE9PXIuaWQmJih0LmRpc2FibGVkPSEwLHIuZGlzYWJsZWQ9ITEscj10KX19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5Td2l0Y2hlcj1yO3ZhciBpPWUoXCIuL3N1YnNjcmlwdGlvbkFQSS9zdWJzY3JpYmVhYmxlXCIpLGw9byhpKSxhPTA7bltcImRlZmF1bHRcIl09cn0se1wiLi9zdWJzY3JpcHRpb25BUEkvc3Vic2NyaWJlYWJsZVwiOjh9XSwxMDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG8oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7cmV0dXJuIGUuY2xhc3NOYW1lPVwidHEtdWktdGFiLXBhbmVsXCIsZS5pbm5lckhUTUw9bi5tYXJrdXAsZX12YXIgbj10aGlzO2V8fChlPXt9KTt2YXIgbz1lLnRhYnN8fFtdO24ubWFya3VwPSdcXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0cS11aS10YWItc3dpdGNoZXIgdHEtdWktc3dpdGNoLWJ1dHRvbnNcIj4nK28ubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuJ1xcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XCInK2UuaWQrJ1wiICcrKDAhPT10P1wiXCI6XCJkaXNhYmxlZFwiKStcIj5cXG4gICAgICAgICAgICAgICAgXCIrKGUubGFiZWx8fGUuaWQpK1wiXFxuICAgICAgICAgICAgPC9idXR0b24+ICBcXG4gICAgICAgIFwifSkuam9pbihcIlwiKStcIjwvZGl2PlwiK28ubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuJ1xcbiAgICAgICAgICAgIDxkaXYgaWQ9XCInK2UuaWQrJ1BhbmVsXCIgY2xhc3M9XCJ0cS11aS10YWItcGFuZWxfcGFnZVwiIHN0eWxlPVwiZGlzcGxheTogJysoMD09PXQ/XCJcIjpcIm5vbmVcIikrJ1wiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHEtdWktdGFiLXBhbmVsX3BhZ2VfYm9keVwiPlxcbiAgICAgICAgICAgICAgICAgICAgJysoXCJzdHJpbmdcIj09dHlwZW9mIGUuYm9keT9lLmJvZHk6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIn0pLmpvaW4oXCJcIiksbi5yb290SHRtbD10KCksbi5pZD1lLmlkfHxcInRhYlBhbmVsLVwiK3Isbi5yb290SHRtbC5pZD1uLmlkLG8ubWFwKGZ1bmN0aW9uKGUpe2lmKGUuYm9keSBpbnN0YW5jZW9mIE9iamVjdCYmZS5ib2R5LnJvb3RIdG1sKXt2YXIgdD1uLnJvb3RIdG1sLnF1ZXJ5U2VsZWN0b3IoXCIjXCIrZS5pZCtcIlBhbmVsIC50cS11aS10YWItcGFuZWxfcGFnZV9ib2R5XCIpO3QuYXBwZW5kQ2hpbGQoZS5ib2R5LnJvb3RIdG1sKX19KTt2YXIgaT1udWxsO28uZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciBvPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkKSxyPW4ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitlLmlkK1wiUGFuZWxcIik7MD09PXQmJihpPXt0YWJCdG46byx0YWJQYW5lbDpyfSksby5vbmNsaWNrPWZ1bmN0aW9uKCl7by5kaXNhYmxlZD0hMCxyLnN0eWxlLmRpc3BsYXk9XCJcIixpLnRhYkJ0bi5kaXNhYmxlZD0hMSxpLnRhYlBhbmVsLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsaT17dGFiQnRuOm8sdGFiUGFuZWw6cn19fSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5UYWJQYW5lbD1vO3ZhciByPU1hdGguZmxvb3IoNTAqTWF0aC5yYW5kb20oKSkrMTtuW1wiZGVmYXVsdFwiXT1vfSx7fV0sMTE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKGUpe2Z1bmN0aW9uIHQoZSl7dmFyIHQ9dm9pZCAwO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO24uaW5uZXJIVE1MPWUsdD1uLmZpcnN0Q2hpbGR9ZWxzZSBpZihlLmlkJiZlLmljb24pe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7aWYoby5pbm5lckhUTUw9JzxidXR0b24gaWQ9XCInK2UuaWQrJ1wiIHRpdGxlPVwiJysoZS5sYWJlbHx8ZS5pZCkrJ1wiIGNsYXNzPVwidHEtdWktdG9vbGJhcl9fYnV0dG9uXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJytlLmljb24rJ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8L2J1dHRvbj4nLHQ9by5maXJzdENoaWxkLGUuaWNvbjIpe3ZhciByPSEwO3Qub25jbGljaz1mdW5jdGlvbihuKXt0LmlubmVySFRNTD0nPHNwYW4gY2xhc3M9XCInKyhyP2UuaWNvbjI6ZS5pY29uKSsnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPicsZS5jYWxsYmFjayhuKSxyPSFyfX1lbHNlIHQub25jbGljaz1lLmNhbGxiYWNrfWVsc2UgZS5yb290SHRtbCYmKHQ9ZS5yb290SHRtbCk7cmV0dXJuIHR9ZnVuY3Rpb24gbigpe3ZhciB0PXZvaWQgMDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZS5iYXNlRWxlbWVudD90PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuYmFzZUVsZW1lbnQpOlwib2JqZWN0XCI9PT1yKGUuYmFzZUVsZW1lbnQpJiYodD1lLmJhc2VFbGVtZW50KSx0Pyh0LmlubmVySFRNTD1vLm1hcmt1cCx0KTpudWxsfXZhciBvPXRoaXMsbD1cInRvb2xiYXJSb290RWxlbWVudC1cIitpKys7aWYoZXx8KGU9e30pLG8ubWFya3VwPSdcXG4gICAgICAgIDxkaXYgaWQ9XCInK2wrJ1wiIGNsYXNzPVwidHEtdWktdG9vbGJhclwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICcsby5yb290SHRtbD1uKCksby5pZD1lLmlkfHxcInRvb2xiYXItXCIraSsrLG8ucm9vdEh0bWwuaWQ9by5pZCwhby5yb290SHRtbCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcm9vdCBlbGVtZW50IGlzIG5vdCBzcGVjaWZpZWQhXCIpO28uY29udGFpbmVyPW8ucm9vdEh0bWwucXVlcnlTZWxlY3RvcihcIiNcIitsKSxvLnB1c2hUb29sPWZ1bmN0aW9uKGUpe3ZhciBuPXQoZSk7biYmKFwic3RyaW5nXCIhPXR5cGVvZiBuP2EucHVzaChlKTphLnB1c2goe2lkOlwiY3VzdG9taHRtbFwiK2krKyxtYXJrdXA6ZSxyb290SHRtbDpufSksby5jb250YWluZXIuYXBwZW5kQ2hpbGQobikpfSxvLmluc2VydFRvb2w9ZnVuY3Rpb24oZSxuKXt2YXIgcj1NYXRoLm1pbihNYXRoLm1heChuLDApLGEubGVuZ3RoLTEpLGk9by5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNcIithW3JdLmlkKTtpZihpKXt2YXIgbD10KGUpO2wmJihhLnNwbGljZShyLDAsZSksby5jb250YWluZXIuaW5zZXJ0QmVmb3JlKGwsaSkpfWVsc2Ugby5wdXNoVG9vbChlKX0sby5yZW1vdmVUb29sPWZ1bmN0aW9uKGUpe3ZhciB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5pZDthLnNwbGljZShhLmluZGV4T2YoZSksMSk7dmFyIG49by5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIiNcIit0KTtvLmNvbnRhaW5lci5yZW1vdmVDaGlsZChuKX07dmFyIGE9W107ZS50b29scy5mb3JFYWNoKGZ1bmN0aW9uKGUpe28ucHVzaFRvb2woZSl9KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTtuLlRvb2xiYXI9bzt2YXIgaT1NYXRoLmZsb29yKDUwKk1hdGgucmFuZG9tKCkpKzE7bltcImRlZmF1bHRcIl09b30se31dfSx7fSxbNV0pKDUpfSk7Il19
